{"meta":{"title":"ST","subtitle":"A HAOIER","description":"每一个不曾起舞的日子，都是对于生命的辜负。","author":"ST","url":"https://prostkhala.github.io"},"pages":[{},{},{}],"posts":[{"title":"Codeforces856D Masha and Cactus","date":"2017-09-13T12:40:33.000Z","path":"2017/09/13/Codeforces856D/","text":"Masha and Cactus 题目描述Masha is fond of cacti. When she was a little girl, she decided to plant a tree. Now Masha wants to make a nice cactus out of her tree. Recall that tree is a connected undirected graph that has no cycles. Cactus is a connected undirected graph such that each vertex belongs to at most one cycle. Masha has some additional edges that she can add to a tree. For each edge she knows which vertices it would connect and the beauty of this edge. Masha can add some of these edges to the graph if the resulting graph is a cactus. Beauty of the resulting cactus is sum of beauties of all added edges. Help Masha find out what maximum beauty of the resulting cactus she can achieve. 输入输出格式输入格式:The first line of the input data contains two integers n and m — the number of vertices in a tree, and the number of additional edges available $(3 ≤ n ≤ 2·105; 0 ≤ m ≤ 2·10^5)$. Let us describe Masha’s tree. It has a root at vertex 1. The second line contains n - 1 integers: $p_2, p_3, …, p_n$, here $p_i$ — is the parent of a vertex i — the first vertex on a path from the vertex i to the root of the tree $(1 ≤ p_i &lt; i)$. The following m lines contain three integers ui, vi and ci — pairs of vertices to be connected by the additional edges that Masha can add to the tree and beauty of edge $(1 ≤ ui, vi ≤ n; ui ≠ vi; 1 ≤ ci ≤ 10^4)$. It is guaranteed that no additional edge coincides with the edge of the tree. 输出格式：Output one integer — the maximum beauty of a cactus Masha can achieve. 输入输出样例输入样例：7 3 1 1 2 2 3 3 4 5 1 6 7 1 2 3 1 输出样例：2 题解题目大意为有$n$个点，$m$条带权链，每个点只能被链覆盖一次，问可行覆盖方案的最大权值和。 该题动态规划方程较容易设计，可以设$f_x$为以$x$为根的子树所能达到的最大权值和，如果没有链以该点为LCA，那么$f_x=\\sum f_{son}$，否则$f_x= \\sum f_{不在链中且父亲节点在链中的子节点}+w$,但是对于第二种情况如果直接暴力找子节点，显然时间复杂度为$O(nq)$，不在可接受范围之内。 我们可以利用该种子节点的性质来为每个节点赋值，使得$ \\sum f_{不在链中且父亲节点在链中的子节点}$=$w_{x-&gt;y}$和，从而通过树链剖分来实现$O(logn)$查询。考虑对于每一个已经求出的$f_x$，不妨将$w_{fa_x}+=f_x$，$w_x-=f_x$即可满足条件，理由如下： 对于父亲和自己均在链中的节点，则其贡献被计算了两次，一次为正，一次为负，即为没有贡献。 对于父亲和自己均不在链中的节点，则其没有贡献。 对于父亲在链中而自己不在链中的节点，其贡献只被计算了一次正值。 对于自己的链中而父亲不在链中的节点，显然只有当前节点（即询问节点的LCA），其$w$尚没有赋值。 CODE#include&lt;bits/stdc++.h&gt; #define lb(x) x&amp;(-x) using namespace std; typedef long long ll; const int N = 1e6+1; int n,m,fa[N],st[N],ed[N],top[N],d[N],sz[N],son[N],totw; int a[N],f[N],g[N],X[N],Y[N],W[N]; struct nd { int ne[N*2],to[N*2]; int head[N],cnt; void in(int x,int y){to[++cnt]=y;ne[cnt]=head[x];head[x]=cnt;} void init(){memset(head,0,sizeof(head));cnt=0;} }e,e1; void dfs1(int x) { sz[x]=1; for(int i=e.head[x];i;i=e.ne[i]) { int y=e.to[i]; d[y]=d[x]+1; dfs1(y); sz[x]+=sz[y]; if(sz[son[x]]&lt;sz[y])son[x]=y; } } void dfs2(int x) { st[x]=++totw; int y=son[x];if(!y)return; top[y]=top[x];dfs2(y); for(int i=e.head[x];i;i=e.ne[i]) { y=e.to[i]; if(y==son[x])continue; top[y]=y; dfs2(y); } ed[x]=totw; } void insert(int x,int d) { for(int i=x;i&lt;=n;i+=lb(i))a[i]+=d; } int sum(int x,int y) { if(!x||!y)return 0; int ret=0; for(int i=y;i;i-=lb(i))ret+=a[i]; for(int i=x-1;i;i-=lb(i))ret-=a[i]; return ret; } int lca(int x,int y) { while(top[x]!=top[y]) { if(d[top[x]]&lt;d[top[y]])swap(x,y); x=fa[top[x]]; } if(d[x]&lt;d[y])return x; return y; } int query(int x,int y) { int ret=0; while(top[x]!=top[y]) { if(d[top[x]]&lt;d[top[y]])swap(x,y); ret+=sum(st[top[x]],st[x]); x=fa[top[x]]; } if(st[x]&gt;st[y])swap(x,y); ret+=sum(st[x],st[y]); return ret; } int dp(int x) { for(int i=e.head[x];i;i=e.ne[i]) dp(e.to[i]),g[x]+=f[e.to[i]]; f[x]=g[x]; for(int i=e1.head[x];i;i=e1.ne[i]) { int to=e1.to[i]; f[x]=max(f[x],query(X[to],Y[to])+W[to]); } insert(st[x],-f[x]); if(fa[x])insert(st[fa[x]],f[x]); } int main() { // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;c.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=2;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;fa[i]),e.in(fa[i],i); top[1]=1;dfs1(1);dfs2(1); for(int i=1;i&lt;=m;++i) { scanf(&quot;%d%d%d&quot;,&amp;X[i],&amp;Y[i],&amp;W[i]); e1.in(lca(X[i],Y[i]),i); } dp(1); cout&lt;&lt;f[1]; }","raw":"title: Codeforces856D Masha and Cactus\ndate: 2017-09-13 20:40:33\ncategories:\n  - Codeforces&AtCoder\ntags:\n  - 动态规划\n  - 树链剖分\n---\n\n# [Masha and Cactus](Masha and Cactus)\n---\n## 题目描述\nMasha is fond of cacti. When she was a little girl, she decided to plant a tree. Now Masha wants to make a nice cactus out of her tree.\n\nRecall that tree is a connected undirected graph that has no cycles. Cactus is a connected undirected graph such that each vertex belongs to at most one cycle.\n\nMasha has some additional edges that she can add to a tree. For each edge she knows which vertices it would connect and the beauty of this edge. Masha can add some of these edges to the graph if the resulting graph is a cactus. Beauty of the resulting cactus is sum of beauties of all added edges.\n\nHelp Masha find out what maximum beauty of the resulting cactus she can achieve.\n### 输入输出格式\n#### 输入格式:\nThe first line of the input data contains two integers n and m — the number of vertices in a tree, and the number of additional edges available $(3 ≤ n ≤ 2·105; 0 ≤ m ≤ 2·10^5)$.\n\nLet us describe Masha's tree. It has a root at vertex 1. The second line contains n - 1 integers: $p_2, p_3, ..., p_n$, here $p_i$ — is the parent of a vertex i — the first vertex on a path from the vertex i to the root of the tree $(1 ≤ p_i < i)$.\n\nThe following m lines contain three integers ui, vi and ci — pairs of vertices to be connected by the additional edges that Masha can add to the tree and beauty of edge $(1 ≤ ui, vi ≤ n; ui ≠ vi; 1 ≤ ci ≤ 10^4)$.\n\nIt is guaranteed that no additional edge coincides with the edge of the tree.\n#### 输出格式：\nOutput one integer — the maximum beauty of a cactus Masha can achieve.\n### 输入输出样例\n#### 输入样例：\n    7 3\n    1 1 2 2 3 3\n    4 5 1\n    6 7 1\n    2 3 1\n#### 输出样例：\n\t2\n\n---\n\n## 题解\n题目大意为有$n$个点，$m$条带权链，每个点只能被链覆盖一次，问可行覆盖方案的最大权值和。\n\n该题动态规划方程较容易设计，可以设$f_x$为以$x$为根的子树所能达到的最大权值和，如果没有链以该点为LCA，那么$f_x=\\sum f_{son}$，否则$f_x= \\sum f_{不在链中且父亲节点在链中的子节点}+w$,但是对于第二种情况如果直接暴力找子节点，显然时间复杂度为$O(nq)$，不在可接受范围之内。\n\n我们可以利用该种子节点的性质来为每个节点赋值，使得$ \\sum f_{不在链中且父亲节点在链中的子节点}$=$w_{x->y}$和，从而通过树链剖分来实现$O(logn)$查询。考虑对于每一个已经求出的$f_x$，不妨将$w_{fa_x}+=f_x$，$w_x-=f_x$即可满足条件，理由如下：\n\n- 对于父亲和自己均在链中的节点，则其贡献被计算了两次，一次为正，一次为负，即为没有贡献。\n- 对于父亲和自己均不在链中的节点，则其没有贡献。\n- 对于父亲在链中而自己不在链中的节点，其贡献只被计算了一次正值。\n- 对于自己的链中而父亲不在链中的节点，显然只有当前节点（即询问节点的LCA），其$w$尚没有赋值。\n\n---\n### CODE\n\n    #include<bits/stdc++.h>\n    #define lb(x) x&(-x)\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e6+1;\n\n    int n,m,fa[N],st[N],ed[N],top[N],d[N],sz[N],son[N],totw;\n    int a[N],f[N],g[N],X[N],Y[N],W[N];\n\n    struct nd\n    {\n        int ne[N*2],to[N*2];\n        int head[N],cnt;\n        void in(int x,int y){to[++cnt]=y;ne[cnt]=head[x];head[x]=cnt;}\n        void init(){memset(head,0,sizeof(head));cnt=0;}\n    }e,e1;\n\n    void dfs1(int x)\n    {\n        sz[x]=1;\n        for(int i=e.head[x];i;i=e.ne[i])\n        {\n            int y=e.to[i];\n            d[y]=d[x]+1;\n            dfs1(y);\n\n            sz[x]+=sz[y];\n            if(sz[son[x]]<sz[y])son[x]=y;\n        }\n    }\n\n    void dfs2(int x)\n    {\n        st[x]=++totw;\n        int y=son[x];if(!y)return;\n        top[y]=top[x];dfs2(y);\n        for(int i=e.head[x];i;i=e.ne[i])\n        {\n            y=e.to[i];\n            if(y==son[x])continue;\n            top[y]=y;\n            dfs2(y);\n        }\n        ed[x]=totw;\n    }\n\n    void insert(int x,int d)\n    {\n        for(int i=x;i<=n;i+=lb(i))a[i]+=d;\n    }\n\n    int sum(int x,int y)\n    {\n        if(!x||!y)return 0;\n        int ret=0;\n        for(int i=y;i;i-=lb(i))ret+=a[i];\n        for(int i=x-1;i;i-=lb(i))ret-=a[i];\n        return ret;\n    }\n\n    int lca(int x,int y)\n    {\n        while(top[x]!=top[y])\n        {\n            if(d[top[x]]<d[top[y]])swap(x,y);\n            x=fa[top[x]];\t\n        }\n        if(d[x]<d[y])return x;\n        return y;\n    }\n\n    int query(int x,int y)\n    {\n        int ret=0;\n        while(top[x]!=top[y])\n        {\n            if(d[top[x]]<d[top[y]])swap(x,y);\n            ret+=sum(st[top[x]],st[x]);\n            x=fa[top[x]];\n        }\n        if(st[x]>st[y])swap(x,y);\n        ret+=sum(st[x],st[y]);\n        return ret;\n    }\n\n    int dp(int x)\n    {\n        for(int i=e.head[x];i;i=e.ne[i])\n        dp(e.to[i]),g[x]+=f[e.to[i]];\n        f[x]=g[x];\n        for(int i=e1.head[x];i;i=e1.ne[i])\n        {\n            int to=e1.to[i];\n            f[x]=max(f[x],query(X[to],Y[to])+W[to]);\n        }\n        insert(st[x],-f[x]);\n        if(fa[x])insert(st[fa[x]],f[x]);\n    }\n\n    int main()\n    {\n    // \tfreopen(\"c.in\",\"r\",stdin);\n    //\tfreopen(\"c.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        for(int i=2;i<=n;++i)scanf(\"%d\",&fa[i]),e.in(fa[i],i);\n        top[1]=1;dfs1(1);dfs2(1);\n        for(int i=1;i<=m;++i)\n        {\n            scanf(\"%d%d%d\",&X[i],&Y[i],&W[i]);\n            e1.in(lca(X[i],Y[i]),i);\n        }\n        dp(1);\n        cout<<f[1];\n    }\n\n","content":"<h1 id=\"Masha-and-Cactus\"><a href=\"#Masha-and-Cactus\" class=\"headerlink\" title=\"Masha and Cactus\"></a><a href=\"Masha and Cactus\">Masha and Cactus</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Masha is fond of cacti. When she was a little girl, she decided to plant a tree. Now Masha wants to make a nice cactus out of her tree.</p>\n<p>Recall that tree is a connected undirected graph that has no cycles. Cactus is a connected undirected graph such that each vertex belongs to at most one cycle.</p>\n<p>Masha has some additional edges that she can add to a tree. For each edge she knows which vertices it would connect and the beauty of this edge. Masha can add some of these edges to the graph if the resulting graph is a cactus. Beauty of the resulting cactus is sum of beauties of all added edges.</p>\n<p>Help Masha find out what maximum beauty of the resulting cactus she can achieve.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>The first line of the input data contains two integers n and m — the number of vertices in a tree, and the number of additional edges available $(3 ≤ n ≤ 2·105; 0 ≤ m ≤ 2·10^5)$.</p>\n<p>Let us describe Masha’s tree. It has a root at vertex 1. The second line contains n - 1 integers: $p_2, p_3, …, p_n$, here $p_i$ — is the parent of a vertex i — the first vertex on a path from the vertex i to the root of the tree $(1 ≤ p_i &lt; i)$.</p>\n<p>The following m lines contain three integers ui, vi and ci — pairs of vertices to be connected by the additional edges that Masha can add to the tree and beauty of edge $(1 ≤ ui, vi ≤ n; ui ≠ vi; 1 ≤ ci ≤ 10^4)$.</p>\n<p>It is guaranteed that no additional edge coincides with the edge of the tree.</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>Output one integer — the maximum beauty of a cactus Masha can achieve.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>7 3\n1 1 2 2 3 3\n4 5 1\n6 7 1\n2 3 1\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>2\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意为有$n$个点，$m$条带权链，每个点只能被链覆盖一次，问可行覆盖方案的最大权值和。</p>\n<p>该题动态规划方程较容易设计，可以设$f_x$为以$x$为根的子树所能达到的最大权值和，如果没有链以该点为LCA，那么$f_x=\\sum f_{son}$，否则$f_x= \\sum f_{不在链中且父亲节点在链中的子节点}+w$,但是对于第二种情况如果直接暴力找子节点，显然时间复杂度为$O(nq)$，不在可接受范围之内。</p>\n<p>我们可以利用该种子节点的性质来为每个节点赋值，使得$ \\sum f_{不在链中且父亲节点在链中的子节点}$=$w_{x-&gt;y}$和，从而通过树链剖分来实现$O(logn)$查询。考虑对于每一个已经求出的$f_x$，不妨将$w_{fa_x}+=f_x$，$w_x-=f_x$即可满足条件，理由如下：</p>\n<ul>\n<li>对于父亲和自己均在链中的节点，则其贡献被计算了两次，一次为正，一次为负，即为没有贡献。</li>\n<li>对于父亲和自己均不在链中的节点，则其没有贡献。</li>\n<li>对于父亲在链中而自己不在链中的节点，其贡献只被计算了一次正值。</li>\n<li>对于自己的链中而父亲不在链中的节点，显然只有当前节点（即询问节点的LCA），其$w$尚没有赋值。</li>\n</ul>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\n#define lb(x) x&amp;(-x)\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6+1;\n\nint n,m,fa[N],st[N],ed[N],top[N],d[N],sz[N],son[N],totw;\nint a[N],f[N],g[N],X[N],Y[N],W[N];\n\nstruct nd\n{\n    int ne[N*2],to[N*2];\n    int head[N],cnt;\n    void in(int x,int y){to[++cnt]=y;ne[cnt]=head[x];head[x]=cnt;}\n    void init(){memset(head,0,sizeof(head));cnt=0;}\n}e,e1;\n\nvoid dfs1(int x)\n{\n    sz[x]=1;\n    for(int i=e.head[x];i;i=e.ne[i])\n    {\n        int y=e.to[i];\n        d[y]=d[x]+1;\n        dfs1(y);\n\n        sz[x]+=sz[y];\n        if(sz[son[x]]&lt;sz[y])son[x]=y;\n    }\n}\n\nvoid dfs2(int x)\n{\n    st[x]=++totw;\n    int y=son[x];if(!y)return;\n    top[y]=top[x];dfs2(y);\n    for(int i=e.head[x];i;i=e.ne[i])\n    {\n        y=e.to[i];\n        if(y==son[x])continue;\n        top[y]=y;\n        dfs2(y);\n    }\n    ed[x]=totw;\n}\n\nvoid insert(int x,int d)\n{\n    for(int i=x;i&lt;=n;i+=lb(i))a[i]+=d;\n}\n\nint sum(int x,int y)\n{\n    if(!x||!y)return 0;\n    int ret=0;\n    for(int i=y;i;i-=lb(i))ret+=a[i];\n    for(int i=x-1;i;i-=lb(i))ret-=a[i];\n    return ret;\n}\n\nint lca(int x,int y)\n{\n    while(top[x]!=top[y])\n    {\n        if(d[top[x]]&lt;d[top[y]])swap(x,y);\n        x=fa[top[x]];    \n    }\n    if(d[x]&lt;d[y])return x;\n    return y;\n}\n\nint query(int x,int y)\n{\n    int ret=0;\n    while(top[x]!=top[y])\n    {\n        if(d[top[x]]&lt;d[top[y]])swap(x,y);\n        ret+=sum(st[top[x]],st[x]);\n        x=fa[top[x]];\n    }\n    if(st[x]&gt;st[y])swap(x,y);\n    ret+=sum(st[x],st[y]);\n    return ret;\n}\n\nint dp(int x)\n{\n    for(int i=e.head[x];i;i=e.ne[i])\n    dp(e.to[i]),g[x]+=f[e.to[i]];\n    f[x]=g[x];\n    for(int i=e1.head[x];i;i=e1.ne[i])\n    {\n        int to=e1.to[i];\n        f[x]=max(f[x],query(X[to],Y[to])+W[to]);\n    }\n    insert(st[x],-f[x]);\n    if(fa[x])insert(st[fa[x]],f[x]);\n}\n\nint main()\n{\n//     freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;c.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=2;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;fa[i]),e.in(fa[i],i);\n    top[1]=1;dfs1(1);dfs2(1);\n    for(int i=1;i&lt;=m;++i)\n    {\n        scanf(&quot;%d%d%d&quot;,&amp;X[i],&amp;Y[i],&amp;W[i]);\n        e1.in(lca(X[i],Y[i]),i);\n    }\n    dp(1);\n    cout&lt;&lt;f[1];\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/09/13/Codeforces856D/","excerpt":"","categories":[{"name":"Codeforces&AtCoder","slug":"Codeforces-AtCoder","permalink":"https://prostkhala.github.io/categories/Codeforces-AtCoder/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://prostkhala.github.io/tags/树链剖分/"}]}]}