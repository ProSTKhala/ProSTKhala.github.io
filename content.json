{"meta":{"title":"ST","subtitle":"A HAOIER","description":"每一个不曾起舞的日子，都是对于生命的辜负。","author":"ST","url":"https://prostkhala.github.io"},"pages":[{},{},{}],"posts":[{"title":"SDOI2017 数字表格","date":"2017-04-27T03:39:21.000Z","path":"2017/04/27/SDOI2017 数字表格/","text":"SDOI2017 数字表格洛谷3704 题目描述Doris 刚刚学习了 fibnacci 数列，用 $f[i]$ 表示数列的第 $i$ 项，那么： $f[0]=0$ $f[1]=1$ $f[n]=f[n−1]+f[n−2],n≥2$ Doris 用老师的超级计算机生成了一个 $n×m$ 的表格，第 $i$ 行第 $j$ 列的格子中的数是 $f[gcd(i,j)]$，其中 $gcd(i,j)$ 表示 $i$ 与 $j$ 的最大公约数。 Doris 的表格中共有 $n×m$ 个数，她想知道这些数的乘积是多少。 这些数的乘积实在是太大了，所以 Doris 只想知道乘积对$1000000007$ 取模后的结果。 输入输出格式输入格式：有多组测试数据。 第一行一个数 $T$，表示数据组数。 接下来 $T $行，每行两个数 $n$ 和 $m$ 。 输出格式：输出 $T$ 行，第 $i$ 行的数是第 $i$ 组数据的结果。 输入输出样例输入样例：3 2 3 4 5 6 7 输出样例：1 6 960 数据范围对于 10%的数据，$1≤n,m≤100$； 对于 30% 的数据，$1≤n,m≤1000$ ； 另外存在 30% 的数据，$T≤3$； 对于 100% 的数据，$1≤n,m≤106 1 \\leq n, m \\leq 10 ^ 6 1≤n,m≤10^6$。 题解已知 $$Ans=\\prod_i^n\\prod_j^mf[gcd(i,j)]$$$$=\\prod_i^{min(n,m)}f[i]^{g(i)}$$ 其中 $$g(x)=\\sum_i^n\\sum_j^m[gcd(i,j)==x]$$$$=\\sum_i^{n/x}\\sum_j^{m/x}[gcd(i,j)==1]$$$$=\\sum_d^{min(n,m)}\\mu(d)×{n \\over dx}×{m \\over dx}$$ 代入原式得 $$Ans=\\prod_i^{min(n,m)}f[i]^{\\sum_d^{min(n,m)}\\mu(d)×{n \\over di}×{m \\over di}}$$ 考虑原题需要取模，直接模会炸，需要先预处理逆元和莫比乌斯函数的前缀和，再通过分块优化，即可做到$O(T\\sqrt n)$的时间复杂度。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; typedef long long ull; typedef double db;; const int mod = 1000000007; const int N = 1e6+1; ull fi[N],p[N],miu[N],phi[N],tot,d[N],f[N],fp[N][3],ff[N],fs[N],rev[N]; bool vis[N]; int ca1[33],ca2[33]; ull qpow(ull a,ull b) { ull ret=1; if(b&lt;0)b+=mod-1; while(b) { if(b&amp;1)ret=(ret*a)%mod; b&gt;&gt;=1; a=(a*a)%mod; } return ret; } void init() { miu[1]=phi[1]=fs[0]=f[1]=1; for(int i=2;i&lt;N;++i) { f[i]=(f[i-1]+f[i-2])%mod; if(!vis[i])miu[i]=-1,p[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;p[j]*i&lt;N;++j) { vis[i*p[j]]=true; if(i%p[j]==0){miu[i*p[j]]=0;phi[i*p[j]]=phi[i]*p[j];break;} miu[i*p[j]]=-miu[i]; phi[i*p[j]]=phi[i]*(p[j]-1); } } for(int i=1;i&lt;N;++i) fp[i][0]=qpow(f[i],-1),fp[i][1]=1,fp[i][2]=f[i]; for(int i=1;i&lt;N;++i)ff[i]=1; for(int i=1;i&lt;N;++i) for(int j=i;j&lt;N;j+=i) ff[j]=(ull)ff[j]*fp[i][miu[j/i]+1]%mod; for(int i=1;i&lt;N;++i)fs[i]=(ull)fs[i-1]*ff[i]%mod; rev[N-1]=qpow(fs[N-1],-1); for(int i=N-2;i&gt;=0;--i)rev[i]=(ull)rev[i+1]*ff[i+1]%mod; return; } //ull solve(int n,int m) //{ // ull ret=0; // int top=min(n,m); // ull i=1,j; // while(i&lt;=top) // { // j=min(n/(n/i),m/(m/i)); // (ret+=(ull)(miu[j]-miu[i-1])*((n/i)*(m/i))%mod)%=mod; // i=j+1; // } // return ret; //} //ull mobi(ull n,ull m) //{ // if(n&gt;m)swap(n,m); // ull ans=0; // for (int i=1,r;i&lt;=n;i=r+1) // { // r=min(n/(n/i),m/(m/i)); // ans=(ans+sum(n/i)*sum(m/i)%mod*(miu[r]-miu[i-1])%mod)%mod; // } // return ans; //} //ull cheng(ull a,ull b) //{ // ull ret=0; // int tmp1=0,tmp2=0; // memset(ca1,0,sizeof(ca1)); // memset(ca2,0,sizeof(ca2)); // while(a)ca1[++tmp1]=a%10,a/=10; // while(b)ca2[++tmp2]=b%10,b/=10; // int *x=ca1,*y=ca2; // if(tmp2&gt;tmp1)swap(x,y),swap(tmp1,tmp2); // for(int i=1;i&lt;=tmp2;++i)x[i]*=y[i]; // for(int i=1;i&lt;=tmp2;++i) // if(x[i]&gt;10) // { // x[i+1]+=x[i]/10; // x[i]%=10; // } // for(int i=1;i&lt;=tmp1;++i)y[tmp1+1-i]=x[i]; // for(int i=1;i&lt;=tmp1;++i)ret=(ret*10+(y[i]))%mod; // return ret; //} int main() { int T,n,m,k; // freopen(&quot;c.out&quot;,&quot;w&quot;,stdout); init(); scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); ull ans=1; int mn=min(n,m); for(int i=1,r;i&lt;=mn;i=r+1) { r=min(n/(n/i),m/(m/i)); ans=ans*qpow(fs[r]*rev[i-1]%mod,(ull)(n/i)*(m/i)%(mod-1))%mod; } cout&lt;&lt;ans&lt;&lt;endl; } }","raw":"title: SDOI2017 数字表格\ndate: 2017-04-27 11:39:21\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 莫比乌斯反演\n  - 组合数学\n  - 线性筛法\n  - 逆元\n---\n\n# SDOI2017 数字表格\n\n## [洛谷3704](https://www.luogu.org/problem/show?pid=3704) \n---\n## 题目描述\nDoris 刚刚学习了 fibnacci 数列，用 $f[i]$ 表示数列的第 $i$  项，那么：\n\n$f[0]=0$\n\n$f[1]=1$\n\n$f[n]=f[n−1]+f[n−2],n≥2$  Doris 用老师的超级计算机生成了一个 $n×m$ 的表格，第 $i$ 行第 $j$ 列的格子中的数是 $f[gcd(i,j)]$，其中 $gcd(i,j)$ 表示 $i$ 与 $j$ 的最大公约数。\n\nDoris 的表格中共有 $n×m$ 个数，她想知道这些数的乘积是多少。\n\n这些数的乘积实在是太大了，所以 Doris 只想知道乘积对$1000000007$ 取模后的结果。\n\n\n### 输入输出格式\n#### 输入格式：\n有多组测试数据。\n\n第一行一个数 $T$，表示数据组数。\n\n接下来 $T $行，每行两个数 $n$ 和 $m$ 。\n\n\n#### 输出格式：\n输出 $T$ 行，第 $i$ 行的数是第 $i$ 组数据的结果。\n\n\n### 输入输出样例\n#### 输入样例：\n    3\n\n    2 3\n\n    4 5\n\n    6 7\n\n#### 输出样例：\n    1\n\n    6\n\n    960\n\n### 数据范围\n对于 10%的数据，$1≤n,m≤100$；\n\n对于 30% 的数据，$1≤n,m≤1000$ ；\n\n另外存在 30% 的数据，$T≤3$；\n\n对于 100% 的数据，$1≤n,m≤106 1 \\leq n, m \\leq 10 ^ 6 1≤n,m≤10^6$。\n\n\n---\n## 题解\n已知\n\n$$Ans=\\prod_i^n\\prod_j^mf[gcd(i,j)]$$\n$$=\\prod_i^{min(n,m)}f[i]^{g(i)}$$\n\n其中\n\n$$g(x)=\\sum_i^n\\sum_j^m[gcd(i,j)==x]$$\n$$=\\sum_i^{n/x}\\sum_j^{m/x}[gcd(i,j)==1]$$\n$$=\\sum_d^{min(n,m)}\\mu(d)×{n \\over dx}×{m \\over dx}$$\n\n代入原式得\n\n$$Ans=\\prod_i^{min(n,m)}f[i]^{\\sum_d^{min(n,m)}\\mu(d)×{n \\over di}×{m \\over di}}$$\n\n考虑原题需要取模，直接模会炸，需要先预处理逆元和莫比乌斯函数的前缀和，再通过分块优化，即可做到$O(T\\sqrt n)$的时间复杂度。\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #include<cmath>\n    using namespace std;\n    typedef long long ull;\n    typedef double db;;\n    const int mod = 1000000007;\n    const int N = 1e6+1;\n    ull fi[N],p[N],miu[N],phi[N],tot,d[N],f[N],fp[N][3],ff[N],fs[N],rev[N];\n    bool vis[N];\n    int ca1[33],ca2[33];\n\n    ull qpow(ull a,ull b)\n    {\n        ull ret=1;\n        if(b<0)b+=mod-1;\n        while(b)\n        {\n            if(b&1)ret=(ret*a)%mod;\n            b>>=1;\n            a=(a*a)%mod;\n        }\n        return ret;\n    }\n    void init()\n    {\n        miu[1]=phi[1]=fs[0]=f[1]=1;\n        for(int i=2;i<N;++i)\n        {\n            f[i]=(f[i-1]+f[i-2])%mod;\n            if(!vis[i])miu[i]=-1,p[++tot]=i,phi[i]=i-1;\n            for(int j=1;j<=tot&&p[j]*i<N;++j)\n            {\n                vis[i*p[j]]=true;\n                if(i%p[j]==0){miu[i*p[j]]=0;phi[i*p[j]]=phi[i]*p[j];break;}\n                miu[i*p[j]]=-miu[i];\n                phi[i*p[j]]=phi[i]*(p[j]-1);\n            }\n        }\n\n        for(int i=1;i<N;++i)\n        fp[i][0]=qpow(f[i],-1),fp[i][1]=1,fp[i][2]=f[i];\n\n        for(int i=1;i<N;++i)ff[i]=1;\n\n        for(int i=1;i<N;++i)\n        for(int j=i;j<N;j+=i)\n        ff[j]=(ull)ff[j]*fp[i][miu[j/i]+1]%mod;\n        for(int i=1;i<N;++i)fs[i]=(ull)fs[i-1]*ff[i]%mod;\n\n        rev[N-1]=qpow(fs[N-1],-1);\n\n        for(int i=N-2;i>=0;--i)rev[i]=(ull)rev[i+1]*ff[i+1]%mod;\n        return;\n    }\n    //ull solve(int n,int m)\n    //{\n    //    ull ret=0;\n    //    int top=min(n,m);\n    //    ull i=1,j;\n    //    while(i<=top)\n    //    {\n    //        j=min(n/(n/i),m/(m/i));\n    //        (ret+=(ull)(miu[j]-miu[i-1])*((n/i)*(m/i))%mod)%=mod; \n    //        i=j+1;\n    //    }\n    //    return ret;\n    //}\n    //ull mobi(ull n,ull m)\n    //{\n    //\tif(n>m)swap(n,m);\n    //\tull ans=0;\n    //\tfor (int i=1,r;i<=n;i=r+1)\n    //    {\n    //        r=min(n/(n/i),m/(m/i));\n    //        ans=(ans+sum(n/i)*sum(m/i)%mod*(miu[r]-miu[i-1])%mod)%mod;\n    //    }\n    //\treturn ans;\n    //}\n    //ull cheng(ull a,ull b)\n    //{\n    //\tull ret=0;\n    //\tint tmp1=0,tmp2=0;\n    //\tmemset(ca1,0,sizeof(ca1));\n    //\tmemset(ca2,0,sizeof(ca2));\n    //\twhile(a)ca1[++tmp1]=a%10,a/=10;\n    //\twhile(b)ca2[++tmp2]=b%10,b/=10;\n    //\tint *x=ca1,*y=ca2;\n    //\tif(tmp2>tmp1)swap(x,y),swap(tmp1,tmp2);\n    //\tfor(int i=1;i<=tmp2;++i)x[i]*=y[i];\n    //\tfor(int i=1;i<=tmp2;++i)\n    //\tif(x[i]>10)\n    //\t{\n    //\t\tx[i+1]+=x[i]/10;\n    //\t\tx[i]%=10;\n    //\t}\n    //\tfor(int i=1;i<=tmp1;++i)y[tmp1+1-i]=x[i];\n    //\tfor(int i=1;i<=tmp1;++i)ret=(ret*10+(y[i]))%mod;\n    //\treturn ret;\n    //}\n    int main()\n    {\n        int T,n,m,k;\n    //\tfreopen(\"c.out\",\"w\",stdout);\n        init();\n        scanf(\"%d\",&T);\n        while(T--)\n        {\n            scanf(\"%d%d\",&n,&m);\n            ull ans=1;\n            int mn=min(n,m);\n            for(int i=1,r;i<=mn;i=r+1)\n            {\n                r=min(n/(n/i),m/(m/i));\n                ans=ans*qpow(fs[r]*rev[i-1]%mod,(ull)(n/i)*(m/i)%(mod-1))%mod;\n            }\n            cout<<ans<<endl;\n        }\n    }","content":"<h1 id=\"SDOI2017-数字表格\"><a href=\"#SDOI2017-数字表格\" class=\"headerlink\" title=\"SDOI2017 数字表格\"></a>SDOI2017 数字表格</h1><h2 id=\"洛谷3704\"><a href=\"#洛谷3704\" class=\"headerlink\" title=\"洛谷3704\"></a><a href=\"https://www.luogu.org/problem/show?pid=3704\" target=\"_blank\" rel=\"external\">洛谷3704</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Doris 刚刚学习了 fibnacci 数列，用 $f[i]$ 表示数列的第 $i$  项，那么：</p>\n<p>$f[0]=0$</p>\n<p>$f[1]=1$</p>\n<p>$f[n]=f[n−1]+f[n−2],n≥2$  Doris 用老师的超级计算机生成了一个 $n×m$ 的表格，第 $i$ 行第 $j$ 列的格子中的数是 $f[gcd(i,j)]$，其中 $gcd(i,j)$ 表示 $i$ 与 $j$ 的最大公约数。</p>\n<p>Doris 的表格中共有 $n×m$ 个数，她想知道这些数的乘积是多少。</p>\n<p>这些数的乘积实在是太大了，所以 Doris 只想知道乘积对$1000000007$ 取模后的结果。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>有多组测试数据。</p>\n<p>第一行一个数 $T$，表示数据组数。</p>\n<p>接下来 $T $行，每行两个数 $n$ 和 $m$ 。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出 $T$ 行，第 $i$ 行的数是第 $i$ 组数据的结果。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\n\n2 3\n\n4 5\n\n6 7\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>1\n\n6\n\n960\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 10%的数据，$1≤n,m≤100$；</p>\n<p>对于 30% 的数据，$1≤n,m≤1000$ ；</p>\n<p>另外存在 30% 的数据，$T≤3$；</p>\n<p>对于 100% 的数据，$1≤n,m≤106 1 \\leq n, m \\leq 10 ^ 6 1≤n,m≤10^6$。</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>已知</p>\n<p>$$Ans=\\prod_i^n\\prod_j^mf[gcd(i,j)]$$<br>$$=\\prod_i^{min(n,m)}f[i]^{g(i)}$$</p>\n<p>其中</p>\n<p>$$g(x)=\\sum_i^n\\sum_j^m[gcd(i,j)==x]$$<br>$$=\\sum_i^{n/x}\\sum_j^{m/x}[gcd(i,j)==1]$$<br>$$=\\sum_d^{min(n,m)}\\mu(d)×{n \\over dx}×{m \\over dx}$$</p>\n<p>代入原式得</p>\n<p>$$Ans=\\prod_i^{min(n,m)}f[i]^{\\sum_d^{min(n,m)}\\mu(d)×{n \\over di}×{m \\over di}}$$</p>\n<p>考虑原题需要取模，直接模会炸，需要先预处理逆元和莫比乌斯函数的前缀和，再通过分块优化，即可做到$O(T\\sqrt n)$的时间复杂度。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\nusing namespace std;\ntypedef long long ull;\ntypedef double db;;\nconst int mod = 1000000007;\nconst int N = 1e6+1;\null fi[N],p[N],miu[N],phi[N],tot,d[N],f[N],fp[N][3],ff[N],fs[N],rev[N];\nbool vis[N];\nint ca1[33],ca2[33];\n\null qpow(ull a,ull b)\n{\n    ull ret=1;\n    if(b&lt;0)b+=mod-1;\n    while(b)\n    {\n        if(b&amp;1)ret=(ret*a)%mod;\n        b&gt;&gt;=1;\n        a=(a*a)%mod;\n    }\n    return ret;\n}\nvoid init()\n{\n    miu[1]=phi[1]=fs[0]=f[1]=1;\n    for(int i=2;i&lt;N;++i)\n    {\n        f[i]=(f[i-1]+f[i-2])%mod;\n        if(!vis[i])miu[i]=-1,p[++tot]=i,phi[i]=i-1;\n        for(int j=1;j&lt;=tot&amp;&amp;p[j]*i&lt;N;++j)\n        {\n            vis[i*p[j]]=true;\n            if(i%p[j]==0){miu[i*p[j]]=0;phi[i*p[j]]=phi[i]*p[j];break;}\n            miu[i*p[j]]=-miu[i];\n            phi[i*p[j]]=phi[i]*(p[j]-1);\n        }\n    }\n\n    for(int i=1;i&lt;N;++i)\n    fp[i][0]=qpow(f[i],-1),fp[i][1]=1,fp[i][2]=f[i];\n\n    for(int i=1;i&lt;N;++i)ff[i]=1;\n\n    for(int i=1;i&lt;N;++i)\n    for(int j=i;j&lt;N;j+=i)\n    ff[j]=(ull)ff[j]*fp[i][miu[j/i]+1]%mod;\n    for(int i=1;i&lt;N;++i)fs[i]=(ull)fs[i-1]*ff[i]%mod;\n\n    rev[N-1]=qpow(fs[N-1],-1);\n\n    for(int i=N-2;i&gt;=0;--i)rev[i]=(ull)rev[i+1]*ff[i+1]%mod;\n    return;\n}\n//ull solve(int n,int m)\n//{\n//    ull ret=0;\n//    int top=min(n,m);\n//    ull i=1,j;\n//    while(i&lt;=top)\n//    {\n//        j=min(n/(n/i),m/(m/i));\n//        (ret+=(ull)(miu[j]-miu[i-1])*((n/i)*(m/i))%mod)%=mod; \n//        i=j+1;\n//    }\n//    return ret;\n//}\n//ull mobi(ull n,ull m)\n//{\n//    if(n&gt;m)swap(n,m);\n//    ull ans=0;\n//    for (int i=1,r;i&lt;=n;i=r+1)\n//    {\n//        r=min(n/(n/i),m/(m/i));\n//        ans=(ans+sum(n/i)*sum(m/i)%mod*(miu[r]-miu[i-1])%mod)%mod;\n//    }\n//    return ans;\n//}\n//ull cheng(ull a,ull b)\n//{\n//    ull ret=0;\n//    int tmp1=0,tmp2=0;\n//    memset(ca1,0,sizeof(ca1));\n//    memset(ca2,0,sizeof(ca2));\n//    while(a)ca1[++tmp1]=a%10,a/=10;\n//    while(b)ca2[++tmp2]=b%10,b/=10;\n//    int *x=ca1,*y=ca2;\n//    if(tmp2&gt;tmp1)swap(x,y),swap(tmp1,tmp2);\n//    for(int i=1;i&lt;=tmp2;++i)x[i]*=y[i];\n//    for(int i=1;i&lt;=tmp2;++i)\n//    if(x[i]&gt;10)\n//    {\n//        x[i+1]+=x[i]/10;\n//        x[i]%=10;\n//    }\n//    for(int i=1;i&lt;=tmp1;++i)y[tmp1+1-i]=x[i];\n//    for(int i=1;i&lt;=tmp1;++i)ret=(ret*10+(y[i]))%mod;\n//    return ret;\n//}\nint main()\n{\n    int T,n,m,k;\n//    freopen(&quot;c.out&quot;,&quot;w&quot;,stdout);\n    init();\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--)\n    {\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        ull ans=1;\n        int mn=min(n,m);\n        for(int i=1,r;i&lt;=mn;i=r+1)\n        {\n            r=min(n/(n/i),m/(m/i));\n            ans=ans*qpow(fs[r]*rev[i-1]%mod,(ull)(n/i)*(m/i)%(mod-1))%mod;\n        }\n        cout&lt;&lt;ans&lt;&lt;endl;\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/27/SDOI2017 数字表格/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"逆元","slug":"逆元","permalink":"https://prostkhala.github.io/tags/逆元/"},{"name":"线性筛法","slug":"线性筛法","permalink":"https://prostkhala.github.io/tags/线性筛法/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://prostkhala.github.io/tags/莫比乌斯反演/"}]},{"title":"2017年4月 题目总结","date":"2017-04-25T04:03:24.000Z","path":"2017/04/25/2017年4月 题目总结/","text":"BZOJ1001 BeiJing2006 狼抓兔子网络流裸题，考虑到边为双向边，建图时应同样将反向边赋值。同时也应加上反向弧优化（当流量为零时直接将点标记为不可达到即可） BZOJ1002 FJOI2007 轮状病毒最简单的方法是打表找规律，进阶一点是动态规划。其实这题跟基尔霍夫矩阵有关，然而还是找规律。（要加上高精度） BZOJ1003 ZJOI2006 物流运输一道DP题，转移方程为$f[i]=min(f[i],f[j]+k+t[j+1][i]*(i-j))$ BZOJ1004 HNOI2008 CardsBurnside引理裸题，题目中给定的限制满足将洗牌看作置换的条件。只要递推加DP求出每种置换下不变方案数即可。考虑到当两张牌在该置换下属于同一循环节时，不变方案要求两者颜色相同，做一下三维背包即可。 BZOJ1005 HNOI2008 明明的烦恼purfer序列裸题，根据确定purfer序列的规则将度数的限制转化为在序列中的限制，求排列总数即可，对于分母需要求逆元，可以上高精度也可以分解质因数。 BZOJ1006 HNOI2008 神奇的国度弦图裸题，见弦图与区间图。 BZOJ1007 HNOI2008 水平可见直线以斜率维护双端队列，当两端元素被覆盖时出队，在将当前直线加入队列，最后剩下的即为答案。 BZOJ1008 HNOI2008 越狱简单的快速幂，稍微推一下即可得到答案为$qpow(m,n)-(qpow(m-1,n-1)*m)$。 BZOJ1009 HNOI2008 GT考试用KMP和AC自动机皆可，KMP需要DP一下，AC自动机上模板就行。 BZOJ1011 HNOI2008 遥远的行星简单的递推，考虑到题目中所说的限制和误差的条件，不妨在$j$大于一个限制时，将求$j$的受力公式化中的分母化为近似的$(A*j)/2$j即可。 BZOJ1012 JSOI2008 最大数各种数据结构的裸题。 BZOJ1013 JSOI2008 球形空间产生器高斯消元，提示中给出了两点间坐标公式，可以将每个给定的点与圆心坐标通过公式建立联系，再消掉公式右项中的半径，即可套用高斯消元算法。 BZOJ4801 BZOJ4月月赛 打牌考验基础的编程能力，每一轮的优先权是解题的关键，不妨将两人有牌权值相同时特殊处理一下，注意思路要清晰，最后注意下$A$的权值与价值不同，优先出牌的人可能故意输掉一局使得分尽可能大。 BZOJ4810 YNOI2017 由乃的玉米田主要考察bitset的运用，但直接套用会明显会超时，需要莫队算法优化时间复杂度。 洛谷3708 洛谷四月月赛 koishi的数学题设$g(x,i)=g (mod i)$，则可以先打表算出$g(1,1)$到$g(n,n)$的值。观察矩阵可知，考虑$f(x-1)$对$f(x)$的贡献，可知两者的区别主要的不同取决于因子的不同，预处理一下即可。 BZOJ1015 JSOI2008 星球大战考察并查集的应用，由于问题可以离线，可以将操作逆处理，将问题转变为熟悉的集合合并问题，再注意一下剪枝即可。 BZOJ1018 SHOI2008 堵塞的交通分块+并查集，思想很简单(分块优化的暴力)，第一次实现这种数据结构，调了好久。正解是线段树维护每一列自身以及与相邻两列的连通性。考虑两点之间可能的联通方式，枚举所有可能的情况，完成所有操作。（比暴力还难写） BZOJ1019 SHOI2008汉诺塔第一眼看题先打表找了个规律，可知，$f[i]$（当前优先级下有$i$层时的答案）与$f[i-1]$线性相关，于是模拟出来前20项，递推出后十项。（正解为DP，严格遵循题目所给的要求（汉诺塔问题均有$f[i]=f[i-1]*k+b$的递推式）） BZOJ1020 SHOI2008 安全的航线（MARK）典型的计算几何，可以二分可以迭代，具体按照莫涛的论文《迭代思想的应用》实现，但是还是TLE了。后来看题解get了求垂足的姿势，复习了一下求点与多边形包含关系的方法。（mark一下，复习时再敲一遍） BZOJ1021 SHOI2008 循环的债务题目可以进一步简化，即已知每个人初始金钱和构成 洛谷3704 SDOI2017 数字表格","raw":"title: 2017年4月 题目总结\ndate: 2017-4-25 12:03:24\ncategories:\n  - 总结\ntags:\n  - 高斯消元\n  - 高精度算法\n  - 网络流\n  - 动态规划\n  - Polya定理&Burnside引理\n  - 弦图与区间图\n  - 计算几何\n  - AC自动机\n  - KMP\n  - SPLAY\n  - HASH\n  - purfer序列\n  - BITSET\n  - 莫队算法\n  - 并查集\n  - 分块\n---\n\n### [BZOJ1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001) BeiJing2006 狼抓兔子\n\n网络流裸题，考虑到边为双向边，建图时应同样将反向边赋值。同时也应加上反向弧优化（当流量为零时直接将点标记为不可达到即可）\n\n---\n### [BZOJ1002](http://www.lydsy.com/JudgeOnline/problem.php?id=1002) FJOI2007 轮状病毒\n最简单的方法是打表找规律，进阶一点是动态规划。其实这题跟基尔霍夫矩阵有关，然而还是找规律。（要加上高精度）\n\n---\n### [BZOJ1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003) ZJOI2006 物流运输\n一道DP题，转移方程为$f[i]=min(f[i],f[j]+k+t[j+1][i]*(i-j))$\n\n---\n\n### [BZOJ1004](http://www.lydsy.com/JudgeOnline/problem.php?id=1004) HNOI2008 Cards\nBurnside引理裸题，题目中给定的限制满足将洗牌看作置换的条件。只要递推加DP求出每种置换下不变方案数即可。考虑到当两张牌在该置换下属于同一循环节时，不变方案要求两者颜色相同，做一下三维背包即可。\n\n\n---\n### [BZOJ1005](http://www.lydsy.com/JudgeOnline/problem.php?id=1005) \tHNOI2008 明明的烦恼\npurfer序列裸题，根据确定purfer序列的规则将度数的限制转化为在序列中的限制，求排列总数即可，对于分母需要求逆元，可以上高精度也可以分解质因数。\n\n---\n### [BZOJ1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006) \tHNOI2008 神奇的国度\n弦图裸题，见[弦图与区间图](https://prostkhala.github.io/2017/04/21/%E5%BC%A6%E5%9B%BE%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9B%BE/)。\n\n---\n### [BZOJ1007](http://www.lydsy.com/JudgeOnline/problem.php?id=1007) \tHNOI2008 水平可见直线\n以斜率维护双端队列，当两端元素被覆盖时出队，在将当前直线加入队列，最后剩下的即为答案。\n\n---\n### [BZOJ1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008) \tHNOI2008 越狱\n简单的快速幂，稍微推一下即可得到答案为$qpow(m,n)-(qpow(m-1,n-1)*m)$。\n\n---\n### [BZOJ1009](http://www.lydsy.com/JudgeOnline/problem.php?id=1009) \tHNOI2008 GT考试\n用KMP和AC自动机皆可，KMP需要DP一下，AC自动机上模板就行。\n\n---\n### [BZOJ1011](http://www.lydsy.com/JudgeOnline/problem.php?id=1011) \tHNOI2008 遥远的行星\n简单的递推，考虑到题目中所说的限制和误差的条件，不妨在$j$大于一个限制时，将求$j$的受力公式化中的分母化为近似的$(A*j)/2$j即可。\n\n---\n### [BZOJ1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012) \tJSOI2008 最大数\n各种数据结构的裸题。\n\n---\n### [BZOJ1013](http://www.lydsy.com/JudgeOnline/problem.php?id=1013) \tJSOI2008 球形空间产生器\n高斯消元，提示中给出了两点间坐标公式，可以将每个给定的点与圆心坐标通过公式建立联系，再消掉公式右项中的半径，即可套用高斯消元算法。\n\n---\n### [BZOJ4801](http://www.lydsy.com/JudgeOnline/problem.php?id=4801) \tBZOJ4月月赛 打牌\n考验基础的编程能力，每一轮的优先权是解题的关键，不妨将两人有牌权值相同时特殊处理一下，注意思路要清晰，最后注意下$A$的权值与价值不同，优先出牌的人可能故意输掉一局使得分尽可能大。\n\n---\n### [BZOJ4810](http://www.lydsy.com/JudgeOnline/problem.php?id=4810) \tYNOI2017 由乃的玉米田\n主要考察bitset的运用，但直接套用会明显会超时，需要莫队算法优化时间复杂度。\n\n---\n### [洛谷3708](https://www.luogu.org/problem/show?pid=3708) 洛谷四月月赛 koishi的数学题\n设$g(x,i)=g (mod i)$，则可以先打表算出$g(1,1)$到$g(n,n)$的值。观察矩阵可知，考虑$f(x-1)$对$f(x)$的贡献，可知两者的区别主要的不同取决于因子的不同，预处理一下即可。\n\n---\n### [BZOJ1015](http://www.lydsy.com/JudgeOnline/problem.php?id=1015) JSOI2008 星球大战\n考察并查集的应用，由于问题可以离线，可以将操作逆处理，将问题转变为熟悉的集合合并问题，再注意一下剪枝即可。\n\n\n\n---\n### [BZOJ1018](http://www.lydsy.com/JudgeOnline/problem.php?id=1018) \tSHOI2008 堵塞的交通\n分块+并查集，思想很简单(分块优化的暴力)，第一次实现这种数据结构，调了好久。正解是线段树维护每一列自身以及与相邻两列的连通性。考虑两点之间可能的联通方式，枚举所有可能的情况，完成所有操作。（比暴力还难写）\n\n---\n### [BZOJ1019](http://www.lydsy.com/JudgeOnline/problem.php?id=1019) SHOI2008汉诺塔\n第一眼看题先打表找了个规律，可知，$f[i]$（当前优先级下有$i$层时的答案）与$f[i-1]$线性相关，于是模拟出来前20项，递推出后十项。（正解为DP，严格遵循题目所给的要求（汉诺塔问题均有$f[i]=f[i-1]*k+b$的递推式））\n\n---\n### [BZOJ1020](http://www.lydsy.com/JudgeOnline/problem.php?id=1020) SHOI2008 安全的航线（MARK）\n典型的计算几何，可以二分可以迭代，具体按照莫涛的论文《迭代思想的应用》实现，但是还是TLE了。后来看题解get了求垂足的姿势，复习了一下求点与多边形包含关系的方法。（mark一下，复习时再敲一遍）\n\n---\n### [BZOJ1021](http://www.lydsy.com/JudgeOnline/problem.php?id=1021)  SHOI2008 循环的债务\n题目可以进一步简化，即已知每个人初始金钱和构成\n\n---\n### [洛谷3704](https://www.luogu.org/problem/show?pid=3704)  SDOI2017 数字表格\n\n\n\n","content":"<h3 id=\"BZOJ1001-BeiJing2006-狼抓兔子\"><a href=\"#BZOJ1001-BeiJing2006-狼抓兔子\" class=\"headerlink\" title=\"BZOJ1001 BeiJing2006 狼抓兔子\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1001\" target=\"_blank\" rel=\"external\">BZOJ1001</a> BeiJing2006 狼抓兔子</h3><p>网络流裸题，考虑到边为双向边，建图时应同样将反向边赋值。同时也应加上反向弧优化（当流量为零时直接将点标记为不可达到即可）</p>\n<hr>\n<h3 id=\"BZOJ1002-FJOI2007-轮状病毒\"><a href=\"#BZOJ1002-FJOI2007-轮状病毒\" class=\"headerlink\" title=\"BZOJ1002 FJOI2007 轮状病毒\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1002\" target=\"_blank\" rel=\"external\">BZOJ1002</a> FJOI2007 轮状病毒</h3><p>最简单的方法是打表找规律，进阶一点是动态规划。其实这题跟基尔霍夫矩阵有关，然而还是找规律。（要加上高精度）</p>\n<hr>\n<h3 id=\"BZOJ1003-ZJOI2006-物流运输\"><a href=\"#BZOJ1003-ZJOI2006-物流运输\" class=\"headerlink\" title=\"BZOJ1003 ZJOI2006 物流运输\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1003\" target=\"_blank\" rel=\"external\">BZOJ1003</a> ZJOI2006 物流运输</h3><p>一道DP题，转移方程为$f[i]=min(f[i],f[j]+k+t[j+1][i]*(i-j))$</p>\n<hr>\n<h3 id=\"BZOJ1004-HNOI2008-Cards\"><a href=\"#BZOJ1004-HNOI2008-Cards\" class=\"headerlink\" title=\"BZOJ1004 HNOI2008 Cards\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1004\" target=\"_blank\" rel=\"external\">BZOJ1004</a> HNOI2008 Cards</h3><p>Burnside引理裸题，题目中给定的限制满足将洗牌看作置换的条件。只要递推加DP求出每种置换下不变方案数即可。考虑到当两张牌在该置换下属于同一循环节时，不变方案要求两者颜色相同，做一下三维背包即可。</p>\n<hr>\n<h3 id=\"BZOJ1005-HNOI2008-明明的烦恼\"><a href=\"#BZOJ1005-HNOI2008-明明的烦恼\" class=\"headerlink\" title=\"BZOJ1005     HNOI2008 明明的烦恼\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1005\" target=\"_blank\" rel=\"external\">BZOJ1005</a>     HNOI2008 明明的烦恼</h3><p>purfer序列裸题，根据确定purfer序列的规则将度数的限制转化为在序列中的限制，求排列总数即可，对于分母需要求逆元，可以上高精度也可以分解质因数。</p>\n<hr>\n<h3 id=\"BZOJ1006-HNOI2008-神奇的国度\"><a href=\"#BZOJ1006-HNOI2008-神奇的国度\" class=\"headerlink\" title=\"BZOJ1006     HNOI2008 神奇的国度\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1006\" target=\"_blank\" rel=\"external\">BZOJ1006</a>     HNOI2008 神奇的国度</h3><p>弦图裸题，见<a href=\"https://prostkhala.github.io/2017/04/21/%E5%BC%A6%E5%9B%BE%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9B%BE/\">弦图与区间图</a>。</p>\n<hr>\n<h3 id=\"BZOJ1007-HNOI2008-水平可见直线\"><a href=\"#BZOJ1007-HNOI2008-水平可见直线\" class=\"headerlink\" title=\"BZOJ1007     HNOI2008 水平可见直线\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1007\" target=\"_blank\" rel=\"external\">BZOJ1007</a>     HNOI2008 水平可见直线</h3><p>以斜率维护双端队列，当两端元素被覆盖时出队，在将当前直线加入队列，最后剩下的即为答案。</p>\n<hr>\n<h3 id=\"BZOJ1008-HNOI2008-越狱\"><a href=\"#BZOJ1008-HNOI2008-越狱\" class=\"headerlink\" title=\"BZOJ1008     HNOI2008 越狱\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1008\" target=\"_blank\" rel=\"external\">BZOJ1008</a>     HNOI2008 越狱</h3><p>简单的快速幂，稍微推一下即可得到答案为$qpow(m,n)-(qpow(m-1,n-1)*m)$。</p>\n<hr>\n<h3 id=\"BZOJ1009-HNOI2008-GT考试\"><a href=\"#BZOJ1009-HNOI2008-GT考试\" class=\"headerlink\" title=\"BZOJ1009     HNOI2008 GT考试\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1009\" target=\"_blank\" rel=\"external\">BZOJ1009</a>     HNOI2008 GT考试</h3><p>用KMP和AC自动机皆可，KMP需要DP一下，AC自动机上模板就行。</p>\n<hr>\n<h3 id=\"BZOJ1011-HNOI2008-遥远的行星\"><a href=\"#BZOJ1011-HNOI2008-遥远的行星\" class=\"headerlink\" title=\"BZOJ1011     HNOI2008 遥远的行星\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1011\" target=\"_blank\" rel=\"external\">BZOJ1011</a>     HNOI2008 遥远的行星</h3><p>简单的递推，考虑到题目中所说的限制和误差的条件，不妨在$j$大于一个限制时，将求$j$的受力公式化中的分母化为近似的$(A*j)/2$j即可。</p>\n<hr>\n<h3 id=\"BZOJ1012-JSOI2008-最大数\"><a href=\"#BZOJ1012-JSOI2008-最大数\" class=\"headerlink\" title=\"BZOJ1012     JSOI2008 最大数\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1012\" target=\"_blank\" rel=\"external\">BZOJ1012</a>     JSOI2008 最大数</h3><p>各种数据结构的裸题。</p>\n<hr>\n<h3 id=\"BZOJ1013-JSOI2008-球形空间产生器\"><a href=\"#BZOJ1013-JSOI2008-球形空间产生器\" class=\"headerlink\" title=\"BZOJ1013     JSOI2008 球形空间产生器\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1013\" target=\"_blank\" rel=\"external\">BZOJ1013</a>     JSOI2008 球形空间产生器</h3><p>高斯消元，提示中给出了两点间坐标公式，可以将每个给定的点与圆心坐标通过公式建立联系，再消掉公式右项中的半径，即可套用高斯消元算法。</p>\n<hr>\n<h3 id=\"BZOJ4801-BZOJ4月月赛-打牌\"><a href=\"#BZOJ4801-BZOJ4月月赛-打牌\" class=\"headerlink\" title=\"BZOJ4801     BZOJ4月月赛 打牌\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=4801\" target=\"_blank\" rel=\"external\">BZOJ4801</a>     BZOJ4月月赛 打牌</h3><p>考验基础的编程能力，每一轮的优先权是解题的关键，不妨将两人有牌权值相同时特殊处理一下，注意思路要清晰，最后注意下$A$的权值与价值不同，优先出牌的人可能故意输掉一局使得分尽可能大。</p>\n<hr>\n<h3 id=\"BZOJ4810-YNOI2017-由乃的玉米田\"><a href=\"#BZOJ4810-YNOI2017-由乃的玉米田\" class=\"headerlink\" title=\"BZOJ4810     YNOI2017 由乃的玉米田\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=4810\" target=\"_blank\" rel=\"external\">BZOJ4810</a>     YNOI2017 由乃的玉米田</h3><p>主要考察bitset的运用，但直接套用会明显会超时，需要莫队算法优化时间复杂度。</p>\n<hr>\n<h3 id=\"洛谷3708-洛谷四月月赛-koishi的数学题\"><a href=\"#洛谷3708-洛谷四月月赛-koishi的数学题\" class=\"headerlink\" title=\"洛谷3708 洛谷四月月赛 koishi的数学题\"></a><a href=\"https://www.luogu.org/problem/show?pid=3708\" target=\"_blank\" rel=\"external\">洛谷3708</a> 洛谷四月月赛 koishi的数学题</h3><p>设$g(x,i)=g (mod i)$，则可以先打表算出$g(1,1)$到$g(n,n)$的值。观察矩阵可知，考虑$f(x-1)$对$f(x)$的贡献，可知两者的区别主要的不同取决于因子的不同，预处理一下即可。</p>\n<hr>\n<h3 id=\"BZOJ1015-JSOI2008-星球大战\"><a href=\"#BZOJ1015-JSOI2008-星球大战\" class=\"headerlink\" title=\"BZOJ1015 JSOI2008 星球大战\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1015\" target=\"_blank\" rel=\"external\">BZOJ1015</a> JSOI2008 星球大战</h3><p>考察并查集的应用，由于问题可以离线，可以将操作逆处理，将问题转变为熟悉的集合合并问题，再注意一下剪枝即可。</p>\n<hr>\n<h3 id=\"BZOJ1018-SHOI2008-堵塞的交通\"><a href=\"#BZOJ1018-SHOI2008-堵塞的交通\" class=\"headerlink\" title=\"BZOJ1018     SHOI2008 堵塞的交通\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1018\" target=\"_blank\" rel=\"external\">BZOJ1018</a>     SHOI2008 堵塞的交通</h3><p>分块+并查集，思想很简单(分块优化的暴力)，第一次实现这种数据结构，调了好久。正解是线段树维护每一列自身以及与相邻两列的连通性。考虑两点之间可能的联通方式，枚举所有可能的情况，完成所有操作。（比暴力还难写）</p>\n<hr>\n<h3 id=\"BZOJ1019-SHOI2008汉诺塔\"><a href=\"#BZOJ1019-SHOI2008汉诺塔\" class=\"headerlink\" title=\"BZOJ1019 SHOI2008汉诺塔\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1019\" target=\"_blank\" rel=\"external\">BZOJ1019</a> SHOI2008汉诺塔</h3><p>第一眼看题先打表找了个规律，可知，$f[i]$（当前优先级下有$i$层时的答案）与$f[i-1]$线性相关，于是模拟出来前20项，递推出后十项。（正解为DP，严格遵循题目所给的要求（汉诺塔问题均有$f[i]=f[i-1]*k+b$的递推式））</p>\n<hr>\n<h3 id=\"BZOJ1020-SHOI2008-安全的航线（MARK）\"><a href=\"#BZOJ1020-SHOI2008-安全的航线（MARK）\" class=\"headerlink\" title=\"BZOJ1020 SHOI2008 安全的航线（MARK）\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1020\" target=\"_blank\" rel=\"external\">BZOJ1020</a> SHOI2008 安全的航线（MARK）</h3><p>典型的计算几何，可以二分可以迭代，具体按照莫涛的论文《迭代思想的应用》实现，但是还是TLE了。后来看题解get了求垂足的姿势，复习了一下求点与多边形包含关系的方法。（mark一下，复习时再敲一遍）</p>\n<hr>\n<h3 id=\"BZOJ1021-SHOI2008-循环的债务\"><a href=\"#BZOJ1021-SHOI2008-循环的债务\" class=\"headerlink\" title=\"BZOJ1021  SHOI2008 循环的债务\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1021\" target=\"_blank\" rel=\"external\">BZOJ1021</a>  SHOI2008 循环的债务</h3><p>题目可以进一步简化，即已知每个人初始金钱和构成</p>\n<hr>\n<h3 id=\"洛谷3704-SDOI2017-数字表格\"><a href=\"#洛谷3704-SDOI2017-数字表格\" class=\"headerlink\" title=\"洛谷3704  SDOI2017 数字表格\"></a><a href=\"https://www.luogu.org/problem/show?pid=3704\" target=\"_blank\" rel=\"external\">洛谷3704</a>  SDOI2017 数字表格</h3>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/25/2017年4月 题目总结/","excerpt":"","categories":[{"name":"总结","slug":"总结","permalink":"https://prostkhala.github.io/categories/总结/"}],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://prostkhala.github.io/tags/AC自动机/"},{"name":"KMP","slug":"KMP","permalink":"https://prostkhala.github.io/tags/KMP/"},{"name":"计算几何","slug":"计算几何","permalink":"https://prostkhala.github.io/tags/计算几何/"},{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"SPLAY","slug":"SPLAY","permalink":"https://prostkhala.github.io/tags/SPLAY/"},{"name":"弦图与区间图","slug":"弦图与区间图","permalink":"https://prostkhala.github.io/tags/弦图与区间图/"},{"name":"Polya定理&Burnside引理","slug":"Polya定理-Burnside引理","permalink":"https://prostkhala.github.io/tags/Polya定理-Burnside引理/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://prostkhala.github.io/tags/高斯消元/"},{"name":"高精度算法","slug":"高精度算法","permalink":"https://prostkhala.github.io/tags/高精度算法/"},{"name":"网络流","slug":"网络流","permalink":"https://prostkhala.github.io/tags/网络流/"},{"name":"HASH","slug":"HASH","permalink":"https://prostkhala.github.io/tags/HASH/"},{"name":"purfer序列","slug":"purfer序列","permalink":"https://prostkhala.github.io/tags/purfer序列/"},{"name":"BITSET","slug":"BITSET","permalink":"https://prostkhala.github.io/tags/BITSET/"},{"name":"莫队算法","slug":"莫队算法","permalink":"https://prostkhala.github.io/tags/莫队算法/"},{"name":"并查集","slug":"并查集","permalink":"https://prostkhala.github.io/tags/并查集/"},{"name":"分块","slug":"分块","permalink":"https://prostkhala.github.io/tags/分块/"}]},{"title":"弦图与区间图","date":"2017-04-21T02:33:21.000Z","path":"2017/04/21/弦图与区间图/","text":"论文 弦图与区间图-陈丹琦 定义团：图G的一个子图$G′=(V′,E′)$，$G′$为关于$V′$的完全图。 极大团：一个团是极大团当它不是其它团的子集。 最大团：点数最多的团。 弦：连接环中不相邻的两个点的边。 弦图：一个无向图称为弦图当且仅当图中任意长度大于3的环都至少有一个弦。 单纯点：设N(v)表示与点v相邻的点集。一个点称为单纯点当{v} + N(v)的诱导子图为一个团。 完美消除序列：这是一个序列${v_i}$，它满足$vi$在${v{1…n}}$的诱导子图中为单纯点。 弦图的判定：存在完美消除序列的图为弦图。 最小色数：用最少的颜色给点染色使相邻点颜色不同，$χ(G)$为其色数。 最大独立集：最大的一个点集使任意两个点不相邻，$α(G)$为其点数。 最小团覆盖：用最少个数的团覆盖所有的点，$κ(G)$为其团数。 求解完美消除序列：可通过最大势算法求解完美消除序列，维护每个点的势（初始化为零），每次将势最大的点从图中删除，并加入到完美消除序列中，然后将所有与其相连的点的势加一，直到图为空为止。时间复杂度为$O(n^2+m)$,可以用桶优化到$O(n+m)$（并不会）(但是可以用堆优化)。 最小色数的求解：简单的贪心策略，遍历完美消除队列，将当前点染为可行的最小编号颜色，最大的编号即为答案。 最大独立集的求解：仍然是贪心，遍历完美消除队列，如果当前点的所有相邻的点不在独立集中，则将该点加入独立集。 最小团覆盖的求解：最小团覆盖数=最大独立集数（以上一切都不会证） HNOI2008 神奇的国度BZOJ1006 COGS1830 题目描述K国是一个热衷三角形的国度,连人的交往也只喜欢三角原则.他们认为三角关系:即AB相互认识,BC相互认识,CA相互认识,是简洁高效的.为了巩固三角关系,K国禁止四边关系,五边关系等等的存在.所谓N边关系,是指N个人 A1A2…An之间仅存在N对认识关系:(A1A2)(A2A3)…(AnA1),而没有其它认识关系.比如四边关系指ABCD四个人 AB,BC,CD,DA相互认识,而AC,BD不认识.全民比赛时,为了防止做弊，规定任意一对相互认识的人不得在一队，国王相知道，最少可以分多少支队。 输入输出格式输入格式：第一行两个整数N，M。表示有N个人，M对认识关系. 接下来M行每行输入一对朋友关系 。 输出格式：输出一个整数，最少可以分多少队 。 输入输出样例输入样例：4 5 1 2 1 4 2 4 2 3 3 4 输出样例：3 (1,3)(2)(4)为一种可行方案 数据范围$1&lt;=N&lt;=10000,1&lt;=M&lt;=1000000$ 题解根据题目所给条件可知，任何点数大于三的环都存在弦，可知该图为弦图，直接求解最小染色数即可。（该题数据范围较小，不需要桶优化） CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; const int N =1e5+1; const int inf = 0x7fffffff; struct nd{int ne,to;}e[20*N]; int head[N],cnt,tot,vis[N],p[N],q[N],n,m,ans,c[N]; bool use[N]; void in(int x,int y) { e[++cnt].ne=head[x]; e[cnt].to=y; head[x]=cnt; return; } int main() { // freopen(&quot;bzoj_1006.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1006.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x,y;i&lt;=m;++i)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x); int x=1; while(tot!=n) { for(int i=1;i&lt;=n;++i)if(p[i]&gt;p[x]&amp;&amp;!vis[i])x=i; vis[x]=1;q[++tot]=x; for(int i=head[x];i;i=e[i].ne)p[e[i].to]++; x=inf; } for(int t=1;t&lt;=n;++t) { int x=q[t]; for(int i=1;i&lt;=ans;++i)use[i]=0; for(int i=head[x];i;i=e[i].ne)use[c[e[i].to]]=true; int now=1; while(use[now])now++; c[x]=now; if(now&gt;ans)ans=now; } printf(&quot;%d&quot;,ans); }","raw":"title: 弦图与区间图\ndate: 2017-04-21 10:33:21\ncategories:\n  - 图论\n  - 弦图与区间图\ntags:\n  - 图论\n  - 弦图与区间图\n---\n\n# 论文\n [弦图与区间图-陈丹琦](https://wenku.baidu.com/view/6f9f2223dd36a32d73758126.html)\n\n---\n\n# 定义\n#### 团：\n图G的一个子图$G′=(V′,E′)$，$G′$为关于$V′$的完全图。\n\n#### 极大团：\n一个团是极大团当它不是其它团的子集。\n\n#### 最大团：\n点数最多的团。\n\n#### 弦：\n连接环中不相邻的两个点的边。\n\n#### 弦图：\n一个无向图称为弦图当且仅当图中任意长度大于3的环都至少有一个弦。\n\n#### 单纯点：\n设N(v)表示与点v相邻的点集。一个点称为单纯点当{v} + N(v)的诱导子图为一个团。\n\n#### 完美消除序列：\n这是一个序列${v_i}$，它满足$v_i$在${v_{1...n}}$的诱导子图中为单纯点。\n\n#### 弦图的判定：\n存在完美消除序列的图为弦图。\n\n#### 最小色数：\n用最少的颜色给点染色使相邻点颜色不同，$χ(G)$为其色数。\n\n#### 最大独立集：\n最大的一个点集使任意两个点不相邻，$α(G)$为其点数。\n\n#### 最小团覆盖：\n用最少个数的团覆盖所有的点，$κ(G)$为其团数。\n\n---\n\n# 求解\n\n#### 完美消除序列：\n可通过最大势算法求解完美消除序列，维护每个点的势（初始化为零），每次将势最大的点从图中删除，并加入到完美消除序列中，然后将所有与其相连的点的势加一，直到图为空为止。时间复杂度为$O(n^2+m)$,可以用桶优化到$O(n+m)$（并不会）(但是可以用堆优化)。\n\n#### 最小色数的求解：\n简单的贪心策略，遍历完美消除队列，将当前点染为可行的最小编号颜色，最大的编号即为答案。\n\n#### 最大独立集的求解：\n仍然是贪心，遍历完美消除队列，如果当前点的所有相邻的点不在独立集中，则将该点加入独立集。\n\n#### 最小团覆盖的求解：\n##### 最小团覆盖数=最大独立集数\n\n（以上一切都不会证）\n\n---\n# HNOI2008 神奇的国度\n## [BZOJ1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006) [COGS1830](http://cogs.pro/cogs/problem/problem.php?pid=1830)\n\n---\n## 题目描述\n\nK国是一个热衷三角形的国度,连人的交往也只喜欢三角原则.他们认为三角关系:即AB相互认识,BC相互认识,CA相互认识,是简洁高效的.为了巩固三角关系,K国禁止四边关系,五边关系等等的存在.所谓N边关系,是指N个人 A1A2...An之间仅存在N对认识关系:(A1A2)(A2A3)...(AnA1),而没有其它认识关系.比如四边关系指ABCD四个人 AB,BC,CD,DA相互认识,而AC,BD不认识.全民比赛时,为了防止做弊，规定任意一对相互认识的人不得在一队，国王相知道，最少可以分多少支队。 \n\n### 输入输出格式\n#### 输入格式：\n第一行两个整数N，M。表示有N个人，M对认识关系. 接下来M行每行输入一对朋友关系 。\n\n#### 输出格式：\n输出一个整数，最少可以分多少队 。\n\n\n### 输入输出样例\n#### 输入样例：\n\n\t4 5\n    1 2\n    1 4\n    2 4\n    2 3\n    3 4\n\n#### 输出样例：\n    3\n    (1,3)(2)(4)为一种可行方案 \n\n### 数据范围\n$1<=N<=10000,1<=M<=1000000$\n\n---\n\n## 题解\n\n根据题目所给条件可知，任何点数大于三的环都存在弦，可知该图为弦图，直接求解最小染色数即可。（该题数据范围较小，不需要桶优化）\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    using namespace std;\n    const int N =1e5+1;\n    const int inf = 0x7fffffff;\n    struct nd{int ne,to;}e[20*N];\n    int head[N],cnt,tot,vis[N],p[N],q[N],n,m,ans,c[N];\n    bool use[N];\n    void in(int x,int y)\n    {\n        e[++cnt].ne=head[x];\n        e[cnt].to=y;\n        head[x]=cnt;\n        return;\n    }\n    int main()\n    {\n    //\tfreopen(\"bzoj_1006.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1006.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1,x,y;i<=m;++i)scanf(\"%d%d\",&x,&y),in(x,y),in(y,x);\n        int x=1;\n        while(tot!=n)\n        {\n            for(int i=1;i<=n;++i)if(p[i]>p[x]&&!vis[i])x=i;\n            vis[x]=1;q[++tot]=x;\n            for(int i=head[x];i;i=e[i].ne)p[e[i].to]++;\n            x=inf;\n        }\n        for(int t=1;t<=n;++t)\n        {\n            int x=q[t];\n            for(int i=1;i<=ans;++i)use[i]=0;\n            for(int i=head[x];i;i=e[i].ne)use[c[e[i].to]]=true;\n            int now=1;\n            while(use[now])now++;\n            c[x]=now;\n            if(now>ans)ans=now;\n        }\n        printf(\"%d\",ans);\n    }","content":"<h1 id=\"论文\"><a href=\"#论文\" class=\"headerlink\" title=\"论文\"></a>论文</h1><p> <a href=\"https://wenku.baidu.com/view/6f9f2223dd36a32d73758126.html\" target=\"_blank\" rel=\"external\">弦图与区间图-陈丹琦</a></p>\n<hr>\n<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><h4 id=\"团：\"><a href=\"#团：\" class=\"headerlink\" title=\"团：\"></a>团：</h4><p>图G的一个子图$G′=(V′,E′)$，$G′$为关于$V′$的完全图。</p>\n<h4 id=\"极大团：\"><a href=\"#极大团：\" class=\"headerlink\" title=\"极大团：\"></a>极大团：</h4><p>一个团是极大团当它不是其它团的子集。</p>\n<h4 id=\"最大团：\"><a href=\"#最大团：\" class=\"headerlink\" title=\"最大团：\"></a>最大团：</h4><p>点数最多的团。</p>\n<h4 id=\"弦：\"><a href=\"#弦：\" class=\"headerlink\" title=\"弦：\"></a>弦：</h4><p>连接环中不相邻的两个点的边。</p>\n<h4 id=\"弦图：\"><a href=\"#弦图：\" class=\"headerlink\" title=\"弦图：\"></a>弦图：</h4><p>一个无向图称为弦图当且仅当图中任意长度大于3的环都至少有一个弦。</p>\n<h4 id=\"单纯点：\"><a href=\"#单纯点：\" class=\"headerlink\" title=\"单纯点：\"></a>单纯点：</h4><p>设N(v)表示与点v相邻的点集。一个点称为单纯点当{v} + N(v)的诱导子图为一个团。</p>\n<h4 id=\"完美消除序列：\"><a href=\"#完美消除序列：\" class=\"headerlink\" title=\"完美消除序列：\"></a>完美消除序列：</h4><p>这是一个序列${v_i}$，它满足$v<em>i$在${v</em>{1…n}}$的诱导子图中为单纯点。</p>\n<h4 id=\"弦图的判定：\"><a href=\"#弦图的判定：\" class=\"headerlink\" title=\"弦图的判定：\"></a>弦图的判定：</h4><p>存在完美消除序列的图为弦图。</p>\n<h4 id=\"最小色数：\"><a href=\"#最小色数：\" class=\"headerlink\" title=\"最小色数：\"></a>最小色数：</h4><p>用最少的颜色给点染色使相邻点颜色不同，$χ(G)$为其色数。</p>\n<h4 id=\"最大独立集：\"><a href=\"#最大独立集：\" class=\"headerlink\" title=\"最大独立集：\"></a>最大独立集：</h4><p>最大的一个点集使任意两个点不相邻，$α(G)$为其点数。</p>\n<h4 id=\"最小团覆盖：\"><a href=\"#最小团覆盖：\" class=\"headerlink\" title=\"最小团覆盖：\"></a>最小团覆盖：</h4><p>用最少个数的团覆盖所有的点，$κ(G)$为其团数。</p>\n<hr>\n<h1 id=\"求解\"><a href=\"#求解\" class=\"headerlink\" title=\"求解\"></a>求解</h1><h4 id=\"完美消除序列：-1\"><a href=\"#完美消除序列：-1\" class=\"headerlink\" title=\"完美消除序列：\"></a>完美消除序列：</h4><p>可通过最大势算法求解完美消除序列，维护每个点的势（初始化为零），每次将势最大的点从图中删除，并加入到完美消除序列中，然后将所有与其相连的点的势加一，直到图为空为止。时间复杂度为$O(n^2+m)$,可以用桶优化到$O(n+m)$（并不会）(但是可以用堆优化)。</p>\n<h4 id=\"最小色数的求解：\"><a href=\"#最小色数的求解：\" class=\"headerlink\" title=\"最小色数的求解：\"></a>最小色数的求解：</h4><p>简单的贪心策略，遍历完美消除队列，将当前点染为可行的最小编号颜色，最大的编号即为答案。</p>\n<h4 id=\"最大独立集的求解：\"><a href=\"#最大独立集的求解：\" class=\"headerlink\" title=\"最大独立集的求解：\"></a>最大独立集的求解：</h4><p>仍然是贪心，遍历完美消除队列，如果当前点的所有相邻的点不在独立集中，则将该点加入独立集。</p>\n<h4 id=\"最小团覆盖的求解：\"><a href=\"#最小团覆盖的求解：\" class=\"headerlink\" title=\"最小团覆盖的求解：\"></a>最小团覆盖的求解：</h4><h5 id=\"最小团覆盖数-最大独立集数\"><a href=\"#最小团覆盖数-最大独立集数\" class=\"headerlink\" title=\"最小团覆盖数=最大独立集数\"></a>最小团覆盖数=最大独立集数</h5><p>（以上一切都不会证）</p>\n<hr>\n<h1 id=\"HNOI2008-神奇的国度\"><a href=\"#HNOI2008-神奇的国度\" class=\"headerlink\" title=\"HNOI2008 神奇的国度\"></a>HNOI2008 神奇的国度</h1><h2 id=\"BZOJ1006-COGS1830\"><a href=\"#BZOJ1006-COGS1830\" class=\"headerlink\" title=\"BZOJ1006 COGS1830\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1006\" target=\"_blank\" rel=\"external\">BZOJ1006</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1830\" target=\"_blank\" rel=\"external\">COGS1830</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>K国是一个热衷三角形的国度,连人的交往也只喜欢三角原则.他们认为三角关系:即AB相互认识,BC相互认识,CA相互认识,是简洁高效的.为了巩固三角关系,K国禁止四边关系,五边关系等等的存在.所谓N边关系,是指N个人 A1A2…An之间仅存在N对认识关系:(A1A2)(A2A3)…(AnA1),而没有其它认识关系.比如四边关系指ABCD四个人 AB,BC,CD,DA相互认识,而AC,BD不认识.全民比赛时,为了防止做弊，规定任意一对相互认识的人不得在一队，国王相知道，最少可以分多少支队。 </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行两个整数N，M。表示有N个人，M对认识关系. 接下来M行每行输入一对朋友关系 。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出一个整数，最少可以分多少队 。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>4 5\n1 2\n1 4\n2 4\n2 3\n3 4\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>3\n(1,3)(2)(4)为一种可行方案 \n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>$1&lt;=N&lt;=10000,1&lt;=M&lt;=1000000$</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>根据题目所给条件可知，任何点数大于三的环都存在弦，可知该图为弦图，直接求解最小染色数即可。（该题数据范围较小，不需要桶优化）</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nconst int N =1e5+1;\nconst int inf = 0x7fffffff;\nstruct nd{int ne,to;}e[20*N];\nint head[N],cnt,tot,vis[N],p[N],q[N],n,m,ans,c[N];\nbool use[N];\nvoid in(int x,int y)\n{\n    e[++cnt].ne=head[x];\n    e[cnt].to=y;\n    head[x]=cnt;\n    return;\n}\nint main()\n{\n//    freopen(&quot;bzoj_1006.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;bzoj_1006.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1,x,y;i&lt;=m;++i)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x);\n    int x=1;\n    while(tot!=n)\n    {\n        for(int i=1;i&lt;=n;++i)if(p[i]&gt;p[x]&amp;&amp;!vis[i])x=i;\n        vis[x]=1;q[++tot]=x;\n        for(int i=head[x];i;i=e[i].ne)p[e[i].to]++;\n        x=inf;\n    }\n    for(int t=1;t&lt;=n;++t)\n    {\n        int x=q[t];\n        for(int i=1;i&lt;=ans;++i)use[i]=0;\n        for(int i=head[x];i;i=e[i].ne)use[c[e[i].to]]=true;\n        int now=1;\n        while(use[now])now++;\n        c[x]=now;\n        if(now&gt;ans)ans=now;\n    }\n    printf(&quot;%d&quot;,ans);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/21/弦图与区间图/","excerpt":"","categories":[{"name":"图论","slug":"图论","permalink":"https://prostkhala.github.io/categories/图论/"},{"name":"弦图与区间图","slug":"图论/弦图与区间图","permalink":"https://prostkhala.github.io/categories/图论/弦图与区间图/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://prostkhala.github.io/tags/图论/"},{"name":"弦图与区间图","slug":"弦图与区间图","permalink":"https://prostkhala.github.io/tags/弦图与区间图/"}]},{"title":"组合数学总结","date":"2017-04-10T13:50:08.802Z","path":"2017/04/10/组合数学总结/","text":"组合数学总结 基本原理加法原理做一件事情，完成它有$N$类方式，第一类方式有$M_1$种方法，第二类方式有$M_2$种方法，……，第$N$类方式有$M_N$种方法，那么完成这件事情共有$M1+M2+……+M_N$种方法。 乘法原理做一件事，完成它需要分成$n$个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，……，做第n步有$m_n$种不同的方法。那么完成这件事共有$m_1×m_2×m_3×…×m_n$种不同的方法。 排列数从$n$个不同元素中任取$r（r≦n）$个元素排成一列（考虑元素先后出现次序）称此为一个排列，此种排列的总数即为排列数，即叫做从$n$个不同元素中取出r个元素的排列数，记为$A(n,r)$。 对于$A(n,r)$，第一个元素有$n$种取法，第二个元素有$n-1$种取法，……，第$r$个元素有$n-r+1$中取法，则根据乘法原理可得。 $A(n,r)=\\frac {n!} {(n-r)!}$ 组合数从$n$个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的组合数，记为$C(n，m)$。 根据定义，可知组合数与排列数的不同便是组合数对顺序没有要求。对组合数来说${1,2,3}$与${1,3,2}$是一种组合，但对排列数则不是。那么在组合数中重复计算的次数即为$r$的全排列，即$r!$， 则有 $C(n,r)=\\frac {A(n,r)} {r!}$， 即 $C(n,r)=\\frac {n!} {r!(n-r)!}$ 常见定理与组合论证1.$C(n,r)=C(n,n-r)$将其表示为一个长度为$n$的二进制串，则组合数为有$r$位为$1$的串的个数，易知其与有$n-r$位为$0$的串的个数等价。 2.$C(n,r)=C(n-1,r-1)+C(n-1,r)$将其表示为一个长度为$n$的二进制串，利用动态规划的思想，可设$C(n-1,r-1)$表示长度为$n-1$的串且在末尾新加入一个$1$的方案数，$C(n-1,r)$表示长度为$n-1$的串且在末尾新加入一个$0$，易证该递推式的正确性。（初始化为$C(i,i)=0$） 3.$2^n=\\sum_k C(n,k)$$2^n$为长度为$n$的二进制串的总方案数，根据加法原理，易知其等价于长度为$n$的二进制串且有$0,1,….n$个$1$的方案数和。 4.$(a+b)^n=\\sum_kC(n,k)a^kb^{b-k}$这个定理同样可以直接通过二项式定理求证。 5.$C(n+m,r)=\\sum_kC(n,k)*C(m,r-k)$左项可以表示为一个长度为$a+b$的二进制串，右项则可以表示为一个长度为$a$的二进制串拼上一个长度为$b$的二进制串，此处可以转化为定理$3$,再结合乘法原理即可得证。 6.$C(n,r)=\\frac n r(n-1,r-1)$结合定理一，可以通过简单的推导得到该定理。 7.$C(n,m)C(m,r)=C(n,r)C(n-r,m-r)$可以将左式表示为在$n$个学生中选出$m$个组长，再在$m$个组长中选出$r$班干部，则右式可以表示为在$n$个学生中选$r$个班干部，再在剩余的学生$n-r$中选出$m-r$个不是班干部的组长，易知两者等价。 可重复组合数从$n$个不同元素中，任取$m(m≤n)$个元素并成一组（可以重复选择），叫做从$n$个不同元素中取出$m$个元素的一个可重复组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的可重复组合数。 可重复组合即为$C(n+m-1,m)$。 对于此结论的证明可以逆向来看，$n$中选$m$个元素即为将$m$个球放在$n$个盒子内的方案数，每个盒子中允许放$0$到$m$个球。对于这$m$个球来说，即为$n-1$个断点将其分为了$n$部分。 不妨将断点用二进制串表示为0，球表示为1，那么在$3$个元素中选$5$个元素的一种方案即可表示为 $ 1-1-1-0-1-0-1 $ 易观察到可重复组合数等于在$n+m-1$个元素中选取$m$个$1$的方案数 即为 $C(n+m-1,m)$ 可重复组合数同样可以解决如下的问题： 已知 $x_1+x_2+x_3+……+x_n=m(x_i&gt;=0)$ 求方程的解数。 此处可以看出答案即为$C(n+m-1,m)$，论证方法同上，该问题同样有很多变式，如改变$x_i$的取值范围等，同样可以通过如上方式得解，此处不再赘述。 斯特林数斯特林数分为第一类斯特林数和第二类斯特林数，其中第一类斯特林数为将$n$个物体排成$m$个非空循环排列的方案数，记为$s(n,m)$，第二类斯特林数为将$n$个物体划分到$m$个集合的方案数，记为$S(n,m)$。 第一类斯特林数$s(n,m)$的递推公式： $s(n,m)=(n-1)*s(n-1,m)+s(n-1,m-1) (1&lt;=m&lt;=n-1)$ 边界条件： $s(n,0)=0 (n&gt;=1)$ $s(n,n)=1(n&gt;=0)$ 递推关系的说明： 考虑第$n$个物品，$n$可以单独构成一个非空循环排列，这样前$n-1$种物品构成$m-1$个非空循环排列，方法数为$s(n-1,m-1)$。 也可以前$n-1$种物品构成$m$个非空循环排列，而第$n$个物品插入第$i$个物品的左边，这有$(n-1)×s(n-1,m)$种方法。 第二类斯特林数S(n,m)的递推公式是： $S(n,m)=m×S(n-1,m)+S(n-1,m-1) (1&lt;=m&lt;=n-1)$ 边界条件： $s(n,0)=0 (n&gt;=1)$ $s(n,n)=1(n&gt;=0)$ 递推关系的说明： 考虑第$n$个物品，$n$可以单独构成一个非空集合，此时前$n-1$个物品构成$m-1$个非空的不可辨别的集合，方法数为$S(n-1,m-1)$； 也可以前$n-1$种物品构成$m$个非空的不可辨别的集合，第$n$个物品放入任意一个中，这样有$m×S(n-1,m)$种方法。 第一类斯特林数和第二类斯特林数有相同的初始条件，但递推关系不同，两者在计数问题中均有着广泛的运用。 卡特兰数一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列? 该答案的解即为卡特兰数。实际上，卡特兰数也同样可以表示为有n个节点的无标号树的个数，汉诺塔问题的解，括号表达式的方案数,凸多边形的三角划分数等等，在组合数学中有着广泛的应用。 令$h(0)=1$,$h(1)=1$，则卡特兰数数满足递推式： $h(n)= h(0)×h(n-1)+h(1)×h(n-2) + … + h(n-1)×h(0) (n&gt;=2)$ 亦或 $h(n)=h(n-1)×(4×n-2)/(n+1)$ 同样可以用组合数表示 $h(n)=\\frac {C(2n,n)} {n+1}$ 或者 $h(n)=C(2n,n)-C(2n,n-1)$ 证明可以将出栈入栈的操作集合，看作一个长度为$2n$的二进制串，$0$代表入栈操作，$1$代表出栈操作，则该字符串有两个限制：0和1的个数相同（即对应每个元素只能入栈出栈一次），对于所有前缀，0的个数要大于等于1的个数（对应栈为空时不能继续出栈）。 先求出只满足第一个限制的方案数，易知其为$C(2n,n)$。 再考虑第二个限制需要排除的方案，易知其前缀必有一处$1$的个数大于$0$的个数，可设此处有$k$个$0$，$k+1$个$1$，剩下的串中有$n-k$个$0$，$n-k-1$个$1$，将剩下的串按位取反，则得到的新串中共有$n-1$个$0$，$n+1$个$1$，这样的串共有$C(2n,n-1)$。 则有 $h(n)=C(2n,n)-C(2n,n-1)$ 以上的组合论证均涉及模型的转化，实际上，模型的建立在组合论证中具有重要的作用，模型需要满足尽可能简化问题，确保与原问题等价等条件，才能优美地求解。 容斥原理在计数时，为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。 易知 则通项公式表示为 错排公式错排是给定原顺序（一般为有序数列），求每个元素都不在原位置的排列方案数。递推式为： $D(n) = (n-1)[ D(n-2) + D(n-1)]$ 初始条件为： $D(1) = 0 $ $ D(2) = 1$ 题目总结：","raw":"title: 组合数学总结\ndate: 2017-m-d h:min:s\ncategories:\n  - 数论\ntags:\n  - 组合数学\n  - 逆元\n  - Polya定理&Burnside引理\n  - 群论\n  - 数论\n  - 容斥原理\n  - no yet\n---\n\n# 组合数学总结\n---\n## 基本原理\n### 加法原理\n做一件事情，完成它有$N$类方式，第一类方式有$M_1$种方法，第二类方式有$M_2$种方法，……，第$N$类方式有$M_N$种方法，那么完成这件事情共有$M1+M2+……+M_N$种方法。\n### 乘法原理\n做一件事，完成它需要分成$n$个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，……，做第n步有$m_n$种不同的方法。那么完成这件事共有$m_1×m_2×m_3×…×m_n$种不同的方法。\n\n---\n## 排列数\n从$n$个不同元素中任取$r（r≦n）$个元素排成一列（考虑元素先后出现次序）称此为一个排列，此种排列的总数即为排列数，即叫做从$n$个不同元素中取出r个元素的排列数，记为$A(n,r)$。\n\n对于$A(n,r)$，第一个元素有$n$种取法，第二个元素有$n-1$种取法，……，第$r$个元素有$n-r+1$中取法，则根据乘法原理可得。\n\n$A(n,r)=\\frac {n!} {(n-r)!}$\n\n---\n## 组合数\n从$n$个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的组合数，记为$C(n，m)$。\n\n根据定义，可知组合数与排列数的不同便是组合数对顺序没有要求。对组合数来说${1,2,3}$与${1,3,2}$是一种组合，但对排列数则不是。那么在组合数中重复计算的次数即为$r$的全排列，即$r!$，\n\n则有\n\n$C(n,r)=\\frac {A(n,r)} {r!}$，\n\n即\n\n$C(n,r)=\\frac {n!} {r!(n-r)!}$\n\n### 常见定理与组合论证\n\n#### 1.$C(n,r)=C(n,n-r)$\n将其表示为一个长度为$n$的二进制串，则组合数为有$r$位为$1$的串的个数，易知其与有$n-r$位为$0$的串的个数等价。\n#### 2.$C(n,r)=C(n-1,r-1)+C(n-1,r)$\n将其表示为一个长度为$n$的二进制串，利用动态规划的思想，可设$C(n-1,r-1)$表示长度为$n-1$的串且在末尾新加入一个$1$的方案数，$C(n-1,r)$表示长度为$n-1$的串且在末尾新加入一个$0$，易证该递推式的正确性。（初始化为$C(i,i)=0$）\n#### 3.$2^n=\\sum_k C(n,k)$\n$2^n$为长度为$n$的二进制串的总方案数，根据加法原理，易知其等价于长度为$n$的二进制串且有$0,1,....n$个$1$的方案数和。\n#### 4.$(a+b)^n=\\sum_kC(n,k)a^kb^{b-k}$\n这个定理同样可以直接通过二项式定理求证。\n\n#### 5.$C(n+m,r)=\\sum_kC(n,k)*C(m,r-k)$\n左项可以表示为一个长度为$a+b$的二进制串，右项则可以表示为一个长度为$a$的二进制串拼上一个长度为$b$的二进制串，此处可以转化为定理$3$,再结合乘法原理即可得证。\n#### 6.$C(n,r)=\\frac n r(n-1,r-1)$\n结合定理一，可以通过简单的推导得到该定理。\n#### 7.$C(n,m)C(m,r)=C(n,r)C(n-r,m-r)$\n可以将左式表示为在$n$个学生中选出$m$个组长，再在$m$个组长中选出$r$班干部，则右式可以表示为在$n$个学生中选$r$个班干部，再在剩余的学生$n-r$中选出$m-r$个不是班干部的组长，易知两者等价。\n\n---\n## 可重复组合数\n从$n$个不同元素中，任取$m(m≤n)$个元素并成一组（可以重复选择），叫做从$n$个不同元素中取出$m$个元素的一个可重复组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的可重复组合数。\n\n可重复组合即为$C(n+m-1,m)$。\n\n对于此结论的证明可以逆向来看，$n$中选$m$个元素即为将$m$个球放在$n$个盒子内的方案数，每个盒子中允许放$0$到$m$个球。对于这$m$个球来说，即为$n-1$个断点将其分为了$n$部分。\n\n不妨将断点用二进制串表示为0，球表示为1，那么在$3$个元素中选$5$个元素的一种方案即可表示为\n\n$ 1-1-1-0-1-0-1 $\n\n易观察到可重复组合数等于在$n+m-1$个元素中选取$m$个$1$的方案数\n\n即为\n\n$C(n+m-1,m)$\n\n可重复组合数同样可以解决如下的问题：\n\n已知\n\n$x_1+x_2+x_3+……+x_n=m(x_i>=0)$\n\n求方程的解数。\n\n此处可以看出答案即为$C(n+m-1,m)$，论证方法同上，该问题同样有很多变式，如改变$x_i$的取值范围等，同样可以通过如上方式得解，此处不再赘述。\n\n---\n## 斯特林数\n斯特林数分为第一类斯特林数和第二类斯特林数，其中第一类斯特林数为将$n$个物体排成$m$个非空循环排列的方案数，记为$s(n,m)$，第二类斯特林数为将$n$个物体划分到$m$个集合的方案数，记为$S(n,m)$。\n### 第一类斯特林数\n$s(n,m)$的递推公式：\n\n$s(n,m)=(n-1)*s(n-1,m)+s(n-1,m-1) (1<=m<=n-1)$\n\n边界条件：\n\n$s(n,0)=0 (n>=1)$ $s(n,n)=1(n>=0)$\n\n\n递推关系的说明：\n\n考虑第$n$个物品，$n$可以单独构成一个非空循环排列，这样前$n-1$种物品构成$m-1$个非空循环排列，方法数为$s(n-1,m-1)$。\n\n也可以前$n-1$种物品构成$m$个非空循环排列，而第$n$个物品插入第$i$个物品的左边，这有$(n-1)×s(n-1,m)$种方法。\n\n \n\n \n\n### 第二类斯特林数\n\nS(n,m)的递推公式是：\n\n$S(n,m)=m×S(n-1,m)+S(n-1,m-1) (1<=m<=n-1)$\n\n边界条件：\n\n$s(n,0)=0 (n>=1)$ $s(n,n)=1(n>=0)$\n\n递推关系的说明：\n\n考虑第$n$个物品，$n$可以单独构成一个非空集合，此时前$n-1$个物品构成$m-1$个非空的不可辨别的集合，方法数为$S(n-1,m-1)$；\n\n也可以前$n-1$种物品构成$m$个非空的不可辨别的集合，第$n$个物品放入任意一个中，这样有$m×S(n-1,m)$种方法。\n\n第一类斯特林数和第二类斯特林数有相同的初始条件，但递推关系不同，两者在计数问题中均有着广泛的运用。\n\n\n---\n## 卡特兰数\n一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?\n\n该答案的解即为卡特兰数。实际上，卡特兰数也同样可以表示为有n个节点的无标号树的个数，汉诺塔问题的解，括号表达式的方案数,凸多边形的三角划分数等等，在组合数学中有着广泛的应用。\n\n令$h(0)=1$,$h(1)=1$，则卡特兰数数满足递推式：\n\n$h(n)= h(0)×h(n-1)+h(1)×h(n-2) + ... + h(n-1)×h(0) (n>=2)$\n\n亦或\n\n$h(n)=h(n-1)×(4×n-2)/(n+1)$\n\n同样可以用组合数表示\n\n$h(n)=\\frac {C(2n,n)} {n+1}$\n\n或者\n\n$h(n)=C(2n,n)-C(2n,n-1)$\n\n证明可以将出栈入栈的操作集合，看作一个长度为$2n$的二进制串，$0$代表入栈操作，$1$代表出栈操作，则该字符串有两个限制：0和1的个数相同（即对应每个元素只能入栈出栈一次），对于所有前缀，0的个数要大于等于1的个数（对应栈为空时不能继续出栈）。\n\n先求出只满足第一个限制的方案数，易知其为$C(2n,n)$。\n\n再考虑第二个限制需要排除的方案，易知其前缀必有一处$1$的个数大于$0$的个数，可设此处有$k$个$0$，$k+1$个$1$，剩下的串中有$n-k$个$0$，$n-k-1$个$1$，将剩下的串按位取反，则得到的新串中共有$n-1$个$0$，$n+1$个$1$，这样的串共有$C(2n,n-1)$。\n\n则有\n\n$h(n)=C(2n,n)-C(2n,n-1)$\n\n以上的组合论证均涉及模型的转化，实际上，模型的建立在组合论证中具有重要的作用，模型需要满足尽可能简化问题，确保与原问题等价等条件，才能优美地求解。\n\n---\n## 容斥原理\n在计数时，为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。\n\n易知\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/05f67b2ce4414f2a1f96e4210a86d71028aa53b6)\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/0b8e7c1631ec013eed94feb5aa406a573caa3559)\n\n则通项公式表示为\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/a7589a99f7137c74fd85940231971082679f12c3)\n\n---\n## 错排公式\n错排是给定原顺序（一般为有序数列），求每个元素都不在原位置的排列方案数。\n递推式为：\n\n$D(n) = (n-1)[ D(n-2) + D(n-1)]$\n\n初始条件为：\n\n$D(1) = 0 $\n\n$ D(2) = 1$\n\n---\n题目总结：\n","content":"<h1 id=\"组合数学总结\"><a href=\"#组合数学总结\" class=\"headerlink\" title=\"组合数学总结\"></a>组合数学总结</h1><hr>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><h3 id=\"加法原理\"><a href=\"#加法原理\" class=\"headerlink\" title=\"加法原理\"></a>加法原理</h3><p>做一件事情，完成它有$N$类方式，第一类方式有$M_1$种方法，第二类方式有$M_2$种方法，……，第$N$类方式有$M_N$种方法，那么完成这件事情共有$M1+M2+……+M_N$种方法。</p>\n<h3 id=\"乘法原理\"><a href=\"#乘法原理\" class=\"headerlink\" title=\"乘法原理\"></a>乘法原理</h3><p>做一件事，完成它需要分成$n$个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，……，做第n步有$m_n$种不同的方法。那么完成这件事共有$m_1×m_2×m_3×…×m_n$种不同的方法。</p>\n<hr>\n<h2 id=\"排列数\"><a href=\"#排列数\" class=\"headerlink\" title=\"排列数\"></a>排列数</h2><p>从$n$个不同元素中任取$r（r≦n）$个元素排成一列（考虑元素先后出现次序）称此为一个排列，此种排列的总数即为排列数，即叫做从$n$个不同元素中取出r个元素的排列数，记为$A(n,r)$。</p>\n<p>对于$A(n,r)$，第一个元素有$n$种取法，第二个元素有$n-1$种取法，……，第$r$个元素有$n-r+1$中取法，则根据乘法原理可得。</p>\n<p>$A(n,r)=\\frac {n!} {(n-r)!}$</p>\n<hr>\n<h2 id=\"组合数\"><a href=\"#组合数\" class=\"headerlink\" title=\"组合数\"></a>组合数</h2><p>从$n$个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的组合数，记为$C(n，m)$。</p>\n<p>根据定义，可知组合数与排列数的不同便是组合数对顺序没有要求。对组合数来说${1,2,3}$与${1,3,2}$是一种组合，但对排列数则不是。那么在组合数中重复计算的次数即为$r$的全排列，即$r!$，</p>\n<p>则有</p>\n<p>$C(n,r)=\\frac {A(n,r)} {r!}$，</p>\n<p>即</p>\n<p>$C(n,r)=\\frac {n!} {r!(n-r)!}$</p>\n<h3 id=\"常见定理与组合论证\"><a href=\"#常见定理与组合论证\" class=\"headerlink\" title=\"常见定理与组合论证\"></a>常见定理与组合论证</h3><h4 id=\"1-C-n-r-C-n-n-r\"><a href=\"#1-C-n-r-C-n-n-r\" class=\"headerlink\" title=\"1.$C(n,r)=C(n,n-r)$\"></a>1.$C(n,r)=C(n,n-r)$</h4><p>将其表示为一个长度为$n$的二进制串，则组合数为有$r$位为$1$的串的个数，易知其与有$n-r$位为$0$的串的个数等价。</p>\n<h4 id=\"2-C-n-r-C-n-1-r-1-C-n-1-r\"><a href=\"#2-C-n-r-C-n-1-r-1-C-n-1-r\" class=\"headerlink\" title=\"2.$C(n,r)=C(n-1,r-1)+C(n-1,r)$\"></a>2.$C(n,r)=C(n-1,r-1)+C(n-1,r)$</h4><p>将其表示为一个长度为$n$的二进制串，利用动态规划的思想，可设$C(n-1,r-1)$表示长度为$n-1$的串且在末尾新加入一个$1$的方案数，$C(n-1,r)$表示长度为$n-1$的串且在末尾新加入一个$0$，易证该递推式的正确性。（初始化为$C(i,i)=0$）</p>\n<h4 id=\"3-2-n-sum-k-C-n-k\"><a href=\"#3-2-n-sum-k-C-n-k\" class=\"headerlink\" title=\"3.$2^n=\\sum_k C(n,k)$\"></a>3.$2^n=\\sum_k C(n,k)$</h4><p>$2^n$为长度为$n$的二进制串的总方案数，根据加法原理，易知其等价于长度为$n$的二进制串且有$0,1,….n$个$1$的方案数和。</p>\n<h4 id=\"4-a-b-n-sum-kC-n-k-a-kb-b-k\"><a href=\"#4-a-b-n-sum-kC-n-k-a-kb-b-k\" class=\"headerlink\" title=\"4.$(a+b)^n=\\sum_kC(n,k)a^kb^{b-k}$\"></a>4.$(a+b)^n=\\sum_kC(n,k)a^kb^{b-k}$</h4><p>这个定理同样可以直接通过二项式定理求证。</p>\n<h4 id=\"5-C-n-m-r-sum-kC-n-k-C-m-r-k\"><a href=\"#5-C-n-m-r-sum-kC-n-k-C-m-r-k\" class=\"headerlink\" title=\"5.$C(n+m,r)=\\sum_kC(n,k)*C(m,r-k)$\"></a>5.$C(n+m,r)=\\sum_kC(n,k)*C(m,r-k)$</h4><p>左项可以表示为一个长度为$a+b$的二进制串，右项则可以表示为一个长度为$a$的二进制串拼上一个长度为$b$的二进制串，此处可以转化为定理$3$,再结合乘法原理即可得证。</p>\n<h4 id=\"6-C-n-r-frac-n-r-n-1-r-1\"><a href=\"#6-C-n-r-frac-n-r-n-1-r-1\" class=\"headerlink\" title=\"6.$C(n,r)=\\frac n r(n-1,r-1)$\"></a>6.$C(n,r)=\\frac n r(n-1,r-1)$</h4><p>结合定理一，可以通过简单的推导得到该定理。</p>\n<h4 id=\"7-C-n-m-C-m-r-C-n-r-C-n-r-m-r\"><a href=\"#7-C-n-m-C-m-r-C-n-r-C-n-r-m-r\" class=\"headerlink\" title=\"7.$C(n,m)C(m,r)=C(n,r)C(n-r,m-r)$\"></a>7.$C(n,m)C(m,r)=C(n,r)C(n-r,m-r)$</h4><p>可以将左式表示为在$n$个学生中选出$m$个组长，再在$m$个组长中选出$r$班干部，则右式可以表示为在$n$个学生中选$r$个班干部，再在剩余的学生$n-r$中选出$m-r$个不是班干部的组长，易知两者等价。</p>\n<hr>\n<h2 id=\"可重复组合数\"><a href=\"#可重复组合数\" class=\"headerlink\" title=\"可重复组合数\"></a>可重复组合数</h2><p>从$n$个不同元素中，任取$m(m≤n)$个元素并成一组（可以重复选择），叫做从$n$个不同元素中取出$m$个元素的一个可重复组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的可重复组合数。</p>\n<p>可重复组合即为$C(n+m-1,m)$。</p>\n<p>对于此结论的证明可以逆向来看，$n$中选$m$个元素即为将$m$个球放在$n$个盒子内的方案数，每个盒子中允许放$0$到$m$个球。对于这$m$个球来说，即为$n-1$个断点将其分为了$n$部分。</p>\n<p>不妨将断点用二进制串表示为0，球表示为1，那么在$3$个元素中选$5$个元素的一种方案即可表示为</p>\n<p>$ 1-1-1-0-1-0-1 $</p>\n<p>易观察到可重复组合数等于在$n+m-1$个元素中选取$m$个$1$的方案数</p>\n<p>即为</p>\n<p>$C(n+m-1,m)$</p>\n<p>可重复组合数同样可以解决如下的问题：</p>\n<p>已知</p>\n<p>$x_1+x_2+x_3+……+x_n=m(x_i&gt;=0)$</p>\n<p>求方程的解数。</p>\n<p>此处可以看出答案即为$C(n+m-1,m)$，论证方法同上，该问题同样有很多变式，如改变$x_i$的取值范围等，同样可以通过如上方式得解，此处不再赘述。</p>\n<hr>\n<h2 id=\"斯特林数\"><a href=\"#斯特林数\" class=\"headerlink\" title=\"斯特林数\"></a>斯特林数</h2><p>斯特林数分为第一类斯特林数和第二类斯特林数，其中第一类斯特林数为将$n$个物体排成$m$个非空循环排列的方案数，记为$s(n,m)$，第二类斯特林数为将$n$个物体划分到$m$个集合的方案数，记为$S(n,m)$。</p>\n<h3 id=\"第一类斯特林数\"><a href=\"#第一类斯特林数\" class=\"headerlink\" title=\"第一类斯特林数\"></a>第一类斯特林数</h3><p>$s(n,m)$的递推公式：</p>\n<p>$s(n,m)=(n-1)*s(n-1,m)+s(n-1,m-1) (1&lt;=m&lt;=n-1)$</p>\n<p>边界条件：</p>\n<p>$s(n,0)=0 (n&gt;=1)$ $s(n,n)=1(n&gt;=0)$</p>\n<p>递推关系的说明：</p>\n<p>考虑第$n$个物品，$n$可以单独构成一个非空循环排列，这样前$n-1$种物品构成$m-1$个非空循环排列，方法数为$s(n-1,m-1)$。</p>\n<p>也可以前$n-1$种物品构成$m$个非空循环排列，而第$n$个物品插入第$i$个物品的左边，这有$(n-1)×s(n-1,m)$种方法。</p>\n<h3 id=\"第二类斯特林数\"><a href=\"#第二类斯特林数\" class=\"headerlink\" title=\"第二类斯特林数\"></a>第二类斯特林数</h3><p>S(n,m)的递推公式是：</p>\n<p>$S(n,m)=m×S(n-1,m)+S(n-1,m-1) (1&lt;=m&lt;=n-1)$</p>\n<p>边界条件：</p>\n<p>$s(n,0)=0 (n&gt;=1)$ $s(n,n)=1(n&gt;=0)$</p>\n<p>递推关系的说明：</p>\n<p>考虑第$n$个物品，$n$可以单独构成一个非空集合，此时前$n-1$个物品构成$m-1$个非空的不可辨别的集合，方法数为$S(n-1,m-1)$；</p>\n<p>也可以前$n-1$种物品构成$m$个非空的不可辨别的集合，第$n$个物品放入任意一个中，这样有$m×S(n-1,m)$种方法。</p>\n<p>第一类斯特林数和第二类斯特林数有相同的初始条件，但递推关系不同，两者在计数问题中均有着广泛的运用。</p>\n<hr>\n<h2 id=\"卡特兰数\"><a href=\"#卡特兰数\" class=\"headerlink\" title=\"卡特兰数\"></a>卡特兰数</h2><p>一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?</p>\n<p>该答案的解即为卡特兰数。实际上，卡特兰数也同样可以表示为有n个节点的无标号树的个数，汉诺塔问题的解，括号表达式的方案数,凸多边形的三角划分数等等，在组合数学中有着广泛的应用。</p>\n<p>令$h(0)=1$,$h(1)=1$，则卡特兰数数满足递推式：</p>\n<p>$h(n)= h(0)×h(n-1)+h(1)×h(n-2) + … + h(n-1)×h(0) (n&gt;=2)$</p>\n<p>亦或</p>\n<p>$h(n)=h(n-1)×(4×n-2)/(n+1)$</p>\n<p>同样可以用组合数表示</p>\n<p>$h(n)=\\frac {C(2n,n)} {n+1}$</p>\n<p>或者</p>\n<p>$h(n)=C(2n,n)-C(2n,n-1)$</p>\n<p>证明可以将出栈入栈的操作集合，看作一个长度为$2n$的二进制串，$0$代表入栈操作，$1$代表出栈操作，则该字符串有两个限制：0和1的个数相同（即对应每个元素只能入栈出栈一次），对于所有前缀，0的个数要大于等于1的个数（对应栈为空时不能继续出栈）。</p>\n<p>先求出只满足第一个限制的方案数，易知其为$C(2n,n)$。</p>\n<p>再考虑第二个限制需要排除的方案，易知其前缀必有一处$1$的个数大于$0$的个数，可设此处有$k$个$0$，$k+1$个$1$，剩下的串中有$n-k$个$0$，$n-k-1$个$1$，将剩下的串按位取反，则得到的新串中共有$n-1$个$0$，$n+1$个$1$，这样的串共有$C(2n,n-1)$。</p>\n<p>则有</p>\n<p>$h(n)=C(2n,n)-C(2n,n-1)$</p>\n<p>以上的组合论证均涉及模型的转化，实际上，模型的建立在组合论证中具有重要的作用，模型需要满足尽可能简化问题，确保与原问题等价等条件，才能优美地求解。</p>\n<hr>\n<h2 id=\"容斥原理\"><a href=\"#容斥原理\" class=\"headerlink\" title=\"容斥原理\"></a>容斥原理</h2><p>在计数时，为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。</p>\n<p>易知</p>\n<p><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/05f67b2ce4414f2a1f96e4210a86d71028aa53b6\" alt=\"\"></p>\n<p><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/0b8e7c1631ec013eed94feb5aa406a573caa3559\" alt=\"\"></p>\n<p>则通项公式表示为</p>\n<p><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a7589a99f7137c74fd85940231971082679f12c3\" alt=\"\"></p>\n<hr>\n<h2 id=\"错排公式\"><a href=\"#错排公式\" class=\"headerlink\" title=\"错排公式\"></a>错排公式</h2><p>错排是给定原顺序（一般为有序数列），求每个元素都不在原位置的排列方案数。<br>递推式为：</p>\n<p>$D(n) = (n-1)[ D(n-2) + D(n-1)]$</p>\n<p>初始条件为：</p>\n<p>$D(1) = 0 $</p>\n<p>$ D(2) = 1$</p>\n<hr>\n<p>题目总结：</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/10/组合数学总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"no yet","slug":"no-yet","permalink":"https://prostkhala.github.io/tags/no-yet/"},{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"逆元","slug":"逆元","permalink":"https://prostkhala.github.io/tags/逆元/"},{"name":"群论","slug":"群论","permalink":"https://prostkhala.github.io/tags/群论/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"},{"name":"容斥原理","slug":"容斥原理","permalink":"https://prostkhala.github.io/tags/容斥原理/"},{"name":"Polya定理&Burnside引理","slug":"Polya定理-Burnside引理","permalink":"https://prostkhala.github.io/tags/Polya定理-Burnside引理/"}]},{"title":"Transposing Is Even More Fun","date":"2017-04-09T10:58:42.000Z","path":"2017/04/09/Transposing is Even More Fun/","text":"Transposing is Even More FunCOGS1608 题目描述给你一个$2^a*2^b$的矩阵，在内存中的存放方式是先存第一行的，再存第二行的……每行也是从左到右存放。现在你想把它变成它的转置矩阵（也是一样的储存方式），但是只能用交换操作（即交换两个储存单元的内容），至少需要交换多少步？ 输入输出格式输入格式： 第1行数数据组数$c(1&lt;=c&lt;=400000)$. 接下来有c行，每行一组测试数据：两个整数$a,b(0&lt;=a+b&lt;=1000000)$。 输出格式：对每组数据输出一个整数，即转置矩阵需要的最少交换次数。因为这个次数可能很大，你只需要输出它模$1000003$的值（没错，这是个素数）。 输入输出样例输入样例：3 1 1 2 2 5 7 输出样例：1 6 3744 题解该题所求的是最小步数不是计数，但仍可以通过polya定理求解。将矩阵表示成在内存中的存储方式，并将转置考虑为一种置换。以$2^1 * 2^2$为例，则置换为 0 1 2 3 4 5 6 7 到 0 2 4 6 1 3 5 7 表示为 / 0 1 2 3 4 5 6 7 \\ \\ 0 2 4 6 1 3 5 7 / 亦或 （1）（1 2 4）（3 6 5）（7） 考虑在任意一个循环节中，需要交换的次数即为 （ 循环节的长度 - 1 ） 次，且已知所有循环节长度为矩阵中元素的总个数（即为$2^{a+b}$个），则有 $Ans=2^{a+b}-循环节个数$ 现在的问题就转换成了求解循环节的个数，已知$c(1&lt;=c&lt;=400000)$且$(0&lt;=a+b&lt;=1000000)$，则循环节的个数显然不能通过暴力求解。考虑这种置换对应矩阵中的转置，有一定的规律可循，不妨将元素转换为二进制进行观察。则置换为 000 - 000 001 - 010 010 - 100 011 - 110 100 - 001 101 - 011 110 - 101 111 - 111 不难发现该转置操作中所有元素的二进制数皆循环右移了$a$位（也可以说循环左移了b位），我们也可以稍微推算一下，对于矩阵元素$（i，j）$来说，转置使其变为了$（j，i）$，将其表示为队列，则从第 $(i-1)2^a+j$ 位转置为第 $(j-1)2^b+i$ 位，即对应二进制的循环右移。那么可以将问题转化为一个polya定理的经典问题，即项链染色问题。将二进制的表示看为一种染色方案，长度为a+b，颜色为 0,1 两种，循环右移左移即对应项链的旋转。 以a=2，b=4为例。 则项链为 a1 / \\ a6 a2 | | a5 a3 \\ / a4 但该题的置换群$G=${$不动，循环右移a位 $ } $ $，显然与原问题不同，那么不妨将项链压缩一下，根据前面的推理，可知循环右移$a$位与左移$b$位是一种操作，那么不妨将$gcd(a，b)$个点压为一个点。则例图转化为 a1,2 / \\ a5,6 -- a3,4 此时对于任意一个点有2^gcd(a,b)中染色方案。 那么该问题就完全的转化为了一个项链染色问题。 则前式中的$循环节个数=(\\sum{i=1}^{n}k^{gcd(i,n)})/n=(\\sum{i=1}^{a+b}2^{gcd(i,a+b)gcd(a,b)})/n$ 考虑对原式$(\\sum_{i=1}^{n}k^{gcd(i,n)})/n$进行优化则有 $(\\sum_{i=1}^{n}k^{gcd(i,n)})/n$ $=(\\sum{d|n}k^{d}\\sum{i=d}^{n}[gcd(i,n)==d])/n$ $=(\\sum{d|n}k^{d}\\sum{i=d}^{n}[gcd(i/d,n/d)==1])/n$ $=(\\sum{d|n}k^{d}\\sum{i=1}^{n/d}[gcd(i,n/d)==1])/n$ $=(\\sum_{d|n}k^{d}\\varphi(n/d))/n$ 则 $Ans=2^{a+b}-(\\sum_{d|n}k^{d}\\varphi(n/d))/n$ 原式中 $n=(a+b)/gcd(a,b),k=2^{gcd(a,b)}$ 由于原式需要取模，则需要求n的逆元，已知$a+b&lt;=1e6$,模数为$1e6+3$（为质数），易知两者互质，则可通过费马小定理求逆。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; const int N = 1e6+1; const int mod = 1000003; typedef long long ll; int a,b; bool vis[N]; int p[N],phi[N],tot,pow2[N]; int gcd(int a,int b){return b?gcd(b,a%b):a;} void get(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } void put(int x) { int num = 0; char c[15]; while(x) c[++num] = (x%10)+48, x /= 10; while(num) putchar(c[num--]); putchar(&#39;\\n&#39;); } int qpow(int a,int b) { int ans=1; while(b) { if(b&amp;1)ans=((ll)ans*a)%mod; b&gt;&gt;=1; a=((ll)a*a)%mod; } return ans; } int getprime() { phi[1]=1; for(int i=2;i&lt;=N-1;++i) { if(!vis[i])p[++tot]=i,phi[i]=(i-1)%mod; for(int t=1;t&lt;=tot&amp;&amp;i*p[t]&lt;=N-1;++t) { vis[i*p[t]]=1; if(i%p[t]==0){phi[i*p[t]]=((ll)phi[i]*p[t])%mod;break;} phi[i*p[t]]=((ll)phi[i]*(p[t]-1))%mod; } } pow2[0]=1; for(int i=1;i&lt;=N-1;++i)pow2[i]=(pow2[i-1]&lt;&lt;1)%mod; } int main() { // freopen(&quot;transp2.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;transp2.out&quot;,&quot;w&quot;,stdout); int T; getprime(); scanf(&quot;%d&quot;,&amp;T); while(T--) { get(a);get(b); int lin=0; int gcdab=gcd(a,b); int n=(a+b)/gcdab; int inv; inv=qpow(n,mod-2); for(int d=1;d&lt;=n;++d) { if(n%d==0) { (lin+=(pow2[gcdab*d]*phi[n/d]))%=mod; } } put(((ll)pow2[a+b]-lin*inv%mod+mod)%mod); } }","raw":"title: Transposing is Even More Fun\ndate: 2017-04-09 18:58:42\ncategories:\n  - 群论\ntags:\n  - 组合数学\n  - 扩展欧几里得\n  - 数论\n  - 欧拉函数\n  - Polya定理&Burnside引理\n  - 费马小定理\n  - 逆元\n---\n\n# Transposing is Even More Fun\n\n## [COGS1608](http://cogs.pro/cogs/problem/problem.php?pid=1608)\n\n---\n## 题目描述\n给你一个$2^a*2^b$的矩阵，在内存中的存放方式是先存第一行的，再存第二行的……每行也是从左到右存放。现在你想把它变成它的转置矩阵（也是一样的储存方式），但是只能用交换操作（即交换两个储存单元的内容），至少需要交换多少步？ \n### 输入输出格式\n#### 输入格式：\n 第1行数数据组数$c(1<=c<=400000)$.\n\n接下来有c行，每行一组测试数据：两个整数$a,b(0<=a+b<=1000000)$。 \n\n#### 输出格式：\n对每组数据输出一个整数，即转置矩阵需要的最少交换次数。因为这个次数可能很大，你只需要输出它模$1000003$的值（没错，这是个素数）。 \n\n\n### 输入输出样例\n#### 输入样例：\n    3\n\n    1 1\n\n    2 2\n\n    5 7 \n\n#### 输出样例：\n   \n    1\n\n    6\n\n    3744\n---\n\n## 题解\n\n该题所求的是最小步数不是计数，但仍可以通过polya定理求解。将矩阵表示成在内存中的存储方式，并将转置考虑为一种置换。\n以$2^1 * 2^2$为例，则置换为\n\t\n    0  1  \n    2  3 \n    4  5\n\t6  7\n到\n\n\t0  2  4  6\n    1  3  5  7\n表示为\n\n\t/ 0 1 2 3 4 5 6 7 \\\n    \\ 0 2 4 6 1 3 5 7 /\n亦或\n\t\n    （1）（1 2 4）（3 6 5）（7）    \n考虑在任意一个循环节中，需要交换的次数即为 （ 循环节的长度 - 1 ） 次，且已知所有循环节长度为矩阵中元素的总个数（即为$2^{a+b}$个），则有\n\n$Ans=2^{a+b}-循环节个数$\n\n现在的问题就转换成了求解循环节的个数，已知$c(1<=c<=400000)$且$(0<=a+b<=1000000)$，则循环节的个数显然不能通过暴力求解。考虑这种置换对应矩阵中的转置，有一定的规律可循，不妨将元素转换为二进制进行观察。\n则置换为\n\t\n    000 - 000\n    001 - 010\n    010 - 100\n    011 - 110\n    100 - 001\n    101 - 011\n    110 - 101\n    111 - 111\n不难发现该转置操作中所有元素的二进制数皆循环右移了$a$位（也可以说循环左移了b位），我们也可以稍微推算一下，对于矩阵元素$（i，j）$来说，转置使其变为了$（j，i）$，将其表示为队列，则从第 $(i-1)*2^a+j$ 位转置为第 $(j-1)*2^b+i$ 位，即对应二进制的循环右移。那么可以将问题转化为一个polya定理的经典问题，即项链染色问题。将二进制的表示看为一种染色方案，长度为a+b，颜色为 0,1 两种，循环右移左移即对应项链的旋转。\n\n\t以a=2，b=4为例。\n    \n    则项链为\n    \n\t      a1\n         /  \\\n        a6   a2\n        |    |\n        a5   a3\n         \\  /\n          a4   \n\n但该题的置换群$G=${$不动，循环右移a位 $ } $ $，显然与原问题不同，那么不妨将项链压缩一下，根据前面的推理，可知循环右移$a$位与左移$b$位是一种操作，那么不妨将$gcd(a，b)$个点压为一个点。则例图转化为\n\n\t\t a1,2\n         /  \\\n     a5,6 -- a3,4\n     此时对于任意一个点有2^gcd(a,b)中染色方案。\n那么该问题就完全的转化为了一个项链染色问题。\n\n则前式中的$循环节个数=(\\sum_{i=1}^{n}k^{gcd(i,n)})/n=(\\sum_{i=1}^{a+b}2^{gcd(i,a+b)gcd(a,b)})/n$\n\n考虑对原式$(\\sum_{i=1}^{n}k^{gcd(i,n)})/n$进行优化\n则有\n\n\n$(\\sum_{i=1}^{n}k^{gcd(i,n)})/n$\n\n$=(\\sum_{d|n}k^{d}\\sum_{i=d}^{n}[gcd(i,n)==d])/n$\n\n$=(\\sum_{d|n}k^{d}\\sum_{i=d}^{n}[gcd(i/d,n/d)==1])/n$\n\n$=(\\sum_{d|n}k^{d}\\sum_{i=1}^{n/d}[gcd(i,n/d)==1])/n$\n\n$=(\\sum_{d|n}k^{d}\\varphi(n/d))/n$\n\n\n则\n\n$Ans=2^{a+b}-(\\sum_{d|n}k^{d}\\varphi(n/d))/n$\n\n原式中\n\n$n=(a+b)/gcd(a,b),k=2^{gcd(a,b)}$\n\n由于原式需要取模，则需要求n的逆元，已知$a+b<=1e6$,模数为$1e6+3$（为质数），易知两者互质，则可通过费马小定理求逆。\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<algorithm>\n    #include<cmath>\n    using namespace std;\n    const int N = 1e6+1;\n    const int mod = 1000003;\n    typedef long long ll;\n    int a,b;\n    bool vis[N];\n    int p[N],phi[N],tot,pow2[N];\n    int gcd(int a,int b){return b?gcd(b,a%b):a;}\n    void get(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    void put(int x)\n    {  \n        int num = 0; char c[15];\n        while(x) c[++num] = (x%10)+48, x /= 10;\n        while(num) putchar(c[num--]);\n        putchar('\\n'); \n    }\n    int qpow(int a,int b)\n    {\n        int ans=1;\n        while(b)\n        {\n            if(b&1)ans=((ll)ans*a)%mod;\n            b>>=1;\n            a=((ll)a*a)%mod;\n        }\n        return ans;\n    }\n    int getprime()\n    {\n        phi[1]=1;\n        for(int i=2;i<=N-1;++i)\n        {\n            if(!vis[i])p[++tot]=i,phi[i]=(i-1)%mod;\n            for(int t=1;t<=tot&&i*p[t]<=N-1;++t)\n            {\n                vis[i*p[t]]=1;\n                if(i%p[t]==0){phi[i*p[t]]=((ll)phi[i]*p[t])%mod;break;}\n                phi[i*p[t]]=((ll)phi[i]*(p[t]-1))%mod;\n            }\n        }\n        pow2[0]=1;\n        for(int i=1;i<=N-1;++i)pow2[i]=(pow2[i-1]<<1)%mod;\n    }\n\n    int main()\n    {\n    //\tfreopen(\"transp2.in\",\"r\",stdin);\n    //\tfreopen(\"transp2.out\",\"w\",stdout);\n        int T;\n        getprime();\n        scanf(\"%d\",&T);\n        while(T--)\n        {\n            get(a);get(b);\n            int lin=0;\n            int gcdab=gcd(a,b);\n            int n=(a+b)/gcdab;\n            int inv;\n            inv=qpow(n,mod-2);\n            for(int d=1;d<=n;++d)\n            {\n                if(n%d==0)\n                {\n                    (lin+=(pow2[gcdab*d]*phi[n/d]))%=mod;\n                }\n            }\n            put(((ll)pow2[a+b]-lin*inv%mod+mod)%mod);\n        }\n    }","content":"<h1 id=\"Transposing-is-Even-More-Fun\"><a href=\"#Transposing-is-Even-More-Fun\" class=\"headerlink\" title=\"Transposing is Even More Fun\"></a>Transposing is Even More Fun</h1><h2 id=\"COGS1608\"><a href=\"#COGS1608\" class=\"headerlink\" title=\"COGS1608\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1608\" target=\"_blank\" rel=\"external\">COGS1608</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给你一个$2^a*2^b$的矩阵，在内存中的存放方式是先存第一行的，再存第二行的……每行也是从左到右存放。现在你想把它变成它的转置矩阵（也是一样的储存方式），但是只能用交换操作（即交换两个储存单元的内容），至少需要交换多少步？ </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p> 第1行数数据组数$c(1&lt;=c&lt;=400000)$.</p>\n<p>接下来有c行，每行一组测试数据：两个整数$a,b(0&lt;=a+b&lt;=1000000)$。 </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对每组数据输出一个整数，即转置矩阵需要的最少交换次数。因为这个次数可能很大，你只需要输出它模$1000003$的值（没错，这是个素数）。 </p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\n\n1 1\n\n2 2\n\n5 7 \n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>1\n\n6\n\n3744\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>该题所求的是最小步数不是计数，但仍可以通过polya定理求解。将矩阵表示成在内存中的存储方式，并将转置考虑为一种置换。<br>以$2^1 * 2^2$为例，则置换为</p>\n<pre><code>0  1  \n2  3 \n4  5\n6  7\n</code></pre><p>到</p>\n<pre><code>0  2  4  6\n1  3  5  7\n</code></pre><p>表示为</p>\n<pre><code>/ 0 1 2 3 4 5 6 7 \\\n\\ 0 2 4 6 1 3 5 7 /\n</code></pre><p>亦或</p>\n<pre><code>（1）（1 2 4）（3 6 5）（7）    \n</code></pre><p>考虑在任意一个循环节中，需要交换的次数即为 （ 循环节的长度 - 1 ） 次，且已知所有循环节长度为矩阵中元素的总个数（即为$2^{a+b}$个），则有</p>\n<p>$Ans=2^{a+b}-循环节个数$</p>\n<p>现在的问题就转换成了求解循环节的个数，已知$c(1&lt;=c&lt;=400000)$且$(0&lt;=a+b&lt;=1000000)$，则循环节的个数显然不能通过暴力求解。考虑这种置换对应矩阵中的转置，有一定的规律可循，不妨将元素转换为二进制进行观察。<br>则置换为</p>\n<pre><code>000 - 000\n001 - 010\n010 - 100\n011 - 110\n100 - 001\n101 - 011\n110 - 101\n111 - 111\n</code></pre><p>不难发现该转置操作中所有元素的二进制数皆循环右移了$a$位（也可以说循环左移了b位），我们也可以稍微推算一下，对于矩阵元素$（i，j）$来说，转置使其变为了$（j，i）$，将其表示为队列，则从第 $(i-1)<em>2^a+j$ 位转置为第 $(j-1)</em>2^b+i$ 位，即对应二进制的循环右移。那么可以将问题转化为一个polya定理的经典问题，即项链染色问题。将二进制的表示看为一种染色方案，长度为a+b，颜色为 0,1 两种，循环右移左移即对应项链的旋转。</p>\n<pre><code>以a=2，b=4为例。\n\n则项链为\n\n      a1\n     /  \\\n    a6   a2\n    |    |\n    a5   a3\n     \\  /\n      a4   \n</code></pre><p>但该题的置换群$G=${$不动，循环右移a位 $ } $ $，显然与原问题不同，那么不妨将项链压缩一下，根据前面的推理，可知循环右移$a$位与左移$b$位是一种操作，那么不妨将$gcd(a，b)$个点压为一个点。则例图转化为</p>\n<pre><code>     a1,2\n     /  \\\n a5,6 -- a3,4\n 此时对于任意一个点有2^gcd(a,b)中染色方案。\n</code></pre><p>那么该问题就完全的转化为了一个项链染色问题。</p>\n<p>则前式中的$循环节个数=(\\sum<em>{i=1}^{n}k^{gcd(i,n)})/n=(\\sum</em>{i=1}^{a+b}2^{gcd(i,a+b)gcd(a,b)})/n$</p>\n<p>考虑对原式$(\\sum_{i=1}^{n}k^{gcd(i,n)})/n$进行优化<br>则有</p>\n<p>$(\\sum_{i=1}^{n}k^{gcd(i,n)})/n$</p>\n<p>$=(\\sum<em>{d|n}k^{d}\\sum</em>{i=d}^{n}[gcd(i,n)==d])/n$</p>\n<p>$=(\\sum<em>{d|n}k^{d}\\sum</em>{i=d}^{n}[gcd(i/d,n/d)==1])/n$</p>\n<p>$=(\\sum<em>{d|n}k^{d}\\sum</em>{i=1}^{n/d}[gcd(i,n/d)==1])/n$</p>\n<p>$=(\\sum_{d|n}k^{d}\\varphi(n/d))/n$</p>\n<p>则</p>\n<p>$Ans=2^{a+b}-(\\sum_{d|n}k^{d}\\varphi(n/d))/n$</p>\n<p>原式中</p>\n<p>$n=(a+b)/gcd(a,b),k=2^{gcd(a,b)}$</p>\n<p>由于原式需要取模，则需要求n的逆元，已知$a+b&lt;=1e6$,模数为$1e6+3$（为质数），易知两者互质，则可通过费马小定理求逆。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nconst int N = 1e6+1;\nconst int mod = 1000003;\ntypedef long long ll;\nint a,b;\nbool vis[N];\nint p[N],phi[N],tot,pow2[N];\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nvoid get(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nvoid put(int x)\n{  \n    int num = 0; char c[15];\n    while(x) c[++num] = (x%10)+48, x /= 10;\n    while(num) putchar(c[num--]);\n    putchar(&#39;\\n&#39;); \n}\nint qpow(int a,int b)\n{\n    int ans=1;\n    while(b)\n    {\n        if(b&amp;1)ans=((ll)ans*a)%mod;\n        b&gt;&gt;=1;\n        a=((ll)a*a)%mod;\n    }\n    return ans;\n}\nint getprime()\n{\n    phi[1]=1;\n    for(int i=2;i&lt;=N-1;++i)\n    {\n        if(!vis[i])p[++tot]=i,phi[i]=(i-1)%mod;\n        for(int t=1;t&lt;=tot&amp;&amp;i*p[t]&lt;=N-1;++t)\n        {\n            vis[i*p[t]]=1;\n            if(i%p[t]==0){phi[i*p[t]]=((ll)phi[i]*p[t])%mod;break;}\n            phi[i*p[t]]=((ll)phi[i]*(p[t]-1))%mod;\n        }\n    }\n    pow2[0]=1;\n    for(int i=1;i&lt;=N-1;++i)pow2[i]=(pow2[i-1]&lt;&lt;1)%mod;\n}\n\nint main()\n{\n//    freopen(&quot;transp2.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;transp2.out&quot;,&quot;w&quot;,stdout);\n    int T;\n    getprime();\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--)\n    {\n        get(a);get(b);\n        int lin=0;\n        int gcdab=gcd(a,b);\n        int n=(a+b)/gcdab;\n        int inv;\n        inv=qpow(n,mod-2);\n        for(int d=1;d&lt;=n;++d)\n        {\n            if(n%d==0)\n            {\n                (lin+=(pow2[gcdab*d]*phi[n/d]))%=mod;\n            }\n        }\n        put(((ll)pow2[a+b]-lin*inv%mod+mod)%mod);\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/09/Transposing is Even More Fun/","excerpt":"","categories":[{"name":"群论","slug":"群论","permalink":"https://prostkhala.github.io/categories/群论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"逆元","slug":"逆元","permalink":"https://prostkhala.github.io/tags/逆元/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://prostkhala.github.io/tags/扩展欧几里得/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://prostkhala.github.io/tags/欧拉函数/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"},{"name":"费马小定理","slug":"费马小定理","permalink":"https://prostkhala.github.io/tags/费马小定理/"},{"name":"Polya定理&Burnside引理","slug":"Polya定理-Burnside引理","permalink":"https://prostkhala.github.io/tags/Polya定理-Burnside引理/"}]},{"title":"JSOI2006 同构","date":"2017-04-08T03:02:12.000Z","path":"2017/04/08/同构/","text":"JSOI2006 同构COGS1609 SGU282 题目描述 我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。 给你$N$,$M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 输入输出格式输入格式：输入一行三个整数$N,M,P(1&lt;=N&lt;=53,1&lt;=M&lt;=1000,P$是素数且$P&lt;=10^6)$。 输出格式：输出一行一个正整数，即互不同构的染色图数量模P的值。 输入输出样例输入样例：sample 1: 1 1 2 sample 2: 3 2 97 sample 3: 3 4 97 输出样例：sample 1: 1 sample 2: 4 sample 3: 20 题解对于本题来说，存在的置换共有 $n!$ 种（即n个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对n进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$ 以内。 对于每个置换，循环节的个数和长度已知，不妨设大小为$k$ 的循环有$c_k$个，则符合该结构的置换即为$\\frac {n!} {\\prod c_k!*k^{c_k}}$个。 再结合Polya定理，设第$k$个循环节的大小为$d_k$则该置换不动方案为$\\prod_k a^{\\frac {dk} 2} $ $ \\prod{j&lt;k} a^{gcd(d_j,d_k)} $个。 关于取模的问题，已知p是质数（p&gt;53???），易证两者互质，则可通过费马小定理求逆。 CODE#include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int N = 1e4+1; ll num[N],cnt[N],res,fac[N],n,m,p,ans; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} ll qpow(ll a,ll b) { ll ans=1; while(b) { if(b&amp;1)ans=(ans*a)%p; b&gt;&gt;=1;a=(a*a)%p; } return ans; } int dfs(ll now,ll maxl) { if(maxl==0) { ll a=1,b=0; for(int i=0;i&lt;res;i++) { a=a*qpow(num[i],cnt[i])%p*fac[cnt[i]]%p; b+=cnt[i]*(cnt[i]-1)/2*num[i]+num[i]/2*cnt[i]; for(ll j=i+1;j&lt;res;j++)b+=cnt[i]*cnt[j]*gcd(num[i],num[j]); } a=qpow(a,p-2)*fac[n]%p; ans=(ans+a*qpow(m,b)%p)%p; } if(now&gt;maxl)return 0; dfs(now+1,maxl); for(int i=1;i*now&lt;=maxl;i++) { num[res]=now,cnt[res++]=i; dfs(now+1,maxl-i*now); res--; } } int main() { // freopen(&quot;isomorphism.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;isomorphism.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;p); fac[0]=1;for(int i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%p; dfs(1,n); ans=ans*qpow(fac[n],p-2)%p; printf(&quot;%lld\\n&quot;,ans); }","raw":"title: JSOI2006 同构\ndate: 2017-04-08 11:02:12\ncategories:\n  - 群论\ntags:\n  - 群论\n  - 组合数学\n  - Polya定理&Burnside引理\n---\n\n# JSOI2006 同构\n\n## [COGS1609](http://cogs.pro/cogs/problem/problem.php?pid=1609)  [SGU282](http://acm.sgu.ru/problem.php?problem=282)\n\n---\n## 题目描述\n 我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。\n\n给你$N$,$M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 \n### 输入输出格式\n#### 输入格式：\n输入一行三个整数$N,M,P(1<=N<=53,1<=M<=1000,P$是素数且$P<=10^6)$。 \n\n#### 输出格式：\n\n输出一行一个正整数，即互不同构的染色图数量模P的值。 \n\n### 输入输出样例\n#### 输入样例：\n    sample 1:\n\n    1 1 2\n\n\n    sample 2:\n\n    3 2 97\n\n\n    sample 3:\n\n    3 4 97 \n\n#### 输出样例：\n    sample 1:\n\n    1\n\n\n    sample 2:\n\n    4\n\n\n    sample 3:\n\n    20 \n---\n\n## 题解\n对于本题来说，存在的置换共有 $n!$ 种（即n个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对n进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$ 以内。\n\n对于每个置换，循环节的个数和长度已知，不妨设大小为$k$ 的循环有$c_k$个，则符合该结构的置换即为$\\frac {n!}  {\\prod c_k!*k^{c_k}}$个。\n\n再结合Polya定理，设第$k$个循环节的大小为$d_k$\n则该置换不动方案为$\\prod_k a^{\\frac {d_k} 2} $ $ \\prod_{j<k}  a^{gcd(d_j,d_k)} $个。\n\n关于取模的问题，已知p是质数（p>53???），易证两者互质，则可通过费马小定理求逆。\n\n\n---\n### CODE\n\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e4+1;\n    ll num[N],cnt[N],res,fac[N],n,m,p,ans;\n    ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} \n    ll qpow(ll a,ll b)\n    {\n        ll ans=1;\n        while(b)\n        {\n            if(b&1)ans=(ans*a)%p;\n            b>>=1;a=(a*a)%p;\n        }\n        return ans;\n    }\n    int dfs(ll now,ll maxl)\n    {\n        if(maxl==0)\n        {\n            ll a=1,b=0;\n            for(int i=0;i<res;i++)\n            {\n                a=a*qpow(num[i],cnt[i])%p*fac[cnt[i]]%p;\n                b+=cnt[i]*(cnt[i]-1)/2*num[i]+num[i]/2*cnt[i];\n                for(ll j=i+1;j<res;j++)b+=cnt[i]*cnt[j]*gcd(num[i],num[j]);\n            }\n            a=qpow(a,p-2)*fac[n]%p;\n            ans=(ans+a*qpow(m,b)%p)%p;\n        }\n        if(now>maxl)return 0;\n        dfs(now+1,maxl);\n        for(int i=1;i*now<=maxl;i++)\n        {\n            num[res]=now,cnt[res++]=i;\n            dfs(now+1,maxl-i*now);\n            res--;\n        }\n    }\n    int main()\n    {\t\n    //\tfreopen(\"isomorphism.in\",\"r\",stdin);\n    //\tfreopen(\"isomorphism.out\",\"w\",stdout);\n        scanf(\"%lld%lld%lld\",&n,&m,&p);\n        fac[0]=1;for(int i=1;i<N;i++)fac[i]=fac[i-1]*i%p;\n        dfs(1,n);\n        ans=ans*qpow(fac[n],p-2)%p;\n        printf(\"%lld\\n\",ans);\n    }","content":"<h1 id=\"JSOI2006-同构\"><a href=\"#JSOI2006-同构\" class=\"headerlink\" title=\"JSOI2006 同构\"></a>JSOI2006 同构</h1><h2 id=\"COGS1609-SGU282\"><a href=\"#COGS1609-SGU282\" class=\"headerlink\" title=\"COGS1609  SGU282\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1609\" target=\"_blank\" rel=\"external\">COGS1609</a>  <a href=\"http://acm.sgu.ru/problem.php?problem=282\" target=\"_blank\" rel=\"external\">SGU282</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p> 我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。</p>\n<p>给你$N$,$M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入一行三个整数$N,M,P(1&lt;=N&lt;=53,1&lt;=M&lt;=1000,P$是素数且$P&lt;=10^6)$。 </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出一行一个正整数，即互不同构的染色图数量模P的值。 </p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>sample 1:\n\n1 1 2\n\n\nsample 2:\n\n3 2 97\n\n\nsample 3:\n\n3 4 97 \n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>sample 1:\n\n1\n\n\nsample 2:\n\n4\n\n\nsample 3:\n\n20 \n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>对于本题来说，存在的置换共有 $n!$ 种（即n个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对n进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$ 以内。</p>\n<p>对于每个置换，循环节的个数和长度已知，不妨设大小为$k$ 的循环有$c_k$个，则符合该结构的置换即为$\\frac {n!}  {\\prod c_k!*k^{c_k}}$个。</p>\n<p>再结合Polya定理，设第$k$个循环节的大小为$d_k$<br>则该置换不动方案为$\\prod_k a^{\\frac {d<em>k} 2} $ $ \\prod</em>{j&lt;k}  a^{gcd(d_j,d_k)} $个。</p>\n<p>关于取模的问题，已知p是质数（p&gt;53???），易证两者互质，则可通过费马小定理求逆。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e4+1;\nll num[N],cnt[N],res,fac[N],n,m,p,ans;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;} \nll qpow(ll a,ll b)\n{\n    ll ans=1;\n    while(b)\n    {\n        if(b&amp;1)ans=(ans*a)%p;\n        b&gt;&gt;=1;a=(a*a)%p;\n    }\n    return ans;\n}\nint dfs(ll now,ll maxl)\n{\n    if(maxl==0)\n    {\n        ll a=1,b=0;\n        for(int i=0;i&lt;res;i++)\n        {\n            a=a*qpow(num[i],cnt[i])%p*fac[cnt[i]]%p;\n            b+=cnt[i]*(cnt[i]-1)/2*num[i]+num[i]/2*cnt[i];\n            for(ll j=i+1;j&lt;res;j++)b+=cnt[i]*cnt[j]*gcd(num[i],num[j]);\n        }\n        a=qpow(a,p-2)*fac[n]%p;\n        ans=(ans+a*qpow(m,b)%p)%p;\n    }\n    if(now&gt;maxl)return 0;\n    dfs(now+1,maxl);\n    for(int i=1;i*now&lt;=maxl;i++)\n    {\n        num[res]=now,cnt[res++]=i;\n        dfs(now+1,maxl-i*now);\n        res--;\n    }\n}\nint main()\n{    \n//    freopen(&quot;isomorphism.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;isomorphism.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;p);\n    fac[0]=1;for(int i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%p;\n    dfs(1,n);\n    ans=ans*qpow(fac[n],p-2)%p;\n    printf(&quot;%lld\\n&quot;,ans);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/08/同构/","excerpt":"","categories":[{"name":"群论","slug":"群论","permalink":"https://prostkhala.github.io/categories/群论/"}],"tags":[{"name":"群论","slug":"群论","permalink":"https://prostkhala.github.io/tags/群论/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"},{"name":"Polya定理&Burnside引理","slug":"Polya定理-Burnside引理","permalink":"https://prostkhala.github.io/tags/Polya定理-Burnside引理/"}]},{"title":"裴蜀定理总结","date":"2017-03-28T09:42:15.000Z","path":"2017/03/28/裴蜀定理总结/","text":"裴蜀定理已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b) | d$。特别的，一定存在整数$x,y$使得$ax+by=gcd(a,b)$成立。 例题（待补充）","raw":"title: 裴蜀定理总结\ndate: 2017-03-28 17:42:15\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 扩展欧几里得\n  - 裴蜀定理\n  - no yet\n---\n\n# 裴蜀定理\n\n已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b) | d$。特别的，一定存在整数$x,y$使得\n$ax+by=gcd(a,b)$成立。\n\n\n## 例题\n（待补充）","content":"<h1 id=\"裴蜀定理\"><a href=\"#裴蜀定理\" class=\"headerlink\" title=\"裴蜀定理\"></a>裴蜀定理</h1><p>已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b) | d$。特别的，一定存在整数$x,y$使得<br>$ax+by=gcd(a,b)$成立。</p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p>（待补充）</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/28/裴蜀定理总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"no yet","slug":"no-yet","permalink":"https://prostkhala.github.io/tags/no-yet/"},{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://prostkhala.github.io/tags/扩展欧几里得/"},{"name":"裴蜀定理","slug":"裴蜀定理","permalink":"https://prostkhala.github.io/tags/裴蜀定理/"}]},{"title":"欧拉函数总结","date":"2017-03-28T02:33:17.000Z","path":"2017/03/28/欧拉函数总结/","text":"欧拉函数的定义 $\\varphi(n)$ 定义为1到n中与n互质的数的个数。 欧拉函数的求解1 . 通项公式 $ \\varphi(n)=n(1-1/p_1)(1-1/p2)…(1-1/p{tot}) $ (其中p为n的质因子，tot为质因子个数) int euler_phi(int n) { int m=(int)sqrt(n); int ans=n; for(int i=2;i&lt;=m;i++) { if(n%i==0) { ans=ans/i*(i-1);//ans*=(1-inv[i])？？； while(n%i==0) n/=i;//与分解质因数相结合 } } if(n&gt;1) ans=ans/n*(n-1); return ans; } 2 . 线性筛法逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前n项欧拉函数。 int prime[2*sqrt(N)+1],phi[N]; bool vis[N]; int tot; int getprime() { for(int i=2;i&lt;=N;++i) { if(!vis[i]) { prime[++tot]=i; phi[i]=i-1; } for(int t=1;t&lt;=tot&amp;&amp;prime[t]*i&lt;=N;++t) { vis[i*prime[t]]=true; if(i%prime[t]==0){phi[i*prime[t]]=phi[i]*prime[t];break;} phi[i*prime[t]]=phi[i]*(prime[t]-1); } } } 相关习题T1已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$ 证明设$T=lcm(1,2,…,p-1)$ 则有 $\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$ 此时只需证明 $T/1+T/2+…+T/(p-1)≡0(modp)$ 根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为 $1+2+…+(p-1)≡0(modp)$ $p*(p-1)≡0(modp)$ 得证。 T1 SDOI2008 沙拉公主的困惑题目描述大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。 输入输出格式输入格式第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n 输出格式共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值 输入输出样例输入样例1 11 4 2 输出样例1 数据范围对于100%的数据，1 &lt; = N , M &lt; = 10000000 题解题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$ 对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。 CODE#include&lt;cstdio&gt; #include&lt;iostream&gt; const int M = 1e6+1; using namespace std; bool vis[M+100]; long long prime[500500],ans[M+100],fac[M+100],rev[M+100]; int n,m,p,T,tot; int main() { scanf(&quot;%d%d&quot;,&amp;T,&amp;p); for(int i=2;i&lt;=M;i++) { if(!vis[i])prime[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++) { vis[prime[j]*i]=1; if(i%prime[j]==0) break; } } fac[1]=1; for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p; rev[1]=1; for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p; ans[1]=1; for(int i=2;i&lt;=M;i++) { if(!vis[i]) ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p; else ans[i]=ans[i-1]; } while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p); } }","raw":"title: 欧拉函数总结\ndate: 2017-03-28 10:33:17\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 线性筛法\n  - 欧拉函数\n---\n\n# 欧拉函数的定义\n $\\varphi(n)$ 定义为1到n中与n互质的数的个数。\n\n---\n# 欧拉函数的求解\n## 1 . 通项公式\n\n $ \\varphi(n)=n(1-1/p_1)(1-1/p_2)...(1-1/p_{tot}) $ (其中p为n的质因子，tot为质因子个数)\n\n    int euler_phi(int n)\n    {\n        int m=(int)sqrt(n);\n        int ans=n;\n        for(int i=2;i<=m;i++)\n        {\n            if(n%i==0)\n            {\n                ans=ans/i*(i-1);//ans*=(1-inv[i])？？；\n                while(n%i==0) n/=i;//与分解质因数相结合\n            }\n        }\n        if(n>1) ans=ans/n*(n-1);\n        return ans;\n    }\n## 2 . 线性筛法\n逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前n项欧拉函数。\n\n    int prime[2*sqrt(N)+1],phi[N];\n\n    bool vis[N];\n\n    int tot;\n    int getprime()\n    {\n        for(int i=2;i<=N;++i)\n        {\n            if(!vis[i])\n            {\n                prime[++tot]=i;\n                phi[i]=i-1;\n            }\n            for(int t=1;t<=tot&&prime[t]*i<=N;++t)\n            {\n                vis[i*prime[t]]=true;\n                if(i%prime[t]==0){phi[i*prime[t]]=phi[i]*prime[t];break;}\n                phi[i*prime[t]]=phi[i]*(prime[t]-1);\n            }\n        }\n    }\n---\n# 相关习题\n\n## T1\n已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$\n\n### 证明\n\n设$T=lcm(1,2,...,p-1)$\n\n则有\n\n$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+...+T/(p-1))/T$\n\n此时只需证明\n\n$T/1+T/2+...+T/(p-1)≡0(modp)$\n\n根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为\n\n$1+2+...+(p-1)≡0(modp)$\n\n$p*(p-1)≡0(modp)$\n\n得证。\n\n---\n## T1 SDOI2008 沙拉公主的困惑\n\n### 题目描述\n大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。\n### 输入输出格式\n#### 输入格式\n第一行为两个整数T，R。R<=10^9+10，T<=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m<=n\n#### 输出格式\n共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值\n### 输入输出样例\n#### 输入样例\n    1 11\n    4 2\n#### 输出样例\n\t1\n### 数据范围\n对于100%的数据，1 < = N , M < = 10000000\n\n---\n### 题解\n题意明确$n>=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$\n\n对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。\n\n---\n### CODE\n    #include<cstdio>\n    #include<iostream>\n    const int M = 1e6+1;\n    using namespace std;\n    bool vis[M+100];\n    long long prime[500500],ans[M+100],fac[M+100],rev[M+100];\n    int n,m,p,T,tot;\n    int main()\n    {\n        scanf(\"%d%d\",&T,&p);\n\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])prime[++tot]=i;\n            for(int j=1;j<=tot&&prime[j]*i<=M;j++)\n            {\n                vis[prime[j]*i]=1;\n                if(i%prime[j]==0)\n                    break;\n            }\n        }\n        fac[1]=1;\n        for(int i=2;i<=M;i++)fac[i]=fac[i-1]*i%p;\n        rev[1]=1;\n        for(int i=2;i<=M&&i<p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n        ans[1]=1;\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])\tans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n            else\t\t\t\tans[i]=ans[i-1];\n        }\n        while(T--)\n        {\n            scanf(\"%d%d\",&n,&m);\n            printf(\"%d\\n\",fac[n]*ans[m]%p);\n        }\n    }\n\n\n\n","content":"<h1 id=\"欧拉函数的定义\"><a href=\"#欧拉函数的定义\" class=\"headerlink\" title=\"欧拉函数的定义\"></a>欧拉函数的定义</h1><p> $\\varphi(n)$ 定义为1到n中与n互质的数的个数。</p>\n<hr>\n<h1 id=\"欧拉函数的求解\"><a href=\"#欧拉函数的求解\" class=\"headerlink\" title=\"欧拉函数的求解\"></a>欧拉函数的求解</h1><h2 id=\"1-通项公式\"><a href=\"#1-通项公式\" class=\"headerlink\" title=\"1 . 通项公式\"></a>1 . 通项公式</h2><p> $ \\varphi(n)=n(1-1/p_1)(1-1/p<em>2)…(1-1/p</em>{tot}) $ (其中p为n的质因子，tot为质因子个数)</p>\n<pre><code>int euler_phi(int n)\n{\n    int m=(int)sqrt(n);\n    int ans=n;\n    for(int i=2;i&lt;=m;i++)\n    {\n        if(n%i==0)\n        {\n            ans=ans/i*(i-1);//ans*=(1-inv[i])？？；\n            while(n%i==0) n/=i;//与分解质因数相结合\n        }\n    }\n    if(n&gt;1) ans=ans/n*(n-1);\n    return ans;\n}\n</code></pre><h2 id=\"2-线性筛法\"><a href=\"#2-线性筛法\" class=\"headerlink\" title=\"2 . 线性筛法\"></a>2 . 线性筛法</h2><p>逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前n项欧拉函数。</p>\n<pre><code>int prime[2*sqrt(N)+1],phi[N];\n\nbool vis[N];\n\nint tot;\nint getprime()\n{\n    for(int i=2;i&lt;=N;++i)\n    {\n        if(!vis[i])\n        {\n            prime[++tot]=i;\n            phi[i]=i-1;\n        }\n        for(int t=1;t&lt;=tot&amp;&amp;prime[t]*i&lt;=N;++t)\n        {\n            vis[i*prime[t]]=true;\n            if(i%prime[t]==0){phi[i*prime[t]]=phi[i]*prime[t];break;}\n            phi[i*prime[t]]=phi[i]*(prime[t]-1);\n        }\n    }\n}\n</code></pre><hr>\n<h1 id=\"相关习题\"><a href=\"#相关习题\" class=\"headerlink\" title=\"相关习题\"></a>相关习题</h1><h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a>T1</h2><p>已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$</p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>设$T=lcm(1,2,…,p-1)$</p>\n<p>则有</p>\n<p>$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$</p>\n<p>此时只需证明</p>\n<p>$T/1+T/2+…+T/(p-1)≡0(modp)$</p>\n<p>根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为</p>\n<p>$1+2+…+(p-1)≡0(modp)$</p>\n<p>$p*(p-1)≡0(modp)$</p>\n<p>得证。</p>\n<hr>\n<h2 id=\"T1-SDOI2008-沙拉公主的困惑\"><a href=\"#T1-SDOI2008-沙拉公主的困惑\" class=\"headerlink\" title=\"T1 SDOI2008 沙拉公主的困惑\"></a>T1 SDOI2008 沙拉公主的困惑</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h4><pre><code>1 11\n4 2\n</code></pre><h4 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h4><pre><code>1\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于100%的数据，1 &lt; = N , M &lt; = 10000000</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$</p>\n<p>对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\nconst int M = 1e6+1;\nusing namespace std;\nbool vis[M+100];\nlong long prime[500500],ans[M+100],fac[M+100],rev[M+100];\nint n,m,p,T,tot;\nint main()\n{\n    scanf(&quot;%d%d&quot;,&amp;T,&amp;p);\n\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])prime[++tot]=i;\n        for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++)\n        {\n            vis[prime[j]*i]=1;\n            if(i%prime[j]==0)\n                break;\n        }\n    }\n    fac[1]=1;\n    for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p;\n    rev[1]=1;\n    for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n    ans[1]=1;\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])    ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n        else                ans[i]=ans[i-1];\n    }\n    while(T--)\n    {\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p);\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/28/欧拉函数总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"线性筛法","slug":"线性筛法","permalink":"https://prostkhala.github.io/tags/线性筛法/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://prostkhala.github.io/tags/欧拉函数/"}]},{"title":"乘法逆元总结","date":"2017-03-28T02:33:17.000Z","path":"2017/03/28/乘法逆元总结/","text":"乘法逆元的定义若$ax≡1 (mod p)$, 则称a关于模p的乘法逆元为x。也可表示为$ax≡1(mod p)$。 当a与p互质时，a关于模p的乘法逆元有解。如果不互质，则无解。如果p为质数，则从1到p-1的任意数都与p互质，即在1到p-1之间都恰好有一个关于模p的乘法逆元。且1到p-1中的所有数的逆元对应1到p-1中的所有数，既是单射也是满射。 逆元的求解1 . 扩展欧几里得算法逆元一般通过EXGCD求解，该方法的时间复杂度为$O(logn)$。 int x, y;//NOIP 同余方程 int extgcd(int a, int b, int &amp;x, int &amp;y) { if (b == 0) { x = 1; y = 0; return a; } int gcd = exgcd(b, a % b, x, y); int tmp = x; x = y; y = tmp - (a/b) * y; return gcd; } //inv[n]=(x%p+x)%p; 2 . 费马小定理当$n$为质数时，同样可以通过费马小定理求解。已知$n^{p-1}≡ 1(mod p)$(费马小定理) 那么$inv[n]=n^{p-2} (mod p)$。该方法的时间复杂度为$O(logn)$（快速幂）。 3 . 线性求前$n$项的逆元 该方法时间复杂度为$O(n)$，可以同时处理前$n$个数在$modp$意义下的逆元。 递推式： $inv[1] = 1$ $inv[n] = inv [ p(mod n)]*(p-p/n)(modp)（n&gt;1）$ 证明： 设$t=p/n$，$k=p(modn)$ 则有 $t*n+k≡0(modp)$ $-t*n≡k(modp)$ 对原式除以$i*k$，得到 $-t*inv[k]≡invn$ 即 $-p/n*inv[p(modn)]≡invn$ $inv[n] = inv [ p(mod n)]*(p-p/n)(modp)$ 得证。 4 . 利用阶乘递推求前$n$项的逆元该方法较简单易懂，理论复杂度是方法3的3倍。据说在某些奇怪的时刻会跑的比上面快。(因为数组的连续访问) //fac为阶乘，rev为阶乘的逆元。 fac[0]=fac[1]=1; for(int i=2;i&lt;=N;i++)fac[i]=fac[i-1]*i%mod; rev[N]=mod_pow(fac[N],mod-2);//mod_pow为带取模的快速幂 for(int i=N-1;i&gt;=0;i--)rev[i]=rev[i+1]*(i+1)%mod; 相关习题T1已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$ 证明设$T=lcm(1,2,…,p-1)$ 则有 $\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$ 此时只需证明 $T/1+T/2+…+T/(p-1)≡0(modp)$ 根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为 $1+2+…+(p-1)≡0(modp)$ $p*(p-1)≡0(modp)$ 得证。 T2 SDOI2008 沙拉公主的困惑题目描述大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。 输入输出格式输入格式第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n 输出格式共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值 输入输出样例输入样例1 11 4 2 输出样例1 数据范围对于100%的数据，1 &lt; = N , M &lt; = 10000000 题解题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$ 对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。 CODE#include&lt;cstdio&gt; #include&lt;iostream&gt; const int M = 1e6+1; using namespace std; bool vis[M+100]; long long prime[500500],ans[M+100],fac[M+100],rev[M+100]; int n,m,p,T,tot; int main() { scanf(&quot;%d%d&quot;,&amp;T,&amp;p); for(int i=2;i&lt;=M;i++) { if(!vis[i])prime[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++) { vis[prime[j]*i]=1; if(i%prime[j]==0) break; } } fac[1]=1; for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p; rev[1]=1; for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p; ans[1]=1; for(int i=2;i&lt;=M;i++) { if(!vis[i]) ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p; else ans[i]=ans[i-1]; } while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p); } }","raw":"title: 乘法逆元总结\ndate: 2017-03-28 10:33:17\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 逆元\n  - 线性筛法\n  - 扩展欧几里得\n  - 欧拉函数\n  - 费马小定理\n---\n\n# 乘法逆元的定义\n若$ax≡1 (mod p)$, 则称a关于模p的乘法逆元为x。也可表示为$ax≡1(mod p)$。\n\n当a与p互质时，a关于模p的乘法逆元有解。如果不互质，则无解。如果p为质数，则从1到p-1的任意数都与p互质，即在1到p-1之间都恰好有一个关于模p的乘法逆元。且1到p-1中的所有数的逆元对应1到p-1中的所有数，既是单射也是满射。\n\n---\n# 逆元的求解\n## 1 . 扩展欧几里得算法\n逆元一般通过EXGCD求解，该方法的时间复杂度为$O(logn)$。\n\n    int x, y;//NOIP 同余方程    \n    int extgcd(int a, int b, int &x, int &y)    \n    {    \n        if (b == 0)\n        {    \n            x = 1;    \n            y = 0;    \n            return a;    \n        }    \n        int gcd = exgcd(b, a % b, x, y);    \n        int tmp = x;    \n        x = y;    \n        y = tmp - (a/b) * y;    \n        return gcd;    \n    }    //inv[n]=(x%p+x)%p;\n ---\n## 2 . 费马小定理\n当$n$为质数时，同样可以通过费马小定理求解。\n已知$n^{p-1}≡ 1(mod p)$(费马小定理)\n 那么$inv[n]=n^{p-2} (mod p)$。该方法的时间复杂度为$O(logn)$（快速幂）。\n \n ---\n ## 3 . 线性求前$n$项的逆元\n 该方法时间复杂度为$O(n)$，可以同时处理前$n$个数在$modp$意义下的逆元。\n \n 递推式：\n \n $inv[1] = 1$\n \n $inv[n] = inv [ p(mod n)]*(p-p/n)(modp)（n>1）$\n \n ### 证明：\n \n 设$t=p/n$，$k=p(modn)$\n\n则有\n\n$t*n+k≡0(modp)$\n\n$-t*n≡k(modp)$\n\n对原式除以$i*k$，得到\n\n$-t*inv[k]≡inv[n](modp)$\n\n即\n\n$-p/n*inv[p(modn)]≡inv[n](modp)$\n\n$inv[n] = inv [ p(mod n)]*(p-p/n)(modp)$\n\n得证。\n\n---\n## 4 . 利用阶乘递推求前$n$项的逆元\n该方法较简单易懂，理论复杂度是方法3的3倍。据说在某些奇怪的时刻会跑的比上面快。(因为数组的连续访问)\n\n\t//fac为阶乘，rev为阶乘的逆元。\n    fac[0]=fac[1]=1;\n\n    for(int i=2;i<=N;i++)fac[i]=fac[i-1]*i%mod;\n\n    rev[N]=mod_pow(fac[N],mod-2);//mod_pow为带取模的快速幂\n\n    for(int i=N-1;i>=0;i--)rev[i]=rev[i+1]*(i+1)%mod;\n\n---\n# 相关习题\n\n## T1\n已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$\n\n### 证明\n\n设$T=lcm(1,2,...,p-1)$\n\n则有\n\n$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+...+T/(p-1))/T$\n\n此时只需证明\n\n$T/1+T/2+...+T/(p-1)≡0(modp)$\n\n根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为\n\n$1+2+...+(p-1)≡0(modp)$\n\n$p*(p-1)≡0(modp)$\n\n得证。\n\n---\n## T2 SDOI2008 沙拉公主的困惑\n\n### 题目描述\n大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。\n### 输入输出格式\n#### 输入格式\n第一行为两个整数T，R。R<=10^9+10，T<=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m<=n\n#### 输出格式\n共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值\n### 输入输出样例\n#### 输入样例\n    1 11\n    4 2\n#### 输出样例\n\t1\n### 数据范围\n对于100%的数据，1 < = N , M < = 10000000\n\n---\n### 题解\n题意明确$n>=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$\n\n对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。\n\n---\n### CODE\n    #include<cstdio>\n    #include<iostream>\n    const int M = 1e6+1;\n    using namespace std;\n    bool vis[M+100];\n    long long prime[500500],ans[M+100],fac[M+100],rev[M+100];\n    int n,m,p,T,tot;\n    int main()\n    {\n        scanf(\"%d%d\",&T,&p);\n\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])prime[++tot]=i;\n            for(int j=1;j<=tot&&prime[j]*i<=M;j++)\n            {\n                vis[prime[j]*i]=1;\n                if(i%prime[j]==0)\n                    break;\n            }\n        }\n        fac[1]=1;\n        for(int i=2;i<=M;i++)fac[i]=fac[i-1]*i%p;\n        rev[1]=1;\n        for(int i=2;i<=M&&i<p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n        ans[1]=1;\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])\tans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n            else\t\t\t\tans[i]=ans[i-1];\n        }\n        while(T--)\n        {\n            scanf(\"%d%d\",&n,&m);\n            printf(\"%d\\n\",fac[n]*ans[m]%p);\n        }\n    }\n","content":"<h1 id=\"乘法逆元的定义\"><a href=\"#乘法逆元的定义\" class=\"headerlink\" title=\"乘法逆元的定义\"></a>乘法逆元的定义</h1><p>若$ax≡1 (mod p)$, 则称a关于模p的乘法逆元为x。也可表示为$ax≡1(mod p)$。</p>\n<p>当a与p互质时，a关于模p的乘法逆元有解。如果不互质，则无解。如果p为质数，则从1到p-1的任意数都与p互质，即在1到p-1之间都恰好有一个关于模p的乘法逆元。且1到p-1中的所有数的逆元对应1到p-1中的所有数，既是单射也是满射。</p>\n<hr>\n<h1 id=\"逆元的求解\"><a href=\"#逆元的求解\" class=\"headerlink\" title=\"逆元的求解\"></a>逆元的求解</h1><h2 id=\"1-扩展欧几里得算法\"><a href=\"#1-扩展欧几里得算法\" class=\"headerlink\" title=\"1 . 扩展欧几里得算法\"></a>1 . 扩展欧几里得算法</h2><p>逆元一般通过EXGCD求解，该方法的时间复杂度为$O(logn)$。</p>\n<pre><code>int x, y;//NOIP 同余方程    \nint extgcd(int a, int b, int &amp;x, int &amp;y)    \n{    \n    if (b == 0)\n    {    \n        x = 1;    \n        y = 0;    \n        return a;    \n    }    \n    int gcd = exgcd(b, a % b, x, y);    \n    int tmp = x;    \n    x = y;    \n    y = tmp - (a/b) * y;    \n    return gcd;    \n}    //inv[n]=(x%p+x)%p;\n</code></pre><hr>\n<h2 id=\"2-费马小定理\"><a href=\"#2-费马小定理\" class=\"headerlink\" title=\"2 . 费马小定理\"></a>2 . 费马小定理</h2><p>当$n$为质数时，同样可以通过费马小定理求解。<br>已知$n^{p-1}≡ 1(mod p)$(费马小定理)<br> 那么$inv[n]=n^{p-2} (mod p)$。该方法的时间复杂度为$O(logn)$（快速幂）。</p>\n<hr>\n<h2 id=\"3-线性求前-n-项的逆元\"><a href=\"#3-线性求前-n-项的逆元\" class=\"headerlink\" title=\"3 . 线性求前$n$项的逆元\"></a>3 . 线性求前$n$项的逆元</h2><p> 该方法时间复杂度为$O(n)$，可以同时处理前$n$个数在$modp$意义下的逆元。</p>\n<p> 递推式：</p>\n<p> $inv[1] = 1$</p>\n<p> $inv[n] = inv [ p(mod n)]*(p-p/n)(modp)（n&gt;1）$</p>\n<h3 id=\"证明：\"><a href=\"#证明：\" class=\"headerlink\" title=\"证明：\"></a>证明：</h3><p> 设$t=p/n$，$k=p(modn)$</p>\n<p>则有</p>\n<p>$t*n+k≡0(modp)$</p>\n<p>$-t*n≡k(modp)$</p>\n<p>对原式除以$i*k$，得到</p>\n<p>$-t*inv[k]≡inv<a href=\"modp\">n</a>$</p>\n<p>即</p>\n<p>$-p/n*inv[p(modn)]≡inv<a href=\"modp\">n</a>$</p>\n<p>$inv[n] = inv [ p(mod n)]*(p-p/n)(modp)$</p>\n<p>得证。</p>\n<hr>\n<h2 id=\"4-利用阶乘递推求前-n-项的逆元\"><a href=\"#4-利用阶乘递推求前-n-项的逆元\" class=\"headerlink\" title=\"4 . 利用阶乘递推求前$n$项的逆元\"></a>4 . 利用阶乘递推求前$n$项的逆元</h2><p>该方法较简单易懂，理论复杂度是方法3的3倍。据说在某些奇怪的时刻会跑的比上面快。(因为数组的连续访问)</p>\n<pre><code>//fac为阶乘，rev为阶乘的逆元。\nfac[0]=fac[1]=1;\n\nfor(int i=2;i&lt;=N;i++)fac[i]=fac[i-1]*i%mod;\n\nrev[N]=mod_pow(fac[N],mod-2);//mod_pow为带取模的快速幂\n\nfor(int i=N-1;i&gt;=0;i--)rev[i]=rev[i+1]*(i+1)%mod;\n</code></pre><hr>\n<h1 id=\"相关习题\"><a href=\"#相关习题\" class=\"headerlink\" title=\"相关习题\"></a>相关习题</h1><h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a>T1</h2><p>已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$</p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>设$T=lcm(1,2,…,p-1)$</p>\n<p>则有</p>\n<p>$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$</p>\n<p>此时只需证明</p>\n<p>$T/1+T/2+…+T/(p-1)≡0(modp)$</p>\n<p>根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为</p>\n<p>$1+2+…+(p-1)≡0(modp)$</p>\n<p>$p*(p-1)≡0(modp)$</p>\n<p>得证。</p>\n<hr>\n<h2 id=\"T2-SDOI2008-沙拉公主的困惑\"><a href=\"#T2-SDOI2008-沙拉公主的困惑\" class=\"headerlink\" title=\"T2 SDOI2008 沙拉公主的困惑\"></a>T2 SDOI2008 沙拉公主的困惑</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h4><pre><code>1 11\n4 2\n</code></pre><h4 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h4><pre><code>1\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于100%的数据，1 &lt; = N , M &lt; = 10000000</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$</p>\n<p>对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\nconst int M = 1e6+1;\nusing namespace std;\nbool vis[M+100];\nlong long prime[500500],ans[M+100],fac[M+100],rev[M+100];\nint n,m,p,T,tot;\nint main()\n{\n    scanf(&quot;%d%d&quot;,&amp;T,&amp;p);\n\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])prime[++tot]=i;\n        for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++)\n        {\n            vis[prime[j]*i]=1;\n            if(i%prime[j]==0)\n                break;\n        }\n    }\n    fac[1]=1;\n    for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p;\n    rev[1]=1;\n    for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n    ans[1]=1;\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])    ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n        else                ans[i]=ans[i-1];\n    }\n    while(T--)\n    {\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p);\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/28/乘法逆元总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"逆元","slug":"逆元","permalink":"https://prostkhala.github.io/tags/逆元/"},{"name":"线性筛法","slug":"线性筛法","permalink":"https://prostkhala.github.io/tags/线性筛法/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://prostkhala.github.io/tags/扩展欧几里得/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://prostkhala.github.io/tags/欧拉函数/"},{"name":"费马小定理","slug":"费马小定理","permalink":"https://prostkhala.github.io/tags/费马小定理/"}]},{"title":"NOI2005 维修数列","date":"2017-03-21T14:13:15.000Z","path":"2017/03/21/维护队列/","text":"NOI2005 维护数列洛谷2042 COGS339 题目描述 请写一个程序，要求维护一个数列，支持以下 6 种操作：（请注意，格式栏 中的下划线‘ _ ’表示实际输入文件中的空格） 操作编号 输入文件中的格式 说明 1. 插入 INSERT_posi_tot_c1_c2_..._ctot 在当前数列的第 posi 个数字后插入 tot个数字：c1, c2, …, ctot；若在数列首插入，则 posi 为 0 2. 删除 DELETE_posi_tot 从当前数列的第 posi 个数字开始连续删除 tot 个数字 3. 修改 MAKE-SAME_posi_tot_c 将当前数列的第 posi 个数字开始的连续 tot 个数字统一修改为 c 4. 翻转 REVERSE_posi_tot 取出从当前数列的第 posi 个数字开始的 tot 个数字，翻转后放入原来的位置 5. 求和 GET-SUM_posi_tot 计算从当前数列开始的第 posi 个数字开始的 tot 个数字的和并输出 6. 求和最大的子列 MAX-SUM 求出当前数列中和最大的一段子列，并输出最大和 输入输出格式输入格式： 输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M表示要进行的操作数目。 第 2 行包含 N 个数字，描述初始时的数列。 以下 M 行，每行一条命令，格式参见问题描述中的表格。 输出格式：对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结果，每个答案（数字）占一行。 输入输出样例输入样例：9 8 2 -6 3 5 1 -5 -3 6 3 GET-SUM 5 4 MAX-SUM INSERT 8 3 -5 7 2 DELETE 12 1 MAKE-SAME 3 3 2 REVERSE 3 6 GET-SUM 5 4 MAX-SUM 输出样例：-1 10 1 10 数据范围你可以认为在任何时刻，数列中至少有 1 个数。 输入数据一定是正确的，即指定位置的数在数列中一定存在。 50%的数据中，任何时刻数列中最多含有 30 000 个数； 100%的数据中，任何时刻数列中最多含有 500 000 个数。 100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。 100%的数据中，M ≤20 000，插入的数字总数不超过 4 000 000 个，输入文件大小不超过 20MBytes。 题解对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立二分搜索树，而不应直接插入，否则会导致时间复杂度过高，同时操作后也要注意更新信息。 对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。 对于求和操作，具体实现与线段树相同。 对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。 （一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入4e6个元素，但同时也说明队列中最多只有5e5个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用。） CODE V1（暴力）#include&lt;iostream&gt; #include&lt;cstdio&gt; const int N = 4e6+5; const int inf = 0x7fffffff; using namespace std; int tot,root,rev[N],size[N],w[N],fa[N],son[N][2],id[N]; void update(int x) { size[x]=size[son[x][0]]+size[son[x][1]]+1; } void pushdown(int x) { if(rev[x]) { swap(son[x][0],son[x][1]); rev[son[x][0]]^=1; rev[son[x][1]]^=1; rev[x]=0; } return; } void zg(int x) { pushdown(fa[x]),pushdown(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(z) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; update(y);update(x); } void splay(int x,int f) { while(fa[x]!=f) { int y=fa[x],z=fa[y]; if(z!=f) { if(son[z][0]==y^son[y][0]==x) zg(x); else zg(y); } zg(x); } if(!f) root=x; } void insert(int &amp;x,int v,int f) { if(!x) { x=++tot; son[x][0]=son[x][1]=0; size[x]=1; w[x]=v;fa[x]=f; splay(x,0); return; } insert(son[x][v&gt;w[x]],v,x); update(x); } int get(int v) { int x=root; while(x&amp;&amp;v!=w[x]) x=son[x][v&gt;w[x]]; return x; } int find(int k,int rank) { pushdown(k); int l=son[k][0],r=son[k][1]; if(size[l]+1==rank)return k; else if(size[l]&gt;=rank)return find(l,rank); else return find(r,rank-size[l]-1); } int a[N]; char op[19]; int sum1,ans1,max1; int inorder(int x) { pushdown(x); if(son[x][0])inorder(son[x][0]); if(w[x]!=inf&amp;&amp;w[x]!=-inf)printf(&quot;%d &quot;,a[w[x]]); if(son[x][1])inorder(son[x][1]); } int inordermax(int x) { pushdown(x); if(son[x][0])inordermax(son[x][0]); if(w[x]!=inf&amp;&amp;w[x]!=-inf) { max1=max(max1,a[w[x]]); sum1+=a[w[x]]*num[x]; if(sum1&gt;0)ans1=max(ans1,sum1); else sum1=0; } if(son[x][1])inordermax(son[x][1]); } int main() { // freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout); int n,m,tmp; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); insert(root,-inf,0);insert(root,inf,0); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i); for(int i=1;i&lt;=n;++i)insert(root,i,0); tmp=n; for(int i=1,pos,tt,x;i&lt;=m;++i) { scanf(&quot;%s&quot;,op); if(op[0]==&#39;I&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int now=find(root,pos+1),ne=find(root,pos+2); update(now),update(ne); splay(now,0);splay(ne,root); for(int i=1;i&lt;=tt;++i)scanf(&quot;%d&quot;,&amp;a[++tmp]),insert(son[ne][0],tmp,ne); update(root),update(son[root][1]); } if(op[0]==&#39;D&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int now=find(root,pos),ne=find(root,pos+tt+1); splay(now,0);splay(ne,root); fa[son[ne][0]]=0; son[ne][0]=0; update(ne);update(now); } if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;) { scanf(&quot;%d%d%d&quot;,&amp;pos,&amp;tt,&amp;x); for(int t=pos+1;t&lt;=pos+tt;++t) a[w[find(root,t)]]=x; } if(op[0]==&#39;R&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int now=find(root,pos),ne=find(root,pos+tt+1); update(now),update(ne); splay(now,0);splay(ne,root); int s=son[ne][0]; rev[s]^=1; } if(op[0]==&#39;G&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int sum=0; for(int t=1;t&lt;=tt;++t) sum+=a[find(root,pos+t)-2]; printf(&quot;%d\\n&quot;,sum); } if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;) { sum1=ans1=0;max1=-0x7fffffff; inordermax(root); printf(&quot;%d\\n&quot;,ans1==0?max1:ans1); } } // inorder(root); } CODE V2#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; const int inf = 1e9; const int N = 1e6+1; inline int read() { int x=0,f=1;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} return x*f; } int n,m,root,cnt; int sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][2];; bool tag[N],rev[N]; queue&lt;int&gt;q; void pushdown(int x) { int sonl=son[x][0],sonr=son[x][1]; if(tag[x]) { if(sonl)tag[sonl]=true,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl]; if(sonr)tag[sonr]=true,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr]; if(v[x]&gt;=0) { if(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl]; if(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr]; } else { if(sonl)lx[sonl]=rx[sonl]=0,mx[sonl]=v[x]; if(sonr)lx[sonr]=rx[sonr]=0,mx[sonr]=v[x]; } rev[x]=tag[x]=0; } if(rev[x]) { rev[x]^=1;rev[sonl]^=1;rev[sonr]^=1; swap(lx[sonl],rx[sonl]);swap(lx[sonr],rx[sonr]); swap(son[sonl][0],son[sonl][1]);swap(son[sonr][0],son[sonr][1]); } } int inorder(int x) { pushdown(x); if(son[x][0])inorder(son[x][0]); if(v[x]!=inf&amp;&amp;v[x]!=-inf)printf(&quot;%d &quot;,v[x]); if(son[x][1])inorder(son[x][1]); } void update(int x) { int sonl=son[x][0],sonr=son[x][1]; sum[x]=sum[sonl]+sum[sonr]+v[x]; size[x]=size[sonl]+size[sonr]+1; mx[x]=max(mx[sonl],mx[sonr]); mx[x]=max(mx[x],rx[sonl]+v[x]+lx[sonr]); lx[x]=max(lx[sonl],sum[sonl]+v[x]+lx[sonr]); rx[x]=max(rx[sonr],sum[sonr]+v[x]+rx[sonl]); } void rotate(int x,int &amp;k) { int y=fa[x],z=fa[y],l,r; l=(son[y][1]==x);r=l^1; if(y==k)k=x; else son[z][son[z][1]==y]=x; fa[son[x][r]]=y;fa[y]=x;fa[x]=z; son[y][l]=son[x][r];son[x][r]=y; update(y);update(x); } void splay(int x,int &amp;k) { while(x!=k) { int y=fa[x],z=fa[y]; if(y!=k) { if(son[y][0]==x^son[z][0]==y)rotate(x,k); else rotate(y,k); } rotate(x,k); } } int find(int x,int rk) { pushdown(x); int l=son[x][0],r=son[x][1]; if(size[l]+1==rk)return x; if(size[l]&gt;=rk)return find(l,rk); return find(r,rk-size[l]-1); } void rec(int x) { if(!x)return; int l=son[x][0],r=son[x][1]; rec(l);rec(r);q.push(x); fa[x]=son[x][0]=son[x][1]=0; tag[x]=rev[x]=0; } int split(int k,int tt) { int x=find(root,k),y=find(root,k+tt+1); splay(x,root);splay(y,son[x][1]); return son[y][0]; } void modify(int k,int tt,int val) { int x=split(k,tt),y=fa[x]; v[x]=val;tag[x]=1;sum[x]=size[x]*val; if(val&gt;=0)lx[x]=rx[x]=mx[x]=sum[x]; else lx[x]=rx[x]=0,mx[x]=val; update(y);update(fa[y]); } void rever(int k,int tt) { int x=split(k,tt),y=fa[x]; if(!tag[x]) { rev[x]^=1; swap(son[x][0],son[x][1]); swap(lx[x],rx[x]); update(y);update(fa[y]); } } void delet(int k,int tt) { int x=split(k,tt),y=fa[x]; rec(x);son[y][0]=0; update(y);update(fa[y]); } void build(int l,int r,int s) { if(l&gt;r)return; int mid=(l+r)&gt;&gt;1,now=id[mid],last=id[s]; if(l==r) { sum[now]=a[l];size[now]=1; tag[now]=rev[now]=0; if(a[l]&gt;=0)lx[now]=rx[now]=mx[now]=a[l]; else lx[now]=rx[now]=0,mx[now]=a[l]; } else build(l,mid-1,mid),build(mid+1,r,mid); v[now]=a[mid];fa[now]=last;update(now); son[last][mid&gt;=s]=now; } void insert(int k,int tt) { for(int i=1;i&lt;=tt;i++)a[i]=read(); for(int i=1;i&lt;=tt;i++) if(!q.empty())id[i]=q.front(),q.pop(); else id[i]=++cnt; build(1,tt,0);int z=id[(1+tt)&gt;&gt;1]; int x=find(root,k+1),y=find(root,k+2); splay(x,root);splay(y,son[x][1]); fa[z]=y;son[y][0]=z; update(y);update(x); } int main() { // freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); mx[0]=a[1]=a[n+2]=-inf; for(int i=2;i&lt;=n+1;i++)a[i]=read(); for(int i=1;i&lt;=n+2;i++)id[i]=i; build(1,n+2,0); root=(n+3)&gt;&gt;1;cnt=n+2; int k,tt,val; char op[19]; for(int i=1;i&lt;=m;++i) { scanf(&quot;%s&quot;,op); if(op[0]==&#39;I&#39;)k=read(),tt=read(),insert(k,tt); if(op[0]==&#39;D&#39;)k=read(),tt=read(),delet(k,tt); if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;)printf(&quot;%d\\n&quot;,mx[root]); if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;)k=read(),tt=read(),val=read(),modify(k,tt,val); if(op[0]==&#39;R&#39;)k=read(),tt=read(),rever(k,tt); if(op[0]==&#39;G&#39;){k=read(),tt=read();printf(&quot;%d\\n&quot;,sum[split(k,tt)]);} } // inorder(root); }","raw":"title: NOI2005 维修数列\ndate: 2017-03-21 22:13:15\ncategories:\n  - 平衡树\n  - SPLAY\ntags:\n  - SPLAY\n---\n\n# NOI2005 维护数列\n\n## [洛谷2042](https://www.luogu.org/problem/show?pid=2042) [COGS339](http://cogs.pro/cogs/problem/problem.php?pid=339)\n\n---\n## 题目描述\n 请写一个程序，要求维护一个数列，支持以下 6 种操作：（请注意，格式栏 中的下划线‘ _ ’表示实际输入文件中的空格）\n\n    操作编号\t输入文件中的格式\t说明\n\n\n    1.  插入\tINSERT_posi_tot_c1_c2_..._ctot\n\t在当前数列的第 posi 个数字后插入 tot个数字：c1, c2, …, ctot；若在数列首插入，则 posi 为 0\n\n    2.  删除\tDELETE_posi_tot\n    从当前数列的第 posi 个数字开始连续删除 tot 个数字\n\n    3.  修改\tMAKE-SAME_posi_tot_c\n\t 将当前数列的第 posi 个数字开始的连续 tot 个数字统一修改为 c\n\n    4.  翻转\tREVERSE_posi_tot\n \t取出从当前数列的第 posi 个数字开始的 tot 个数字，翻转后放入原来的位置\n    \n    5.  求和\tGET-SUM_posi_tot\n\t计算从当前数列开始的第 posi 个数字开始的 tot 个数字的和并输出\n\n    6.  求和最大的子列\tMAX-SUM\n\t求出当前数列中和最大的一段子列，并输出最大和 \n### 输入输出格式\n#### 输入格式：\n 输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M表示要进行的操作数目。\n\n第 2 行包含 N 个数字，描述初始时的数列。\n\n以下 M 行，每行一条命令，格式参见问题描述中的表格。 \n\n\n#### 输出格式：\n\n对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结果，每个答案（数字）占一行。 \n\n### 输入输出样例\n#### 输入样例：\n    9 8\n    2 -6 3 5 1 -5 -3 6 3\n    GET-SUM 5 4\n    MAX-SUM INSERT 8 3 -5 7 2\n    DELETE 12 1\n    MAKE-SAME 3 3 2\n    REVERSE 3 6\n    GET-SUM 5 4\n    MAX-SUM\n    \n\n#### 输出样例：\n    -1\n    10\n    1\n    10\n    \n\n### 数据范围\n\n你可以认为在任何时刻，数列中至少有 1 个数。\n\n输入数据一定是正确的，即指定位置的数在数列中一定存在。\n\n50%的数据中，任何时刻数列中最多含有 30 000 个数；\n\n100%的数据中，任何时刻数列中最多含有 500 000 个数。\n\n100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。\n\n100%的数据中，M ≤20 000，插入的数字总数不超过 4 000 000 个，输入文件大小不超过 20MBytes。\n\n---\n\n## 题解\n对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立二分搜索树，而不应直接插入，否则会导致时间复杂度过高，同时操作后也要注意更新信息。\n\n对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。\n\n对于求和操作，具体实现与线段树相同。\n\n对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。\n\n（一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入4e6个元素，但同时也说明队列中最多只有5e5个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用。）\n\n---\n### CODE V1（暴力）\n    #include<iostream>\n    #include<cstdio>\n    const int N = 4e6+5;\n    const int inf = 0x7fffffff;\n    using namespace std;\n    int tot,root,rev[N],size[N],w[N],fa[N],son[N][2],id[N];\n    void update(int x)\n    {\n        size[x]=size[son[x][0]]+size[son[x][1]]+1;\n    }\n    void pushdown(int x)\n    {\n        if(rev[x])\n        {\n            swap(son[x][0],son[x][1]);\n            rev[son[x][0]]^=1;\n            rev[son[x][1]]^=1;\n            rev[x]=0;\n        }\n        return;\n    }\n    void zg(int x)\n    {\n        pushdown(fa[x]),pushdown(x);\n        int y=fa[x],z=fa[y],t=(son[y][0]==x);\n        if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n        son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n        son[x][t]=y;fa[y]=x;\n        update(y);update(x);\n    }\n    void splay(int x,int f)\n    {\n        while(fa[x]!=f)\n        {\n            int y=fa[x],z=fa[y];\n            if(z!=f)\n            {\n                if(son[z][0]==y^son[y][0]==x) zg(x);\n                else zg(y);\n            } \n            zg(x);\t\n        }\n        if(!f) root=x;\n    }\n    void insert(int &x,int v,int f)\n    {\n        if(!x)\n        {\n            x=++tot;\n            son[x][0]=son[x][1]=0;\n            size[x]=1;\n            w[x]=v;fa[x]=f;\n            splay(x,0);\n            return;\n        }\n        insert(son[x][v>w[x]],v,x);\n        update(x);\n    }\n    int get(int v)\n    {\n        int x=root;\n        while(x&&v!=w[x]) x=son[x][v>w[x]];\n        return x;\n    }\n    int find(int k,int rank)\n    {\n        pushdown(k);\n        int l=son[k][0],r=son[k][1];\n        if(size[l]+1==rank)return k;\n        else if(size[l]>=rank)return find(l,rank);\n        else return find(r,rank-size[l]-1);\n    }\n    int a[N];\n    char op[19];\n    int sum1,ans1,max1;\n    int inorder(int x)\n    {\n        pushdown(x);\n        if(son[x][0])inorder(son[x][0]);\n        if(w[x]!=inf&&w[x]!=-inf)printf(\"%d \",a[w[x]]);\n        if(son[x][1])inorder(son[x][1]);\n    }\n    int inordermax(int x)\n    {\n        pushdown(x);\n        if(son[x][0])inordermax(son[x][0]);\n        if(w[x]!=inf&&w[x]!=-inf)\n        {\n            max1=max(max1,a[w[x]]);\n            sum1+=a[w[x]]*num[x];\n            if(sum1>0)ans1=max(ans1,sum1);\n            else\tsum1=0;\n        }\n        if(son[x][1])inordermax(son[x][1]);\n    }\n\n    int main()\n    {\n    //\tfreopen(\"seq2005.in\",\"r\",stdin);\n    //\tfreopen(\"seq2005.out\",\"w\",stdout);\n        int n,m,tmp;\n        scanf(\"%d%d\",&n,&m);\n        insert(root,-inf,0);insert(root,inf,0);\n        for(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n        for(int i=1;i<=n;++i)insert(root,i,0);\n        tmp=n;\n        for(int i=1,pos,tt,x;i<=m;++i)\n        {\n            scanf(\"%s\",op);\n            if(op[0]=='I')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int now=find(root,pos+1),ne=find(root,pos+2);\n                update(now),update(ne);\n                splay(now,0);splay(ne,root);\n                for(int i=1;i<=tt;++i)scanf(\"%d\",&a[++tmp]),insert(son[ne][0],tmp,ne);\n                update(root),update(son[root][1]);\n            }\n            if(op[0]=='D')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int now=find(root,pos),ne=find(root,pos+tt+1);\n                splay(now,0);splay(ne,root);\n                fa[son[ne][0]]=0;\n                son[ne][0]=0;\n                update(ne);update(now);\n            }\n            if(op[0]=='M'&&op[2]=='K')\n            {\n                scanf(\"%d%d%d\",&pos,&tt,&x);\n                for(int t=pos+1;t<=pos+tt;++t)\n                a[w[find(root,t)]]=x;\n            }\n            if(op[0]=='R')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int now=find(root,pos),ne=find(root,pos+tt+1);\n                update(now),update(ne);\n                splay(now,0);splay(ne,root);\n                int s=son[ne][0];\n                rev[s]^=1;\n            }\n            if(op[0]=='G')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int sum=0;\n                for(int t=1;t<=tt;++t)\n                sum+=a[find(root,pos+t)-2];\n                printf(\"%d\\n\",sum);\n            }\n            if(op[0]=='M'&&op[2]=='X')\n            {\n                sum1=ans1=0;max1=-0x7fffffff;\n                inordermax(root);\n                printf(\"%d\\n\",ans1==0?max1:ans1);\n            }\n        }\n        //\tinorder(root);\n    }\n    \n    \n ---\n ### CODE V2\n \n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #include<queue>\n    using namespace std;\n    const int inf = 1e9;\n    const int N = 1e6+1;\n    inline int read()\n    {\n        int x=0,f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n        return x*f;\n    }\n    int n,m,root,cnt;\n    int sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][2];;\n    bool tag[N],rev[N];\n    queue<int>q;\n    void pushdown(int x)\n    {\n        int sonl=son[x][0],sonr=son[x][1];\n        if(tag[x])\n        {\n\n            if(sonl)tag[sonl]=true,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl];\n            if(sonr)tag[sonr]=true,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr];\n            if(v[x]>=0)\n            {\n                if(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl];\n                if(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr];\n            }\n            else \n            {\n                if(sonl)lx[sonl]=rx[sonl]=0,mx[sonl]=v[x];\n                if(sonr)lx[sonr]=rx[sonr]=0,mx[sonr]=v[x];\n            }\n            rev[x]=tag[x]=0;\n        }\n        if(rev[x])\n        {\n            rev[x]^=1;rev[sonl]^=1;rev[sonr]^=1;\n            swap(lx[sonl],rx[sonl]);swap(lx[sonr],rx[sonr]);\n            swap(son[sonl][0],son[sonl][1]);swap(son[sonr][0],son[sonr][1]);\n        }\n    }\n    int inorder(int x)\n    {\n        pushdown(x);\n        if(son[x][0])inorder(son[x][0]);\n        if(v[x]!=inf&&v[x]!=-inf)printf(\"%d \",v[x]);\n        if(son[x][1])inorder(son[x][1]);\n    }\n    void update(int x)\n    {\n        int sonl=son[x][0],sonr=son[x][1];\n        sum[x]=sum[sonl]+sum[sonr]+v[x];\n        size[x]=size[sonl]+size[sonr]+1;\n        mx[x]=max(mx[sonl],mx[sonr]);\n        mx[x]=max(mx[x],rx[sonl]+v[x]+lx[sonr]);\n        lx[x]=max(lx[sonl],sum[sonl]+v[x]+lx[sonr]);\n        rx[x]=max(rx[sonr],sum[sonr]+v[x]+rx[sonl]);\n    }\n\n    void rotate(int x,int &k)\n    {\n        int y=fa[x],z=fa[y],l,r;\n        l=(son[y][1]==x);r=l^1;\n        if(y==k)k=x;\n        else son[z][son[z][1]==y]=x;\n        fa[son[x][r]]=y;fa[y]=x;fa[x]=z;\n        son[y][l]=son[x][r];son[x][r]=y;\n        update(y);update(x);\n    }\n    void splay(int x,int &k)\n    {\n        while(x!=k)\n        {\n            int y=fa[x],z=fa[y];\n            if(y!=k)\n            {\n                if(son[y][0]==x^son[z][0]==y)rotate(x,k);\n                else rotate(y,k);\n            }\n            rotate(x,k);\n        }\n    }\n    int find(int x,int rk)\n    {\n        pushdown(x);\n        int l=son[x][0],r=son[x][1];\n        if(size[l]+1==rk)return x;\n        if(size[l]>=rk)return find(l,rk);\n        return find(r,rk-size[l]-1);\n    }\n    void rec(int x)\n    {\n        if(!x)return;\n        int l=son[x][0],r=son[x][1];\n        rec(l);rec(r);q.push(x);\n        fa[x]=son[x][0]=son[x][1]=0;\n        tag[x]=rev[x]=0;\n    }\n    int split(int k,int tt)\n    {\n        int x=find(root,k),y=find(root,k+tt+1);\n        splay(x,root);splay(y,son[x][1]);\n        return son[y][0];\n    }\n    void modify(int k,int tt,int val)\n    {\n        int x=split(k,tt),y=fa[x];\n        v[x]=val;tag[x]=1;sum[x]=size[x]*val;\n        if(val>=0)lx[x]=rx[x]=mx[x]=sum[x];\n        else lx[x]=rx[x]=0,mx[x]=val;\n        update(y);update(fa[y]);\n    }\n    void rever(int k,int tt)\n    {\n        int x=split(k,tt),y=fa[x];\n        if(!tag[x])\n        {\n            rev[x]^=1;\n            swap(son[x][0],son[x][1]);\n            swap(lx[x],rx[x]);\n            update(y);update(fa[y]);\n        }\n    }\n    void delet(int k,int tt)\n    {\n        int x=split(k,tt),y=fa[x];\n        rec(x);son[y][0]=0;\n        update(y);update(fa[y]);\n    }\n    void build(int l,int r,int s)\n    {\n        if(l>r)return;\n        int mid=(l+r)>>1,now=id[mid],last=id[s];\n        if(l==r)\n        {\n            sum[now]=a[l];size[now]=1;\n            tag[now]=rev[now]=0;\n            if(a[l]>=0)lx[now]=rx[now]=mx[now]=a[l];\n            else lx[now]=rx[now]=0,mx[now]=a[l];\n        }\n        else build(l,mid-1,mid),build(mid+1,r,mid);\n        v[now]=a[mid];fa[now]=last;update(now);\n        son[last][mid>=s]=now;\n       }\n    void insert(int k,int tt)\n    {\n        for(int i=1;i<=tt;i++)a[i]=read();\n        for(int i=1;i<=tt;i++)\n        if(!q.empty())id[i]=q.front(),q.pop();\n        else id[i]=++cnt;\n        build(1,tt,0);int z=id[(1+tt)>>1];\n        int x=find(root,k+1),y=find(root,k+2);\n        splay(x,root);splay(y,son[x][1]);\n        fa[z]=y;son[y][0]=z;\n        update(y);update(x);\n    }\n    int main()\n    {\n    //\tfreopen(\"seq2005.in\",\"r\",stdin);\n    //\tfreopen(\"seq2005.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        mx[0]=a[1]=a[n+2]=-inf;\n        for(int i=2;i<=n+1;i++)a[i]=read();\n        for(int i=1;i<=n+2;i++)id[i]=i;\n        build(1,n+2,0);\n        root=(n+3)>>1;cnt=n+2;\n        int k,tt,val;\n        char op[19];\n        for(int i=1;i<=m;++i)\n        {\n            scanf(\"%s\",op);\n            if(op[0]=='I')k=read(),tt=read(),insert(k,tt);\n            if(op[0]=='D')k=read(),tt=read(),delet(k,tt);\n            if(op[0]=='M'&&op[2]=='X')printf(\"%d\\n\",mx[root]);\n            if(op[0]=='M'&&op[2]=='K')k=read(),tt=read(),val=read(),modify(k,tt,val);\n            if(op[0]=='R')k=read(),tt=read(),rever(k,tt);\n            if(op[0]=='G'){k=read(),tt=read();printf(\"%d\\n\",sum[split(k,tt)]);}\n        }\n    //\t\tinorder(root);\n    }\n\n \n","content":"<h1 id=\"NOI2005-维护数列\"><a href=\"#NOI2005-维护数列\" class=\"headerlink\" title=\"NOI2005 维护数列\"></a>NOI2005 维护数列</h1><h2 id=\"洛谷2042-COGS339\"><a href=\"#洛谷2042-COGS339\" class=\"headerlink\" title=\"洛谷2042 COGS339\"></a><a href=\"https://www.luogu.org/problem/show?pid=2042\" target=\"_blank\" rel=\"external\">洛谷2042</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=339\" target=\"_blank\" rel=\"external\">COGS339</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p> 请写一个程序，要求维护一个数列，支持以下 6 种操作：（请注意，格式栏 中的下划线‘ _ ’表示实际输入文件中的空格）</p>\n<pre><code>操作编号    输入文件中的格式    说明\n\n\n1.  插入    INSERT_posi_tot_c1_c2_..._ctot\n在当前数列的第 posi 个数字后插入 tot个数字：c1, c2, …, ctot；若在数列首插入，则 posi 为 0\n\n2.  删除    DELETE_posi_tot\n从当前数列的第 posi 个数字开始连续删除 tot 个数字\n\n3.  修改    MAKE-SAME_posi_tot_c\n 将当前数列的第 posi 个数字开始的连续 tot 个数字统一修改为 c\n\n4.  翻转    REVERSE_posi_tot\n 取出从当前数列的第 posi 个数字开始的 tot 个数字，翻转后放入原来的位置\n\n5.  求和    GET-SUM_posi_tot\n计算从当前数列开始的第 posi 个数字开始的 tot 个数字的和并输出\n\n6.  求和最大的子列    MAX-SUM\n求出当前数列中和最大的一段子列，并输出最大和 \n</code></pre><h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p> 输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M表示要进行的操作数目。</p>\n<p>第 2 行包含 N 个数字，描述初始时的数列。</p>\n<p>以下 M 行，每行一条命令，格式参见问题描述中的表格。 </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结果，每个答案（数字）占一行。 </p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>9 8\n2 -6 3 5 1 -5 -3 6 3\nGET-SUM 5 4\nMAX-SUM INSERT 8 3 -5 7 2\nDELETE 12 1\nMAKE-SAME 3 3 2\nREVERSE 3 6\nGET-SUM 5 4\nMAX-SUM\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>-1\n10\n1\n10\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>你可以认为在任何时刻，数列中至少有 1 个数。</p>\n<p>输入数据一定是正确的，即指定位置的数在数列中一定存在。</p>\n<p>50%的数据中，任何时刻数列中最多含有 30 000 个数；</p>\n<p>100%的数据中，任何时刻数列中最多含有 500 000 个数。</p>\n<p>100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。</p>\n<p>100%的数据中，M ≤20 000，插入的数字总数不超过 4 000 000 个，输入文件大小不超过 20MBytes。</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立二分搜索树，而不应直接插入，否则会导致时间复杂度过高，同时操作后也要注意更新信息。</p>\n<p>对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。</p>\n<p>对于求和操作，具体实现与线段树相同。</p>\n<p>对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。</p>\n<p>（一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入4e6个元素，但同时也说明队列中最多只有5e5个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用。）</p>\n<hr>\n<h3 id=\"CODE-V1（暴力）\"><a href=\"#CODE-V1（暴力）\" class=\"headerlink\" title=\"CODE V1（暴力）\"></a>CODE V1（暴力）</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nconst int N = 4e6+5;\nconst int inf = 0x7fffffff;\nusing namespace std;\nint tot,root,rev[N],size[N],w[N],fa[N],son[N][2],id[N];\nvoid update(int x)\n{\n    size[x]=size[son[x][0]]+size[son[x][1]]+1;\n}\nvoid pushdown(int x)\n{\n    if(rev[x])\n    {\n        swap(son[x][0],son[x][1]);\n        rev[son[x][0]]^=1;\n        rev[son[x][1]]^=1;\n        rev[x]=0;\n    }\n    return;\n}\nvoid zg(int x)\n{\n    pushdown(fa[x]),pushdown(x);\n    int y=fa[x],z=fa[y],t=(son[y][0]==x);\n    if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n    son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n    son[x][t]=y;fa[y]=x;\n    update(y);update(x);\n}\nvoid splay(int x,int f)\n{\n    while(fa[x]!=f)\n    {\n        int y=fa[x],z=fa[y];\n        if(z!=f)\n        {\n            if(son[z][0]==y^son[y][0]==x) zg(x);\n            else zg(y);\n        } \n        zg(x);    \n    }\n    if(!f) root=x;\n}\nvoid insert(int &amp;x,int v,int f)\n{\n    if(!x)\n    {\n        x=++tot;\n        son[x][0]=son[x][1]=0;\n        size[x]=1;\n        w[x]=v;fa[x]=f;\n        splay(x,0);\n        return;\n    }\n    insert(son[x][v&gt;w[x]],v,x);\n    update(x);\n}\nint get(int v)\n{\n    int x=root;\n    while(x&amp;&amp;v!=w[x]) x=son[x][v&gt;w[x]];\n    return x;\n}\nint find(int k,int rank)\n{\n    pushdown(k);\n    int l=son[k][0],r=son[k][1];\n    if(size[l]+1==rank)return k;\n    else if(size[l]&gt;=rank)return find(l,rank);\n    else return find(r,rank-size[l]-1);\n}\nint a[N];\nchar op[19];\nint sum1,ans1,max1;\nint inorder(int x)\n{\n    pushdown(x);\n    if(son[x][0])inorder(son[x][0]);\n    if(w[x]!=inf&amp;&amp;w[x]!=-inf)printf(&quot;%d &quot;,a[w[x]]);\n    if(son[x][1])inorder(son[x][1]);\n}\nint inordermax(int x)\n{\n    pushdown(x);\n    if(son[x][0])inordermax(son[x][0]);\n    if(w[x]!=inf&amp;&amp;w[x]!=-inf)\n    {\n        max1=max(max1,a[w[x]]);\n        sum1+=a[w[x]]*num[x];\n        if(sum1&gt;0)ans1=max(ans1,sum1);\n        else    sum1=0;\n    }\n    if(son[x][1])inordermax(son[x][1]);\n}\n\nint main()\n{\n//    freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout);\n    int n,m,tmp;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    insert(root,-inf,0);insert(root,inf,0);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i);\n    for(int i=1;i&lt;=n;++i)insert(root,i,0);\n    tmp=n;\n    for(int i=1,pos,tt,x;i&lt;=m;++i)\n    {\n        scanf(&quot;%s&quot;,op);\n        if(op[0]==&#39;I&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int now=find(root,pos+1),ne=find(root,pos+2);\n            update(now),update(ne);\n            splay(now,0);splay(ne,root);\n            for(int i=1;i&lt;=tt;++i)scanf(&quot;%d&quot;,&amp;a[++tmp]),insert(son[ne][0],tmp,ne);\n            update(root),update(son[root][1]);\n        }\n        if(op[0]==&#39;D&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int now=find(root,pos),ne=find(root,pos+tt+1);\n            splay(now,0);splay(ne,root);\n            fa[son[ne][0]]=0;\n            son[ne][0]=0;\n            update(ne);update(now);\n        }\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;)\n        {\n            scanf(&quot;%d%d%d&quot;,&amp;pos,&amp;tt,&amp;x);\n            for(int t=pos+1;t&lt;=pos+tt;++t)\n            a[w[find(root,t)]]=x;\n        }\n        if(op[0]==&#39;R&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int now=find(root,pos),ne=find(root,pos+tt+1);\n            update(now),update(ne);\n            splay(now,0);splay(ne,root);\n            int s=son[ne][0];\n            rev[s]^=1;\n        }\n        if(op[0]==&#39;G&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int sum=0;\n            for(int t=1;t&lt;=tt;++t)\n            sum+=a[find(root,pos+t)-2];\n            printf(&quot;%d\\n&quot;,sum);\n        }\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;)\n        {\n            sum1=ans1=0;max1=-0x7fffffff;\n            inordermax(root);\n            printf(&quot;%d\\n&quot;,ans1==0?max1:ans1);\n        }\n    }\n    //    inorder(root);\n}\n</code></pre><hr>\n<h3 id=\"CODE-V2\"><a href=\"#CODE-V2\" class=\"headerlink\" title=\"CODE V2\"></a>CODE V2</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int inf = 1e9;\nconst int N = 1e6+1;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n    return x*f;\n}\nint n,m,root,cnt;\nint sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][2];;\nbool tag[N],rev[N];\nqueue&lt;int&gt;q;\nvoid pushdown(int x)\n{\n    int sonl=son[x][0],sonr=son[x][1];\n    if(tag[x])\n    {\n\n        if(sonl)tag[sonl]=true,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl];\n        if(sonr)tag[sonr]=true,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr];\n        if(v[x]&gt;=0)\n        {\n            if(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl];\n            if(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr];\n        }\n        else \n        {\n            if(sonl)lx[sonl]=rx[sonl]=0,mx[sonl]=v[x];\n            if(sonr)lx[sonr]=rx[sonr]=0,mx[sonr]=v[x];\n        }\n        rev[x]=tag[x]=0;\n    }\n    if(rev[x])\n    {\n        rev[x]^=1;rev[sonl]^=1;rev[sonr]^=1;\n        swap(lx[sonl],rx[sonl]);swap(lx[sonr],rx[sonr]);\n        swap(son[sonl][0],son[sonl][1]);swap(son[sonr][0],son[sonr][1]);\n    }\n}\nint inorder(int x)\n{\n    pushdown(x);\n    if(son[x][0])inorder(son[x][0]);\n    if(v[x]!=inf&amp;&amp;v[x]!=-inf)printf(&quot;%d &quot;,v[x]);\n    if(son[x][1])inorder(son[x][1]);\n}\nvoid update(int x)\n{\n    int sonl=son[x][0],sonr=son[x][1];\n    sum[x]=sum[sonl]+sum[sonr]+v[x];\n    size[x]=size[sonl]+size[sonr]+1;\n    mx[x]=max(mx[sonl],mx[sonr]);\n    mx[x]=max(mx[x],rx[sonl]+v[x]+lx[sonr]);\n    lx[x]=max(lx[sonl],sum[sonl]+v[x]+lx[sonr]);\n    rx[x]=max(rx[sonr],sum[sonr]+v[x]+rx[sonl]);\n}\n\nvoid rotate(int x,int &amp;k)\n{\n    int y=fa[x],z=fa[y],l,r;\n    l=(son[y][1]==x);r=l^1;\n    if(y==k)k=x;\n    else son[z][son[z][1]==y]=x;\n    fa[son[x][r]]=y;fa[y]=x;fa[x]=z;\n    son[y][l]=son[x][r];son[x][r]=y;\n    update(y);update(x);\n}\nvoid splay(int x,int &amp;k)\n{\n    while(x!=k)\n    {\n        int y=fa[x],z=fa[y];\n        if(y!=k)\n        {\n            if(son[y][0]==x^son[z][0]==y)rotate(x,k);\n            else rotate(y,k);\n        }\n        rotate(x,k);\n    }\n}\nint find(int x,int rk)\n{\n    pushdown(x);\n    int l=son[x][0],r=son[x][1];\n    if(size[l]+1==rk)return x;\n    if(size[l]&gt;=rk)return find(l,rk);\n    return find(r,rk-size[l]-1);\n}\nvoid rec(int x)\n{\n    if(!x)return;\n    int l=son[x][0],r=son[x][1];\n    rec(l);rec(r);q.push(x);\n    fa[x]=son[x][0]=son[x][1]=0;\n    tag[x]=rev[x]=0;\n}\nint split(int k,int tt)\n{\n    int x=find(root,k),y=find(root,k+tt+1);\n    splay(x,root);splay(y,son[x][1]);\n    return son[y][0];\n}\nvoid modify(int k,int tt,int val)\n{\n    int x=split(k,tt),y=fa[x];\n    v[x]=val;tag[x]=1;sum[x]=size[x]*val;\n    if(val&gt;=0)lx[x]=rx[x]=mx[x]=sum[x];\n    else lx[x]=rx[x]=0,mx[x]=val;\n    update(y);update(fa[y]);\n}\nvoid rever(int k,int tt)\n{\n    int x=split(k,tt),y=fa[x];\n    if(!tag[x])\n    {\n        rev[x]^=1;\n        swap(son[x][0],son[x][1]);\n        swap(lx[x],rx[x]);\n        update(y);update(fa[y]);\n    }\n}\nvoid delet(int k,int tt)\n{\n    int x=split(k,tt),y=fa[x];\n    rec(x);son[y][0]=0;\n    update(y);update(fa[y]);\n}\nvoid build(int l,int r,int s)\n{\n    if(l&gt;r)return;\n    int mid=(l+r)&gt;&gt;1,now=id[mid],last=id[s];\n    if(l==r)\n    {\n        sum[now]=a[l];size[now]=1;\n        tag[now]=rev[now]=0;\n        if(a[l]&gt;=0)lx[now]=rx[now]=mx[now]=a[l];\n        else lx[now]=rx[now]=0,mx[now]=a[l];\n    }\n    else build(l,mid-1,mid),build(mid+1,r,mid);\n    v[now]=a[mid];fa[now]=last;update(now);\n    son[last][mid&gt;=s]=now;\n   }\nvoid insert(int k,int tt)\n{\n    for(int i=1;i&lt;=tt;i++)a[i]=read();\n    for(int i=1;i&lt;=tt;i++)\n    if(!q.empty())id[i]=q.front(),q.pop();\n    else id[i]=++cnt;\n    build(1,tt,0);int z=id[(1+tt)&gt;&gt;1];\n    int x=find(root,k+1),y=find(root,k+2);\n    splay(x,root);splay(y,son[x][1]);\n    fa[z]=y;son[y][0]=z;\n    update(y);update(x);\n}\nint main()\n{\n//    freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    mx[0]=a[1]=a[n+2]=-inf;\n    for(int i=2;i&lt;=n+1;i++)a[i]=read();\n    for(int i=1;i&lt;=n+2;i++)id[i]=i;\n    build(1,n+2,0);\n    root=(n+3)&gt;&gt;1;cnt=n+2;\n    int k,tt,val;\n    char op[19];\n    for(int i=1;i&lt;=m;++i)\n    {\n        scanf(&quot;%s&quot;,op);\n        if(op[0]==&#39;I&#39;)k=read(),tt=read(),insert(k,tt);\n        if(op[0]==&#39;D&#39;)k=read(),tt=read(),delet(k,tt);\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;)printf(&quot;%d\\n&quot;,mx[root]);\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;)k=read(),tt=read(),val=read(),modify(k,tt,val);\n        if(op[0]==&#39;R&#39;)k=read(),tt=read(),rever(k,tt);\n        if(op[0]==&#39;G&#39;){k=read(),tt=read();printf(&quot;%d\\n&quot;,sum[split(k,tt)]);}\n    }\n//        inorder(root);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/21/维护队列/","excerpt":"","categories":[{"name":"平衡树","slug":"平衡树","permalink":"https://prostkhala.github.io/categories/平衡树/"},{"name":"SPLAY","slug":"平衡树/SPLAY","permalink":"https://prostkhala.github.io/categories/平衡树/SPLAY/"}],"tags":[{"name":"SPLAY","slug":"SPLAY","permalink":"https://prostkhala.github.io/tags/SPLAY/"}]},{"title":"普通平衡树","date":"2017-03-19T12:21:17.000Z","path":"2017/03/19/普通平衡树/","text":"普通平衡树BZOJ3224 COGS1829 题目描述您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 插入x数 删除x数(若有多个相同的数，因只删除一个) 查询x数的排名(若有多个相同的数，因输出最小的排名) 查询排名为x的数 求x的前驱(前驱定义为小于x，且最大的数) 求x的后继(后继定义为大于x，且最小的数)输入输出格式输入格式：第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号$(1&lt;=opt&lt;=6)$ 输出格式：对于操作3,4,5,6每行输出一个数，表示对应答案 输入输出样例输入样例：10 1 106465 4 1 1 317721 1 460929 1 644985 1 84185 1 89851 6 81968 1 492737 5 493598 输出样例：106465 84185 492737 数据范围1.n的数据范围：$n&lt;=100000$ 2.每个数的数据范围：$[-1e7,1e7]$（BZOJ3224:$[-2e9,2e9]$） 题解各种平衡树的模板题（然而只会SPLAY） CODE#include #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; const int inf = 0x7fffffff; const int N = 1e5+1; struct splay{int data,ls,rs,fa,size;}a[N]; int q,root=0,tot=0; void pushup(int x){a[x].size=a[a[x].ls].size+a[a[x].rs].size+1;} void zig(int x) { int y=a[x].fa; int z=a[y].fa; a[y].fa=x;a[x].fa=z; a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y; if(y==a[z].ls) a[z].ls=x; else a[z].rs=x; pushup(y); } void zag(int x) { int y=a[x].fa; int z=a[y].fa; a[y].fa=x,a[x].fa=z; a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y; if(y==a[z].ls) a[z].ls=x; else a[z].rs=x; pushup(y); } void splay(int x,int s) { while (a[x].fa!=s) { int y=a[x].fa; int z=a[y].fa; if(z==s) { if(x==a[y].ls) zig(x); else zag(x); break; } if(y==a[z].ls) { if(x==a[y].ls) zig(y),zig(x); else zag(x),zig(x); } else { if(x==a[y].rs) zag(y),zag(x); else zig(x),zag(x); } } pushup(x); if (s==0) root=x; } int Search(int w) { int p,x=root; while (x) { p=x; if (a[x].data&gt;w) x=a[x].ls; else x=a[x].rs; } return p; } void newnode(int &amp;x,int fa,int key) { x=++tot; a[x].ls=a[x].rs=0; a[x].fa=fa; a[x].data=key; } void insert(int w) { if (root==0) { newnode(root,0,w); return; } int i=Search(w); if (w&lt;a[i].data) newnode(a[i].ls,i,w); else newnode(a[i].rs,i,w); splay(tot,0); } int get(int w) { int x=root,ans=tot+1; while(x) { if(a[x].data&gt;w){x=a[x].ls;continue;} if(a[x].data&lt;w){x=a[x].rs;continue;} if(a[x].data==w) { ans=x; x=a[x].ls; } } if(ans==tot+1) return -1; return ans; } int getmax(int x){while(a[x].rs)x=a[x].rs;return x;} int getmin(int x){while (a[x].ls)x=a[x].ls;return x;} int getpre1(int x){return getmax(a[root].ls);} int getne1(int x){return getmin(a[root].rs);} void delet(int w) { int x=get(w); splay(x,0); int pp=getpre1(x),nn=getne1(x); splay(pp,0); splay(nn,root); int y=a[x].fa; a[x].fa=0; if(x==a[y].ls) a[y].ls=0; else a[x].ls=0; pushup(y);pushup(root); } int find(int w) { int x=get(w); splay(x,0); return a[a[x].ls].size; } int findkth(int x,int k) { int s=a[a[x].ls].size; if (k==s+1) return a[x].data; if (s&gt;=k) return findkth(a[x].ls,k); else return findkth(a[x].rs,k-s-1); } int getpre(int w) { int y=get(w); insert(w); if(y!=-1)splay(y,0); int ans=getmax(a[root].ls); delet(w); return a[ans].data; } int getne(int w) { insert(w); int ans=getmin(a[root].rs); delet(w); return a[ans].data; } int main() { root=tot=0; insert(-inf);insert(inf); scanf(&quot;%d&quot;,&amp;q); while(q--) { int x,k; scanf(&quot;%d%d&quot;,&amp;x,&amp;k); if(x==1) insert(k); else if(x==2) delet(k); else if(x==3) printf(&quot;%d\\n&quot;,find(k)); else if(x==4) printf(&quot;%d\\n&quot;,findkth(root,k+1)); else if(x==5) printf(&quot;%d\\n&quot;,getpre(k)); else if(x==6) printf(&quot;%d\\n&quot;,getne(k)); } return 0; } CODE V2 #include&lt;cstdio&gt; #include&lt;iostream&gt; const int N=1e5+5; int tot,root,size[N],num[N],key[N],fa[N],son[N][2]; void pushup(int x) { size[x]=size[son[x][0]]+size[son[x][1]]+num[x]; } void zg(int x) { //push_down(fa[x]);push_down(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(z) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; pushup(y);pushup(x); } void splay(int x,int f) { while(fa[x]!=f) { int y=fa[x],z=fa[y]; if(z!=f) { if(son[z][0]==y^son[y][0]==x) zg(x); else zg(y); } zg(x); } if(!f) root=x; } void insert(int &amp;x,int v,int f) { if(!x) { x=++tot; son[x][0]=son[x][1]=0; size[x]=num[x]=1; key[x]=v;fa[x]=f; splay(x,0); return; } if(v==key[x]) { num[x]++;size[x]++; splay(x,0); return; } insert(son[x][v&gt;key[x]],v,x); pushup(x); } int get(int v) { int x=root; while(x&amp;&amp;v!=key[x]) x=son[x][v&gt;key[x]]; return x; } void delet(int x) { x=get(x);if(!x) return; splay(x,0); if(num[x]&gt;1) {num[x]--;size[x]--;return;} if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1]; else { int y=son[x][1];while(son[y][0]) y=son[y][0]; splay(y,x); son[y][0]=son[x][0];fa[son[y][0]]=y; root=y; } fa[root]=0; pushup(root); } int getrank(int v) { insert(root,v,0); int ans=size[son[root][0]]+1; delet(v); return ans; } int kth(int x) { int y=root; while(x&lt;=size[son[y][0]]||x&gt;size[son[y][0]]+num[y]) { if(x&lt;=size[son[y][0]]) y=son[y][0]; else x-=size[son[y][0]]+num[y],y=son[y][1]; } return key[y]; } int pre(int v) { insert(root,v,0); int x=son[root][0];while(son[x][1]) x=son[x][1]; delet(v); return key[x]; } int ne(int v) { insert(root,v,0); int x=son[root][1];while(son[x][0]) x=son[x][0]; delet(v); return key[x]; } int main() { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1,x,y;i&lt;=n;++i) { if(x==1) insert(root,y,0); if(x==2) delet(y); if(x==3) printf(&quot;%d\\n&quot;,getrank(y)); if(x==4) printf(&quot;%d\\n&quot;,kth(y)); if(x==5) printf(&quot;%d\\n&quot;,pre(y)); if(x==6) printf(&quot;%d\\n&quot;,ne(y)); } }","raw":"title: 普通平衡树\ndate: 2017-03-19 20:21:17\ncategories:\n  - 平衡树\n  - SPLAY\ntags:\n  - SPLAY\n  - TREAP\n  - 模板\n---\n\n# 普通平衡树\n\n## [BZOJ3224](http://www.lydsy.com/JudgeOnline/problem.php?id=3224) [COGS1829](http://cogs.pro/cogs/problem/problem.php?pid=1829)\n\n---\n## 题目描述\n您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：\n1. 插入x数\n2. 删除x数(若有多个相同的数，因只删除一个)\n3. 查询x数的排名(若有多个相同的数，因输出最小的排名)\n4. 查询排名为x的数\n5. 求x的前驱(前驱定义为小于x，且最大的数)\n6. 求x的后继(后继定义为大于x，且最小的数)\n### 输入输出格式\n#### 输入格式：\n第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号$(1<=opt<=6)$\n\n#### 输出格式：\n对于操作3,4,5,6每行输出一个数，表示对应答案\n\n\n### 输入输出样例\n#### 输入样例：\n    10\n    1 106465\n    4 1\n    1 317721\n    1 460929\n    1 644985\n    1 84185\n    1 89851\n    6 81968\n    1 492737\n    5 493598\n    \n\n#### 输出样例：\n    106465\n    84185\n    492737\n    \n\n### 数据范围\n\n1.n的数据范围：$n<=100000$\n\n2.每个数的数据范围：$[-1e7,1e7]$（BZOJ3224:$[-2e9,2e9]$）\n\n---\n\n## 题解\n各种平衡树的模板题（然而只会SPLAY）\n\n---\n### CODE\n#include <iostream>\n\t#include<cstring>\n\t#include<algorithm>\n\t#include<cstdio>\n\tusing namespace std;\n\tconst int inf = 0x7fffffff;\n\tconst int N = 1e5+1;\n\tstruct splay{int data,ls,rs,fa,size;}a[N];  \n\tint q,root=0,tot=0;\n\tvoid pushup(int x){a[x].size=a[a[x].ls].size+a[a[x].rs].size+1;}  \n\tvoid zig(int x)  \n\t{  \n\t    int y=a[x].fa; \n\t    int z=a[y].fa; \n\t    a[y].fa=x;a[x].fa=z;  \n\t    a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y;  \n\t    if(y==a[z].ls)\ta[z].ls=x;\n\t    else \t\t\ta[z].rs=x;\n\t    pushup(y);\n\t}\n\tvoid zag(int x)\n\t{\n\t    int y=a[x].fa;  \n\t    int z=a[y].fa;\n\t    a[y].fa=x,a[x].fa=z;\n\t    a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y;\n\t    if(y==a[z].ls) \ta[z].ls=x;\n\t    else \t\t\ta[z].rs=x;\n\t    pushup(y);\n\t}\n\tvoid splay(int x,int s)  \n\t{  \n\t    while (a[x].fa!=s)  \n\t    {  \n\t        int y=a[x].fa;  \n\t        int z=a[y].fa;  \n\t        if(z==s)  \n\t        {\n\t            if(x==a[y].ls) zig(x);  \n\t            else \t\t  zag(x);  \n\t            break;  \n\t        }  \n\t        if(y==a[z].ls)  \n\t        {  \n\t            if(x==a[y].ls) zig(y),zig(x);  \n\t            else \t\t  zag(x),zig(x);  \n\t        }  \n\t        else \n\t        {  \n\t            if(x==a[y].rs) zag(y),zag(x);  \n\t            else \t\t  zig(x),zag(x);  \n\t        }  \n\t    }\n\t    pushup(x);  \n\t    if (s==0) root=x;  \n\t}  \n\tint Search(int w)  \n\t{  \n\t    int p,x=root;  \n\t    while (x)  \n\t    {  \n\t        p=x;  \n\t        if (a[x].data>w) x=a[x].ls;  \n\t        else x=a[x].rs;  \n\t    }  \n\t    return p;  \n\t}  \n\tvoid newnode(int &x,int fa,int key)  \n\t{  \n\t    x=++tot;  \n\t    a[x].ls=a[x].rs=0;  \n\t    a[x].fa=fa;  \n\t    a[x].data=key;  \n\t}  \n\tvoid insert(int w)  \n\t{  \n\t    if (root==0)  \n\t    {  \n\t        newnode(root,0,w);  \n\t        return;  \n\t    }  \n\t    int i=Search(w);  \n\t    if (w<a[i].data) newnode(a[i].ls,i,w);     \n\t    else newnode(a[i].rs,i,w);\n\t    splay(tot,0);  \n\t}  \n\tint get(int w)\n\t{\n\t    int x=root,ans=tot+1;  \n\t    while(x)  \n\t    {  \n\t        if(a[x].data>w){x=a[x].ls;continue;}  \n\t        if(a[x].data<w){x=a[x].rs;continue;}  \n\t        if(a[x].data==w)  \n\t        {  \n\t            ans=x;\n\t            x=a[x].ls; \n\t        }  \n\t    }  \n\t    if(ans==tot+1) return -1;\n\t    return ans;  \n\t}\n\tint getmax(int x){while(a[x].rs)x=a[x].rs;return x;}  \n\tint getmin(int x){while (a[x].ls)x=a[x].ls;return x;}  \n\tint getpre1(int x){return getmax(a[root].ls);}  \n\tint getne1(int x){return getmin(a[root].rs);}\n\tvoid delet(int w)  \n\t{  \n\t    int x=get(w);  \n\t    splay(x,0);  \n\t    int pp=getpre1(x),nn=getne1(x);  \n\t    splay(pp,0);  \n\t    splay(nn,root);  \n\t    int y=a[x].fa;  \n\t    a[x].fa=0;  \n\t    if(x==a[y].ls) a[y].ls=0;\n\t    else \t\t  a[x].ls=0;\n\t    pushup(y);pushup(root);  \n\t}  \n\tint find(int w)  \n\t{  \n\t    int x=get(w);  \n\t    splay(x,0);  \n\t    return a[a[x].ls].size;  \n\t}  \n\tint findkth(int x,int k)  \n\t{  \n\t    int s=a[a[x].ls].size;  \n\t    if (k==s+1) return a[x].data;  \n\t    if (s>=k) return findkth(a[x].ls,k);  \n\t    else return findkth(a[x].rs,k-s-1);  \n\t}  \n\tint getpre(int w) \n\t{  \n\t    int y=get(w);  \n\t    insert(w);  \n\t    if(y!=-1)splay(y,0);  \n\t    int ans=getmax(a[root].ls);  \n\t    delet(w);  \n\t    return a[ans].data;  \n\t}  \n\tint getne(int w)  \n\t{  \n\t    insert(w);\n\t    int ans=getmin(a[root].rs);\n\t    delet(w);\n\t    return a[ans].data;\n\t}\n\tint main()\n\t{\n\t    root=tot=0;\n\t    insert(-inf);insert(inf);\n\t    scanf(\"%d\",&q);\n\t    while(q--)\n\t    {\n\t        int x,k;\n\t        scanf(\"%d%d\",&x,&k);\n\t        if(x==1) \t  insert(k);\n\t        else if(x==2) delet(k);\n\t        else if(x==3) printf(\"%d\\n\",find(k));\n\t        else if(x==4) printf(\"%d\\n\",findkth(root,k+1));\n\t        else if(x==5) printf(\"%d\\n\",getpre(k));\n\t        else if(x==6) printf(\"%d\\n\",getne(k));\n\t    }\n\t    return 0;\n\t}    \n    \n    \n ---\n ### CODE V2\n \n     #include<cstdio>\n     #include<iostream>\n    const int N=1e5+5;\n    int tot,root,size[N],num[N],key[N],fa[N],son[N][2];\n    void pushup(int x)\n    {\n        size[x]=size[son[x][0]]+size[son[x][1]]+num[x];\n    }\n    void zg(int x)\n    {\n        //push_down(fa[x]);push_down(x); \n        int y=fa[x],z=fa[y],t=(son[y][0]==x);\n        if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n        son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n        son[x][t]=y;fa[y]=x;\n        pushup(y);pushup(x);\n    }\n    void splay(int x,int f)\n    {\n        while(fa[x]!=f)\n        {\n            int y=fa[x],z=fa[y];\n            if(z!=f)\n            {\n                if(son[z][0]==y^son[y][0]==x) zg(x);\n                else zg(y);\n            } \n            zg(x);\t\n        }\n        if(!f) root=x;\n    }\n    void insert(int &x,int v,int f)\n    {\n        if(!x)\n        {\n            x=++tot;\n            son[x][0]=son[x][1]=0;\n            size[x]=num[x]=1;\n            key[x]=v;fa[x]=f;\n            splay(x,0);\n            return;\n        }\n        if(v==key[x])\n        {\n            num[x]++;size[x]++;\n            splay(x,0);\n            return;\n        }\n        insert(son[x][v>key[x]],v,x);\n        pushup(x);\n    }\n    int get(int v)\n    {\n        int x=root;\n        while(x&&v!=key[x]) x=son[x][v>key[x]];\n        return x;\n    }\n    void delet(int x)\n    {\n        x=get(x);if(!x) return;\n        splay(x,0);\n        if(num[x]>1) {num[x]--;size[x]--;return;}\n        if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1];\n        else\n        {\n            int y=son[x][1];while(son[y][0]) y=son[y][0];\n            splay(y,x);\n            son[y][0]=son[x][0];fa[son[y][0]]=y;\n            root=y;\n        }\n        fa[root]=0;\n        pushup(root);\n    }\n    int getrank(int v)\n    {\n        insert(root,v,0);\n        int ans=size[son[root][0]]+1;\n        delet(v);\n        return ans;\n    }\n    int kth(int x)\n    {\n        int y=root;\n        while(x<=size[son[y][0]]||x>size[son[y][0]]+num[y])\n        {\n            if(x<=size[son[y][0]]) y=son[y][0];\n            else x-=size[son[y][0]]+num[y],y=son[y][1];\n        }\n        return key[y];\n    }\n    int pre(int v)\n    {\n        insert(root,v,0);\n        int x=son[root][0];while(son[x][1]) x=son[x][1];\n        delet(v);\n        return key[x];\n    }\n    int ne(int v)\n    {\n        insert(root,v,0);\n        int x=son[root][1];while(son[x][0]) x=son[x][0];\n        delet(v);\n        return key[x];\n    }\n    int main()\n    {\n        int n;\n        scanf(\"%d\",&n);\n        for(int i=1,x,y;i<=n;++i)\n        {\n            if(x==1) \t\tinsert(root,y,0);\n            if(x==2) \t\tdelet(y);\n            if(x==3) \t\tprintf(\"%d\\n\",getrank(y));\n            if(x==4) \t\tprintf(\"%d\\n\",kth(y));\n            if(x==5) \t\tprintf(\"%d\\n\",pre(y));\n            if(x==6)\t\tprintf(\"%d\\n\",ne(y));\n        }\n    }","content":"<h1 id=\"普通平衡树\"><a href=\"#普通平衡树\" class=\"headerlink\" title=\"普通平衡树\"></a>普通平衡树</h1><h2 id=\"BZOJ3224-COGS1829\"><a href=\"#BZOJ3224-COGS1829\" class=\"headerlink\" title=\"BZOJ3224 COGS1829\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=3224\" target=\"_blank\" rel=\"external\">BZOJ3224</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1829\" target=\"_blank\" rel=\"external\">COGS1829</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：</p>\n<ol>\n<li>插入x数</li>\n<li>删除x数(若有多个相同的数，因只删除一个)</li>\n<li>查询x数的排名(若有多个相同的数，因输出最小的排名)</li>\n<li>查询排名为x的数</li>\n<li>求x的前驱(前驱定义为小于x，且最大的数)</li>\n<li>求x的后继(后继定义为大于x，且最小的数)<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4>第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号$(1&lt;=opt&lt;=6)$</li>\n</ol>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于操作3,4,5,6每行输出一个数，表示对应答案</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>10\n1 106465\n4 1\n1 317721\n1 460929\n1 644985\n1 84185\n1 89851\n6 81968\n1 492737\n5 493598\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>106465\n84185\n492737\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>1.n的数据范围：$n&lt;=100000$</p>\n<p>2.每个数的数据范围：$[-1e7,1e7]$（BZOJ3224:$[-2e9,2e9]$）</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>各种平衡树的模板题（然而只会SPLAY）</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><p>#include <iostream></iostream></p>\n<pre><code>#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nconst int inf = 0x7fffffff;\nconst int N = 1e5+1;\nstruct splay{int data,ls,rs,fa,size;}a[N];  \nint q,root=0,tot=0;\nvoid pushup(int x){a[x].size=a[a[x].ls].size+a[a[x].rs].size+1;}  \nvoid zig(int x)  \n{  \n    int y=a[x].fa; \n    int z=a[y].fa; \n    a[y].fa=x;a[x].fa=z;  \n    a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y;  \n    if(y==a[z].ls)    a[z].ls=x;\n    else             a[z].rs=x;\n    pushup(y);\n}\nvoid zag(int x)\n{\n    int y=a[x].fa;  \n    int z=a[y].fa;\n    a[y].fa=x,a[x].fa=z;\n    a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y;\n    if(y==a[z].ls)     a[z].ls=x;\n    else             a[z].rs=x;\n    pushup(y);\n}\nvoid splay(int x,int s)  \n{  \n    while (a[x].fa!=s)  \n    {  \n        int y=a[x].fa;  \n        int z=a[y].fa;  \n        if(z==s)  \n        {\n            if(x==a[y].ls) zig(x);  \n            else           zag(x);  \n            break;  \n        }  \n        if(y==a[z].ls)  \n        {  \n            if(x==a[y].ls) zig(y),zig(x);  \n            else           zag(x),zig(x);  \n        }  \n        else \n        {  \n            if(x==a[y].rs) zag(y),zag(x);  \n            else           zig(x),zag(x);  \n        }  \n    }\n    pushup(x);  \n    if (s==0) root=x;  \n}  \nint Search(int w)  \n{  \n    int p,x=root;  \n    while (x)  \n    {  \n        p=x;  \n        if (a[x].data&gt;w) x=a[x].ls;  \n        else x=a[x].rs;  \n    }  \n    return p;  \n}  \nvoid newnode(int &amp;x,int fa,int key)  \n{  \n    x=++tot;  \n    a[x].ls=a[x].rs=0;  \n    a[x].fa=fa;  \n    a[x].data=key;  \n}  \nvoid insert(int w)  \n{  \n    if (root==0)  \n    {  \n        newnode(root,0,w);  \n        return;  \n    }  \n    int i=Search(w);  \n    if (w&lt;a[i].data) newnode(a[i].ls,i,w);     \n    else newnode(a[i].rs,i,w);\n    splay(tot,0);  \n}  \nint get(int w)\n{\n    int x=root,ans=tot+1;  \n    while(x)  \n    {  \n        if(a[x].data&gt;w){x=a[x].ls;continue;}  \n        if(a[x].data&lt;w){x=a[x].rs;continue;}  \n        if(a[x].data==w)  \n        {  \n            ans=x;\n            x=a[x].ls; \n        }  \n    }  \n    if(ans==tot+1) return -1;\n    return ans;  \n}\nint getmax(int x){while(a[x].rs)x=a[x].rs;return x;}  \nint getmin(int x){while (a[x].ls)x=a[x].ls;return x;}  \nint getpre1(int x){return getmax(a[root].ls);}  \nint getne1(int x){return getmin(a[root].rs);}\nvoid delet(int w)  \n{  \n    int x=get(w);  \n    splay(x,0);  \n    int pp=getpre1(x),nn=getne1(x);  \n    splay(pp,0);  \n    splay(nn,root);  \n    int y=a[x].fa;  \n    a[x].fa=0;  \n    if(x==a[y].ls) a[y].ls=0;\n    else           a[x].ls=0;\n    pushup(y);pushup(root);  \n}  \nint find(int w)  \n{  \n    int x=get(w);  \n    splay(x,0);  \n    return a[a[x].ls].size;  \n}  \nint findkth(int x,int k)  \n{  \n    int s=a[a[x].ls].size;  \n    if (k==s+1) return a[x].data;  \n    if (s&gt;=k) return findkth(a[x].ls,k);  \n    else return findkth(a[x].rs,k-s-1);  \n}  \nint getpre(int w) \n{  \n    int y=get(w);  \n    insert(w);  \n    if(y!=-1)splay(y,0);  \n    int ans=getmax(a[root].ls);  \n    delet(w);  \n    return a[ans].data;  \n}  \nint getne(int w)  \n{  \n    insert(w);\n    int ans=getmin(a[root].rs);\n    delet(w);\n    return a[ans].data;\n}\nint main()\n{\n    root=tot=0;\n    insert(-inf);insert(inf);\n    scanf(&quot;%d&quot;,&amp;q);\n    while(q--)\n    {\n        int x,k;\n        scanf(&quot;%d%d&quot;,&amp;x,&amp;k);\n        if(x==1)       insert(k);\n        else if(x==2) delet(k);\n        else if(x==3) printf(&quot;%d\\n&quot;,find(k));\n        else if(x==4) printf(&quot;%d\\n&quot;,findkth(root,k+1));\n        else if(x==5) printf(&quot;%d\\n&quot;,getpre(k));\n        else if(x==6) printf(&quot;%d\\n&quot;,getne(k));\n    }\n    return 0;\n}    \n</code></pre><hr>\n<h3 id=\"CODE-V2\"><a href=\"#CODE-V2\" class=\"headerlink\" title=\"CODE V2\"></a>CODE V2</h3><pre><code> #include&lt;cstdio&gt;\n #include&lt;iostream&gt;\nconst int N=1e5+5;\nint tot,root,size[N],num[N],key[N],fa[N],son[N][2];\nvoid pushup(int x)\n{\n    size[x]=size[son[x][0]]+size[son[x][1]]+num[x];\n}\nvoid zg(int x)\n{\n    //push_down(fa[x]);push_down(x); \n    int y=fa[x],z=fa[y],t=(son[y][0]==x);\n    if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n    son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n    son[x][t]=y;fa[y]=x;\n    pushup(y);pushup(x);\n}\nvoid splay(int x,int f)\n{\n    while(fa[x]!=f)\n    {\n        int y=fa[x],z=fa[y];\n        if(z!=f)\n        {\n            if(son[z][0]==y^son[y][0]==x) zg(x);\n            else zg(y);\n        } \n        zg(x);    \n    }\n    if(!f) root=x;\n}\nvoid insert(int &amp;x,int v,int f)\n{\n    if(!x)\n    {\n        x=++tot;\n        son[x][0]=son[x][1]=0;\n        size[x]=num[x]=1;\n        key[x]=v;fa[x]=f;\n        splay(x,0);\n        return;\n    }\n    if(v==key[x])\n    {\n        num[x]++;size[x]++;\n        splay(x,0);\n        return;\n    }\n    insert(son[x][v&gt;key[x]],v,x);\n    pushup(x);\n}\nint get(int v)\n{\n    int x=root;\n    while(x&amp;&amp;v!=key[x]) x=son[x][v&gt;key[x]];\n    return x;\n}\nvoid delet(int x)\n{\n    x=get(x);if(!x) return;\n    splay(x,0);\n    if(num[x]&gt;1) {num[x]--;size[x]--;return;}\n    if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1];\n    else\n    {\n        int y=son[x][1];while(son[y][0]) y=son[y][0];\n        splay(y,x);\n        son[y][0]=son[x][0];fa[son[y][0]]=y;\n        root=y;\n    }\n    fa[root]=0;\n    pushup(root);\n}\nint getrank(int v)\n{\n    insert(root,v,0);\n    int ans=size[son[root][0]]+1;\n    delet(v);\n    return ans;\n}\nint kth(int x)\n{\n    int y=root;\n    while(x&lt;=size[son[y][0]]||x&gt;size[son[y][0]]+num[y])\n    {\n        if(x&lt;=size[son[y][0]]) y=son[y][0];\n        else x-=size[son[y][0]]+num[y],y=son[y][1];\n    }\n    return key[y];\n}\nint pre(int v)\n{\n    insert(root,v,0);\n    int x=son[root][0];while(son[x][1]) x=son[x][1];\n    delet(v);\n    return key[x];\n}\nint ne(int v)\n{\n    insert(root,v,0);\n    int x=son[root][1];while(son[x][0]) x=son[x][0];\n    delet(v);\n    return key[x];\n}\nint main()\n{\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1,x,y;i&lt;=n;++i)\n    {\n        if(x==1)         insert(root,y,0);\n        if(x==2)         delet(y);\n        if(x==3)         printf(&quot;%d\\n&quot;,getrank(y));\n        if(x==4)         printf(&quot;%d\\n&quot;,kth(y));\n        if(x==5)         printf(&quot;%d\\n&quot;,pre(y));\n        if(x==6)        printf(&quot;%d\\n&quot;,ne(y));\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/19/普通平衡树/","excerpt":"","categories":[{"name":"平衡树","slug":"平衡树","permalink":"https://prostkhala.github.io/categories/平衡树/"},{"name":"SPLAY","slug":"平衡树/SPLAY","permalink":"https://prostkhala.github.io/categories/平衡树/SPLAY/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://prostkhala.github.io/tags/模板/"},{"name":"SPLAY","slug":"SPLAY","permalink":"https://prostkhala.github.io/tags/SPLAY/"},{"name":"TREAP","slug":"TREAP","permalink":"https://prostkhala.github.io/tags/TREAP/"}]},{"title":"DNA Sequence","date":"2017-03-18T02:51:23.000Z","path":"2017/03/18/DNA Sequence/","text":"DNA SequencePOJ2778 题目描述It’s well known that DNA Sequence is a sequence only contains A, C, T and G, and it’s very useful to analyze a segment of DNA Sequence，For example, if a animal’s DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don’t contain those segments. Suppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. 输入输出格式输入格式：First line contains two integer m (0 &lt;= m &lt;= 10), n (1 &lt;= n &lt;=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences. Next m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. 输出格式：An integer, the number of DNA sequences, mod 100000. 输入输出样例输入样例：4 3 AT AC AG AA 输出样例：36 题解题目大意为给定n个病毒串，求不包含这些病毒串且长度为m的资源串个数（均由A,G,C,T组成）。 这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即$res [ i ] [ t ]$存的是从i到t恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res’=res^m$时，$res’[i][t]$表示从i到t恰好走m步能到达的方案数。 有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点（0）到叶节点（i）的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为将赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其fail指针指向病毒串），只需要特判一下即可。 刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了…后来因为取模操作过多又TLE了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int N =200+1; const int mod =100000; const int maxf =255; long long n,m,tr[N][4],tot,tmp,fail[N]; int idd[N]; bool tag[N]; char s[N]; int ss[4]={&#39;A&#39;,&#39;G&#39;,&#39;C&#39;,&#39;T&#39;}; struct martix{long long a[N][N];}res,ans; martix operator * (martix c,martix b) { martix ret; memset(ret.a,0,sizeof(ret.a)); for(int i=0;i&lt;=tot;++i) for(int t=0;t&lt;=tot;++t) { for(int k=0;k&lt;=tot;++k) ret.a[i][t]+=c.a[i][k]*b.a[k][t]; ret.a[i][t]%=mod; } return ret; } void init(){idd[ss[0]]=0;idd[ss[1]]=1;idd[ss[2]]=2;idd[ss[3]]=3;} void insert(int num) { int now=0; int n=strlen(s); for(int i=0;i&lt;n;++i) { if(tr[now][idd[s[i]]]==-1) { tr[now][idd[s[i]]]=++tot; for(int j=0;j&lt;4;++j)tr[tot][j]=-1; // tag[tot]=0; } now=tr[now][idd[s[i]]]; } tag[now]=true; } void getfail() { queue&lt;int&gt;q;fail[0]=0; for(int j=0;j&lt;4;++j) if(tr[0][j]!=-1)q.push(tr[0][j]),fail[tr[0][j]]=0; else tr[0][j]=0; while(!q.empty()) { int x=q.front();q.pop(); if(tag[fail[x]])tag[x]=true; for(int j=0;j&lt;4;++j) if(tr[x][j]!=-1) fail[tr[x][j]]=tr[fail[x]][j],q.push(tr[x][j]); else tr[x][j] =tr[fail[x]][j]; } } void slove() { for(int i=0;i&lt;=tot;i++) for(int j=0;j&lt;4;j++) if(!tag[i]&amp;&amp;!tag[tr[i][j]]) res.a[i][tr[i][j]]++; } int main() { init(); scanf(&quot;%d&quot;,&amp;n);scanf(&quot;%d&quot;,&amp;m); for(int i=0;i&lt;4;++i)tr[0][i]=-1; for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s),insert(i); getfail(); slove(); for(int i=0;i&lt;=tot;++i)ans.a[i][i]=1; if(!m){cout&lt;&lt;0;return 0;} while(m) { if(m&amp;1) ans=ans*res; m/=2; res=res*res; } int anss=0; for(int i=0;i&lt;=tot;++i)(anss+=ans.a[0][i])%=mod; cout&lt;&lt;anss; }","raw":"title: DNA Sequence\ndate: 2017-03-18 10:51:23\ncategories:\n  - Hollerith-type\n  - AC自动机\ntags:\n  - AC自动机\n  - 矩阵快速幂\n  - KMP\n---\n\n# DNA Sequence\n\n## [POJ2778](http://poj.org/problem?id=2778)\n\n---\n## 题目描述\nIt's well known that DNA Sequence is a sequence only contains A, C, T and G, and it's very useful to analyze a segment of DNA Sequence，For example, if a animal's DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don't contain those segments.\n\nSuppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. \n### 输入输出格式\n#### 输入格式：\nFirst line contains two integer m (0 <= m <= 10), n (1 <= n <=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences.\n\nNext m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. \n\n\n#### 输出格式：\nAn integer, the number of DNA sequences, mod 100000.\n\n\n### 输入输出样例\n#### 输入样例：\n    4 3\n    AT\n    AC\n    AG\n    AA\n    \n\n#### 输出样例：\n\t36\n---\n\n## 题解\n\n题目大意为给定n个病毒串，求不包含这些病毒串且长度为m的资源串个数（均由A,G,C,T组成）。\n\n这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即\n$res [ i ] [ t ]$存的是从i到t恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res'=res^m$时，$res'[i][t]$表示从i到t恰好走m步能到达的方案数。\n\n有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点（0）\n到叶节点（i）的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为将赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其fail指针指向病毒串），只需要特判一下即可。\n\n刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了...后来因为取模操作过多又TLE了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。\n\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<queue>\n    using namespace std;\n    const int  N =200+1;\n    const int mod =100000;\n    const int maxf =255;\n    long long n,m,tr[N][4],tot,tmp,fail[N];\n    int idd[N];\n    bool tag[N];\n    char s[N];\n    int ss[4]={'A','G','C','T'};\n    struct martix{long long a[N][N];}res,ans;\n    martix operator * (martix c,martix b)\n    {\n        martix ret;\n        memset(ret.a,0,sizeof(ret.a));\n        for(int i=0;i<=tot;++i)\n        for(int t=0;t<=tot;++t)\n        {\n            for(int k=0;k<=tot;++k)\n            ret.a[i][t]+=c.a[i][k]*b.a[k][t];\n            ret.a[i][t]%=mod;\n        }\n        return ret;\n    }\n    void init(){idd[ss[0]]=0;idd[ss[1]]=1;idd[ss[2]]=2;idd[ss[3]]=3;}\n    void insert(int num)\n    {\n        int now=0;\n        int n=strlen(s);\n        for(int i=0;i<n;++i)\n        {\n            if(tr[now][idd[s[i]]]==-1)\n            {\n                tr[now][idd[s[i]]]=++tot;\n                for(int j=0;j<4;++j)tr[tot][j]=-1;\t\n            //\ttag[tot]=0;\n            }\n            now=tr[now][idd[s[i]]];\n        }\n        tag[now]=true;\n    }\n    void getfail()\n    {\n        queue<int>q;fail[0]=0;\n        for(int j=0;j<4;++j)\n        if(tr[0][j]!=-1)q.push(tr[0][j]),fail[tr[0][j]]=0;\n        else\t\t\ttr[0][j]=0;\n\n        while(!q.empty())\n        {\n            int x=q.front();q.pop();\n            if(tag[fail[x]])tag[x]=true;\n            for(int j=0;j<4;++j)\n            if(tr[x][j]!=-1)\tfail[tr[x][j]]=tr[fail[x]][j],q.push(tr[x][j]);\t\n            else\t\t\t\t\t tr[x][j] =tr[fail[x]][j];\n        }\n    }\n    void slove()\n    {\n        for(int i=0;i<=tot;i++)\n        for(int j=0;j<4;j++)\n        if(!tag[i]&&!tag[tr[i][j]]) res.a[i][tr[i][j]]++;\n\n    }\n    int main()\n    {\n        init();\n        scanf(\"%d\",&n);scanf(\"%d\",&m);\n        for(int i=0;i<4;++i)tr[0][i]=-1;\n        for(int i=1;i<=n;++i)scanf(\"%s\",s),insert(i);\n        getfail();\n        slove();\n        for(int i=0;i<=tot;++i)ans.a[i][i]=1;\n        if(!m){cout<<0;return 0;}\n        while(m)\n        {\n            if(m&1) ans=ans*res;\n            m/=2;\n            res=res*res;\n        }\n        int anss=0;\n        for(int i=0;i<=tot;++i)(anss+=ans.a[0][i])%=mod;\n        cout<<anss;\n    }\n\n","content":"<h1 id=\"DNA-Sequence\"><a href=\"#DNA-Sequence\" class=\"headerlink\" title=\"DNA Sequence\"></a>DNA Sequence</h1><h2 id=\"POJ2778\"><a href=\"#POJ2778\" class=\"headerlink\" title=\"POJ2778\"></a><a href=\"http://poj.org/problem?id=2778\" target=\"_blank\" rel=\"external\">POJ2778</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>It’s well known that DNA Sequence is a sequence only contains A, C, T and G, and it’s very useful to analyze a segment of DNA Sequence，For example, if a animal’s DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don’t contain those segments.</p>\n<p>Suppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>First line contains two integer m (0 &lt;= m &lt;= 10), n (1 &lt;= n &lt;=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences.</p>\n<p>Next m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>An integer, the number of DNA sequences, mod 100000.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>4 3\nAT\nAC\nAG\nAA\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>36\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意为给定n个病毒串，求不包含这些病毒串且长度为m的资源串个数（均由A,G,C,T组成）。</p>\n<p>这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即<br>$res [ i ] [ t ]$存的是从i到t恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res’=res^m$时，$res’[i][t]$表示从i到t恰好走m步能到达的方案数。</p>\n<p>有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点（0）<br>到叶节点（i）的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为将赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其fail指针指向病毒串），只需要特判一下即可。</p>\n<p>刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了…后来因为取模操作过多又TLE了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int  N =200+1;\nconst int mod =100000;\nconst int maxf =255;\nlong long n,m,tr[N][4],tot,tmp,fail[N];\nint idd[N];\nbool tag[N];\nchar s[N];\nint ss[4]={&#39;A&#39;,&#39;G&#39;,&#39;C&#39;,&#39;T&#39;};\nstruct martix{long long a[N][N];}res,ans;\nmartix operator * (martix c,martix b)\n{\n    martix ret;\n    memset(ret.a,0,sizeof(ret.a));\n    for(int i=0;i&lt;=tot;++i)\n    for(int t=0;t&lt;=tot;++t)\n    {\n        for(int k=0;k&lt;=tot;++k)\n        ret.a[i][t]+=c.a[i][k]*b.a[k][t];\n        ret.a[i][t]%=mod;\n    }\n    return ret;\n}\nvoid init(){idd[ss[0]]=0;idd[ss[1]]=1;idd[ss[2]]=2;idd[ss[3]]=3;}\nvoid insert(int num)\n{\n    int now=0;\n    int n=strlen(s);\n    for(int i=0;i&lt;n;++i)\n    {\n        if(tr[now][idd[s[i]]]==-1)\n        {\n            tr[now][idd[s[i]]]=++tot;\n            for(int j=0;j&lt;4;++j)tr[tot][j]=-1;    \n        //    tag[tot]=0;\n        }\n        now=tr[now][idd[s[i]]];\n    }\n    tag[now]=true;\n}\nvoid getfail()\n{\n    queue&lt;int&gt;q;fail[0]=0;\n    for(int j=0;j&lt;4;++j)\n    if(tr[0][j]!=-1)q.push(tr[0][j]),fail[tr[0][j]]=0;\n    else            tr[0][j]=0;\n\n    while(!q.empty())\n    {\n        int x=q.front();q.pop();\n        if(tag[fail[x]])tag[x]=true;\n        for(int j=0;j&lt;4;++j)\n        if(tr[x][j]!=-1)    fail[tr[x][j]]=tr[fail[x]][j],q.push(tr[x][j]);    \n        else                     tr[x][j] =tr[fail[x]][j];\n    }\n}\nvoid slove()\n{\n    for(int i=0;i&lt;=tot;i++)\n    for(int j=0;j&lt;4;j++)\n    if(!tag[i]&amp;&amp;!tag[tr[i][j]]) res.a[i][tr[i][j]]++;\n\n}\nint main()\n{\n    init();\n    scanf(&quot;%d&quot;,&amp;n);scanf(&quot;%d&quot;,&amp;m);\n    for(int i=0;i&lt;4;++i)tr[0][i]=-1;\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s),insert(i);\n    getfail();\n    slove();\n    for(int i=0;i&lt;=tot;++i)ans.a[i][i]=1;\n    if(!m){cout&lt;&lt;0;return 0;}\n    while(m)\n    {\n        if(m&amp;1) ans=ans*res;\n        m/=2;\n        res=res*res;\n    }\n    int anss=0;\n    for(int i=0;i&lt;=tot;++i)(anss+=ans.a[0][i])%=mod;\n    cout&lt;&lt;anss;\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/18/DNA Sequence/","excerpt":"","categories":[{"name":"Hollerith-type","slug":"Hollerith-type","permalink":"https://prostkhala.github.io/categories/Hollerith-type/"},{"name":"AC自动机","slug":"Hollerith-type/AC自动机","permalink":"https://prostkhala.github.io/categories/Hollerith-type/AC自动机/"}],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://prostkhala.github.io/tags/AC自动机/"},{"name":"KMP","slug":"KMP","permalink":"https://prostkhala.github.io/tags/KMP/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://prostkhala.github.io/tags/矩阵快速幂/"}]},{"title":"NOIP模拟赛 2017 3 17","date":"2017-03-17T12:50:23.000Z","path":"2017/03/17/NOIP模拟赛 2017 3 17/","text":"T1 计算几何 题目描述花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问题。今天，他想到了一个十分有意思的题目： 首先，花花会在 x 轴正半轴和 y 轴正半轴分别挑选 n 个点。随后，他将 x 轴的点与 y 轴的点一一连接，形成 n 条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅有一种。最后，花花会给出 m 个询问。对于每个询问，将会给定一个点 P($x_p$ ,$y_p$ )，问线段OP（O 为坐标原点）与 n 条线段会产生多少个交点？ 输入输出格式输入格式：第 1 行包含一个正整数 n，表示线段的数量； 第 2 行包含 n 个正整数，表示花花在 x 轴选取的点的横坐标； 第 3 行包含 n 个正整数，表示花花在 y 轴选取的点的纵坐标； 第 4 行包含一个正整数 m，表示询问数量； 随后 m 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。 输出格式：共 m 行，每行包含一个非负整数，表示你对这条询问给出的答案。 输入输出样例输入样例：3 4 5 3 3 5 4 2 1 1 3 3 输出样例：0 3 数据范围对于 40% 的数据：n,m ≤ $10$； 另有 20% 的数据：n,m ≤ $100$； 另有 20% 的数据：n,m ≤ $1000$； 对于 100% 的数据：n,m ≤ $10^5$,y &lt; $2^{31}$ 题解本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $yp$ 与 $y{mid}$ 大小即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N =1e5+1; int n,m,x[N],y[N]; double a[N]; typedef double db; inline void get(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int main() { // freopen(&quot;geometry.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;geometry.out&quot;,&quot;w&quot;,stdout); get(n); for(int i=1;i&lt;=n;++i)get(x[i]);sort(x+1,x+n+1); for(int i=1;i&lt;=n;++i)get(y[i]);sort(y+1,y+n+1); get(m); for(int i=1,xx,yy;i&lt;=m;++i) { get(xx);get(yy); int l=0,r=n,mid; while(l!=r) { mid=l+r+1&gt;&gt;1; if(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid])); double yt=a[mid]*(db)xx+y[mid]; if(yt&lt;=(db)yy) l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,l); } } T2 花花的聚会 题目描述花花住在 H 国。H 国有 n 个城市，其中 1 号城市为其首都。城市间有 n − 1 条单向道路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市走到首都的路径是唯一的。 过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 m 种过路券，每张过路券以三个整数表示：v k w：你可以在城市 v 以价格 w 买到一张过路券。这张券可以使用 k 次。这意味着，拿着这张券通过了 k 条道路之后，这张券就不能再使用了。 请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，并且在所在的城市再买一张。 花花家在首都。他有 q 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。 花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮他么？ 输入输出格式输入格式：输入的第一行包含两个空格隔开的整数 n 和 m，表示 H 国的城市数量和过路券的种数。 之后的 n − 1 行各自包含两个数 a i 和 b i ，代表城市 a i 到城市 b i 间有一条单向道路。 之后的 m 行每行包括三个整数 v i ,k i 和 w i ，表示一种过路券。 下一行包含一个整数 q，表示花花朋友的数量。 之后的 q 行各自包含一个整数，表示花花朋友的所在城市。 输出格式：输出共 q 行，每一行代表一位朋友的路费。 输入输出样例输入样例：7 7 3 1 2 1 7 6 6 3 5 3 4 3 7 2 3 7 1 1 2 3 5 3 6 2 4 2 4 5 3 10 6 1 20 3 5 6 7 输出样例：10 22 5 数据范围对于 40% 的数据：n,m,q ≤ 10,w i ≤ 10； 另有 20% 的数据：n,m,q ≤ 500,w i ≤ 100； 另有 20% 的数据：n,m,q ≤ 5000,w i ≤ 1000； 对于 100% 的数据：n,m,q ≤ 10 5 ,w i ≤ 10000,1 ≤ v i ,k i ≤ n。 题解树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：$f[y] = min ( f[x] + w[y][i] )( x 为 y 祖先 &amp;&amp; dep[x] - dep[y] &gt; = k[y][i] )$ 先进行拓扑排序，顺序进行操作。对于寻找$min(f[x])$的操作，则可以通过LCA或树链剖分实现。(要开 long long 不然会爆) CODE#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; const int inf =0x7fffffff; const int N =1e5+1; const int maxlogn =21; using namespace std; int deep[N],head[N],head2[N]; long long st[N][maxlogn],minn[N][maxlogn],f[N]; int tot,tot2,n,m,qu; struct edg{int t,ne;}e[N*2]; struct edg2{int k,w,ne;}e2[N*2]; void in(int x,int y) { e[++tot].t=y; e[tot].ne=head[x]; head[x]=tot; return; } void in2(int x,int k,int w) { e2[++tot2].k=k; e2[tot2].w=w; e2[tot2].ne=head2[x]; head2[x]=tot2; return; } void getf(int x,int pre) { st[x][0]=pre;minn[x][0]=f[pre]; for(int i=1;i&lt;maxlogn;i++) { st[x][i]=st[st[x][i-1]][i-1]; minn[x][i]=min(minn[x][i-1],minn[st[x][i-1]][i-1]); } f[x]=x==1?0:inf; for(int i=head2[x];i;i=e2[i].ne) { long long tmp=inf,y=x,k=e2[i].k,p=0; while(k) { if(k&amp;1)tmp=min(tmp,minn[y][p]),y=st[y][p]; p++;k&gt;&gt;=1; } f[x]=min(f[x],tmp+e2[i].w); } for(int i=head[x];i;i=e[i].ne) { int y=e[i].t; if(y!=pre)getf(y,x); } return; } int main() { // freopen(&quot;party.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;party.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x,y;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x); for(int i=1,x,k,w;i&lt;=m;i++)scanf(&quot;%d%d%d&quot;,&amp;x,&amp;k,&amp;w),in2(x,k,w); scanf(&quot;%d&quot;,&amp;qu);getf(1,1); for(int i=1,x;i&lt;=qu;i++){scanf(&quot;%d&quot;,&amp;x);printf(&quot;%d\\n&quot;,f[x]);} } T3 文本编辑器 题目描述九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一些功能。 功能列表如下： &lt; w w 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。 该命令将选定光标向左移动，如果已经是最左端则不移动。 命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。 &gt; w w 同上。 与&lt; 命令不同的是，该命令将光标向右移动。 命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。 I w c w 同上。 c 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。 该命令始终输出“T”。 D w w 同上。 代表删除该光标右侧的一个字符。 命令执行成功时输出“T”，若光标右侧没有字符输出“F”。 R 代表翻转左光标和右光标之间的字符。 该命令只有左光标在右光标左侧时才能执行。 （两光标重合时也不能执行） 命令执行成功时输出“T”，否则输“F”。 S 代表显示当前处理的文本。 该命令只输出文本，不输出“T”和“F”。 开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。 注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。 输入输出格式输入格式：第一行是初始时文本编辑器内容。 第二行是一个正整数 N，N 表示操作次数。 接下来有 N 行，每行有一个命令，命令格式如上方表格。 输出格式：对于每个命令，按上方表格要求执行并输出。 输入输出样例输入样例：goodykc 11 I R u I R l &gt; L &gt; L &gt; L &gt; L R D R &lt; R D R S 输出样例：T T T T T T T F T T goodluck 数据范围对于 40% 的数据：1 ≤ N , 初始文本长度 ≤ 100，数据不包含翻转（Reverse）操作； 另有 30% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据不包含翻转（Reverse）操作； 另有 20% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据包含翻转（Reverse）操作； 对于 100% 的数据：1 ≤ N , 初始文本长度 ≤ 4 × 10 6 ，输出文件大小 ≤ 20MB; 题解用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。 具体的实现代码十分清楚，但还有许多细节要注意，因为l，r的相对位置可能互换，所以只能写左开右开或左闭右闭区间。 CODE#include&lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int N=1e7+1; int tot,m,pos[2],cnt[2],pre[N],next[N]; char opreator,ch[N],str[N]; int move(){getchar();return getchar()==&#39;L&#39;?0:1;} void in(int opreator,char c) { ++tot; ch[tot]=c; int u=pos[opreator],v=next[u]; pre[tot]=u;next[tot]=v; next[u]=tot;pre[v]=tot; if (cnt[opreator^1]&gt;=cnt[opreator])cnt[opreator^1]++; pos[opreator]=tot;cnt[opreator]++; if (pos[opreator^1]==u)pos[opreator^1]=tot; printf(&quot;T\\n&quot;); } void ll(int opreator) { if (pos[opreator]==1){printf(&quot;F\\n&quot;);return;} int u=pos[opreator],v=pre[u]; if (next[v]!=u)swap(next[v],pre[v]); pos[opreator]=v; cnt[opreator]--; printf(&quot;T\\n&quot;); } void rl(int opreator) { if (next[pos[opreator]]==2){printf(&quot;F\\n&quot;);return;} int u=next[pos[opreator]],v=next[u]; if(pre[v]!=u)swap(next[v],pre[v]); pos[opreator]=u;cnt[opreator]++; printf(&quot;T\\n&quot;); } void D(int opreator) { if (next[pos[opreator]]== 2){printf(&quot;F\\n&quot;);return;} int u = pos[opreator], v = next[u], w = next[v]; if (pre[w]!=v) swap(next[w], pre[w]); if (cnt[opreator^1]&gt;cnt[opreator])cnt[opreator^1]--; if (pos[opreator^1]==v)pos[opreator^1]=u; next[u]= w;pre[w]=u; printf(&quot;T\\n&quot;); } void R() { if (cnt[1]-cnt[0]&lt;=0){printf(&quot;F\\n&quot;);return;} if (cnt[1]-cnt[0]==1){printf(&quot;T\\n&quot;);return;} int now=pos[0],ne=next[now],c=pos[1],d=next[c]; swap(pre[ne], next[ne]);swap(pre[c],next[c]); next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne; pos[1]=ne; printf(&quot;T\\n&quot;); } void show() { int u=1; while(true) { if(pre[next[u]]!= u)swap(pre[next[u]],next[next[u]]); u=next[u]; if (u==2)break; putchar(ch[u]); } printf(&quot;\\n&quot;); } void init() { tot=2; pre[1]=-1;next[1]= 2; pre[2]=1;next[2]=-1; pos[0]=pos[1]=cnt[0]=cnt[1]=1; int len=strlen(str); for(int i=0;i&lt;len;i++) { ++tot; ch[tot]=str[i]; pre[tot]= i==0?1:tot-1; next[tot]= i==len-1?2:tot+1; } if(len&gt;0) { next[1]=3;pre[2]=tot; pos[1]=tot;cnt[1]=len+1; } } int act() { if(opreator==&#39;&lt;&#39;) ll(move()); if(opreator==&#39;&gt;&#39;) rl(move()); if(opreator==&#39;I&#39;) { int d=move(); char c=getchar(); while (c&lt;33||c&gt;126)c=getchar(); in(d,c); } if (opreator==&#39;D&#39;) D(move()); if (opreator==&#39;R&#39;) R(); if (opreator==&#39;S&#39;) show(); } int main() { // freopen(&quot;editor.in&quot;,&quot;r&quot;, stdin); // freopen(&quot;editor.out&quot;,&quot;w&quot;, stdout); scanf(&quot;%s&quot;,str); init(); scanf(&quot;%d&quot;,&amp;m); for (int i=1;i&lt;=m;i++) { getchar(); opreator=getchar(); while (opreator!=&#39;&lt;&#39;&amp;&amp; opreator!=&#39;&gt;&#39;&amp;&amp;!(opreator &gt;=&#39;A&#39;&amp;&amp; opreator &lt;=&#39;Z&#39;))opreator=getchar(); act(); } return 0; }","raw":"title: NOIP模拟赛 2017 3 17\ndate: 2017-03-17 20:50:23\ncategories:\n  - NOIP模拟赛\ntags:\n  - 二分答案\n  - 计算几何\n  - 动态规划\n  - 链表\n  - 树链剖分\n---\n\n# T1 计算几何\n\n---\n## 题目描述\n花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问\n题。今天，他想到了一个十分有意思的题目：\n\n首先，花花会在 x 轴正半轴和 y 轴正半轴分别挑选 n 个点。随后，他将 x 轴的点与 y 轴\n的点一一连接，形成 n 条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅\n有一种。最后，花花会给出 m 个询问。对于每个询问，将会给定一个点 P($x_p$ ,$y_p$ )，问线段\nOP（O 为坐标原点）与 n 条线段会产生多少个交点？\n\n### 输入输出格式\n#### 输入格式：\n第 1 行包含一个正整数 n，表示线段的数量；\n\n第 2 行包含 n 个正整数，表示花花在 x 轴选取的点的横坐标；\n\n第 3 行包含 n 个正整数，表示花花在 y 轴选取的点的纵坐标；\n\n第 4 行包含一个正整数 m，表示询问数量；\n\n随后 m 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。\n\n\n#### 输出格式：\n\n共 m 行，每行包含一个非负整数，表示你对这条询问给出的答案。\n\n### 输入输出样例\n#### 输入样例：\n    3\n    4 5 3\n    3 5 4\n    2\n    1 1\n    3 3\n    \n\n#### 输出样例：\n    0\n\t3\n\n### 数据范围\n对于 40% 的数据：n,m ≤ $10$；\n\n另有 20% 的数据：n,m ≤ $100$；\n\n另有 20% 的数据：n,m ≤ $1000$；\n\n对于 100% 的数据：n,m ≤ $10^5$,y < $2^{31}$\n\n---\n\n## 题解\n\n本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $y_p$ 与 $y_{mid}$ 大小即可。\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N =1e5+1;\n    int n,m,x[N],y[N];\n    double a[N];\n    typedef double db;\n    inline void get(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int main()\n    {\n    //    freopen(\"geometry.in\",\"r\",stdin);\n    //    freopen(\"geometry.out\",\"w\",stdout);\n        get(n);\n        for(int i=1;i<=n;++i)get(x[i]);sort(x+1,x+n+1);\n        for(int i=1;i<=n;++i)get(y[i]);sort(y+1,y+n+1);\n\n        get(m);\n        for(int i=1,xx,yy;i<=m;++i)\n        {\n            get(xx);get(yy);\n            int l=0,r=n,mid;\n            while(l!=r)\n            {\n                mid=l+r+1>>1;\n                if(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid]));\n                double yt=a[mid]*(db)xx+y[mid];\n                if(yt<=(db)yy) l=mid;\n                else\t\t  r=mid-1;\n            }\n            printf(\"%d\\n\",l);\n        }\n    }\n    \n---\n# T2 花花的聚会\n\n---\n## 题目描述\n花花住在 H 国。H 国有 n 个城市，其中 1 号城市为其首都。城市间有 n − 1 条单向道\n路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市\n走到首都的路径是唯一的。\n\n过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 m 种过\n路券，每张过路券以三个整数表示：v k w：你可以在城市 v 以价格 w 买到一张过路券。这\n张券可以使用 k 次。这意味着，拿着这张券通过了 k 条道路之后，这张券就不能再使用了。\n\n请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，\n并且在所在的城市再买一张。\n\n花花家在首都。他有 q 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道\n每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。\n\n花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮\n他么？\n### 输入输出格式\n#### 输入格式：\n输入的第一行包含两个空格隔开的整数 n 和 m，表示 H 国的城市数量和过路券的种数。\n\n之后的 n − 1 行各自包含两个数 a i 和 b i ，代表城市 a i 到城市 b i 间有一条单向道路。\n\n之后的 m 行每行包括三个整数 v i ,k i 和 w i ，表示一种过路券。\n\n下一行包含一个整数 q，表示花花朋友的数量。\n\n之后的 q 行各自包含一个整数，表示花花朋友的所在城市。\n\n\n\n#### 输出格式：\n\n输出共 q 行，每一行代表一位朋友的路费。\n\n### 输入输出样例\n#### 输入样例：\n    7 7\n    3 1\n    2 1\n    7 6\n    6 3\n    5 3\n    4 3\n    7 2 3\n    7 1 1\n    2 3 5\n    3 6 2\n    4 2 4\n    5 3 10\n    6 1 20\n    3\n    5\n    6\n    7\n\n#### 输出样例：\n    10\n    22\n    5\n    \n\n### 数据范围\n对于 40% 的数据：n,m,q ≤ 10,w i ≤ 10；\n \n另有 20% 的数据：n,m,q ≤ 500,w i ≤ 100；\n\n另有 20% 的数据：n,m,q ≤ 5000,w i ≤ 1000；\n\n对于 100% 的数据：n,m,q ≤ 10 5 ,w i ≤ 10000,1 ≤ v i ,k i ≤ n。\n \n---\n\n## 题解\n\n树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：\n$f[y] = min ( f[x] + w[y][i] )( x 为 y 祖先 && dep[x] - dep[y] > = k[y][i] )$\n\n先进行拓扑排序，顺序进行操作。对于寻找$min(f[x])$的操作，则可以通过LCA或树链剖分实现。(要开 long long 不然会爆)\n\n---\n### CODE\n    #include<iostream>\n    #include<algorithm>\n    #include<cstdio>\n    const int inf =0x7fffffff;\n    const int N =1e5+1;\n    const int maxlogn =21;\n    using namespace std;\n    int deep[N],head[N],head2[N];\n    long long st[N][maxlogn],minn[N][maxlogn],f[N];\n    int tot,tot2,n,m,qu;\n    struct edg{int t,ne;}e[N*2];\n    struct edg2{int k,w,ne;}e2[N*2];\n    void in(int x,int y)\n    {\n        e[++tot].t=y;\n        e[tot].ne=head[x];\n        head[x]=tot;\n        return;\n    }\n\n    void in2(int x,int k,int w)\n    {\n        e2[++tot2].k=k;\n        e2[tot2].w=w;\n        e2[tot2].ne=head2[x];\n        head2[x]=tot2;\n        return;\n    }\n\n    void getf(int x,int pre)\n    {\n        st[x][0]=pre;minn[x][0]=f[pre];\n        for(int i=1;i<maxlogn;i++)\n        {\n            st[x][i]=st[st[x][i-1]][i-1];\n            minn[x][i]=min(minn[x][i-1],minn[st[x][i-1]][i-1]);\n        }\n        f[x]=x==1?0:inf;\n        for(int i=head2[x];i;i=e2[i].ne)\n        {\n            long long tmp=inf,y=x,k=e2[i].k,p=0;\n            while(k)\n            {\n                if(k&1)tmp=min(tmp,minn[y][p]),y=st[y][p];\n                p++;k>>=1;\n            }\n            f[x]=min(f[x],tmp+e2[i].w);\n        }\n        for(int i=head[x];i;i=e[i].ne)\n        {\n            int y=e[i].t;\n            if(y!=pre)getf(y,x);\n        }\n        return;\n    }\n\n    int main()\n    {\n    //    freopen(\"party.in\",\"r\",stdin);\n    //    freopen(\"party.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1,x,y;i<n;i++)scanf(\"%d%d\",&x,&y),in(x,y),in(y,x);\n        for(int i=1,x,k,w;i<=m;i++)scanf(\"%d%d%d\",&x,&k,&w),in2(x,k,w);\n        scanf(\"%d\",&qu);getf(1,1);\n        for(int i=1,x;i<=qu;i++){scanf(\"%d\",&x);printf(\"%d\\n\",f[x]);}\n    }\n---\n# T3 文本编辑器\n\n---\n## 题目描述\n九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时\n在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用\n处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但\n是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一\n些功能。\n\n功能列表如下：\n\n\n    < w\n    \n    w 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。\n    该命令将选定光标向左移动，如果已经是最左端则不移动。\n    命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。\n    \n    > w\n    \n    w 同上。\n    与< 命令不同的是，该命令将光标向右移动。\n    命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。\n    \n    I w c\n    \n    w 同上。\n    c 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。\n    该命令始终输出“T”。\n    \n    D w\n    \n    w 同上。\n    代表删除该光标右侧的一个字符。\n    命令执行成功时输出“T”，若光标右侧没有字符输出“F”。\n    \n    R\n    \n    代表翻转左光标和右光标之间的字符。\n    该命令只有左光标在右光标左侧时才能执行。\n    （两光标重合时也不能执行）\n    命令执行成功时输出“T”，否则输“F”。\n    \n    S\n    \n    代表显示当前处理的文本。\n    该命令只输出文本，不输出“T”和“F”。\n    \n开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。\n\n注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。\n### 输入输出格式\n#### 输入格式：\n第一行是初始时文本编辑器内容。\n\n第二行是一个正整数 N，N 表示操作次数。\n\n接下来有 N 行，每行有一个命令，命令格式如上方表格。\n\n#### 输出格式：\n对于每个命令，按上方表格要求执行并输出。\n\n\n### 输入输出样例\n#### 输入样例：\n    goodykc\n    11\n    I R u\n    I R l\n    > L\n    > L\n    > L\n    > L\n    R\n    D R\n    < R\n    D R\n    S\n\n\n#### 输出样例：\n    T\n    T\n    T\n    T\n    T\n    T\n    T\n    F\n    T\n    T\n    goodluck\n    \n\n### 数据范围\n对于 40% 的数据：1 ≤ N , 初始文本长度 ≤ 100，数据不包含翻转（Reverse）操作；\n\n另有 30% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据不包含翻转（Reverse）操作；\n\n另有 20% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据包含翻转（Reverse）操作；\n\n对于 100% 的数据：1 ≤ N , 初始文本长度 ≤ 4 × 10 6 ，输出文件大小 ≤ 20MB;\n\n---\n\n## 题解\n用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。\n\n具体的实现代码十分清楚，但还有许多细节要注意，因为l，r的相对位置可能互换，所以只能写左开右开或左闭右闭区间。\n\n---\n### CODE\n    #include<iostream>\n    #include <cstdio>\n    #include <cstring>\n    using namespace std;\n    const int N=1e7+1;\n\n    int tot,m,pos[2],cnt[2],pre[N],next[N];\n\n    char opreator,ch[N],str[N];\n\n    int move(){getchar();return getchar()=='L'?0:1;}\n\n    void in(int opreator,char c)\n    {\n        ++tot;\n        ch[tot]=c;\n        int u=pos[opreator],v=next[u];\n\n        pre[tot]=u;next[tot]=v;\n        next[u]=tot;pre[v]=tot;\n\n        if (cnt[opreator^1]>=cnt[opreator])cnt[opreator^1]++;\n\n        pos[opreator]=tot;cnt[opreator]++;\n        if (pos[opreator^1]==u)pos[opreator^1]=tot;\n        printf(\"T\\n\");\n    }\n\n    void ll(int opreator)\n    {\n        if (pos[opreator]==1){printf(\"F\\n\");return;}\n        int u=pos[opreator],v=pre[u];\n\n        if (next[v]!=u)swap(next[v],pre[v]);\n\n        pos[opreator]=v; cnt[opreator]--;\n        printf(\"T\\n\");\n    }\n\n    void rl(int opreator)\n    {\n        if (next[pos[opreator]]==2){printf(\"F\\n\");return;}\n        int u=next[pos[opreator]],v=next[u];\n\n        if(pre[v]!=u)swap(next[v],pre[v]);\n\n        pos[opreator]=u;cnt[opreator]++;\n        printf(\"T\\n\");\t\n    }\n\n    void D(int opreator)\n    {\n        if (next[pos[opreator]]== 2){printf(\"F\\n\");return;}\n        int u = pos[opreator], v = next[u], w = next[v];\n\n        if (pre[w]!=v) swap(next[w], pre[w]);\n        if (cnt[opreator^1]>cnt[opreator])cnt[opreator^1]--;\n        if (pos[opreator^1]==v)pos[opreator^1]=u;\n\n        next[u]= w;pre[w]=u;\n        printf(\"T\\n\");\n    }\n\n    void R()\n    {\n        if (cnt[1]-cnt[0]<=0){printf(\"F\\n\");return;}\n        if (cnt[1]-cnt[0]==1){printf(\"T\\n\");return;}\n        int now=pos[0],ne=next[now],c=pos[1],d=next[c];\n\n        swap(pre[ne], next[ne]);swap(pre[c],next[c]);\n        next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne;\n        pos[1]=ne;\n        printf(\"T\\n\");\n    }\n\n    void show()\n    {\n        int u=1;\n        while(true)\n        {\n            if(pre[next[u]]!= u)swap(pre[next[u]],next[next[u]]);\n            u=next[u];\n            if (u==2)break;\n            putchar(ch[u]);\n        }\n        printf(\"\\n\");\n    }\n\n    void init()\n    {\n        tot=2;\n        pre[1]=-1;next[1]= 2;\n        pre[2]=1;next[2]=-1;\n        pos[0]=pos[1]=cnt[0]=cnt[1]=1;\n        int len=strlen(str);\n        for(int i=0;i<len;i++)\n        {\n            ++tot;\n            ch[tot]=str[i];\n            pre[tot]= i==0?1:tot-1;\n            next[tot]= i==len-1?2:tot+1;\n        }\n        if(len>0)\n        {\n            next[1]=3;pre[2]=tot;\n            pos[1]=tot;cnt[1]=len+1;\n        }\n    }\n\n    int act()\n    {\n        if(opreator=='<') \t\tll(move());\n        if(opreator=='>') \t\trl(move());\n        if(opreator=='I')\n        {\n            int d=move();\n            char c=getchar();\n            while (c<33||c>126)c=getchar();\n            in(d,c);\n        }\n        if (opreator=='D') \t\tD(move());\n        if (opreator=='R') \t\tR();\n        if (opreator=='S') \t\tshow();\n    }\n    int main()\n    {\n    //    freopen(\"editor.in\",\"r\", stdin);\n    //    freopen(\"editor.out\",\"w\", stdout);\n        scanf(\"%s\",str);\n        init();\n        scanf(\"%d\",&m);\n        for (int i=1;i<=m;i++)\n        {\n            getchar();\n            opreator=getchar();\n            while (opreator!='<'&& opreator!='>'&&!(opreator >='A'&& opreator <='Z'))opreator=getchar();\n            act();\n        }\n        return 0;\n    }\n---","content":"<h1 id=\"T1-计算几何\"><a href=\"#T1-计算几何\" class=\"headerlink\" title=\"T1 计算几何\"></a>T1 计算几何</h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问<br>题。今天，他想到了一个十分有意思的题目：</p>\n<p>首先，花花会在 x 轴正半轴和 y 轴正半轴分别挑选 n 个点。随后，他将 x 轴的点与 y 轴<br>的点一一连接，形成 n 条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅<br>有一种。最后，花花会给出 m 个询问。对于每个询问，将会给定一个点 P($x_p$ ,$y_p$ )，问线段<br>OP（O 为坐标原点）与 n 条线段会产生多少个交点？</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第 1 行包含一个正整数 n，表示线段的数量；</p>\n<p>第 2 行包含 n 个正整数，表示花花在 x 轴选取的点的横坐标；</p>\n<p>第 3 行包含 n 个正整数，表示花花在 y 轴选取的点的纵坐标；</p>\n<p>第 4 行包含一个正整数 m，表示询问数量；</p>\n<p>随后 m 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>共 m 行，每行包含一个非负整数，表示你对这条询问给出的答案。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\n4 5 3\n3 5 4\n2\n1 1\n3 3\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>0\n3\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 40% 的数据：n,m ≤ $10$；</p>\n<p>另有 20% 的数据：n,m ≤ $100$；</p>\n<p>另有 20% 的数据：n,m ≤ $1000$；</p>\n<p>对于 100% 的数据：n,m ≤ $10^5$,y &lt; $2^{31}$</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $y<em>p$ 与 $y</em>{mid}$ 大小即可。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N =1e5+1;\nint n,m,x[N],y[N];\ndouble a[N];\ntypedef double db;\ninline void get(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint main()\n{\n//    freopen(&quot;geometry.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;geometry.out&quot;,&quot;w&quot;,stdout);\n    get(n);\n    for(int i=1;i&lt;=n;++i)get(x[i]);sort(x+1,x+n+1);\n    for(int i=1;i&lt;=n;++i)get(y[i]);sort(y+1,y+n+1);\n\n    get(m);\n    for(int i=1,xx,yy;i&lt;=m;++i)\n    {\n        get(xx);get(yy);\n        int l=0,r=n,mid;\n        while(l!=r)\n        {\n            mid=l+r+1&gt;&gt;1;\n            if(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid]));\n            double yt=a[mid]*(db)xx+y[mid];\n            if(yt&lt;=(db)yy) l=mid;\n            else          r=mid-1;\n        }\n        printf(&quot;%d\\n&quot;,l);\n    }\n}\n</code></pre><hr>\n<h1 id=\"T2-花花的聚会\"><a href=\"#T2-花花的聚会\" class=\"headerlink\" title=\"T2 花花的聚会\"></a>T2 花花的聚会</h1><hr>\n<h2 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>花花住在 H 国。H 国有 n 个城市，其中 1 号城市为其首都。城市间有 n − 1 条单向道<br>路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市<br>走到首都的路径是唯一的。</p>\n<p>过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 m 种过<br>路券，每张过路券以三个整数表示：v k w：你可以在城市 v 以价格 w 买到一张过路券。这<br>张券可以使用 k 次。这意味着，拿着这张券通过了 k 条道路之后，这张券就不能再使用了。</p>\n<p>请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，<br>并且在所在的城市再买一张。</p>\n<p>花花家在首都。他有 q 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道<br>每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。</p>\n<p>花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮<br>他么？</p>\n<h3 id=\"输入输出格式-1\"><a href=\"#输入输出格式-1\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：-1\"><a href=\"#输入格式：-1\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入的第一行包含两个空格隔开的整数 n 和 m，表示 H 国的城市数量和过路券的种数。</p>\n<p>之后的 n − 1 行各自包含两个数 a i 和 b i ，代表城市 a i 到城市 b i 间有一条单向道路。</p>\n<p>之后的 m 行每行包括三个整数 v i ,k i 和 w i ，表示一种过路券。</p>\n<p>下一行包含一个整数 q，表示花花朋友的数量。</p>\n<p>之后的 q 行各自包含一个整数，表示花花朋友的所在城市。</p>\n<h4 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出共 q 行，每一行代表一位朋友的路费。</p>\n<h3 id=\"输入输出样例-1\"><a href=\"#输入输出样例-1\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>7 7\n3 1\n2 1\n7 6\n6 3\n5 3\n4 3\n7 2 3\n7 1 1\n2 3 5\n3 6 2\n4 2 4\n5 3 10\n6 1 20\n3\n5\n6\n7\n</code></pre><h4 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>10\n22\n5\n</code></pre><h3 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 40% 的数据：n,m,q ≤ 10,w i ≤ 10；</p>\n<p>另有 20% 的数据：n,m,q ≤ 500,w i ≤ 100；</p>\n<p>另有 20% 的数据：n,m,q ≤ 5000,w i ≤ 1000；</p>\n<p>对于 100% 的数据：n,m,q ≤ 10 5 ,w i ≤ 10000,1 ≤ v i ,k i ≤ n。</p>\n<hr>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：<br>$f[y] = min ( f[x] + w[y][i] )( x 为 y 祖先 &amp;&amp; dep[x] - dep[y] &gt; = k[y][i] )$</p>\n<p>先进行拓扑排序，顺序进行操作。对于寻找$min(f[x])$的操作，则可以通过LCA或树链剖分实现。(要开 long long 不然会爆)</p>\n<hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nconst int inf =0x7fffffff;\nconst int N =1e5+1;\nconst int maxlogn =21;\nusing namespace std;\nint deep[N],head[N],head2[N];\nlong long st[N][maxlogn],minn[N][maxlogn],f[N];\nint tot,tot2,n,m,qu;\nstruct edg{int t,ne;}e[N*2];\nstruct edg2{int k,w,ne;}e2[N*2];\nvoid in(int x,int y)\n{\n    e[++tot].t=y;\n    e[tot].ne=head[x];\n    head[x]=tot;\n    return;\n}\n\nvoid in2(int x,int k,int w)\n{\n    e2[++tot2].k=k;\n    e2[tot2].w=w;\n    e2[tot2].ne=head2[x];\n    head2[x]=tot2;\n    return;\n}\n\nvoid getf(int x,int pre)\n{\n    st[x][0]=pre;minn[x][0]=f[pre];\n    for(int i=1;i&lt;maxlogn;i++)\n    {\n        st[x][i]=st[st[x][i-1]][i-1];\n        minn[x][i]=min(minn[x][i-1],minn[st[x][i-1]][i-1]);\n    }\n    f[x]=x==1?0:inf;\n    for(int i=head2[x];i;i=e2[i].ne)\n    {\n        long long tmp=inf,y=x,k=e2[i].k,p=0;\n        while(k)\n        {\n            if(k&amp;1)tmp=min(tmp,minn[y][p]),y=st[y][p];\n            p++;k&gt;&gt;=1;\n        }\n        f[x]=min(f[x],tmp+e2[i].w);\n    }\n    for(int i=head[x];i;i=e[i].ne)\n    {\n        int y=e[i].t;\n        if(y!=pre)getf(y,x);\n    }\n    return;\n}\n\nint main()\n{\n//    freopen(&quot;party.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;party.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1,x,y;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x);\n    for(int i=1,x,k,w;i&lt;=m;i++)scanf(&quot;%d%d%d&quot;,&amp;x,&amp;k,&amp;w),in2(x,k,w);\n    scanf(&quot;%d&quot;,&amp;qu);getf(1,1);\n    for(int i=1,x;i&lt;=qu;i++){scanf(&quot;%d&quot;,&amp;x);printf(&quot;%d\\n&quot;,f[x]);}\n}\n</code></pre><hr>\n<h1 id=\"T3-文本编辑器\"><a href=\"#T3-文本编辑器\" class=\"headerlink\" title=\"T3 文本编辑器\"></a>T3 文本编辑器</h1><hr>\n<h2 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时<br>在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用<br>处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但<br>是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一<br>些功能。</p>\n<p>功能列表如下：</p>\n<pre><code>&lt; w\n\nw 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。\n该命令将选定光标向左移动，如果已经是最左端则不移动。\n命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。\n\n&gt; w\n\nw 同上。\n与&lt; 命令不同的是，该命令将光标向右移动。\n命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。\n\nI w c\n\nw 同上。\nc 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。\n该命令始终输出“T”。\n\nD w\n\nw 同上。\n代表删除该光标右侧的一个字符。\n命令执行成功时输出“T”，若光标右侧没有字符输出“F”。\n\nR\n\n代表翻转左光标和右光标之间的字符。\n该命令只有左光标在右光标左侧时才能执行。\n（两光标重合时也不能执行）\n命令执行成功时输出“T”，否则输“F”。\n\nS\n\n代表显示当前处理的文本。\n该命令只输出文本，不输出“T”和“F”。\n</code></pre><p>开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。</p>\n<p>注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。</p>\n<h3 id=\"输入输出格式-2\"><a href=\"#输入输出格式-2\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：-2\"><a href=\"#输入格式：-2\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行是初始时文本编辑器内容。</p>\n<p>第二行是一个正整数 N，N 表示操作次数。</p>\n<p>接下来有 N 行，每行有一个命令，命令格式如上方表格。</p>\n<h4 id=\"输出格式：-2\"><a href=\"#输出格式：-2\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于每个命令，按上方表格要求执行并输出。</p>\n<h3 id=\"输入输出样例-2\"><a href=\"#输入输出样例-2\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-2\"><a href=\"#输入样例：-2\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>goodykc\n11\nI R u\nI R l\n&gt; L\n&gt; L\n&gt; L\n&gt; L\nR\nD R\n&lt; R\nD R\nS\n</code></pre><h4 id=\"输出样例：-2\"><a href=\"#输出样例：-2\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>T\nT\nT\nT\nT\nT\nT\nF\nT\nT\ngoodluck\n</code></pre><h3 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 40% 的数据：1 ≤ N , 初始文本长度 ≤ 100，数据不包含翻转（Reverse）操作；</p>\n<p>另有 30% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据不包含翻转（Reverse）操作；</p>\n<p>另有 20% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据包含翻转（Reverse）操作；</p>\n<p>对于 100% 的数据：1 ≤ N , 初始文本长度 ≤ 4 × 10 6 ，输出文件大小 ≤ 20MB;</p>\n<hr>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。</p>\n<p>具体的实现代码十分清楚，但还有许多细节要注意，因为l，r的相对位置可能互换，所以只能写左开右开或左闭右闭区间。</p>\n<hr>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int N=1e7+1;\n\nint tot,m,pos[2],cnt[2],pre[N],next[N];\n\nchar opreator,ch[N],str[N];\n\nint move(){getchar();return getchar()==&#39;L&#39;?0:1;}\n\nvoid in(int opreator,char c)\n{\n    ++tot;\n    ch[tot]=c;\n    int u=pos[opreator],v=next[u];\n\n    pre[tot]=u;next[tot]=v;\n    next[u]=tot;pre[v]=tot;\n\n    if (cnt[opreator^1]&gt;=cnt[opreator])cnt[opreator^1]++;\n\n    pos[opreator]=tot;cnt[opreator]++;\n    if (pos[opreator^1]==u)pos[opreator^1]=tot;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid ll(int opreator)\n{\n    if (pos[opreator]==1){printf(&quot;F\\n&quot;);return;}\n    int u=pos[opreator],v=pre[u];\n\n    if (next[v]!=u)swap(next[v],pre[v]);\n\n    pos[opreator]=v; cnt[opreator]--;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid rl(int opreator)\n{\n    if (next[pos[opreator]]==2){printf(&quot;F\\n&quot;);return;}\n    int u=next[pos[opreator]],v=next[u];\n\n    if(pre[v]!=u)swap(next[v],pre[v]);\n\n    pos[opreator]=u;cnt[opreator]++;\n    printf(&quot;T\\n&quot;);    \n}\n\nvoid D(int opreator)\n{\n    if (next[pos[opreator]]== 2){printf(&quot;F\\n&quot;);return;}\n    int u = pos[opreator], v = next[u], w = next[v];\n\n    if (pre[w]!=v) swap(next[w], pre[w]);\n    if (cnt[opreator^1]&gt;cnt[opreator])cnt[opreator^1]--;\n    if (pos[opreator^1]==v)pos[opreator^1]=u;\n\n    next[u]= w;pre[w]=u;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid R()\n{\n    if (cnt[1]-cnt[0]&lt;=0){printf(&quot;F\\n&quot;);return;}\n    if (cnt[1]-cnt[0]==1){printf(&quot;T\\n&quot;);return;}\n    int now=pos[0],ne=next[now],c=pos[1],d=next[c];\n\n    swap(pre[ne], next[ne]);swap(pre[c],next[c]);\n    next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne;\n    pos[1]=ne;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid show()\n{\n    int u=1;\n    while(true)\n    {\n        if(pre[next[u]]!= u)swap(pre[next[u]],next[next[u]]);\n        u=next[u];\n        if (u==2)break;\n        putchar(ch[u]);\n    }\n    printf(&quot;\\n&quot;);\n}\n\nvoid init()\n{\n    tot=2;\n    pre[1]=-1;next[1]= 2;\n    pre[2]=1;next[2]=-1;\n    pos[0]=pos[1]=cnt[0]=cnt[1]=1;\n    int len=strlen(str);\n    for(int i=0;i&lt;len;i++)\n    {\n        ++tot;\n        ch[tot]=str[i];\n        pre[tot]= i==0?1:tot-1;\n        next[tot]= i==len-1?2:tot+1;\n    }\n    if(len&gt;0)\n    {\n        next[1]=3;pre[2]=tot;\n        pos[1]=tot;cnt[1]=len+1;\n    }\n}\n\nint act()\n{\n    if(opreator==&#39;&lt;&#39;)         ll(move());\n    if(opreator==&#39;&gt;&#39;)         rl(move());\n    if(opreator==&#39;I&#39;)\n    {\n        int d=move();\n        char c=getchar();\n        while (c&lt;33||c&gt;126)c=getchar();\n        in(d,c);\n    }\n    if (opreator==&#39;D&#39;)         D(move());\n    if (opreator==&#39;R&#39;)         R();\n    if (opreator==&#39;S&#39;)         show();\n}\nint main()\n{\n//    freopen(&quot;editor.in&quot;,&quot;r&quot;, stdin);\n//    freopen(&quot;editor.out&quot;,&quot;w&quot;, stdout);\n    scanf(&quot;%s&quot;,str);\n    init();\n    scanf(&quot;%d&quot;,&amp;m);\n    for (int i=1;i&lt;=m;i++)\n    {\n        getchar();\n        opreator=getchar();\n        while (opreator!=&#39;&lt;&#39;&amp;&amp; opreator!=&#39;&gt;&#39;&amp;&amp;!(opreator &gt;=&#39;A&#39;&amp;&amp; opreator &lt;=&#39;Z&#39;))opreator=getchar();\n        act();\n    }\n    return 0;\n}\n</code></pre><hr>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/17/NOIP模拟赛 2017 3 17/","excerpt":"","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"https://prostkhala.github.io/categories/NOIP模拟赛/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://prostkhala.github.io/tags/二分答案/"},{"name":"计算几何","slug":"计算几何","permalink":"https://prostkhala.github.io/tags/计算几何/"},{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"链表","slug":"链表","permalink":"https://prostkhala.github.io/tags/链表/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://prostkhala.github.io/tags/树链剖分/"}]},{"title":"病毒侵袭","date":"2017-03-17T02:21:17.000Z","path":"2017/03/17/病毒入侵/","text":"病毒侵袭hdu 2896 题目描述当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~ 但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。 万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~ 输入输出格式输入格式：第一行，一个整数N（1&lt;=N&lt;=500），表示病毒特征码的个数。 接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。每个病毒都有一个编号，依此为1—N。 不同编号的病毒特征码不会相同。 在这之后一行，有一个整数M（1&lt;=M&lt;=1000），表示网站数。 接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。 每个网站都有一个编号，依此为1—M。 以上字符串中字符都是ASCII码可见字符（不包括回车）。 输出格式：依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。 web 网站编号: 病毒编号 病毒编号 … 冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。 最后一行输出统计信息，如下格式 total: 带病毒网站数 (冒号后有一个空格) 输入输出样例输入样例#1：3 aaa bbb ccc 2 aaabbbccc bbaacc 输出样例#1：web 1: 1 2 3 total: 1 AC自动机模板题CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N=501*201+5; const int maxf = 128; int ans[1001],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N]; char s[10001]; bool use[N]; void insert(int noww) { int n=strlen(s),now=0; for(int i=0;i&lt;n;++i) { if(tr[now][s[i]]==-1) { tr[now][s[i]]=++tot; for(int j=0;j&lt;maxf;++j)tr[tot][j]=-1; tag[tot]=0; } now=tr[now][s[i]]; } tag[now]=noww; } void getfail() { queue&lt;int&gt;q; fail[0]=0; for(int i=0;i&lt;maxf;++i) if(tr[0][i]!=-1) fail[tr[0][i]]=0,q.push(tr[0][i]); else tr[0][i]=0; while(!q.empty()) { int x=q.front();q.pop(); for(int j=0;j&lt;maxf;++j) if(tr[x][j]!=-1) {q.push(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];} else tr[x][j]=tr[fail[x]][j]; } } void solve(int noww) { int n=strlen(s),now=0; memset(use,0,sizeof(use)); tmp=0; for(int i=0;i&lt;n;++i) { now=tr[now][s[i]]; for(int j=now;j;j=fail[j]) if(tag[j]&amp;&amp;!use[tag[j]]) ans[++tmp]=tag[j],use[tag[j]]=1; } if(tmp) { ans2++; printf(&quot;web %d:&quot;,noww); sort(ans+1,ans+tmp+1); for(int j=1;j&lt;=tmp;++j) printf(&quot; %d&quot;,ans[j]); printf(&quot;\\n&quot;); } } int main() { int n,m; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;maxf;++i)tr[0][i]=-1; for(int i=1;i&lt;=n;++i) scanf(&quot;%s&quot;,s),insert(i); getfail(); scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;++i) scanf(&quot;%s&quot;,s),solve(i); printf(&quot;total: %d\\n&quot;,ans2); }","raw":"title: 病毒侵袭\ndate: 2017-03-17 10:21:17\ncategories:\n  - Hollerith-type\n  - AC自动机\ntags:\n  - AC自动机\n  - 模板\n  - KMP\n---\n\n# 病毒侵袭\n\n## [hdu 2896](http://acm.hdu.edu.cn/showproblem.php?pid=2896)\n\n---\n## 题目描述\n\n当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~\n\n但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。\n\n万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~\n### 输入输出格式\n#### 输入格式：\n第一行，一个整数N（1<=N<=500），表示病毒特征码的个数。\n\n接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。\n每个病毒都有一个编号，依此为1—N。\n\n不同编号的病毒特征码不会相同。\n\n在这之后一行，有一个整数M（1<=M<=1000），表示网站数。\n\n接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。\n\n每个网站都有一个编号，依此为1—M。\n\n以上字符串中字符都是ASCII码可见字符（不包括回车）。\n#### 输出格式：\n依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。\n\nweb 网站编号: 病毒编号 病毒编号 …\n\n冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。\n\n最后一行输出统计信息，如下格式\n\ntotal: 带病毒网站数\n\n(冒号后有一个空格)\n\n\n### 输入输出样例\n#### 输入样例#1：\n    3\n    aaa\n    bbb\n    ccc\n    2\n    aaabbbccc\n    bbaacc\n\n\n    \n\n#### 输出样例#1：\n\n    web 1: 1 2 3\n\ttotal: 1\n\n---\nAC自动机模板题\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<queue>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N=501*201+5;\n    const int maxf = 128;\n    int ans[1001],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N];\n    char s[10001];\n    bool use[N];\n    void insert(int noww)\n    {\n        int n=strlen(s),now=0;\n        for(int i=0;i<n;++i)\n        {\n            if(tr[now][s[i]]==-1)\n            {\n                tr[now][s[i]]=++tot;\n                for(int j=0;j<maxf;++j)tr[tot][j]=-1;\n                tag[tot]=0;\n            }\n            now=tr[now][s[i]];\n        }\n        tag[now]=noww;\n    }\n    void getfail()\n    {\n        queue<int>q;\n        fail[0]=0;\n        for(int i=0;i<maxf;++i)\n        if(tr[0][i]!=-1)\n        fail[tr[0][i]]=0,q.push(tr[0][i]);\n        else tr[0][i]=0;\n        while(!q.empty())\n        {\n            int x=q.front();q.pop();\n            for(int j=0;j<maxf;++j)\n            if(tr[x][j]!=-1)\n            {q.push(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];}\n            else\n            tr[x][j]=tr[fail[x]][j];\n        }\n    }\n    void solve(int noww)\n    {\n        int n=strlen(s),now=0;\n        memset(use,0,sizeof(use));\n        tmp=0;\n        for(int i=0;i<n;++i)\n        {\n            now=tr[now][s[i]];\n            for(int j=now;j;j=fail[j])\n            if(tag[j]&&!use[tag[j]])\n            ans[++tmp]=tag[j],use[tag[j]]=1;\n        }\n        if(tmp)\n        {\n            ans2++;\n            printf(\"web %d:\",noww);\n            sort(ans+1,ans+tmp+1);\n            for(int j=1;j<=tmp;++j)\n            printf(\" %d\",ans[j]);\n            printf(\"\\n\");\n        }\n    }\n    int main()\n    {\n        int n,m;\n        scanf(\"%d\",&n);\n        for(int i=0;i<maxf;++i)tr[0][i]=-1;\n        for(int i=1;i<=n;++i)\n        scanf(\"%s\",s),insert(i);\n        getfail();\n        scanf(\"%d\",&m);\n        for(int i=1;i<=m;++i)\n        scanf(\"%s\",s),solve(i);\n            printf(\"total: %d\\n\",ans2);\n    }","content":"<h1 id=\"病毒侵袭\"><a href=\"#病毒侵袭\" class=\"headerlink\" title=\"病毒侵袭\"></a>病毒侵袭</h1><h2 id=\"hdu-2896\"><a href=\"#hdu-2896\" class=\"headerlink\" title=\"hdu 2896\"></a><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2896\" target=\"_blank\" rel=\"external\">hdu 2896</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~</p>\n<p>但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。</p>\n<p>万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行，一个整数N（1&lt;=N&lt;=500），表示病毒特征码的个数。</p>\n<p>接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。<br>每个病毒都有一个编号，依此为1—N。</p>\n<p>不同编号的病毒特征码不会相同。</p>\n<p>在这之后一行，有一个整数M（1&lt;=M&lt;=1000），表示网站数。</p>\n<p>接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。</p>\n<p>每个网站都有一个编号，依此为1—M。</p>\n<p>以上字符串中字符都是ASCII码可见字符（不包括回车）。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。</p>\n<p>web 网站编号: 病毒编号 病毒编号 …</p>\n<p>冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。</p>\n<p>最后一行输出统计信息，如下格式</p>\n<p>total: 带病毒网站数</p>\n<p>(冒号后有一个空格)</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>3\naaa\nbbb\nccc\n2\naaabbbccc\nbbaacc\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>web 1: 1 2 3\ntotal: 1\n</code></pre><hr>\n<h2 id=\"AC自动机模板题\"><a href=\"#AC自动机模板题\" class=\"headerlink\" title=\"AC自动机模板题\"></a>AC自动机模板题</h2><h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;queue&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N=501*201+5;\nconst int maxf = 128;\nint ans[1001],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N];\nchar s[10001];\nbool use[N];\nvoid insert(int noww)\n{\n    int n=strlen(s),now=0;\n    for(int i=0;i&lt;n;++i)\n    {\n        if(tr[now][s[i]]==-1)\n        {\n            tr[now][s[i]]=++tot;\n            for(int j=0;j&lt;maxf;++j)tr[tot][j]=-1;\n            tag[tot]=0;\n        }\n        now=tr[now][s[i]];\n    }\n    tag[now]=noww;\n}\nvoid getfail()\n{\n    queue&lt;int&gt;q;\n    fail[0]=0;\n    for(int i=0;i&lt;maxf;++i)\n    if(tr[0][i]!=-1)\n    fail[tr[0][i]]=0,q.push(tr[0][i]);\n    else tr[0][i]=0;\n    while(!q.empty())\n    {\n        int x=q.front();q.pop();\n        for(int j=0;j&lt;maxf;++j)\n        if(tr[x][j]!=-1)\n        {q.push(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];}\n        else\n        tr[x][j]=tr[fail[x]][j];\n    }\n}\nvoid solve(int noww)\n{\n    int n=strlen(s),now=0;\n    memset(use,0,sizeof(use));\n    tmp=0;\n    for(int i=0;i&lt;n;++i)\n    {\n        now=tr[now][s[i]];\n        for(int j=now;j;j=fail[j])\n        if(tag[j]&amp;&amp;!use[tag[j]])\n        ans[++tmp]=tag[j],use[tag[j]]=1;\n    }\n    if(tmp)\n    {\n        ans2++;\n        printf(&quot;web %d:&quot;,noww);\n        sort(ans+1,ans+tmp+1);\n        for(int j=1;j&lt;=tmp;++j)\n        printf(&quot; %d&quot;,ans[j]);\n        printf(&quot;\\n&quot;);\n    }\n}\nint main()\n{\n    int n,m;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;maxf;++i)tr[0][i]=-1;\n    for(int i=1;i&lt;=n;++i)\n    scanf(&quot;%s&quot;,s),insert(i);\n    getfail();\n    scanf(&quot;%d&quot;,&amp;m);\n    for(int i=1;i&lt;=m;++i)\n    scanf(&quot;%s&quot;,s),solve(i);\n        printf(&quot;total: %d\\n&quot;,ans2);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/17/病毒入侵/","excerpt":"","categories":[{"name":"Hollerith-type","slug":"Hollerith-type","permalink":"https://prostkhala.github.io/categories/Hollerith-type/"},{"name":"AC自动机","slug":"Hollerith-type/AC自动机","permalink":"https://prostkhala.github.io/categories/Hollerith-type/AC自动机/"}],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://prostkhala.github.io/tags/AC自动机/"},{"name":"模板","slug":"模板","permalink":"https://prostkhala.github.io/tags/模板/"},{"name":"KMP","slug":"KMP","permalink":"https://prostkhala.github.io/tags/KMP/"}]},{"title":"HAOI2007 理想的正方形","date":"2017-03-14T07:36:17.000Z","path":"2017/03/14/理想的正方形/","text":"[HAOI2007] 理想的正方形BZOJ1047 洛谷2216 题目描述有一个ab的整数组成的矩阵，现请你从中找出一个nn的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 输入输出格式输入格式：第一行为3个整数，分别表示a,b,n的值 第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。 输出格式：仅一个整数，为ab矩阵中所有“nn正方形区域中的最大整数和最小整数的差值”的最小值。 输入输出样例输入样例：5 4 2 1 2 5 6 0 17 16 0 16 17 2 1 2 10 2 1 1 2 2 2 输出样例：1 数据范围矩阵中的所有数都不超过1,000,000,000 20%的数据2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10 100%的数据2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100 题解二维滑动窗口，先对每一行建立双端队列，记录每一个$1n$的长方体中的极值，将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n1$的长方体(在原矩阵中为nn的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的nn正方形的极值信息)，枚举即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int inf = 0x7fffffff; const int N =1e3+1; inline int get(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N]; int y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N]; int mapp[N][N],a,b,n; long long ans=inf; int main() { get(a),get(b),get(n); for(int i=1;i&lt;=a;++i)for(int t=1;t&lt;=b;++t)get(mapp[i][t]); for(int i=1;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1; for(int i=1;i&lt;=a;++i) for(int t=1;t&lt;=b;++t) { while(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--; x1[++tailx1[i]]=t; while(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++; minx[i][t]=mapp[i][x1[headx1[i]]]; } for(int i=1;i&lt;=a;++i) for(int t=1;t&lt;=b;++t) { while(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--; x2[++tailx2[i]]=t; while(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++; maxx[i][t]=mapp[i][x2[headx2[i]]]; } for(int t=n;t&lt;=b;++t) for(int i=1;i&lt;=a;++i) { while(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--; y1[++taily1[t]]=i; while(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++; miny[i][t]=minx[y1[heady1[t]]][t]; } for(int t=n;t&lt;=b;++t) for(int i=1;i&lt;=a;++i) { while(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--; y2[++taily2[t]]=i; while(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++; maxy[i][t]=maxx[y2[heady2[t]]][t]; } for(int t=n;t&lt;=b;++t) for(int i=n;i&lt;=a;++i) if(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t]; printf(&quot;%lld&quot;,ans); }","raw":"title: HAOI2007 理想的正方形\ndate: 2017-03-14 15:36:17\ncategories:\n  - 动态规划\n  - 单调性优化\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n---\n\n# [HAOI2007] 理想的正方形\n\n## [BZOJ1047](http://www.lydsy.com/JudgeOnline/problem.php?id=1047) [洛谷2216](https://www.luogu.org/problem/show?pid=2216)\n\n---\n## 题目描述\n\n有一个a*b的整数组成的矩阵，现请你从中找出一个n*n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。\n\n### 输入输出格式\n#### 输入格式：\n第一行为3个整数，分别表示a,b,n的值\n\n第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。\n\n\n#### 输出格式：\n仅一个整数，为a*b矩阵中所有“n*n正方形区域中的最大整数和最小整数的差值”的最小值。\n\n\n### 输入输出样例\n#### 输入样例：\n    5 4 2\n    1 2 5 6\n    0 17 16 0\n    16 17 2 1\n    2 10 2 1\n    1 2 2 2\n    \n\n#### 输出样例：\n\t1\n    \n\n### 数据范围\n矩阵中的所有数都不超过1,000,000,000\n\n20%的数据2<=a,b<=100,n<=a,n<=b,n<=10\n\n100%的数据2<=a,b<=1000,n<=a,n<=b,n<=100\n\n---\n\n## 题解\n二维滑动窗口，先对每一行建立双端队列，记录每一个$1*n$的长方体中的极值，\n将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n*1$的长方体(在原矩阵中为n*n的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的n*n正方形的极值信息)，枚举即可。\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<queue>\n    using namespace std;\n    const int inf = 0x7fffffff;\n    const int N =1e3+1;\n    inline int get(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];\n    int y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];\n    int mapp[N][N],a,b,n;\n    long long ans=inf;\n    int main()\n    {\n\n        get(a),get(b),get(n);\n        for(int i=1;i<=a;++i)for(int t=1;t<=b;++t)get(mapp[i][t]);\n        for(int i=1;i<N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1;\n        for(int i=1;i<=a;++i)\n        for(int t=1;t<=b;++t)\n        {\n            while(headx1[i]<=tailx1[i]&&mapp[i][x1[tailx1[i]]]>=mapp[i][t])tailx1[i]--;\n            x1[++tailx1[i]]=t;\n            while(headx1[i]<=tailx1[i]&&x1[headx1[i]]<=t-n)headx1[i]++;\n            minx[i][t]=mapp[i][x1[headx1[i]]];\n        }\n        for(int i=1;i<=a;++i)\n        for(int t=1;t<=b;++t)\n        {\n            while(headx2[i]<=tailx2[i]&&mapp[i][x2[tailx2[i]]]<=mapp[i][t])tailx2[i]--;\n            x2[++tailx2[i]]=t;\n            while(headx2[i]<=tailx2[i]&&x2[headx2[i]]<=t-n)headx2[i]++;\n            maxx[i][t]=mapp[i][x2[headx2[i]]];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=1;i<=a;++i)\n        {\n            while(heady1[t]<=taily1[t]&&minx[y1[taily1[t]]][t]>=minx[i][t])taily1[t]--;\n            y1[++taily1[t]]=i;\n            while(heady1[t]<=taily1[t]&&y1[heady1[t]]<=i-n)heady1[t]++;\n            miny[i][t]=minx[y1[heady1[t]]][t];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=1;i<=a;++i)\n        {\n            while(heady2[t]<=taily2[t]&&maxx[y2[taily2[t]]][t]<=maxx[i][t])taily2[t]--;\n            y2[++taily2[t]]=i;\n            while(heady2[t]<=taily2[t]&&y2[heady2[t]]<=i-n)heady2[t]++;\n            maxy[i][t]=maxx[y2[heady2[t]]][t];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=n;i<=a;++i)\n        if(maxy[i][t]-miny[i][t]<ans)ans=maxy[i][t]-miny[i][t];\n        printf(\"%lld\",ans);\n    }","content":"<h1 id=\"HAOI2007-理想的正方形\"><a href=\"#HAOI2007-理想的正方形\" class=\"headerlink\" title=\"[HAOI2007] 理想的正方形\"></a>[HAOI2007] 理想的正方形</h1><h2 id=\"BZOJ1047-洛谷2216\"><a href=\"#BZOJ1047-洛谷2216\" class=\"headerlink\" title=\"BZOJ1047 洛谷2216\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1047\" target=\"_blank\" rel=\"external\">BZOJ1047</a> <a href=\"https://www.luogu.org/problem/show?pid=2216\" target=\"_blank\" rel=\"external\">洛谷2216</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有一个a<em>b的整数组成的矩阵，现请你从中找出一个n</em>n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行为3个整数，分别表示a,b,n的值</p>\n<p>第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>仅一个整数，为a<em>b矩阵中所有“n</em>n正方形区域中的最大整数和最小整数的差值”的最小值。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>5 4 2\n1 2 5 6\n0 17 16 0\n16 17 2 1\n2 10 2 1\n1 2 2 2\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>1\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>矩阵中的所有数都不超过1,000,000,000</p>\n<p>20%的数据2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10</p>\n<p>100%的数据2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>二维滑动窗口，先对每一行建立双端队列，记录每一个$1<em>n$的长方体中的极值，<br>将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n</em>1$的长方体(在原矩阵中为n<em>n的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的n</em>n正方形的极值信息)，枚举即可。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int inf = 0x7fffffff;\nconst int N =1e3+1;\ninline int get(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];\nint y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];\nint mapp[N][N],a,b,n;\nlong long ans=inf;\nint main()\n{\n\n    get(a),get(b),get(n);\n    for(int i=1;i&lt;=a;++i)for(int t=1;t&lt;=b;++t)get(mapp[i][t]);\n    for(int i=1;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1;\n    for(int i=1;i&lt;=a;++i)\n    for(int t=1;t&lt;=b;++t)\n    {\n        while(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--;\n        x1[++tailx1[i]]=t;\n        while(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++;\n        minx[i][t]=mapp[i][x1[headx1[i]]];\n    }\n    for(int i=1;i&lt;=a;++i)\n    for(int t=1;t&lt;=b;++t)\n    {\n        while(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--;\n        x2[++tailx2[i]]=t;\n        while(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++;\n        maxx[i][t]=mapp[i][x2[headx2[i]]];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=1;i&lt;=a;++i)\n    {\n        while(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--;\n        y1[++taily1[t]]=i;\n        while(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++;\n        miny[i][t]=minx[y1[heady1[t]]][t];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=1;i&lt;=a;++i)\n    {\n        while(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--;\n        y2[++taily2[t]]=i;\n        while(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++;\n        maxy[i][t]=maxx[y2[heady2[t]]][t];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=n;i&lt;=a;++i)\n    if(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t];\n    printf(&quot;%lld&quot;,ans);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/14/理想的正方形/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"},{"name":"单调性优化","slug":"动态规划/单调性优化","permalink":"https://prostkhala.github.io/categories/动态规划/单调性优化/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"}]},{"title":"NOIP模拟赛 2017 3 12","date":"2017-03-13T10:01:11.000Z","path":"2017/03/13/NOIP模拟赛 2017 3 12/","text":"T1 Blue题目描述Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。 他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。 当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。 输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。 输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。 样例输入5 10 9 16 30 2 4 6 9 11 15 18 19 25 27 10 1 23 30 10 11 13 14 15 16 18 26 27 29 10 7 28 30 2 3 7 9 12 15 20 24 27 28 10 3 18 30 1 6 9 14 18 19 22 27 28 29 10 7 10 30 1 2 4 6 18 19 20 22 23 26 样例输出5 Excited Excited Excited 0 数据范围对于 10%的数据保证 $m=1$. 对于另外 10%的数据保证 $D=L$. 对于另外 10%的数据保证 $n=L-1$. 对于另外 30%的数据保证 $n&lt;=100, L&lt;=10^5$. 对于 100%的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$.数据范围中的 n、m 皆代表题目描述中 n、m 的总和。 题解这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。 具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了…. CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N =1e6+1; inline void read(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int tt,n,m,d,l,a[N],b[N]; bool can(int ans) { for(int i=1;i&lt;=ans;++i)b[i]=0; int anss=0; for(int now=1;now&lt;=n;++now) { if(a[now]-b[++anss]&lt;=d)b[anss]=a[now]; if(anss==ans)anss=0; } for(int i=1;i&lt;=ans;++i) if(l-b[i]&gt;d)return 0; return 1; } int main() { // freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout); read(tt); while(tt--) { read(n),read(m),read(d),read(l); for(int i=1;i&lt;=n;++i)read(a[i]); int ll=0,rr=m,mid; while(ll!=rr) { mid=ll+rr+1&gt;&gt;1; if(can(mid)) ll=mid; else rr=mid-1; } if(rr==m) printf(&quot;Excited\\n&quot;); else printf(&quot;%d\\n&quot;,rr); } return 0; } T2 Weed题目描述duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。 电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上面没有金坷垃了。 duyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最终金坷垃的量有多少。 输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，后面 2 个数描述更改为这样的操作。 输出 q 行代表每次金坷垃的量为多少 样例输入10 5 0 10 1 5 0 13 0 18 0 2 1 1 0 8 0 9 1 3 0 7 9 0 3 10 1 7 6 0 8 10 0 5 8 1 2 样例输出58 0 0 66 41 数据范围对于 30%的数据，m&lt;=1000,q&lt;=1000. 对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。 对于 100%的数据，m&lt;=210^5,q&lt;=210^5,vi&lt;=10^4. 题解由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现… 题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; inline void read(int &amp;x) { x=0;int f=1;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} x*=f; } const int N =2e5+7; struct build{int sum,in,out;}tr[8*N]; int n,q,k,a[N],tot; int find(int x,int pot) { if(pot&gt;=tr[x].in) return 0; if(!pot) return tr[x].sum; if(pot&lt;=tr[x*2+1].in) return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot); return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out); } void update(int x) { tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out); tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in); tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out); } void build(int x,int l,int r) { if(l==r) { if(a[l]&lt;0) tr[x].out=-a[l]; else tr[x].in=1,tr[x].sum=a[l]; } else { int mid=l+r&gt;&gt;1; build(x*2,l,mid); build(x*2+1,mid+1,r); update(x); } } void change(int x,int pot,int w,int l,int r) { if(l==r) { memset(&amp;tr[x],0,sizeof(tr[x])); if(w&lt;0) tr[x].out=-w; else tr[x].in=1,tr[x].sum=w; } else { int mid=l+r&gt;&gt;1; if(pot&gt;mid) change(x*2+1,pot,w,mid+1,r); else change(x*2,pot,w,l,mid); update(x); } } int main() { // freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout); read(n),read(q); for(int i=1;i&lt;=n;++i) { read(k),read(a[i]); if(k)a[i]*=-1; } build(1,1,n); while(q--) { int x,w; read(x);read(k);read(w); if(k)w*=-1; change(1,x,w,1,n); printf(&quot;%d\\n&quot;,tr[1].sum); } } T3 Drink题目描述在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚不到这么多资本），所以决定用特殊的方法赏赐毒液哥。 Link的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财的他想知道最后棋盘内所有的宝物价值以方便他挑选。 作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）和资产阶级代表（Link）之间的贫富差距么。 输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c的正方形。 输出一个 N * M 的矩阵表示最后的棋盘。 样例输入4 4 3 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 1 3 3 3 2 2 2 2 样例输出1 5 1 4 2 7 6 8 3 7 2 3 5 6 8 4 数据范围对于 30%的数据，N, M, Q &lt;= 100. 对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。 对于 100%的数据, N, M, Q &lt;= 1000.所有数取值都为 0~9. 题解以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。 CODE/* * @Author: 閫搁棽 * @Date: 2016-09-25 13:04:44 * @Last Modified by: 閫搁棽 * @Last Modified time: 2016-10-01 10:19:00 */ #include &quot;cstdio&quot; #include &quot;cstdlib&quot; #include &quot;iostream&quot; #include &quot;algorithm&quot; #include &quot;cstring&quot; #include &quot;queue&quot; using namespace std; #define INF 0x3F3F3F3F #define MAX_SIZE 2005 #define Eps #define Mod #define Get(x, a) (x ? x -&gt; a : 0) #define Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it) inline int Get_Int() { int Num = 0, Flag = 1; char ch; do { ch = getchar(); if(ch == &#39;-&#39;) Flag = -Flag; } while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;); do { Num = Num * 10 + ch - &#39;0&#39;; ch = getchar(); } while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return Num * Flag; } int N, M, Q; int A[MAX_SIZE * MAX_SIZE][4], Map[MAX_SIZE][MAX_SIZE]; inline void Move(int &amp;Direction, int &amp;Now, int j) { int Next = A[Now][j - Direction + 4 &amp; 3]; for(Direction = 0; A[Next][j - Direction + 6 &amp; 3] != Now; ++Direction); Now = Next; } int main() { #ifndef ONLINE_JUDGE // freopen(&quot;drink.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;drink.out&quot;, &quot;w&quot;, stdout); #endif cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q; for(int i = 1; i &lt;= N; ++i) for(int j = 1; j &lt;= M; ++j) Map[i][j] = Get_Int(); for(int i = 1; i &lt;= (N + 2) * (M + 2); ++i) { A[i][0] = i - M - 2; A[i][1] = i + 1; A[i][2] = i + M + 2; A[i][3] = i - 1; } while(Q--) { int x = Get_Int(), y = Get_Int(), c = Get_Int(); int Direction = 0, Now = 1; vector&lt; pair&lt;int, int&gt; &gt; Border[4][2]; for(int i = 1; i &lt;= x; ++i) Move(Direction, Now, 2); for(int i = 1; i &lt;= y; ++i) Move(Direction, Now, 1); for(int j = 0; j &lt; 4; ++j) for(int i = 1; i &lt;= c; ++i) { Border[j][0].push_back(make_pair(Direction, Now)); Move(Direction, Now, j); Border[j][1].push_back(make_pair(Direction, Now)); Move(Direction, Now, j + 2 &amp; 3); if(i != c) Move(Direction, Now, j + 1 &amp; 3); } for(int j = 0; j &lt; 4; ++j) for(int i = 0; i &lt; c; ++i) { pair&lt;int, int&gt; Now = Border[j][1][i]; A[Now.second][j + 6 - Now.first &amp; 3] = Border[j + 3 &amp; 3][0][i].second; Now = Border[j][0][i]; A[Now.second][j + 4 - Now.first &amp; 3] = Border[j + 1 &amp; 3][1][i].second; } } int Direction = 0, Now = 1; for(int i = 1; i &lt;= N; ++i) { Move(Direction, Now, 2); int temp = Direction, Next = Now; for(int j = 1; j &lt;= M; ++j) { Move(temp, Next, 1); printf(&quot;%d &quot;, Map[(Next - 1) / (M + 2)][(Next - 1) % (M + 2)]); } printf(&quot;\\n&quot;); } fclose(stdin); fclose(stdout); return 0; }","raw":"title: NOIP模拟赛 2017 3 12\ndate: 2017-03-13 18:01:11\ncategories:\n  - NOIP模拟赛\ntags:\n  - 二分答案\n  - 贪心\n  - 线段树\n  - 二维线段树\n---\n\n## T1 Blue\n### 题目描述\nBlue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。\n\n他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)\n中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。\n\n当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就\n会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。\n\n输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。\n第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。\n\n输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。\n\n\n#### 样例输入\n    5\n    10 9 16 30\n    2 4 6 9 11 15 18 19 25 27 \n    10 1 23 30\n    10 11 13 14 15 16 18 26 27 29 \n    10 7 28 30\n    2 3 7 9 12 15 20 24 27 28 \n    10 3 18 30\n    1 6 9 14 18 19 22 27 28 29 \n    10 7 10 30\n    1 2 4 6 18 19 20 22 23 26 \n#### 样例输出\n    5\n    Excited\n    Excited\n    Excited\n    0\n#### 数据范围\n对于 10%的数据保证 $m=1$.\n\n对于另外 10%的数据保证 $D=L$.\n\n对于另外 10%的数据保证 $n=L-1$.\n\n对于另外 30%的数据保证 $n<=100, L<=10^5$.\n\n对于 100%的数据保证 $m<=n<=10^6,D<=L<=10^9$.\n数据范围中的 n、m 皆代表题目描述中 n、m 的总和。\n\n---\n### 题解\n\n这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D<=L<=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。\n\n具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了....\n\n---\n#### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N =1e6+1;\n    inline void read(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int tt,n,m,d,l,a[N],b[N];\n    bool can(int ans)\n    {\n        for(int i=1;i<=ans;++i)b[i]=0;\n        int anss=0;\n        for(int now=1;now<=n;++now)\n        {\n            if(a[now]-b[++anss]<=d)b[anss]=a[now];\n            if(anss==ans)anss=0;\n        }\n        for(int i=1;i<=ans;++i)\n        if(l-b[i]>d)return 0;\n        return 1;\n    }\n    int main()\n    {\n    //    freopen(\"Blue.in\",\"r\",stdin);\n    //    freopen(\"Blue.out\",\"w\",stdout);\n        read(tt);\n        while(tt--)\n        {\n            read(n),read(m),read(d),read(l);\n            for(int i=1;i<=n;++i)read(a[i]);\n            int ll=0,rr=m,mid;\n            while(ll!=rr)\n            {\n                mid=ll+rr+1>>1;\n                if(can(mid))\tll=mid;\n                else\t\t\trr=mid-1;\n            }\n            if(rr==m)\tprintf(\"Excited\\n\");\n            else \t\tprintf(\"%d\\n\",rr);\n        }\n        return 0;\n    }\n\n\n---\n## T2 Weed\n### 题目描述\nduyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。\n为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。\n\n电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最\n新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上\n面没有金坷垃了。\n\nduyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行\n了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最\n终金坷垃的量有多少。\n\n输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，\n为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，\n后面 2 个数描述更改为这样的操作。\n\n输出 q 行代表每次金坷垃的量为多少\n#### 样例输入\n    10 5\n    0 10\n    1 5\n    0 13\n    0 18\n    0 2\n    1 1\n    0 8\n    0 9\n    1 3\n    0 7\n    9 0 3\n    10 1 7\n    6 0 8\n    10 0 5\n    8 1 2\n\n\n#### 样例输出\n    58\n    0\n    0\n    66\n    41\n\n#### 数据范围\n对于 30%的数据，m<=1000,q<=1000.\n\n对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。\n\n对于 100%的数据，m<=2*10^5,q<=2*10^5,vi<=10^4.\n\n---\n### 题解\n由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现...\n\n题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    inline void read(int &x)\n    {\n        x=0;int f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n        x*=f;\n    }\n    const int N =2e5+7;\n    struct build{int sum,in,out;}tr[8*N];\n    int n,q,k,a[N],tot;\n    int find(int x,int pot)\n    {\n        if(pot>=tr[x].in)\t\t\treturn 0;\n        if(!pot)\t\t\t\t\treturn tr[x].sum;\n        if(pot<=tr[x*2+1].in)\n        return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot);\n        return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out);\n    }\n    void update(int x)\n    {\n        tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out);\n        tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in);\n        tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out);\n    }\n    void build(int x,int l,int r)\n    {\n        if(l==r)\n        {\n            if(a[l]<0)\ttr[x].out=-a[l];\n            else\t\ttr[x].in=1,tr[x].sum=a[l];\n        }\n        else\n        {\n            int mid=l+r>>1;\n            build(x*2,l,mid);\n            build(x*2+1,mid+1,r);\n            update(x);\n        }\n    }\n    void change(int x,int pot,int w,int l,int r)\n    {\n        if(l==r)\n        {\n            memset(&tr[x],0,sizeof(tr[x]));\n            if(w<0)\t\ttr[x].out=-w;\n            else\t\ttr[x].in=1,tr[x].sum=w;\n        }\n        else\n        {\n            int mid=l+r>>1;\n            if(pot>mid)\tchange(x*2+1,pot,w,mid+1,r);\n            else\t\tchange(x*2,pot,w,l,mid);\n            update(x);\n        }\n    }\n    int main()\n    {\n    //    freopen(\"weed.in\", \"r\", stdin);\n    //    freopen(\"weed.out\", \"w\", stdout);\n        read(n),read(q);\n        for(int i=1;i<=n;++i)\n        {\n            read(k),read(a[i]);\n            if(k)a[i]*=-1;\n        }\n        build(1,1,n);\n        while(q--)\n        {\n            int x,w;\n            read(x);read(k);read(w);\n            if(k)w*=-1;\n            change(1,x,w,1,n);\n            printf(\"%d\\n\",tr[1].sum);\n        }\n    }\n---\n## T3 Drink\n### 题目描述\n在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份\n丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚\n不到这么多资本），所以决定用特殊的方法赏赐毒液哥。\n\nLink的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，\n每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。\n毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财\n的他想知道最后棋盘内所有的宝物价值以方便他挑选。\n\n作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）\n和资产阶级代表（Link）之间的贫富差距么。\n\n输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。\n接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。\n接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c\n的正方形。\n\n输出一个 N * M 的矩阵表示最后的棋盘。\n#### 样例输入\n    4 4 3\n    1 2 3 4\n    5 6 7 8\n    1 2 3 4\n    5 6 7 8\n    1 1 3\n    3 3 2\n    2 2 2\n\n\n#### 样例输出\n    1 5 1 4 \n    2 7 6 8 \n    3 7 2 3 \n    5 6 8 4 \n\n#### 数据范围\n对于 30%的数据，N, M, Q <= 100.\n\n对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。\n\n对于 100%的数据, N, M, Q <= 1000.所有数取值都为 0~9.\n\n---\n### 题解\n以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。\n\n### CODE\n\n    /*\n    * @Author: 閫搁棽\n    * @Date:   2016-09-25 13:04:44\n    * @Last Modified by:   閫搁棽\n    * @Last Modified time: 2016-10-01 10:19:00\n    */\n\n    #include \"cstdio\"\n    #include \"cstdlib\"\n    #include \"iostream\"\n    #include \"algorithm\"\n    #include \"cstring\"\n    #include \"queue\"\n\n    using namespace std;\n\n    #define INF 0x3F3F3F3F\n    #define MAX_SIZE 2005\n    #define Eps\n    #define Mod\n    #define Get(x, a) (x ? x -> a : 0)\n    #define Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it)\n\n    inline int Get_Int()\n    {\n        int Num = 0, Flag = 1;\n        char ch;\n        do\n        {\n            ch = getchar();\n            if(ch == '-')\n                Flag = -Flag;\n        }\n        while(ch < '0' || ch > '9');\n        do\n        {\n            Num = Num * 10 + ch - '0';\n            ch = getchar();\n        }\n        while(ch >= '0' && ch <= '9');\n        return Num * Flag;\n    }\n\n    int N, M, Q;\n    int A[MAX_SIZE * MAX_SIZE][4], Map[MAX_SIZE][MAX_SIZE];\n\n    inline void Move(int &Direction, int &Now, int j)\n    {\n        int Next = A[Now][j - Direction + 4 & 3];\n        for(Direction = 0; A[Next][j - Direction + 6 & 3] != Now; ++Direction);\n        Now = Next;\n    }\n\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n    //\tfreopen(\"drink.in\", \"r\", stdin);\n    //\tfreopen(\"drink.out\", \"w\", stdout);\n    #endif\n        cin >> N >> M >> Q;\n        for(int i = 1; i <= N; ++i)\n            for(int j = 1; j <= M; ++j)\n                Map[i][j] = Get_Int();\n        for(int i = 1; i <= (N + 2) * (M + 2); ++i)\n        {\n            A[i][0] = i - M - 2;\n            A[i][1] = i + 1;\n            A[i][2] = i + M + 2;\n            A[i][3] = i - 1;\n        }\n        while(Q--)\n        {\n            int x = Get_Int(), y = Get_Int(), c = Get_Int();\n            int Direction = 0, Now = 1;\n            vector< pair<int, int> > Border[4][2];\n            for(int i = 1; i <= x; ++i)\n                Move(Direction, Now, 2);\n            for(int i = 1; i <= y; ++i)\n                Move(Direction, Now, 1);\n            for(int j = 0; j < 4; ++j)\n                for(int i = 1; i <= c; ++i)\n                {\n                    Border[j][0].push_back(make_pair(Direction, Now));\n                    Move(Direction, Now, j);\n                    Border[j][1].push_back(make_pair(Direction, Now));\n                    Move(Direction, Now, j + 2 & 3);\n                    if(i != c)\n                        Move(Direction, Now, j + 1 & 3);\n                }\n            for(int j = 0; j < 4; ++j)\n                for(int i = 0; i < c; ++i)\n                {\n                    pair<int, int> Now = Border[j][1][i];\n                    A[Now.second][j + 6 - Now.first & 3] = Border[j + 3 & 3][0][i].second;\n                    Now = Border[j][0][i];\n                    A[Now.second][j + 4 - Now.first & 3] = Border[j + 1 & 3][1][i].second;\n                }\n        }\n        int Direction = 0, Now = 1;\n        for(int i = 1; i <= N; ++i)\n        {\n            Move(Direction, Now, 2);\n            int temp = Direction, Next = Now;\n            for(int j = 1; j <= M; ++j)\n            {\n                Move(temp, Next, 1);\n                printf(\"%d \", Map[(Next - 1) / (M + 2)][(Next - 1) % (M + 2)]);\n            }\n            printf(\"\\n\");\n        }\n        fclose(stdin);\n        fclose(stdout);\n        return 0;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h2 id=\"T1-Blue\"><a href=\"#T1-Blue\" class=\"headerlink\" title=\"T1 Blue\"></a>T1 Blue</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。</p>\n<p>他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)<br>中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。</p>\n<p>当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就<br>会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。</p>\n<p>输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。<br>第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。</p>\n<p>输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。</p>\n<h4 id=\"样例输入\"><a href=\"#样例输入\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>5\n10 9 16 30\n2 4 6 9 11 15 18 19 25 27 \n10 1 23 30\n10 11 13 14 15 16 18 26 27 29 \n10 7 28 30\n2 3 7 9 12 15 20 24 27 28 \n10 3 18 30\n1 6 9 14 18 19 22 27 28 29 \n10 7 10 30\n1 2 4 6 18 19 20 22 23 26 \n</code></pre><h4 id=\"样例输出\"><a href=\"#样例输出\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>5\nExcited\nExcited\nExcited\n0\n</code></pre><h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 10%的数据保证 $m=1$.</p>\n<p>对于另外 10%的数据保证 $D=L$.</p>\n<p>对于另外 10%的数据保证 $n=L-1$.</p>\n<p>对于另外 30%的数据保证 $n&lt;=100, L&lt;=10^5$.</p>\n<p>对于 100%的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$.<br>数据范围中的 n、m 皆代表题目描述中 n、m 的总和。</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。</p>\n<p>具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了….</p>\n<hr>\n<h4 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N =1e6+1;\ninline void read(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint tt,n,m,d,l,a[N],b[N];\nbool can(int ans)\n{\n    for(int i=1;i&lt;=ans;++i)b[i]=0;\n    int anss=0;\n    for(int now=1;now&lt;=n;++now)\n    {\n        if(a[now]-b[++anss]&lt;=d)b[anss]=a[now];\n        if(anss==ans)anss=0;\n    }\n    for(int i=1;i&lt;=ans;++i)\n    if(l-b[i]&gt;d)return 0;\n    return 1;\n}\nint main()\n{\n//    freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout);\n    read(tt);\n    while(tt--)\n    {\n        read(n),read(m),read(d),read(l);\n        for(int i=1;i&lt;=n;++i)read(a[i]);\n        int ll=0,rr=m,mid;\n        while(ll!=rr)\n        {\n            mid=ll+rr+1&gt;&gt;1;\n            if(can(mid))    ll=mid;\n            else            rr=mid-1;\n        }\n        if(rr==m)    printf(&quot;Excited\\n&quot;);\n        else         printf(&quot;%d\\n&quot;,rr);\n    }\n    return 0;\n}\n</code></pre><hr>\n<h2 id=\"T2-Weed\"><a href=\"#T2-Weed\" class=\"headerlink\" title=\"T2 Weed\"></a>T2 Weed</h2><h3 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。<br>为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。</p>\n<p>电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最<br>新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上<br>面没有金坷垃了。</p>\n<p>duyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行<br>了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最<br>终金坷垃的量有多少。</p>\n<p>输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，<br>为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，<br>后面 2 个数描述更改为这样的操作。</p>\n<p>输出 q 行代表每次金坷垃的量为多少</p>\n<h4 id=\"样例输入-1\"><a href=\"#样例输入-1\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>10 5\n0 10\n1 5\n0 13\n0 18\n0 2\n1 1\n0 8\n0 9\n1 3\n0 7\n9 0 3\n10 1 7\n6 0 8\n10 0 5\n8 1 2\n</code></pre><h4 id=\"样例输出-1\"><a href=\"#样例输出-1\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>58\n0\n0\n66\n41\n</code></pre><h4 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 30%的数据，m&lt;=1000,q&lt;=1000.</p>\n<p>对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。</p>\n<p>对于 100%的数据，m&lt;=2<em>10^5,q&lt;=2</em>10^5,vi&lt;=10^4.</p>\n<hr>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现…</p>\n<p>题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。</p>\n<hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ninline void read(int &amp;x)\n{\n    x=0;int f=1;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n    x*=f;\n}\nconst int N =2e5+7;\nstruct build{int sum,in,out;}tr[8*N];\nint n,q,k,a[N],tot;\nint find(int x,int pot)\n{\n    if(pot&gt;=tr[x].in)            return 0;\n    if(!pot)                    return tr[x].sum;\n    if(pot&lt;=tr[x*2+1].in)\n    return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot);\n    return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out);\n}\nvoid update(int x)\n{\n    tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out);\n    tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in);\n    tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out);\n}\nvoid build(int x,int l,int r)\n{\n    if(l==r)\n    {\n        if(a[l]&lt;0)    tr[x].out=-a[l];\n        else        tr[x].in=1,tr[x].sum=a[l];\n    }\n    else\n    {\n        int mid=l+r&gt;&gt;1;\n        build(x*2,l,mid);\n        build(x*2+1,mid+1,r);\n        update(x);\n    }\n}\nvoid change(int x,int pot,int w,int l,int r)\n{\n    if(l==r)\n    {\n        memset(&amp;tr[x],0,sizeof(tr[x]));\n        if(w&lt;0)        tr[x].out=-w;\n        else        tr[x].in=1,tr[x].sum=w;\n    }\n    else\n    {\n        int mid=l+r&gt;&gt;1;\n        if(pot&gt;mid)    change(x*2+1,pot,w,mid+1,r);\n        else        change(x*2,pot,w,l,mid);\n        update(x);\n    }\n}\nint main()\n{\n//    freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin);\n//    freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout);\n    read(n),read(q);\n    for(int i=1;i&lt;=n;++i)\n    {\n        read(k),read(a[i]);\n        if(k)a[i]*=-1;\n    }\n    build(1,1,n);\n    while(q--)\n    {\n        int x,w;\n        read(x);read(k);read(w);\n        if(k)w*=-1;\n        change(1,x,w,1,n);\n        printf(&quot;%d\\n&quot;,tr[1].sum);\n    }\n}\n</code></pre><hr>\n<h2 id=\"T3-Drink\"><a href=\"#T3-Drink\" class=\"headerlink\" title=\"T3 Drink\"></a>T3 Drink</h2><h3 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份<br>丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚<br>不到这么多资本），所以决定用特殊的方法赏赐毒液哥。</p>\n<p>Link的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，<br>每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。<br>毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财<br>的他想知道最后棋盘内所有的宝物价值以方便他挑选。</p>\n<p>作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）<br>和资产阶级代表（Link）之间的贫富差距么。</p>\n<p>输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。<br>接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。<br>接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c<br>的正方形。</p>\n<p>输出一个 N * M 的矩阵表示最后的棋盘。</p>\n<h4 id=\"样例输入-2\"><a href=\"#样例输入-2\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>4 4 3\n1 2 3 4\n5 6 7 8\n1 2 3 4\n5 6 7 8\n1 1 3\n3 3 2\n2 2 2\n</code></pre><h4 id=\"样例输出-2\"><a href=\"#样例输出-2\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>1 5 1 4 \n2 7 6 8 \n3 7 2 3 \n5 6 8 4 \n</code></pre><h4 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 30%的数据，N, M, Q &lt;= 100.</p>\n<p>对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。</p>\n<p>对于 100%的数据, N, M, Q &lt;= 1000.所有数取值都为 0~9.</p>\n<hr>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。</p>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>/*\n* @Author: 閫搁棽\n* @Date:   2016-09-25 13:04:44\n* @Last Modified by:   閫搁棽\n* @Last Modified time: 2016-10-01 10:19:00\n*/\n\n#include &quot;cstdio&quot;\n#include &quot;cstdlib&quot;\n#include &quot;iostream&quot;\n#include &quot;algorithm&quot;\n#include &quot;cstring&quot;\n#include &quot;queue&quot;\n\nusing namespace std;\n\n#define INF 0x3F3F3F3F\n#define MAX_SIZE 2005\n#define Eps\n#define Mod\n#define Get(x, a) (x ? x -&gt; a : 0)\n#define Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it)\n\ninline int Get_Int()\n{\n    int Num = 0, Flag = 1;\n    char ch;\n    do\n    {\n        ch = getchar();\n        if(ch == &#39;-&#39;)\n            Flag = -Flag;\n    }\n    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;);\n    do\n    {\n        Num = Num * 10 + ch - &#39;0&#39;;\n        ch = getchar();\n    }\n    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);\n    return Num * Flag;\n}\n\nint N, M, Q;\nint A[MAX_SIZE * MAX_SIZE][4], Map[MAX_SIZE][MAX_SIZE];\n\ninline void Move(int &amp;Direction, int &amp;Now, int j)\n{\n    int Next = A[Now][j - Direction + 4 &amp; 3];\n    for(Direction = 0; A[Next][j - Direction + 6 &amp; 3] != Now; ++Direction);\n    Now = Next;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//    freopen(&quot;drink.in&quot;, &quot;r&quot;, stdin);\n//    freopen(&quot;drink.out&quot;, &quot;w&quot;, stdout);\n#endif\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q;\n    for(int i = 1; i &lt;= N; ++i)\n        for(int j = 1; j &lt;= M; ++j)\n            Map[i][j] = Get_Int();\n    for(int i = 1; i &lt;= (N + 2) * (M + 2); ++i)\n    {\n        A[i][0] = i - M - 2;\n        A[i][1] = i + 1;\n        A[i][2] = i + M + 2;\n        A[i][3] = i - 1;\n    }\n    while(Q--)\n    {\n        int x = Get_Int(), y = Get_Int(), c = Get_Int();\n        int Direction = 0, Now = 1;\n        vector&lt; pair&lt;int, int&gt; &gt; Border[4][2];\n        for(int i = 1; i &lt;= x; ++i)\n            Move(Direction, Now, 2);\n        for(int i = 1; i &lt;= y; ++i)\n            Move(Direction, Now, 1);\n        for(int j = 0; j &lt; 4; ++j)\n            for(int i = 1; i &lt;= c; ++i)\n            {\n                Border[j][0].push_back(make_pair(Direction, Now));\n                Move(Direction, Now, j);\n                Border[j][1].push_back(make_pair(Direction, Now));\n                Move(Direction, Now, j + 2 &amp; 3);\n                if(i != c)\n                    Move(Direction, Now, j + 1 &amp; 3);\n            }\n        for(int j = 0; j &lt; 4; ++j)\n            for(int i = 0; i &lt; c; ++i)\n            {\n                pair&lt;int, int&gt; Now = Border[j][1][i];\n                A[Now.second][j + 6 - Now.first &amp; 3] = Border[j + 3 &amp; 3][0][i].second;\n                Now = Border[j][0][i];\n                A[Now.second][j + 4 - Now.first &amp; 3] = Border[j + 1 &amp; 3][1][i].second;\n            }\n    }\n    int Direction = 0, Now = 1;\n    for(int i = 1; i &lt;= N; ++i)\n    {\n        Move(Direction, Now, 2);\n        int temp = Direction, Next = Now;\n        for(int j = 1; j &lt;= M; ++j)\n        {\n            Move(temp, Next, 1);\n            printf(&quot;%d &quot;, Map[(Next - 1) / (M + 2)][(Next - 1) % (M + 2)]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    fclose(stdin);\n    fclose(stdout);\n    return 0;\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/13/NOIP模拟赛 2017 3 12/","excerpt":"","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"https://prostkhala.github.io/categories/NOIP模拟赛/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://prostkhala.github.io/tags/二分答案/"},{"name":"贪心","slug":"贪心","permalink":"https://prostkhala.github.io/tags/贪心/"},{"name":"线段树","slug":"线段树","permalink":"https://prostkhala.github.io/tags/线段树/"},{"name":"二维线段树","slug":"二维线段树","permalink":"https://prostkhala.github.io/tags/二维线段树/"}]},{"title":"SCOI2010 股票交易","date":"2017-03-11T01:11:51.000Z","path":"2017/03/11/股票交易/","text":"[SCOI2010] 股票交易BZOJ1855 洛谷2569 题目描述最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。 通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi&gt;=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。 另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。 在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？ 输入输出格式输入格式：输入数据第一行包括3个整数，分别是T，MaxP，W。 接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。 输出格式：输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。 输入输出样例输入样例#1：5 2 0 2 1 1 1 2 1 1 1 3 2 1 1 4 3 1 1 5 4 1 1 输出样例#1：3 说明对于30%的数据，0&lt;=W&lt;T&lt;=50,1&lt;=MaxP&lt;=50 对于50%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=50 对于100%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=2000 对于所有的数据，1&lt;=BPi&lt;=APi&lt;=1000,1&lt;=ASi,BSi&lt;=MaxP $o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i]j$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。 $O(t*maxp^2)$算法：#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 2017; int n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w); for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i); memset(dp,-0x3f,sizeof(dp)); for(int i=1;i&lt;=n;++i) { for(int j=0;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。 for(int j=0;j&lt;=maxp;++j) { dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作 if(i-w-1&gt;=0) for(int k=j+1;k&lt;=min(j+bs[i],maxp);++k) dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出 if(i-w-1&gt;=0) for(int k=max(j-as[i],0);k&lt;j;++k) dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入 } } printf(&quot;%d&quot;,dp[n][0]); } 此题单调队列优化思想不难，但是还要注意各种细节。 $O(t*maxp)$算法(单调队列)：#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 2017; int n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w); for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i); memset(dp,-0x3f,sizeof(dp)); for(int i=1;i&lt;=n;++i) { for(int j=0;j&lt;=as[i];++j) dp[i][j]=-ap[i]*j; for(int j=0;j&lt;=maxp;++j) dp[i][j]=max(dp[i][j],dp[i-1][j]); if(i-w-1&gt;=0) { head=1,tail=0; for(int j=0;j&lt;=maxp;++j)//买入 { while(head&lt;=tail&amp;&amp;q[head]&lt;max(0,j-as[i]))head++; if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]); while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*ap[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--; q[++tail]=j; } head=1,tail=0; for(int j=maxp;j&gt;=0;--j)//卖出 { while(head&lt;=tail&amp;&amp;q[head]&gt;min(maxp,j+bs[i]))head++; if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]); while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*bp[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--; q[++tail]=j; } } } printf(&quot;%d&quot;,dp[n][0]); }","raw":"title: SCOI2010 股票交易\ndate: 2017-03-11 9:11:51\ncategories:\n  - 动态规划\n  - 单调性优化\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n---\n# [SCOI2010] 股票交易\n## [BZOJ1855](http://www.lydsy.com/JudgeOnline/problem.php?id=1855) [洛谷2569](https://www.luogu.org/problem/show?pid=2569)\n---\n\n## 题目描述\n\n最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。\n\n通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi>=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。\n\n另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。\n\n在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？\n### 输入输出格式\n#### 输入格式：\n\n输入数据第一行包括3个整数，分别是T，MaxP，W。\n\n接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。\n\n#### 输出格式：\n\n输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。\n\n### 输入输出样例\n#### 输入样例#1：\n\n    5 2 0\n    2 1 1 1\n    2 1 1 1\n    3 2 1 1\n    4 3 1 1\n    5 4 1 1\n\n#### 输出样例#1：\n\n    3\n\n### 说明\n\n对于30%的数据，0<=W<T<=50,1<=MaxP<=50\n\n对于50%的数据，0<=W<T<=2000,1<=MaxP<=50\n\n对于100%的数据，0<=W<T<=2000,1<=MaxP<=2000\n\n对于所有的数据，1<=BPi<=APi<=1000,1<=ASi,BSi<=MaxP\n\n---\n\n$o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i][j](j<=t，j<=maxp)$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。\n\n## $O(t*maxp^2)$算法：\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 2017;\n    int n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];\n    int main()\n    {\n      scanf(\"%d%d%d\",&n,&maxp,&w);\n        for(int i=1;i<=n;++i)scanf(\"%d%d%d%d\",ap+i,bp+i,as+i,bs+i);\n      memset(dp,-0x3f,sizeof(dp));\n      for(int i=1;i<=n;++i)\n      {\n          for(int j=0;j<=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。\n          for(int j=0;j<=maxp;++j)\n          {\n              dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作\n              if(i-w-1>=0)\n              for(int k=j+1;k<=min(j+bs[i],maxp);++k)\n              dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出\n              if(i-w-1>=0)\n              for(int k=max(j-as[i],0);k<j;++k)\n              dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入\n          }\n      }\n      printf(\"%d\",dp[n][0]);\n    }\n---\n此题单调队列优化思想不难，但是还要注意各种细节。\n## $O(t*maxp)$算法(单调队列)：\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 2017;\n    int n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N];\n    int main()\n    {\n        scanf(\"%d%d%d\",&n,&maxp,&w);\n        for(int i=1;i<=n;++i)scanf(\"%d%d%d%d\",ap+i,bp+i,as+i,bs+i);\n        memset(dp,-0x3f,sizeof(dp));\n        for(int i=1;i<=n;++i)\n        {\n            for(int j=0;j<=as[i];++j)\tdp[i][j]=-ap[i]*j;\n            for(int j=0;j<=maxp;++j)\tdp[i][j]=max(dp[i][j],dp[i-1][j]);\n            if(i-w-1>=0)\n            {\n                head=1,tail=0;\n                for(int j=0;j<=maxp;++j)//买入 \n                {\n                    while(head<=tail&&q[head]<max(0,j-as[i]))head++;\n                    if(head<=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]);\n                    while(head<=tail&&dp[i-w-1][j]+j*ap[i]>=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--;\n                    q[++tail]=j;\n                }\n                head=1,tail=0;\n                for(int j=maxp;j>=0;--j)//卖出 \n                {\n                    while(head<=tail&&q[head]>min(maxp,j+bs[i]))head++;\n                    if(head<=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]);\n                    while(head<=tail&&dp[i-w-1][j]+j*bp[i]>=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--;\n                    q[++tail]=j;\n                }\n            }\n        }\n        printf(\"%d\",dp[n][0]);\n    }","content":"<h1 id=\"SCOI2010-股票交易\"><a href=\"#SCOI2010-股票交易\" class=\"headerlink\" title=\"[SCOI2010] 股票交易\"></a>[SCOI2010] 股票交易</h1><h2 id=\"BZOJ1855-洛谷2569\"><a href=\"#BZOJ1855-洛谷2569\" class=\"headerlink\" title=\"BZOJ1855 洛谷2569\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1855\" target=\"_blank\" rel=\"external\">BZOJ1855</a> <a href=\"https://www.luogu.org/problem/show?pid=2569\" target=\"_blank\" rel=\"external\">洛谷2569</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。</p>\n<p>通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi&gt;=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。</p>\n<p>另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。</p>\n<p>在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入数据第一行包括3个整数，分别是T，MaxP，W。</p>\n<p>接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>5 2 0\n2 1 1 1\n2 1 1 1\n3 2 1 1\n4 3 1 1\n5 4 1 1\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>3\n</code></pre><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>对于30%的数据，0&lt;=W&lt;T&lt;=50,1&lt;=MaxP&lt;=50</p>\n<p>对于50%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=50</p>\n<p>对于100%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=2000</p>\n<p>对于所有的数据，1&lt;=BPi&lt;=APi&lt;=1000,1&lt;=ASi,BSi&lt;=MaxP</p>\n<hr>\n<p>$o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i]<a href=\"j&lt;=t，j&lt;=maxp\">j</a>$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。</p>\n<h2 id=\"O-t-maxp-2-算法：\"><a href=\"#O-t-maxp-2-算法：\" class=\"headerlink\" title=\"$O(t*maxp^2)$算法：\"></a>$O(t*maxp^2)$算法：</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 2017;\nint n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];\nint main()\n{\n  scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i);\n  memset(dp,-0x3f,sizeof(dp));\n  for(int i=1;i&lt;=n;++i)\n  {\n      for(int j=0;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。\n      for(int j=0;j&lt;=maxp;++j)\n      {\n          dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作\n          if(i-w-1&gt;=0)\n          for(int k=j+1;k&lt;=min(j+bs[i],maxp);++k)\n          dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出\n          if(i-w-1&gt;=0)\n          for(int k=max(j-as[i],0);k&lt;j;++k)\n          dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入\n      }\n  }\n  printf(&quot;%d&quot;,dp[n][0]);\n}\n</code></pre><hr>\n<p>此题单调队列优化思想不难，但是还要注意各种细节。</p>\n<h2 id=\"O-t-maxp-算法-单调队列-：\"><a href=\"#O-t-maxp-算法-单调队列-：\" class=\"headerlink\" title=\"$O(t*maxp)$算法(单调队列)：\"></a>$O(t*maxp)$算法(单调队列)：</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 2017;\nint n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N];\nint main()\n{\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i);\n    memset(dp,-0x3f,sizeof(dp));\n    for(int i=1;i&lt;=n;++i)\n    {\n        for(int j=0;j&lt;=as[i];++j)    dp[i][j]=-ap[i]*j;\n        for(int j=0;j&lt;=maxp;++j)    dp[i][j]=max(dp[i][j],dp[i-1][j]);\n        if(i-w-1&gt;=0)\n        {\n            head=1,tail=0;\n            for(int j=0;j&lt;=maxp;++j)//买入 \n            {\n                while(head&lt;=tail&amp;&amp;q[head]&lt;max(0,j-as[i]))head++;\n                if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]);\n                while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*ap[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--;\n                q[++tail]=j;\n            }\n            head=1,tail=0;\n            for(int j=maxp;j&gt;=0;--j)//卖出 \n            {\n                while(head&lt;=tail&amp;&amp;q[head]&gt;min(maxp,j+bs[i]))head++;\n                if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]);\n                while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*bp[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--;\n                q[++tail]=j;\n            }\n        }\n    }\n    printf(&quot;%d&quot;,dp[n][0]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/11/股票交易/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"},{"name":"单调性优化","slug":"动态规划/单调性优化","permalink":"https://prostkhala.github.io/categories/动态规划/单调性优化/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"}]},{"title":"动态规划优化 题目列表","date":"2017-03-10T14:12:24.000Z","path":"2017/03/10/动态规划 题目列表/","text":"单调队列优化dpBZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047! 单调栈BZOJ 1057!、BZOJ 1683、BZOJ 3956、BZOJ 3611 状压DPBZOJ 1879!、BZOJ 1087!、BZOJ 2669!、BZOJ 3812 斜率优化BZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675 dp+四边形不等式优化POJ1160! HDU2829! HDU3480 HDU3506 HDU3516http://blog.csdn.net/shiwei408/article/details/8791011 斜率优化DP和四边形不等式优化DP整理http://blog.csdn.net/tomorrowtodie/article/details/52279807 http://blog.csdn.net/u014800748/article/details/45750737","raw":"title: 动态规划优化 题目列表\ndate: 2017-03-10 22:12:24\ncategories:\n  - 动态规划\n  - 单调性优化\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n  - 斜率优化\n  - 单调栈\n---\n# 单调队列优化dp\nBZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047!\n\n# 单调栈\nBZOJ 1057!、BZOJ 1683、BZOJ 3956、BZOJ 3611\n\n# 状压DP\nBZOJ 1879!、BZOJ 1087!、BZOJ 2669!、BZOJ 3812\n\n# 斜率优化\nBZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675\n\n# dp+四边形不等式优化\nPOJ1160! HDU2829! HDU3480 HDU3506 HDU3516\nhttp://blog.csdn.net/shiwei408/article/details/8791011\n\n# 斜率优化DP和四边形不等式优化DP整理\nhttp://blog.csdn.net/tomorrowtodie/article/details/52279807\n\nhttp://blog.csdn.net/u014800748/article/details/45750737","content":"<h1 id=\"单调队列优化dp\"><a href=\"#单调队列优化dp\" class=\"headerlink\" title=\"单调队列优化dp\"></a>单调队列优化dp</h1><p>BZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047!</p>\n<h1 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h1><p>BZOJ 1057!、BZOJ 1683、BZOJ 3956、BZOJ 3611</p>\n<h1 id=\"状压DP\"><a href=\"#状压DP\" class=\"headerlink\" title=\"状压DP\"></a>状压DP</h1><p>BZOJ 1879!、BZOJ 1087!、BZOJ 2669!、BZOJ 3812</p>\n<h1 id=\"斜率优化\"><a href=\"#斜率优化\" class=\"headerlink\" title=\"斜率优化\"></a>斜率优化</h1><p>BZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675</p>\n<h1 id=\"dp-四边形不等式优化\"><a href=\"#dp-四边形不等式优化\" class=\"headerlink\" title=\"dp+四边形不等式优化\"></a>dp+四边形不等式优化</h1><p>POJ1160! HDU2829! HDU3480 HDU3506 HDU3516<br><a href=\"http://blog.csdn.net/shiwei408/article/details/8791011\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/shiwei408/article/details/8791011</a></p>\n<h1 id=\"斜率优化DP和四边形不等式优化DP整理\"><a href=\"#斜率优化DP和四边形不等式优化DP整理\" class=\"headerlink\" title=\"斜率优化DP和四边形不等式优化DP整理\"></a>斜率优化DP和四边形不等式优化DP整理</h1><p><a href=\"http://blog.csdn.net/tomorrowtodie/article/details/52279807\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/tomorrowtodie/article/details/52279807</a></p>\n<p><a href=\"http://blog.csdn.net/u014800748/article/details/45750737\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u014800748/article/details/45750737</a></p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/10/动态规划 题目列表/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"},{"name":"单调性优化","slug":"动态规划/单调性优化","permalink":"https://prostkhala.github.io/categories/动态规划/单调性优化/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://prostkhala.github.io/tags/斜率优化/"},{"name":"单调栈","slug":"单调栈","permalink":"https://prostkhala.github.io/tags/单调栈/"}]},{"title":"HNOI2008     玩具装箱Toy(详解)","date":"2017-03-10T14:02:35.000Z","path":"2017/03/10/玩具装箱toy/","text":"[HNOI2008] 玩具装箱toyBZOJ1010 COGS1330 题目描述P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小. 输入输出格式输入格式：第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7 输出格式：输出最小费用. 输入输出样例输入样例#1：5 4 3 4 2 1 4 输出样例#1：1 题解设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0&lt;=i&lt;j&lt;=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N=50005; long long n,l,dp[N],a[N]; int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1]; memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l)); printf(&quot;%lld&quot;,dp[n]); } 观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。 斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，在某DP视频中，主讲人向同学们推荐了打出决策表的方法，对于此题来说，数据容易生成，可以尝试一下。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N=50005; long long n,l,dp[N],a[N],best[N]; int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1]; memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j; for(int i=1;i&lt;=n;i++)printf(&quot;%d&quot;,best[i]);//决策表 printf(&quot;%lld&quot;,dp[n]); } 易观察到best[i]单调不降，满足决策单调性。（证明见下文） 则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有 $dp[k]+(i-k-1+a[i]-a[k]-l)^2&lt;dp[j]+(i-j-1+a[i]-a[j]-l)^2$ $dp[k]-dp[j]&lt;(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$ 对于该方程，可设 $b[i]=a[i]+i$; $l=l+1$ 则有 $dp[k]-dp[j]&lt;(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$ 化简得 $((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])&lt;2b[i]-2l$ 此时的形式为点斜式方程： $(yk-yj)/(xk-xj)&lt;ansi$ 已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。 设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]&lt;b[i]-2l$时，由$A1$转移而来优于$A2$。 当$a&lt;b&lt;c$时，且$g[c,b]&lt;g[b,a]$,易证得b必不为最优决策。 证明1.$g[c,b]&lt;ansi$此时c决策优于b，则b一定不为最优决策。 2.$g[c,b]&gt;=ansi$此时b决策优于c，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时b决策不优于a决策。 综上所述，则可将所有满足$g[c,b]&lt;gb,a$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。 以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：1： 用单调队列维护点集信息。2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。AC代码如下： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 50005; long long n,l,a[N],b[N],dp[N],q[N]; double g(long long k,long long j) { return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]); } int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,a+i),a[i]+=a[i-1]; for(int i=1;i&lt;=n;++i)b[i]=a[i]+i; l++; int head=1,tail=1; q[1]=0; for(int i=1;i&lt;=n;++i) { while(head&lt;tail&amp;&amp;g(q[head+1],q[head])&lt;2*b[i]-2*l)head++; int j=q[head]; dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l); while(head&lt;tail&amp;&amp;g(i,q[tail])&lt;g(q[tail],q[tail-1]))tail--; q[++tail]=i; } printf(&quot;%lld&quot;,dp[n]); }","raw":"title: HNOI2008     玩具装箱toy(详解)\ndate: 2017-03-10 22:02:35\ncategories:\n  - 动态规划\n  - 单调性优化\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n  - 斜率优化\n---\n# [HNOI2008]  玩具装箱toy\n\n## [BZOJ1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010) [COGS1330](http://cogs.pro/cogs/problem/problem.php?pid=1330)\n\n---\n\n## 题目描述\n\nP教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1...N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i<=K<=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.\n### 输入输出格式\n#### 输入格式：\n\n第一行输入两个整数N，L.接下来N行输入Ci.1<=N<=50000,1<=L,Ci<=10^7\n\n#### 输出格式：\n\n输出最小费用.\n\n### 输入输出样例\n#### 输入样例#1：\n\n    5 4\n    3\n    4\n    2\n    1\n    4\n\n#### 输出样例#1：\n\n    1\n\n\n---\n## 题解\n设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0<=i<j<=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。\n```cpp\n    #include<cstdio>\n    #include<iostream>\n    #include<cstring>\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N];\n\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i<=n;i++)\n        for(int j=0;j<i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l));\n        printf(\"%lld\",dp[n]);\n    } \n```\n观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。\n\n斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，在某DP视频中，主讲人向同学们推荐了打出决策表的方法，对于此题来说，数据容易生成，可以尝试一下。\n\n    #include<cstdio>\n    #include<iostream>\n    #include<cstring>\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N],best[N];\n\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i<=n;i++)\n        for(int j=0;j<i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j;\n        for(int i=1;i<=n;i++)printf(\"%d\",best[i]);//决策表\n        printf(\"%lld\",dp[n]);\n    } \n\n易观察到best[i]单调不降，满足决策单调性。（证明见下文）\n\n\n则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有\n\n$dp[k]+(i-k-1+a[i]-a[k]-l)^2<dp[j]+(i-j-1+a[i]-a[j]-l)^2$\n\n$dp[k]-dp[j]<(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$\n\n对于该方程，可设\n\n$b[i]=a[i]+i$;\n\n$l=l+1$\n\n则有\n\n$dp[k]-dp[j]<(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$\n\n化简得\n\n$((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])<2b[i]-2l$\n\n此时的形式为点斜式方程：\n\n$(yk-yj)/(xk-xj)<ansi$\n\n已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。\n\n设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]<b[i]-2l$时，由$A1$转移而来优于$A2$。\n\n当$a<b<c$时，且$g[c,b]<g[b,a]$,易证得b必不为最优决策。\n## 证明\n### 1.$g[c,b]<ansi$\n此时c决策优于b，则b一定不为最优决策。\n### 2.$g[c,b]>=ansi$\n此时b决策优于c，但又有$g[b,a]>g[c,b]>=ansi$,此时b决策不优于a决策。\n\n综上所述，则可将所有满足$g[c,b]<g[b,a](a<b<c)$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。\n\n## 以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\n### 1： 用单调队列维护点集信息。\n### 2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)<ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。\n### 3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\n\nAC代码如下：\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 50005;\n    long long n,l,a[N],b[N],dp[N],q[N];\n    double g(long long k,long long j)\n    {\n        return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);\n    }\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;++i)scanf(\"%lld\",a+i),a[i]+=a[i-1];\n        for(int i=1;i<=n;++i)b[i]=a[i]+i;\n        l++;\n        int head=1,tail=1;\n        q[1]=0;\n        for(int i=1;i<=n;++i)\n        {\n            while(head<tail&&g(q[head+1],q[head])<2*b[i]-2*l)head++;\n            int j=q[head];\n            dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);\n            while(head<tail&&g(i,q[tail])<g(q[tail],q[tail-1]))tail--;\n            q[++tail]=i;\n        }\n        printf(\"%lld\",dp[n]);\n    }","content":"<h1 id=\"HNOI2008-玩具装箱toy\"><a href=\"#HNOI2008-玩具装箱toy\" class=\"headerlink\" title=\"[HNOI2008]  玩具装箱toy\"></a>[HNOI2008]  玩具装箱toy</h1><h2 id=\"BZOJ1010-COGS1330\"><a href=\"#BZOJ1010-COGS1330\" class=\"headerlink\" title=\"BZOJ1010 COGS1330\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1010\" target=\"_blank\" rel=\"external\">BZOJ1010</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1330\" target=\"_blank\" rel=\"external\">COGS1330</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出最小费用.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>5 4\n3\n4\n2\n1\n4\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>1\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0&lt;=i&lt;j&lt;=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。</p>\n<pre><code class=\"cpp\">    #include&lt;cstdio&gt;\n    #include&lt;iostream&gt;\n    #include&lt;cstring&gt;\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N];\n\n    int main()\n    {\n    //    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n    //    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n        for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i&lt;=n;i++)\n        for(int j=0;j&lt;i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l));\n        printf(&quot;%lld&quot;,dp[n]);\n    }\n</code></pre>\n<p>观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。</p>\n<p>斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，在某DP视频中，主讲人向同学们推荐了打出决策表的方法，对于此题来说，数据容易生成，可以尝试一下。</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N=50005;\n\nlong long n,l,dp[N],a[N],best[N];\n\nint main()\n{\n//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n    for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1];\n    memset(dp,0x3f,sizeof(dp));\n    dp[0]=0;\n    for(int i=1;i&lt;=n;i++)\n    for(int j=0;j&lt;i;j++)\n    dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j;\n    for(int i=1;i&lt;=n;i++)printf(&quot;%d&quot;,best[i]);//决策表\n    printf(&quot;%lld&quot;,dp[n]);\n} \n</code></pre><p>易观察到best[i]单调不降，满足决策单调性。（证明见下文）</p>\n<p>则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有</p>\n<p>$dp[k]+(i-k-1+a[i]-a[k]-l)^2&lt;dp[j]+(i-j-1+a[i]-a[j]-l)^2$</p>\n<p>$dp[k]-dp[j]&lt;(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$</p>\n<p>对于该方程，可设</p>\n<p>$b[i]=a[i]+i$;</p>\n<p>$l=l+1$</p>\n<p>则有</p>\n<p>$dp[k]-dp[j]&lt;(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$</p>\n<p>化简得</p>\n<p>$((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])&lt;2b[i]-2l$</p>\n<p>此时的形式为点斜式方程：</p>\n<p>$(yk-yj)/(xk-xj)&lt;ansi$</p>\n<p>已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。</p>\n<p>设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]&lt;b[i]-2l$时，由$A1$转移而来优于$A2$。</p>\n<p>当$a&lt;b&lt;c$时，且$g[c,b]&lt;g[b,a]$,易证得b必不为最优决策。</p>\n<h2 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h2><h3 id=\"1-g-c-b-lt-ansi\"><a href=\"#1-g-c-b-lt-ansi\" class=\"headerlink\" title=\"1.$g[c,b]&lt;ansi$\"></a>1.$g[c,b]&lt;ansi$</h3><p>此时c决策优于b，则b一定不为最优决策。</p>\n<h3 id=\"2-g-c-b-gt-ansi\"><a href=\"#2-g-c-b-gt-ansi\" class=\"headerlink\" title=\"2.$g[c,b]&gt;=ansi$\"></a>2.$g[c,b]&gt;=ansi$</h3><p>此时b决策优于c，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时b决策不优于a决策。</p>\n<p>综上所述，则可将所有满足$g[c,b]&lt;g<a href=\"a&lt;b&lt;c\">b,a</a>$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。</p>\n<h2 id=\"以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\"><a href=\"#以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\" class=\"headerlink\" title=\"以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\"></a>以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：</h2><h3 id=\"1：-用单调队列维护点集信息。\"><a href=\"#1：-用单调队列维护点集信息。\" class=\"headerlink\" title=\"1： 用单调队列维护点集信息。\"></a>1： 用单调队列维护点集信息。</h3><h3 id=\"2：-求解dp-i-可以从队首开始扫描，当g-head-1-head-lt-ansi时，可知head-1优于head，故继续扫描，直到不满足条件，此时bext-i-head-即使dp-i-最优的决策为队首。\"><a href=\"#2：-求解dp-i-可以从队首开始扫描，当g-head-1-head-lt-ansi时，可知head-1优于head，故继续扫描，直到不满足条件，此时bext-i-head-即使dp-i-最优的决策为队首。\" class=\"headerlink\" title=\"2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。\"></a>2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。</h3><h3 id=\"3：-当加入点i，我们要维护队列的上凸性质-即从队尾开始扫描，判断g-i-tail-是否小于g-tail，tail-1-，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\"><a href=\"#3：-当加入点i，我们要维护队列的上凸性质-即从队尾开始扫描，判断g-i-tail-是否小于g-tail，tail-1-，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\" class=\"headerlink\" title=\"3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\"></a>3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。</h3><p>AC代码如下：</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 50005;\nlong long n,l,a[N],b[N],dp[N],q[N];\ndouble g(long long k,long long j)\n{\n    return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);\n}\nint main()\n{\n//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,a+i),a[i]+=a[i-1];\n    for(int i=1;i&lt;=n;++i)b[i]=a[i]+i;\n    l++;\n    int head=1,tail=1;\n    q[1]=0;\n    for(int i=1;i&lt;=n;++i)\n    {\n        while(head&lt;tail&amp;&amp;g(q[head+1],q[head])&lt;2*b[i]-2*l)head++;\n        int j=q[head];\n        dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);\n        while(head&lt;tail&amp;&amp;g(i,q[tail])&lt;g(q[tail],q[tail-1]))tail--;\n        q[++tail]=i;\n    }\n    printf(&quot;%lld&quot;,dp[n]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/10/玩具装箱toy/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"},{"name":"单调性优化","slug":"动态规划/单调性优化","permalink":"https://prostkhala.github.io/categories/动态规划/单调性优化/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://prostkhala.github.io/tags/斜率优化/"}]},{"title":"后缀数组十三题","date":"2017-03-08T03:02:35.000Z","path":"2017/03/08/后缀数组13题/","text":"论文后缀数组——处理字符串的有力工具–罗穗骞 题目 例3 (1).cogs902:Musical Theme(poj1743)本题题目描述与论文略有差别。 应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..）） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; const int inf = 0x7fffffff; int wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N]; int s[N]; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(p=1,j=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } bool can(int k,int n) { int tmp=0,maxsa=-1,minsa=inf; for(int i=1;i&lt;=n;++i) { if(h[i]&lt;k)maxsa=-1,minsa=inf; if(sa[i]&lt;minsa)minsa=sa[i]; if(sa[i]&gt;maxsa)maxsa=sa[i]; if(maxsa-minsa&gt;k)return 1; } return 0; } int main() { // freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout); int n,x; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) { memset(h,0,sizeof(h)); memset(sa,0,sizeof(sa)); memset(rank,0,sizeof(rank)); if(!n)break; cin&gt;&gt;x; for(int i=1;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;s[i]); s[0]=s[1]-x; for(int i=1;i&lt;n-1;++i)s[i]=s[i+1]-s[i]; n--; for(int i=0;i&lt;n;++i)s[i]+=150; da(n+1,maxf); getheight(n); int l=0,r=1e6,ans; int mid=0; while(l!=r) { ans=l+r+1&gt;&gt;1; if(can(ans,n)) l=ans; else r=ans-1; } l++; printf(&quot;%d\\n&quot;,(l)&gt;=5?l:0); } } CODE 例4 (1).poj3261：Milk Patterns#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int maxf = 255; const int inf = 0x7fffffff; const int N = 1e5+5; int sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N]; int s[N],k; int cmp(int*r,int a,int b,int l) {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;height[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } bool can(int ans,int n) { int tot=0; for(int i=1;i&lt;=n;++i) { if(height[i]&lt;ans)tot=0; tot++; if(tot==k)return 1; } return 0; } int main() { int n; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,s+i); da(n+1,maxf); getheight(n); int l=1,r=n+1,ans,mid; while(l!=r) { int mid=(l+r&gt;&gt;1)+1; if(can(mid,n))ans=l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,ans); } CODE 例5 (1).spoj694：Distinct Substrings(Vjudge)这题论文中的方法不太好想，可以换一种思路。 易证长度为len的字符串一共有$（len+1）*len / 2$个子串。而其中重复的字串个数则为height数组的总和，减去即可。 以 sa[i-1] abba sa[i] abcd //height[i] = 2 这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。 这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为 bba bcd //height = 1 重复的子串 b 将在此处减掉。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; const int N =1e4+5; using namespace std; char s[N]; int sa[N],wa[N],wb[N],tong[N],wv[N]; int rank[N],height[N]; int cmp(int*r,int a,int b,int l) {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void calheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;i++) rank[sa[i]]=i; for(i=0;i&lt;n;height[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int i; scanf(&quot;%s&quot;,s); int n=strlen(s); da(n+1,128); calheight(n); long long ans=n*(n+1)/2; for(i=1;i&lt;=n;i++) ans-=height[i]; printf(&quot;%lld\\n&quot;,ans); } } CODE (2).cogs1709:不同的子串 （spoj705） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N]; char s[N]; bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } int main() { // freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%s&quot;,s); int n=strlen(s); da(n+1,maxf); getheight(n); for(int i=1;i&lt;=n;++i)sa[i]++; long long ans=0; for(int i=1;i&lt;=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1; printf(&quot;%d&quot;,ans); } CODE 例6 (1).ural1297：Palindrome(Vjudge)这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。 #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; const int N = 1e4+1; int tong[N],wv[N],wa[N],wb[N]; int rank1[N],height[N],sa[N]; char s[N]; int a[N],n; int dp[N][30]; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=a[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void calheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;i++)rank1[sa[i]]=i; for(i=0;i&lt;n;height[rank1[i++]]=k) for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++); return; } void preRMQ() { int i,j; memset(dp,127,sizeof(dp)); for(i=1;i&lt;=n*2+1;i++)dp[i][0]=height[i]; for(j=1;(1&lt;&lt;j)&lt;=2*n+1;j++) for(i=1;i+(1&lt;&lt;j)-1&lt;=2*n+1;i++) dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]); } int lcp(int l,int r) { int a=rank1[l],b=rank1[r]; if(a&gt;b) swap(a,b); a++; int t=(int)(log(double(b-a+1))/log(2.00)); return min(dp[a][t],dp[b-(1&lt;&lt;t)+1][t]); } int main() { int i,res,flag,max; while(scanf(&quot;%s&quot;,s)!=EOF) { max=0; n=strlen(s); for(i=0;i&lt;n;i++)a[i]=(int)s[i]; a[n]=1; for(i=0;i&lt;n;i++)a[i+n+1]=int(s[n-i-1]); a[2*n+1]=0; da(2*n+2,123); calheight(2*n+1); preRMQ(); for(i=0;i&lt;n;i++) { res=lcp(i,2*n-i)*2-1; if(max&lt;res) max=res,flag=i; if(i&gt;0) { res=lcp(i,2*n-i+1)*2; if(max&lt;res) max=res,flag=i; } } if(max%2==1)for(i=flag-max/2;i&lt;=flag+max/2;i++) printf(&quot;%c&quot;,s[i]); else for(i=flag-max/2;i&lt;=flag+max/2-1;i++) printf(&quot;%c&quot;,s[i]); printf(&quot;\\n&quot;); } } CODE 例7 (1).cogs1710:Power Strings （poj2406）本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。 例8 (1).poj3693:Maximum repetition substring #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N]; int k,now,jj,maxr,cnt; int d[N][21],ans[N]; char s[N*2]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } int prermq(int*a,int n) { for(int i=0;i&lt;n;++i)d[i][0]=a[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;++j) for(int i=0;i+(1&lt;&lt;j)-1&lt;n;++i) d[i][j]=min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]); } int askrmq(int l,int r) { l=rank[l],r=rank[r]; if(l&gt;r)swap(l,r); l++; int k=0; while((1&lt;&lt;(k+1))&lt;=r-l+1)k++; return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]); } int main() { int ccase=0; while(1) { memset(h,0,sizeof(h)); memset(d,0,sizeof(d)); memset(tong,0,sizeof(tong)); memset(rank,0,sizeof(rank)); memset(ans,0,sizeof(ans)); ccase++; k=now=jj=maxr=cnt=0; scanf(&quot;%s&quot;,s); if(s[0]==&#39;#&#39;)return 0; int n=strlen(s); da(n+1,maxf); getheight(n); prermq(h,n+1); for(int i=1;i&lt;n;++i) for(int j=0;j+i&lt;n;j+=i) { k=askrmq(j,j+i); now=k/i+1; jj=j-(i-k%i); if (jj&gt;=0&amp;&amp;askrmq(jj,jj+i)&gt;=(i-k%i))++now; if(now&gt;maxr) {cnt=0;maxr=now;ans[cnt++]=i;} else if(now==maxr) ans[cnt++]=i; } for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;cnt;++j) if(askrmq(sa[i],sa[i]+ans[j])&gt;=(maxr-1)*ans[j]) { jj=sa[i],k=ans[j]; goto dd; } dd:; printf(&quot;Case %d: &quot;,ccase); for (int i=0;i&lt;maxr*k;++i)putchar(s[jj++]); printf(&quot;\\n&quot;); } } CODE (2).cogs1711:重复的字符串 （spoj687） 例9 (1).cogs1713:Long Long Message （poj2774）#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 3e5+1; const int maxf = 255; const int inf =0x7fffffff; int sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N]; char s[N],ss[N]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;m=p,j&lt;&lt;=1) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } int main() { freopen(&quot;longlongmessage.in&quot;,&quot;r&quot;,stdin); freopen(&quot;longlongmessage.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%s&quot;,s); scanf(&quot;%s&quot;,ss); int n=strlen(s),m=strlen(ss); s[n]=&#39;*&#39;; for(int i=n+1;i&lt;=n+m;++i)s[i]=ss[i-n-1]; int l=n+m+1; da(l+1,maxf); geth(l); int maxx=0; for(int i=2;i&lt;=l;++i) { if(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i-1]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i-1]&lt;n))) maxx=h[i]; } cout&lt;&lt;maxx; } CODE 例10 (1).cogs1712:Common Substrings （poj3415） 例11 (1).cogs2128:生命形态 （poj3294）例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 2e5+1; const int inf =0x7fffffff; const int maxf = 255; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} int sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N]; char ss[111][10001],s[N]; int nn[111],tt; bool inq[111]; int ll[N]; void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(i=1,p=1,swap(x,y),x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++); } int k; int ansg; bool can(int ans,int n,int flag) { if(!flag) { int tot1=0; memset(inq,0,sizeof(inq)); for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { memset(inq,0,sizeof(inq)); tot1=0; } else { int nowq,nowt; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t; if(!inq[nowq])tot1++,inq[nowq]=true; if(!inq[nowt])tot1++,inq[nowt]=true; if(tot1&gt;=k)return 1; } } return 0; } if(flag) { int lll=inf,rrr=-1; int tot1=0; memset(inq,0,sizeof(inq)); for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { memset(inq,0,sizeof(inq)); tot1=0; lll=inf;rrr=-1; } else { int nowq,nowt; if(sa[i-1]&lt;lll)lll=sa[i-1];if(sa[i-1]&gt;rrr)rrr=sa[i-1]; if(sa[i]&lt;lll)lll=sa[i];if(sa[i]&gt;rrr)rrr=sa[i]; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t; if(!inq[nowq])tot1++,inq[nowq]=true; if(!inq[nowt])tot1++,inq[nowt]=true; if(tot1==k)ll[++ansg]=lll; } } } } int main() { // freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout); while(scanf(&quot;%d&quot;,&amp;tt)!=EOF) { if(!tt)return 0; memset(wa,0,sizeof(wa)); memset(wb,0,sizeof(wb)); memset(wv,0,sizeof(wv)); memset(rank,0,sizeof(rank)); memset(sa,0,sizeof(sa)); memset(h,0,sizeof(h)); memset(nn,0,sizeof(nn)); memset(s,0,sizeof(s)); int tot=0; int tmp=2; ansg=0; for(int i=1;i&lt;=tt;++i) { scanf(&quot;%s&quot;,ss[i]); nn[i]=strlen(ss[i]); nn[0]=-1; for(int t=0;t&lt;nn[i];++t)s[tot++]=ss[i][t]; nn[i]+=nn[i-1]+(i==tt?0:1); if(i!=tt)s[tot++]=tmp++; } nn[tt]++; int n=strlen(s); da(n+1,maxf); geth(n); k=(tt)/2+1; int l=0,r=n+1,mid; while(l!=r) { mid=(l+r+1)&gt;&gt;1; if(can(mid,n,0)) l=mid; else r=mid-1; } if(l==0){printf(&quot;?&quot;);goto dd;} can(l,n,1); for(int i=1;i&lt;=ansg;++i) { if(i!=1) { bool flag=0; for(int t=0;t&lt;l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;} if(!flag)continue; } for(int t=ll[i];t&lt;=ll[i]+l-1;++t)putchar(s[t]); printf(&quot;\\n&quot;); } dd:; } } CODE 例12 (1).cogs2120:破译进攻计划 （spoj220）#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; const int N = 2e5+500; const int maxf = 255; int sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N]; char s[N],ss[13][15031]; int inq[13],maxq[13],minq[13]; int tt,num; bool use[13]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),x[sa[0]]=0,i=1,p=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } bool can(int ans,int n) { int tot=0; for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { tot=0; memset(inq,0,sizeof(inq)); memset(maxq,0,sizeof(maxq)); memset(minq,0x3f,sizeof(minq)); memset(use,0,sizeof(use)); } else { for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t]) { inq[t]++; minq[t]=min(minq[t],sa[i]); maxq[t]=max(maxq[t],sa[i]); if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true; if(tot==num)return 1; } for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t]) { inq[t]++; minq[t]=min(minq[t],sa[i-1]); maxq[t]=max(maxq[t],sa[i-1]); if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true; if(tot==num)return 1; } } } return 0; } int main() { // freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout); nn[0]=-1; scanf(&quot;%d&quot;,&amp;tt); while(tt--) { memset(inq,0,sizeof(inq)); memset(wa,0,sizeof(wa)); memset(wb,0,sizeof(wb)); memset(wv,0,sizeof(wv)); memset(sa,0,sizeof(sa)); memset(rank,0,sizeof(rank)); memset(h,0,sizeof(h)); scanf(&quot;%d&quot;,&amp;num); int tot=0,qiguaizifu=2; for(int i=1;i&lt;=num;++i) { scanf(&quot;%s&quot;,ss[i]); nn[i]=strlen(ss[i]); } for(int i=1;i&lt;=num;++i) { for(int t=0;t&lt;nn[i];++t) s[tot++]=ss[i][t]; s[tot++]=qiguaizifu++; } for(int i=1;i&lt;=num;++i)nn[i]+=(nn[i-1]+1); int n=strlen(s); da(n+1,maxf); geth(n); int l=0,r=(n+1)/2; while(l!=r) { int mid=l+r+1&gt;&gt;1; if(can(mid,n)) l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,l); } } CODE 例13 (1).poj1226:Substrings","raw":"title: 后缀数组十三题\ndate: 2017-03-08 11:02:35\ncategories:\n  - Hollerith-type\n  - 后缀数组\ntags:\n  - 后缀数组\n  - 模板\n---\n\n\n# 论文\n[后缀数组——处理字符串的有力工具--罗穗骞](https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/pdfs/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E4%B9%8B%E3%80%8A%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E5%8A%9B%E5%B7%A5%E5%85%B7%E3%80%8B.pdf)\n\n\n <!--more--> \n \n \n# 题目\n\n-----------------------------------------------------------------------------------------------------------\n## 例3         (1).[cogs902:Musical Theme](http://cogs.pro/cogs/problem/problem.php?pid=902)(poj1743)\n\n本题题目描述与论文略有差别。\n\n应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa > k，而不是maxsa - minsa > = k（然而POJ并没有卡我..））\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 1e5+1;\n    const int maxf = 255;\n    const int inf = 0x7fffffff;\n    int wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];\n    int s[N];\n    int cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i<m;i++)tong[i]=0;\n    for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i<m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n    for(p=1,j=1;p<n;j<<=1,m=p)\n    {\n        for(p=0,i=n-j;i<n;++i)y[p++]=i;\n        for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n        for(i=0;i<n;++i)wv[i]=x[y[i]];\n        for(i=0;i<m;i++)tong[i]=0;\n        for(i=0;i<n;++i)tong[wv[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n    }\n    void getheight(int n)\n    {\n    int i,j,k=0;\n    for(i=1;i<=n;++i)rank[sa[i]]=i;\n    for(i=0;i<n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    return;\n    }\n    bool can(int k,int n)\n    {\n    int tmp=0,maxsa=-1,minsa=inf;\n    for(int i=1;i<=n;++i)\n    {\n        if(h[i]<k)maxsa=-1,minsa=inf;\n        if(sa[i]<minsa)minsa=sa[i];\n        if(sa[i]>maxsa)maxsa=sa[i];\n        if(maxsa-minsa>k)return 1;\n    }\n    return 0;\n    }\n    int main()\n    {\n    //  freopen(\"theme.in\",\"r\",stdin);\n    //  freopen(\"theme.out\",\"w\",stdout);\n    int n,x;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        memset(h,0,sizeof(h));\n        memset(sa,0,sizeof(sa));\n        memset(rank,0,sizeof(rank));\n        if(!n)break;\n        cin>>x;\n        for(int i=1;i<n;++i)scanf(\"%d\",&s[i]);\n        s[0]=s[1]-x;\n        for(int i=1;i<n-1;++i)s[i]=s[i+1]-s[i];\n        n--;\n        for(int i=0;i<n;++i)s[i]+=150;\n        da(n+1,maxf);\n        getheight(n);\n        int l=0,r=1e6,ans;\n        int mid=0;\n        while(l!=r)\n        {\n            ans=l+r+1>>1;\n            if(can(ans,n))  l=ans;\n            else      r=ans-1;\n        }\n        l++;\n        printf(\"%d\\n\",(l)>=5?l:0);\n    }\n    }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B3.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例4         (1).[poj3261：Milk Patterns](http://poj.org/problem?id=3261)\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int maxf = 255;\n    const int inf = 0x7fffffff;\n    const int N = 1e5+5;\n    int sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];\n    int s[N],k;\n    int cmp(int*r,int a,int b,int l)\n    {return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;i++)tong[i]=0;\n            for(i=0;i<n;i++)tong[wv[i]]++;\n            for(i=1;i<m;i++)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void getheight(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;height[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n        return;\n    }\n    bool can(int ans,int n)\n    {\n        int tot=0;\n        for(int i=1;i<=n;++i)\n        {\n            if(height[i]<ans)tot=0;\n            tot++;\n            if(tot==k)return 1;\n        }\n        return 0;\n    }\n    int main()\n    {\n        int n;\n        scanf(\"%d%d\",&n,&k);\n        for(int i=0;i<n;++i)scanf(\"%d\",s+i);\n        da(n+1,maxf);\n        getheight(n);\n        int l=1,r=n+1,ans,mid;\n        while(l!=r)\n        {\n            int mid=(l+r>>1)+1;\n            if(can(mid,n))ans=l=mid;\n            else    r=mid-1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B4.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例5         (1).[spoj694：Distinct Substrings](https://vjudge.net/problem/SPOJ-DISUBSTR)(Vjudge)   \n\n这题论文中的方法不太好想，可以换一种思路。\n\n易证长度为len的字符串一共有$（len+1）*len / 2$个子串。\n而其中重复的字串个数则为height数组的总和，减去即可。\n\n以\n\n\tsa[i-1]  abba\n\n\tsa[i]    abcd //height[i] = 2\n\n这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。\n\n这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为\n   \n   \tbba\n       bcd //height = 1\n    \n    \n   重复的子串 b 将在此处减掉。\n   \n\n      #include<iostream> \n      #include<cstring>\n      #include<cstdio>\n      const int N =1e4+5;       \n      using namespace std;       \n      char s[N];   \n      int sa[N],wa[N],wb[N],tong[N],wv[N];      \n      int rank[N],height[N];      \n      int cmp(int*r,int a,int b,int l)\n      {return r[a]==r[b]&&r[a+l]==r[b+l];}\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<m;i++)tong[i]=0;\n              for(i=0;i<n;i++)tong[wv[i]]++;\n              for(i=1;i<m;i++)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n          return;\n      }\n      void calheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;i++) rank[sa[i]]=i;\n          for(i=0;i<n;height[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n          return;\n      }\n      int main()  \n      {  \n          int t;  \n          scanf(\"%d\",&t);  \n          while(t--)  \n          {  \n              int i;  \n              scanf(\"%s\",s);  \n              int n=strlen(s);   \n              da(n+1,128);  \n              calheight(n);  \n              long long ans=n*(n+1)/2;  \n              for(i=1;i<=n;i++)  \n              ans-=height[i];  \n              printf(\"%lld\\n\",ans);  \n          }  \n      }  \n\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.cpp)\n\n\n\n## (2).[cogs1709:不同的子串](http://cogs.pro/cogs/problem/problem.php?pid=1709) （spoj705）\n\n      #include<iostream>\n      #include<cstdio>\n      #include<cstring>\n      using namespace std;\n      const int N = 1e5+1;\n      const int maxf = 255;\n      int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];\n      char s[N];\n      bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;i--)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<m;++i)tong[i]=0;\n              for(i=0;i<n;++i)tong[wv[i]]++;\n              for(i=1;i<m;++i)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,i=1,x[sa[0]]=0;i<n;++i)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n          return;\n      }\n      void getheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;++i)rank[sa[i]]=i;\n          for(i=0;i<n;h[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n          return;\n      }\n      int main()\n      {\n      //  freopen(\"subst1.in\",\"r\",stdin);\n      //  freopen(\"subst1.out\",\"w\",stdout);\n          scanf(\"%s\",s);\n          int n=strlen(s);\n          da(n+1,maxf);\n          getheight(n);\n          for(int i=1;i<=n;++i)sa[i]++;\n          long long ans=0;\n          for(int i=1;i<=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1;\n          printf(\"%d\",ans);\n      }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.2.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例6         (1).[ural1297：Palindrome](https://vjudge.net/problem/URAL-1297)(Vjudge)\n\n这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]>=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。\n\n\n\n    #include<cstring>\n    #include<cstdlib>\n    #include<cstdio>\n    #include<iostream>\n    #include<cmath>\n    using namespace std;\n    const int N = 1e4+1;\n    int tong[N],wv[N],wa[N],wb[N];\n    int rank1[N],height[N],sa[N];\n    char s[N];\n    int a[N],n;\n    int dp[N][30];\n    int cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=a[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;i++)tong[i]=0;\n            for(i=0;i<n;i++)tong[wv[i]]++;\n            for(i=1;i<m;i++)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n      return;\n    }\n\n    void calheight(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;i++)rank1[sa[i]]=i;\n        for(i=0;i<n;height[rank1[i++]]=k)\n        for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++);\n        return;\n    }\n\n    void preRMQ()\n    {\n        int i,j;\n        memset(dp,127,sizeof(dp));\n        for(i=1;i<=n*2+1;i++)dp[i][0]=height[i];\n        for(j=1;(1<<j)<=2*n+1;j++)\n        for(i=1;i+(1<<j)-1<=2*n+1;i++)\n        dp[i][j]=min(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);\n    }\n\n    int lcp(int l,int r)\n    {\n        int a=rank1[l],b=rank1[r];\n        if(a>b)\n            swap(a,b);\n        a++;\n        int t=(int)(log(double(b-a+1))/log(2.00));\n        return min(dp[a][t],dp[b-(1<<t)+1][t]);\n    }\n\n    int main()\n    {\n        int i,res,flag,max;\n        while(scanf(\"%s\",s)!=EOF)\n        {\n            max=0;\n            n=strlen(s);\n            for(i=0;i<n;i++)a[i]=(int)s[i];\n            a[n]=1;\n            for(i=0;i<n;i++)a[i+n+1]=int(s[n-i-1]);\n            a[2*n+1]=0;\n            da(2*n+2,123);\n            calheight(2*n+1);\n            preRMQ();\n            for(i=0;i<n;i++)\n            {\n                res=lcp(i,2*n-i)*2-1;\n                if(max<res)   max=res,flag=i;\n                if(i>0)\n                {\n                    res=lcp(i,2*n-i+1)*2;\n                    if(max<res) max=res,flag=i;\n                }\n            }\n            if(max%2==1)for(i=flag-max/2;i<=flag+max/2;i++)   printf(\"%c\",s[i]);\n            else    for(i=flag-max/2;i<=flag+max/2-1;i++) printf(\"%c\",s[i]);\n            printf(\"\\n\");\n        }\n  }\n\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B6.cpp)\n\n-----------------------------------------------------------------------------------------------------------\n## 例7           (1).[cogs1710:Power Strings](http://cogs.pro/cogs/problem/problem.php?pid=1710)  （poj2406）\n\n本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n ## 例8       (1).[poj3693:Maximum repetition substring](http://poj.org/problem?id=3693)\n\n\n      #include<iostream>\n      #include<cstdio>\n      #include<cstring>\n      using namespace std;\n      const int N = 1e5+1;\n      const int maxf = 255;\n      int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];\n      int k,now,jj,maxr,cnt;\n      int d[N][21],ans[N];\n      char s[N*2];\n      bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<m;++i)tong[i]=0;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<n;++i)tong[wv[i]]++;\n              for(i=1;i<m;++i)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;++i)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n      }\n      void getheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;++i)rank[sa[i]]=i;\n          for(i=0;i<n;h[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      }\n      int prermq(int*a,int n)\n      {\n          for(int i=0;i<n;++i)d[i][0]=a[i];\n          for(int j=1;(1<<j)<=n;++j)\n          for(int i=0;i+(1<<j)-1<n;++i)\n          d[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n      }\n      int askrmq(int l,int r)\n      {\n          l=rank[l],r=rank[r];\n          if(l>r)swap(l,r);\n          l++;\n          int k=0;\n          while((1<<(k+1))<=r-l+1)k++;\n          return min(d[l][k],d[r-(1<<k)+1][k]);\n      }\n      int main()\n      {\n          int ccase=0;\n          while(1)\n          {\n          memset(h,0,sizeof(h));\n          memset(d,0,sizeof(d));\n          memset(tong,0,sizeof(tong));\n          memset(rank,0,sizeof(rank));\n          memset(ans,0,sizeof(ans));\n          ccase++;\n\n          k=now=jj=maxr=cnt=0;\n          scanf(\"%s\",s);\n          if(s[0]=='#')return 0;\n          int n=strlen(s);\n          da(n+1,maxf);\n          getheight(n);\n          prermq(h,n+1);\n          for(int i=1;i<n;++i) \n          for(int j=0;j+i<n;j+=i) \n          {\n              k=askrmq(j,j+i);\n              now=k/i+1;\n              jj=j-(i-k%i);\n              if (jj>=0&&askrmq(jj,jj+i)>=(i-k%i))++now;\n              if(now>maxr)    {cnt=0;maxr=now;ans[cnt++]=i;}\n              else if(now==maxr)  ans[cnt++]=i;\n          }\n              for(int i=1;i<=n;++i) \n              for(int j=0;j<cnt;++j)\n              if(askrmq(sa[i],sa[i]+ans[j])>=(maxr-1)*ans[j])\n              {\n                  jj=sa[i],k=ans[j];\n                  goto dd;\n              }\n              dd:;\n              printf(\"Case %d: \",ccase);\n              for (int i=0;i<maxr*k;++i)putchar(s[jj++]);\n              printf(\"\\n\");\n          }\n      }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B8.cpp)\n\n\n\n\n\n## (2).[cogs1711:重复的字符串](http://cogs.pro/cogs/problem/problem.php?pid=1711) （spoj687）\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例9      (1).[cogs1713:Long Long Message](http://cogs.pro/cogs/problem/problem.php?pid=1713)  （poj2774）\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 3e5+1;\n    const int maxf = 255;\n    const int inf =0x7fffffff;\n    int sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N];\n    char s[N],ss[N];\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;m=p,j<<=1)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,i=1,x[sa[0]]=0;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    }\n    int main()\n    {\n        freopen(\"longlongmessage.in\",\"r\",stdin);\n        freopen(\"longlongmessage.out\",\"w\",stdout);\n        scanf(\"%s\",s);\n        scanf(\"%s\",ss);\n        int n=strlen(s),m=strlen(ss);\n        s[n]='*';\n        for(int i=n+1;i<=n+m;++i)s[i]=ss[i-n-1];\n        int l=n+m+1;\n        da(l+1,maxf);\n        geth(l);\n        int maxx=0;\n        for(int i=2;i<=l;++i)\n        {\n            if(h[i]>maxx&&((sa[i]<n&&sa[i-1]>n)||(sa[i]>n&&sa[i-1]<n)))\n            maxx=h[i];\n        }\n        cout<<maxx;\n    }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B9.tag.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例10    (1).[cogs1712:Common Substrings](http://cogs.pro/cogs/problem/problem.php?pid=1712)  （poj3415）\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例11    (1).[cogs2128:生命形态](http://cogs.pro/cogs/problem/problem.php?pid=2128)   （poj3294）\n\n例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。\n\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N = 2e5+1;\n    const int inf =0x7fffffff;\n    const int maxf = 255;\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    int sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];\n    char ss[111][10001],s[N];\n    int nn[111],tt;\n    bool inq[111];\n    int ll[N];\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]=x[y[i]]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(i=1,p=1,swap(x,y),x[sa[0]]=0;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++);\n    }\n    int k;\n    int ansg;\n    bool can(int ans,int n,int flag)\n    {\n        if(!flag)\n        {\n            int tot1=0;\n            memset(inq,0,sizeof(inq));\n            for(int i=1;i<=n;++i)\n            {\n                if(h[i]<ans)\n                {\n                    memset(inq,0,sizeof(inq));  tot1=0;\n                }\n                else\n                {\n                    int nowq,nowt;\n                    for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])nowt=t;\n                    for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i]&&sa[i]<nn[t])nowq=t;\n                    if(!inq[nowq])tot1++,inq[nowq]=true;\n                    if(!inq[nowt])tot1++,inq[nowt]=true;\n                    if(tot1>=k)return 1;\n                }\n            }\n            return 0;\n        }\n        if(flag)\n        {\n          int lll=inf,rrr=-1;\n          int tot1=0;\n          memset(inq,0,sizeof(inq));\n          for(int i=1;i<=n;++i)\n          {\n              if(h[i]<ans)\n              {\n                  memset(inq,0,sizeof(inq));  tot1=0;\n                  lll=inf;rrr=-1;\n              }\n              else\n              {\n                  int nowq,nowt;\n                  if(sa[i-1]<lll)lll=sa[i-1];if(sa[i-1]>rrr)rrr=sa[i-1];\n                  if(sa[i]<lll)lll=sa[i];if(sa[i]>rrr)rrr=sa[i];\n                  for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])nowt=t;\n                  for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i]&&sa[i]<nn[t])nowq=t;\n                  if(!inq[nowq])tot1++,inq[nowq]=true;\n                  if(!inq[nowt])tot1++,inq[nowt]=true;\n                  if(tot1==k)ll[++ansg]=lll;\n              }\n          }\n      }\n    }\n      int main()\n      {\n      //  freopen(\"Lifeforms.in\",\"r\",stdin);\n      //  freopen(\"Lifeforms.out\",\"w\",stdout);\n          while(scanf(\"%d\",&tt)!=EOF)\n          {\n              if(!tt)return 0;\n              memset(wa,0,sizeof(wa));\n              memset(wb,0,sizeof(wb));\n              memset(wv,0,sizeof(wv));\n              memset(rank,0,sizeof(rank));\n              memset(sa,0,sizeof(sa));\n              memset(h,0,sizeof(h));\n              memset(nn,0,sizeof(nn));\n              memset(s,0,sizeof(s));\n              int tot=0;\n              int tmp=2;\n              ansg=0;\n              for(int i=1;i<=tt;++i)\n              {\n                  scanf(\"%s\",ss[i]);\n                  nn[i]=strlen(ss[i]);\n                  nn[0]=-1;\n                  for(int t=0;t<nn[i];++t)s[tot++]=ss[i][t];\n                  nn[i]+=nn[i-1]+(i==tt?0:1);\n                  if(i!=tt)s[tot++]=tmp++;\n              }\n              nn[tt]++;\n              int n=strlen(s);\n              da(n+1,maxf);\n              geth(n);\n              k=(tt)/2+1;\n              int l=0,r=n+1,mid;\n              while(l!=r)\n              {\n                  mid=(l+r+1)>>1;\n                  if(can(mid,n,0))  l=mid;\n                  else      r=mid-1;\n              }\n              if(l==0){printf(\"?\");goto dd;}\n              can(l,n,1);\n              for(int i=1;i<=ansg;++i)\n              {\n                  if(i!=1)\n                  {\n                  bool flag=0;\n                  for(int t=0;t<l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;}\n                  if(!flag)continue;\n                  }\n                  for(int t=ll[i];t<=ll[i]+l-1;++t)putchar(s[t]);\n                  printf(\"\\n\");\n              }\n              dd:;\n          }\n      }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B11.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例12    (1).[cogs2120:破译进攻计划](http://cogs.pro/cogs/problem/problem.php?pid=2120)   （spoj220）\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<cmath>\n    using namespace std;\n    const int N = 2e5+500;\n    const int maxf = 255;\n    int sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];\n    char s[N],ss[13][15031];\n    int inq[13],maxq[13],minq[13];\n    int tt,num;\n    bool use[13];\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;i--)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]=x[y[i]]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),x[sa[0]]=0,i=1,p=1;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    }\n    bool can(int ans,int n)\n    {\n        int tot=0;\n        for(int i=1;i<=n;++i)\n        {\n            if(h[i]<ans)\n            {\n                tot=0;\n                memset(inq,0,sizeof(inq));\n                memset(maxq,0,sizeof(maxq));\n                memset(minq,0x3f,sizeof(minq));\n                memset(use,0,sizeof(use));\n            }\n            else\n            {\n                for(int t=1;t<=num;++t)if(nn[t-1]<sa[i]&&sa[i]<=nn[t])\n                {\n                    inq[t]++;\n                    minq[t]=min(minq[t],sa[i]);\n                    maxq[t]=max(maxq[t],sa[i]);\n                    if(maxq[t]-minq[t]>=ans&&!use[t])tot++,use[t]=true;\n                    if(tot==num)return 1;\n                }\n                for(int t=1;t<=num;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])\n                {\n                    inq[t]++;\n                    minq[t]=min(minq[t],sa[i-1]);\n                    maxq[t]=max(maxq[t],sa[i-1]);\n                    if(maxq[t]-minq[t]>=ans&&!use[t])tot++,use[t]=true;\n                    if(tot==num)return 1;\n                }\n            } \n        }\n        return 0;\n    }\n    int main()\n    {\n    //  freopen(\"RelevantPhrasesofAnnihil.in\",\"r\",stdin);\n    //  freopen(\"RelevantPhrasesofAnnihil.out\",\"w\",stdout);\n        nn[0]=-1;\n        scanf(\"%d\",&tt);\n        while(tt--)\n        {\n            memset(inq,0,sizeof(inq));\n            memset(wa,0,sizeof(wa));\n            memset(wb,0,sizeof(wb));\n            memset(wv,0,sizeof(wv));\n            memset(sa,0,sizeof(sa));\n            memset(rank,0,sizeof(rank));\n            memset(h,0,sizeof(h));\n            scanf(\"%d\",&num);\n            int tot=0,qiguaizifu=2;\n            for(int i=1;i<=num;++i)\n            {\n                scanf(\"%s\",ss[i]);\n                nn[i]=strlen(ss[i]);\n            }\n            for(int i=1;i<=num;++i)\n            {\n                for(int t=0;t<nn[i];++t)\n                s[tot++]=ss[i][t];\n                s[tot++]=qiguaizifu++;\n            }\n            for(int i=1;i<=num;++i)nn[i]+=(nn[i-1]+1);\n            int n=strlen(s);\n            da(n+1,maxf);\n            geth(n);\n            int l=0,r=(n+1)/2;\n            while(l!=r)\n            {\n                int mid=l+r+1>>1;\n                if(can(mid,n))  l=mid;\n                else      r=mid-1;\n            }\n            printf(\"%d\\n\",l);\n        }\n    }\n\n\n[CODE](https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B12.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例13    (1).[poj1226:Substrings](http://poj.org/problem?id=1226)\n-------------------------------------------------------------\n\n    \n","content":"<h1 id=\"论文\"><a href=\"#论文\" class=\"headerlink\" title=\"论文\"></a>论文</h1><p><a href=\"https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/pdfs/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E4%B9%8B%E3%80%8A%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E5%8A%9B%E5%B7%A5%E5%85%B7%E3%80%8B.pdf\" target=\"_blank\" rel=\"external\">后缀数组——处理字符串的有力工具–罗穗骞</a></p>\n <a id=\"more\"></a> \n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><hr>\n<h2 id=\"例3-1-cogs902-Musical-Theme-poj1743\"><a href=\"#例3-1-cogs902-Musical-Theme-poj1743\" class=\"headerlink\" title=\"例3         (1).cogs902:Musical Theme(poj1743)\"></a>例3         (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=902\" target=\"_blank\" rel=\"external\">cogs902:Musical Theme</a>(poj1743)</h2><p>本题题目描述与论文略有差别。</p>\n<p>应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..））</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 1e5+1;\nconst int maxf = 255;\nconst int inf = 0x7fffffff;\nint wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];\nint s[N];\nint cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\nint i,j,p,*x=wa,*y=wb;\nfor(i=0;i&lt;m;i++)tong[i]=0;\nfor(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\nfor(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\nfor(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\nfor(p=1,j=1;p&lt;n;j&lt;&lt;=1,m=p)\n{\n    for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n    for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n    for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n    for(i=0;i&lt;m;i++)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[wv[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n    for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i)\n    x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n}\nreturn;\n}\nvoid getheight(int n)\n{\nint i,j,k=0;\nfor(i=1;i&lt;=n;++i)rank[sa[i]]=i;\nfor(i=0;i&lt;n;h[rank[i++]]=k)\nfor(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\nreturn;\n}\nbool can(int k,int n)\n{\nint tmp=0,maxsa=-1,minsa=inf;\nfor(int i=1;i&lt;=n;++i)\n{\n    if(h[i]&lt;k)maxsa=-1,minsa=inf;\n    if(sa[i]&lt;minsa)minsa=sa[i];\n    if(sa[i]&gt;maxsa)maxsa=sa[i];\n    if(maxsa-minsa&gt;k)return 1;\n}\nreturn 0;\n}\nint main()\n{\n//  freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin);\n//  freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout);\nint n,x;\nwhile(scanf(&quot;%d&quot;,&amp;n)!=EOF)\n{\n    memset(h,0,sizeof(h));\n    memset(sa,0,sizeof(sa));\n    memset(rank,0,sizeof(rank));\n    if(!n)break;\n    cin&gt;&gt;x;\n    for(int i=1;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;s[i]);\n    s[0]=s[1]-x;\n    for(int i=1;i&lt;n-1;++i)s[i]=s[i+1]-s[i];\n    n--;\n    for(int i=0;i&lt;n;++i)s[i]+=150;\n    da(n+1,maxf);\n    getheight(n);\n    int l=0,r=1e6,ans;\n    int mid=0;\n    while(l!=r)\n    {\n        ans=l+r+1&gt;&gt;1;\n        if(can(ans,n))  l=ans;\n        else      r=ans-1;\n    }\n    l++;\n    printf(&quot;%d\\n&quot;,(l)&gt;=5?l:0);\n}\n}\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B3.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例4-1-poj3261：Milk-Patterns\"><a href=\"#例4-1-poj3261：Milk-Patterns\" class=\"headerlink\" title=\"例4         (1).poj3261：Milk Patterns\"></a>例4         (1).<a href=\"http://poj.org/problem?id=3261\" target=\"_blank\" rel=\"external\">poj3261：Milk Patterns</a></h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxf = 255;\nconst int inf = 0x7fffffff;\nconst int N = 1e5+5;\nint sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];\nint s[N],k;\nint cmp(int*r,int a,int b,int l)\n{return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n        for(i=0;i&lt;m;i++)tong[i]=0;\n        for(i=0;i&lt;n;i++)tong[wv[i]]++;\n        for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n}\nvoid getheight(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;height[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    return;\n}\nbool can(int ans,int n)\n{\n    int tot=0;\n    for(int i=1;i&lt;=n;++i)\n    {\n        if(height[i]&lt;ans)tot=0;\n        tot++;\n        if(tot==k)return 1;\n    }\n    return 0;\n}\nint main()\n{\n    int n;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);\n    for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,s+i);\n    da(n+1,maxf);\n    getheight(n);\n    int l=1,r=n+1,ans,mid;\n    while(l!=r)\n    {\n        int mid=(l+r&gt;&gt;1)+1;\n        if(can(mid,n))ans=l=mid;\n        else    r=mid-1;\n    }\n    printf(&quot;%d\\n&quot;,ans);\n}\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B4.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例5-1-spoj694：Distinct-Substrings-Vjudge\"><a href=\"#例5-1-spoj694：Distinct-Substrings-Vjudge\" class=\"headerlink\" title=\"例5         (1).spoj694：Distinct Substrings(Vjudge)\"></a>例5         (1).<a href=\"https://vjudge.net/problem/SPOJ-DISUBSTR\" target=\"_blank\" rel=\"external\">spoj694：Distinct Substrings</a>(Vjudge)</h2><p>这题论文中的方法不太好想，可以换一种思路。</p>\n<p>易证长度为len的字符串一共有$（len+1）*len / 2$个子串。<br>而其中重复的字串个数则为height数组的总和，减去即可。</p>\n<p>以</p>\n<pre><code>sa[i-1]  abba\n\nsa[i]    abcd //height[i] = 2\n</code></pre><p>这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。</p>\n<p>这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为</p>\n<pre><code>   bba\n   bcd //height = 1\n</code></pre><p>   重复的子串 b 将在此处减掉。</p>\n<pre><code>  #include&lt;iostream&gt; \n  #include&lt;cstring&gt;\n  #include&lt;cstdio&gt;\n  const int N =1e4+5;       \n  using namespace std;       \n  char s[N];   \n  int sa[N],wa[N],wb[N],tong[N],wv[N];      \n  int rank[N],height[N];      \n  int cmp(int*r,int a,int b,int l)\n  {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n  void da(int n,int m)\n  {\n      int i,j,p,*x=wa,*y=wb;\n      for(i=0;i&lt;m;++i)tong[i]=0;\n      for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n      for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n      for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n      for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n      {\n          for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n          for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n          for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n          for(i=0;i&lt;m;i++)tong[i]=0;\n          for(i=0;i&lt;n;i++)tong[wv[i]]++;\n          for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n          for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n          x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n      }\n      return;\n  }\n  void calheight(int n)\n  {\n      int i,j,k=0;\n      for(i=1;i&lt;=n;i++) rank[sa[i]]=i;\n      for(i=0;i&lt;n;height[rank[i++]]=k)\n      for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      return;\n  }\n  int main()  \n  {  \n      int t;  \n      scanf(&quot;%d&quot;,&amp;t);  \n      while(t--)  \n      {  \n          int i;  \n          scanf(&quot;%s&quot;,s);  \n          int n=strlen(s);   \n          da(n+1,128);  \n          calheight(n);  \n          long long ans=n*(n+1)/2;  \n          for(i=1;i&lt;=n;i++)  \n          ans-=height[i];  \n          printf(&quot;%lld\\n&quot;,ans);  \n      }  \n  }  \n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<h2 id=\"2-cogs1709-不同的子串-（spoj705）\"><a href=\"#2-cogs1709-不同的子串-（spoj705）\" class=\"headerlink\" title=\"(2).cogs1709:不同的子串 （spoj705）\"></a>(2).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1709\" target=\"_blank\" rel=\"external\">cogs1709:不同的子串</a> （spoj705）</h2><pre><code>  #include&lt;iostream&gt;\n  #include&lt;cstdio&gt;\n  #include&lt;cstring&gt;\n  using namespace std;\n  const int N = 1e5+1;\n  const int maxf = 255;\n  int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];\n  char s[N];\n  bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n  void da(int n,int m)\n  {\n      int i,j,p,*x=wa,*y=wb;\n      for(i=0;i&lt;m;++i)tong[i]=0;\n      for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n      for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n      for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i;\n      for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n      {\n          for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n          for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n          for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n          for(i=0;i&lt;m;++i)tong[i]=0;\n          for(i=0;i&lt;n;++i)tong[wv[i]]++;\n          for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n          for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i)\n          x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n      }\n      return;\n  }\n  void getheight(int n)\n  {\n      int i,j,k=0;\n      for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n      for(i=0;i&lt;n;h[rank[i++]]=k)\n      for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      return;\n  }\n  int main()\n  {\n  //  freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin);\n  //  freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout);\n      scanf(&quot;%s&quot;,s);\n      int n=strlen(s);\n      da(n+1,maxf);\n      getheight(n);\n      for(int i=1;i&lt;=n;++i)sa[i]++;\n      long long ans=0;\n      for(int i=1;i&lt;=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1;\n      printf(&quot;%d&quot;,ans);\n  }\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.2.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例6-1-ural1297：Palindrome-Vjudge\"><a href=\"#例6-1-ural1297：Palindrome-Vjudge\" class=\"headerlink\" title=\"例6         (1).ural1297：Palindrome(Vjudge)\"></a>例6         (1).<a href=\"https://vjudge.net/problem/URAL-1297\" target=\"_blank\" rel=\"external\">ural1297：Palindrome</a>(Vjudge)</h2><p>这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。</p>\n<pre><code>#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nconst int N = 1e4+1;\nint tong[N],wv[N],wa[N],wb[N];\nint rank1[N],height[N],sa[N];\nchar s[N];\nint a[N],n;\nint dp[N][30];\nint cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=a[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n        for(i=0;i&lt;m;i++)tong[i]=0;\n        for(i=0;i&lt;n;i++)tong[wv[i]]++;\n        for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n  return;\n}\n\nvoid calheight(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;i++)rank1[sa[i]]=i;\n    for(i=0;i&lt;n;height[rank1[i++]]=k)\n    for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++);\n    return;\n}\n\nvoid preRMQ()\n{\n    int i,j;\n    memset(dp,127,sizeof(dp));\n    for(i=1;i&lt;=n*2+1;i++)dp[i][0]=height[i];\n    for(j=1;(1&lt;&lt;j)&lt;=2*n+1;j++)\n    for(i=1;i+(1&lt;&lt;j)-1&lt;=2*n+1;i++)\n    dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);\n}\n\nint lcp(int l,int r)\n{\n    int a=rank1[l],b=rank1[r];\n    if(a&gt;b)\n        swap(a,b);\n    a++;\n    int t=(int)(log(double(b-a+1))/log(2.00));\n    return min(dp[a][t],dp[b-(1&lt;&lt;t)+1][t]);\n}\n\nint main()\n{\n    int i,res,flag,max;\n    while(scanf(&quot;%s&quot;,s)!=EOF)\n    {\n        max=0;\n        n=strlen(s);\n        for(i=0;i&lt;n;i++)a[i]=(int)s[i];\n        a[n]=1;\n        for(i=0;i&lt;n;i++)a[i+n+1]=int(s[n-i-1]);\n        a[2*n+1]=0;\n        da(2*n+2,123);\n        calheight(2*n+1);\n        preRMQ();\n        for(i=0;i&lt;n;i++)\n        {\n            res=lcp(i,2*n-i)*2-1;\n            if(max&lt;res)   max=res,flag=i;\n            if(i&gt;0)\n            {\n                res=lcp(i,2*n-i+1)*2;\n                if(max&lt;res) max=res,flag=i;\n            }\n        }\n        if(max%2==1)for(i=flag-max/2;i&lt;=flag+max/2;i++)   printf(&quot;%c&quot;,s[i]);\n        else    for(i=flag-max/2;i&lt;=flag+max/2-1;i++) printf(&quot;%c&quot;,s[i]);\n        printf(&quot;\\n&quot;);\n    }\n</code></pre><p>  }</p>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B6.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例7-1-cogs1710-Power-Strings-（poj2406）\"><a href=\"#例7-1-cogs1710-Power-Strings-（poj2406）\" class=\"headerlink\" title=\"例7           (1).cogs1710:Power Strings  （poj2406）\"></a>例7           (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1710\" target=\"_blank\" rel=\"external\">cogs1710:Power Strings</a>  （poj2406）</h2><p>本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。</p>\n<hr>\n<h2 id=\"例8-1-poj3693-Maximum-repetition-substring\"><a href=\"#例8-1-poj3693-Maximum-repetition-substring\" class=\"headerlink\" title=\"例8       (1).poj3693:Maximum repetition substring\"></a>例8       (1).<a href=\"http://poj.org/problem?id=3693\" target=\"_blank\" rel=\"external\">poj3693:Maximum repetition substring</a></h2><pre><code>  #include&lt;iostream&gt;\n  #include&lt;cstdio&gt;\n  #include&lt;cstring&gt;\n  using namespace std;\n  const int N = 1e5+1;\n  const int maxf = 255;\n  int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];\n  int k,now,jj,maxr,cnt;\n  int d[N][21],ans[N];\n  char s[N*2];\n  bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n\n  void da(int n,int m)\n  {\n      int i,j,p,*x=wa,*y=wb;\n      for(i=0;i&lt;m;++i)tong[i]=0;\n      for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n      for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n      for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n      for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n      {\n          for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n          for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n          for(i=0;i&lt;m;++i)tong[i]=0;\n          for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n          for(i=0;i&lt;n;++i)tong[wv[i]]++;\n          for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n          for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i)\n          x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n      }\n  }\n  void getheight(int n)\n  {\n      int i,j,k=0;\n      for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n      for(i=0;i&lt;n;h[rank[i++]]=k)\n      for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n  }\n  int prermq(int*a,int n)\n  {\n      for(int i=0;i&lt;n;++i)d[i][0]=a[i];\n      for(int j=1;(1&lt;&lt;j)&lt;=n;++j)\n      for(int i=0;i+(1&lt;&lt;j)-1&lt;n;++i)\n      d[i][j]=min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]);\n  }\n  int askrmq(int l,int r)\n  {\n      l=rank[l],r=rank[r];\n      if(l&gt;r)swap(l,r);\n      l++;\n      int k=0;\n      while((1&lt;&lt;(k+1))&lt;=r-l+1)k++;\n      return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]);\n  }\n  int main()\n  {\n      int ccase=0;\n      while(1)\n      {\n      memset(h,0,sizeof(h));\n      memset(d,0,sizeof(d));\n      memset(tong,0,sizeof(tong));\n      memset(rank,0,sizeof(rank));\n      memset(ans,0,sizeof(ans));\n      ccase++;\n\n      k=now=jj=maxr=cnt=0;\n      scanf(&quot;%s&quot;,s);\n      if(s[0]==&#39;#&#39;)return 0;\n      int n=strlen(s);\n      da(n+1,maxf);\n      getheight(n);\n      prermq(h,n+1);\n      for(int i=1;i&lt;n;++i) \n      for(int j=0;j+i&lt;n;j+=i) \n      {\n          k=askrmq(j,j+i);\n          now=k/i+1;\n          jj=j-(i-k%i);\n          if (jj&gt;=0&amp;&amp;askrmq(jj,jj+i)&gt;=(i-k%i))++now;\n          if(now&gt;maxr)    {cnt=0;maxr=now;ans[cnt++]=i;}\n          else if(now==maxr)  ans[cnt++]=i;\n      }\n          for(int i=1;i&lt;=n;++i) \n          for(int j=0;j&lt;cnt;++j)\n          if(askrmq(sa[i],sa[i]+ans[j])&gt;=(maxr-1)*ans[j])\n          {\n              jj=sa[i],k=ans[j];\n              goto dd;\n          }\n          dd:;\n          printf(&quot;Case %d: &quot;,ccase);\n          for (int i=0;i&lt;maxr*k;++i)putchar(s[jj++]);\n          printf(&quot;\\n&quot;);\n      }\n  }\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B8.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<h2 id=\"2-cogs1711-重复的字符串-（spoj687）\"><a href=\"#2-cogs1711-重复的字符串-（spoj687）\" class=\"headerlink\" title=\"(2).cogs1711:重复的字符串 （spoj687）\"></a>(2).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1711\" target=\"_blank\" rel=\"external\">cogs1711:重复的字符串</a> （spoj687）</h2><hr>\n<h2 id=\"例9-1-cogs1713-Long-Long-Message-（poj2774）\"><a href=\"#例9-1-cogs1713-Long-Long-Message-（poj2774）\" class=\"headerlink\" title=\"例9      (1).cogs1713:Long Long Message  （poj2774）\"></a>例9      (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1713\" target=\"_blank\" rel=\"external\">cogs1713:Long Long Message</a>  （poj2774）</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 3e5+1;\nconst int maxf = 255;\nconst int inf =0x7fffffff;\nint sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N];\nchar s[N],ss[N];\nbool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;m=p,j&lt;&lt;=1)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[wv[i]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n}\nvoid geth(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n}\nint main()\n{\n    freopen(&quot;longlongmessage.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;longlongmessage.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%s&quot;,s);\n    scanf(&quot;%s&quot;,ss);\n    int n=strlen(s),m=strlen(ss);\n    s[n]=&#39;*&#39;;\n    for(int i=n+1;i&lt;=n+m;++i)s[i]=ss[i-n-1];\n    int l=n+m+1;\n    da(l+1,maxf);\n    geth(l);\n    int maxx=0;\n    for(int i=2;i&lt;=l;++i)\n    {\n        if(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i-1]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i-1]&lt;n)))\n        maxx=h[i];\n    }\n    cout&lt;&lt;maxx;\n}\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B9.tag.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例10-1-cogs1712-Common-Substrings-（poj3415）\"><a href=\"#例10-1-cogs1712-Common-Substrings-（poj3415）\" class=\"headerlink\" title=\"例10    (1).cogs1712:Common Substrings  （poj3415）\"></a>例10    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1712\" target=\"_blank\" rel=\"external\">cogs1712:Common Substrings</a>  （poj3415）</h2><hr>\n<h2 id=\"例11-1-cogs2128-生命形态-（poj3294）\"><a href=\"#例11-1-cogs2128-生命形态-（poj3294）\" class=\"headerlink\" title=\"例11    (1).cogs2128:生命形态   （poj3294）\"></a>例11    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=2128\" target=\"_blank\" rel=\"external\">cogs2128:生命形态</a>   （poj3294）</h2><p>例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N = 2e5+1;\nconst int inf =0x7fffffff;\nconst int maxf = 255;\nbool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nint sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];\nchar ss[111][10001],s[N];\nint nn[111],tt;\nbool inq[111];\nint ll[N];\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(i=1,p=1,swap(x,y),x[sa[0]]=0;i&lt;n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n}\nvoid geth(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;h[rank[i++]]=k)\n    for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++);\n}\nint k;\nint ansg;\nbool can(int ans,int n,int flag)\n{\n    if(!flag)\n    {\n        int tot1=0;\n        memset(inq,0,sizeof(inq));\n        for(int i=1;i&lt;=n;++i)\n        {\n            if(h[i]&lt;ans)\n            {\n                memset(inq,0,sizeof(inq));  tot1=0;\n            }\n            else\n            {\n                int nowq,nowt;\n                for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t;\n                for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;\n                if(!inq[nowq])tot1++,inq[nowq]=true;\n                if(!inq[nowt])tot1++,inq[nowt]=true;\n                if(tot1&gt;=k)return 1;\n            }\n        }\n        return 0;\n    }\n    if(flag)\n    {\n      int lll=inf,rrr=-1;\n      int tot1=0;\n      memset(inq,0,sizeof(inq));\n      for(int i=1;i&lt;=n;++i)\n      {\n          if(h[i]&lt;ans)\n          {\n              memset(inq,0,sizeof(inq));  tot1=0;\n              lll=inf;rrr=-1;\n          }\n          else\n          {\n              int nowq,nowt;\n              if(sa[i-1]&lt;lll)lll=sa[i-1];if(sa[i-1]&gt;rrr)rrr=sa[i-1];\n              if(sa[i]&lt;lll)lll=sa[i];if(sa[i]&gt;rrr)rrr=sa[i];\n              for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t;\n              for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;\n              if(!inq[nowq])tot1++,inq[nowq]=true;\n              if(!inq[nowt])tot1++,inq[nowt]=true;\n              if(tot1==k)ll[++ansg]=lll;\n          }\n      }\n  }\n}\n  int main()\n  {\n  //  freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin);\n  //  freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout);\n      while(scanf(&quot;%d&quot;,&amp;tt)!=EOF)\n      {\n          if(!tt)return 0;\n          memset(wa,0,sizeof(wa));\n          memset(wb,0,sizeof(wb));\n          memset(wv,0,sizeof(wv));\n          memset(rank,0,sizeof(rank));\n          memset(sa,0,sizeof(sa));\n          memset(h,0,sizeof(h));\n          memset(nn,0,sizeof(nn));\n          memset(s,0,sizeof(s));\n          int tot=0;\n          int tmp=2;\n          ansg=0;\n          for(int i=1;i&lt;=tt;++i)\n          {\n              scanf(&quot;%s&quot;,ss[i]);\n              nn[i]=strlen(ss[i]);\n              nn[0]=-1;\n              for(int t=0;t&lt;nn[i];++t)s[tot++]=ss[i][t];\n              nn[i]+=nn[i-1]+(i==tt?0:1);\n              if(i!=tt)s[tot++]=tmp++;\n          }\n          nn[tt]++;\n          int n=strlen(s);\n          da(n+1,maxf);\n          geth(n);\n          k=(tt)/2+1;\n          int l=0,r=n+1,mid;\n          while(l!=r)\n          {\n              mid=(l+r+1)&gt;&gt;1;\n              if(can(mid,n,0))  l=mid;\n              else      r=mid-1;\n          }\n          if(l==0){printf(&quot;?&quot;);goto dd;}\n          can(l,n,1);\n          for(int i=1;i&lt;=ansg;++i)\n          {\n              if(i!=1)\n              {\n              bool flag=0;\n              for(int t=0;t&lt;l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;}\n              if(!flag)continue;\n              }\n              for(int t=ll[i];t&lt;=ll[i]+l-1;++t)putchar(s[t]);\n              printf(&quot;\\n&quot;);\n          }\n          dd:;\n      }\n  }\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B11.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例12-1-cogs2120-破译进攻计划-（spoj220）\"><a href=\"#例12-1-cogs2120-破译进攻计划-（spoj220）\" class=\"headerlink\" title=\"例12    (1).cogs2120:破译进攻计划   （spoj220）\"></a>例12    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=2120\" target=\"_blank\" rel=\"external\">cogs2120:破译进攻计划</a>   （spoj220）</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nconst int N = 2e5+500;\nconst int maxf = 255;\nint sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];\nchar s[N],ss[13][15031];\nint inq[13],maxq[13],minq[13];\nint tt,num;\nbool use[13];\nbool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),x[sa[0]]=0,i=1,p=1;i&lt;n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n}\nvoid geth(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n}\nbool can(int ans,int n)\n{\n    int tot=0;\n    for(int i=1;i&lt;=n;++i)\n    {\n        if(h[i]&lt;ans)\n        {\n            tot=0;\n            memset(inq,0,sizeof(inq));\n            memset(maxq,0,sizeof(maxq));\n            memset(minq,0x3f,sizeof(minq));\n            memset(use,0,sizeof(use));\n        }\n        else\n        {\n            for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t])\n            {\n                inq[t]++;\n                minq[t]=min(minq[t],sa[i]);\n                maxq[t]=max(maxq[t],sa[i]);\n                if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true;\n                if(tot==num)return 1;\n            }\n            for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])\n            {\n                inq[t]++;\n                minq[t]=min(minq[t],sa[i-1]);\n                maxq[t]=max(maxq[t],sa[i-1]);\n                if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true;\n                if(tot==num)return 1;\n            }\n        } \n    }\n    return 0;\n}\nint main()\n{\n//  freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin);\n//  freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout);\n    nn[0]=-1;\n    scanf(&quot;%d&quot;,&amp;tt);\n    while(tt--)\n    {\n        memset(inq,0,sizeof(inq));\n        memset(wa,0,sizeof(wa));\n        memset(wb,0,sizeof(wb));\n        memset(wv,0,sizeof(wv));\n        memset(sa,0,sizeof(sa));\n        memset(rank,0,sizeof(rank));\n        memset(h,0,sizeof(h));\n        scanf(&quot;%d&quot;,&amp;num);\n        int tot=0,qiguaizifu=2;\n        for(int i=1;i&lt;=num;++i)\n        {\n            scanf(&quot;%s&quot;,ss[i]);\n            nn[i]=strlen(ss[i]);\n        }\n        for(int i=1;i&lt;=num;++i)\n        {\n            for(int t=0;t&lt;nn[i];++t)\n            s[tot++]=ss[i][t];\n            s[tot++]=qiguaizifu++;\n        }\n        for(int i=1;i&lt;=num;++i)nn[i]+=(nn[i-1]+1);\n        int n=strlen(s);\n        da(n+1,maxf);\n        geth(n);\n        int l=0,r=(n+1)/2;\n        while(l!=r)\n        {\n            int mid=l+r+1&gt;&gt;1;\n            if(can(mid,n))  l=mid;\n            else      r=mid-1;\n        }\n        printf(&quot;%d\\n&quot;,l);\n    }\n}\n</code></pre><p><a href=\"https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B12.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例13-1-poj1226-Substrings\"><a href=\"#例13-1-poj1226-Substrings\" class=\"headerlink\" title=\"例13    (1).poj1226:Substrings\"></a>例13    (1).<a href=\"http://poj.org/problem?id=1226\" target=\"_blank\" rel=\"external\">poj1226:Substrings</a></h2><hr>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/08/后缀数组13题/","excerpt":"论文后缀数组——处理字符串的有力工具–罗穗骞","categories":[{"name":"Hollerith-type","slug":"Hollerith-type","permalink":"https://prostkhala.github.io/categories/Hollerith-type/"},{"name":"后缀数组","slug":"Hollerith-type/后缀数组","permalink":"https://prostkhala.github.io/categories/Hollerith-type/后缀数组/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://prostkhala.github.io/tags/模板/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://prostkhala.github.io/tags/后缀数组/"}]},{"title":"C/C++代码规范","date":"2017-03-07T09:53:42.000Z","path":"2017/03/07/c++代码规范/","text":"命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C+ 命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C++ 12 静态变量的命名前缀 适用于C 13 自定义类型typedef的命名 适用于C++ 14 宏定义的命名 适用于C++ 15 C 函数的命名 适用于C++ 16 枚举的命名 适用于C++ 排版规则 1 布局和模板 11 类的布局模板 适用于C 12 源文件格式 适用于C 13 保护头文件不被重复包含 适用于C++ 14 方法和函数的布局 适用于C++ 2 缩进制表符以及空格 适用于C++ 3 尽量使一行不要超过78个字母 适用于C++ 4 保证一行只写一条语句 适用于C++ 5 花括号 规则 适用于C++ 51 花括号的位置 52 什么时候应使用花括号 53 在花括号结束的位置加上注释 54 注意屏幕大小 6圆括号 规则 适用于C++ 7if else 语句的格式 适用于C++ 8switch 格式 适用于C++ 9 使用gotocontinuebreak 和 适用于C++ 91 Goto 92 Continue and Break 93 10 运算符号的规则 适用于C++ 11 变量声明语句块 适用于C++ 文档及注释 1 文件或程序库的文档注释 适用于C++ 2 类文档注释 适用于C++ 3 函数文档注释 适用于C++ 4 Include 语句注释 适用于C++ 5语句块注释 适用于C++ 编码要求 1 不要忽略编译器的警告 适用于C++ 2 应使用源代码管理器 适用于C++ 3 固有的类方法成员 适用于C 4 使用命名空间 适用于C 5 初始化所有的变量 适用于C++ 6 保持函数短小精悍 适用于C++ 7对空语句进行注释 适用于C++ 8不要用if语句的默认方法测试非零值 适用于C++ 9布尔类型 适用于C++ 10避免在语句中内含赋值 适用于C++ 11正确的使用Const 适用于C++ 12不要在头文件定义数据适用于C++ 13不要直接使用数字 适用于C++ 14宏 适用于C++ 1. 命名规则1.1. 起个合适的名字1.1.1. 类的名称（适用于C++）² 类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。 ² 类的名字不需要告诉我们，它从哪个类继承而来的。 ² 有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。 1.1.2. 方法和函数的名称（适用于C/C++）² 方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。 ² 函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。 ² 可以加一些必要的后缀： Max – 表示取最大值 Cnt – 表示当前的计数值 Key – 表示键值 例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。 ² 前缀也同样有用： Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。 Get – 用于获取一个值。 Set – 用于设置一个值。 例如：IsHitRetryLimit. 1.1.3. 含有度量单位的名称（适用于C/C++）² 如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。 例如： uint32 mTimeoutMsecs; uint32 mMyWeightLbs; 1.1.4. 缩写名称不要全部大写（适用于C/C++）² 无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。 例如： class FluidOz; // 而不是 FluidOZ class NetworkAbcKey; // 而不是 NetworkABCKey 1.2.类的命名（适用于C++）² 用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。 ² 名字的第一个字母应大写 ² 不含有下划线 (‘_’) 例如： class NameOneTwo; class Name; 1.3.类库（或程序库）命名 （适用于C/C++）² 使用命名空间防止名字冲突。 ² 如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。 例如： John Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样： class JjLinkList { } 1.4.方法和函数的命名（适用于C++）² 使用与类名相同的规则 例如： class NameOneTwo { public: int DoIt(); void HandleError(); } 1.5.类属性的命名（适用于C++）² 属性（通常是非公有数据成员）名字以字母’m’开头。 ² 在 ‘m(m_)’ 后面，使用与类名相同的规则。 ² ‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。 例如： class NameOneTwo { public: int VarAbc(); int ErrorNumber(); private: int mVarAbc; int mErrorNumber; String* mpName; } 1.6.方法和函数参数的命名（适用于C++）² 第一个字母必须小写。 ² 第一个字母后面的单词使用与类名相同的规则。 例如： class NameOneTwo { public: int StartYourEngines( Engine&amp;rSomeEngine, Engine&amp;rAnotherEngine); } 1.7.局部变量的命名（适用于C/C++）² 所有字母都用小写 ² 使用下划线 ‘_’ 作为单词的分隔。 例如： int NameOneTwo::HandleError(int errorNumber) { int error= OsErr(); Time time_of_error; ErrorProcessor error_processor; } 1.8.指针变量的命名前缀（适用于C/C++）² 指针变量多数情况应在前面加 ‘p’。 ² 星号 ‘*’ 应靠近类型，而不是变量名。 例如： String* pName=new String; 特别的：String* pName, name; 应分成两行来写： String* pName; String name; 1.9.引用变量和返回引用函数的命名前缀（适用于C++）² 引用必须用 ‘r’作前缀修饰。 例如： class Test { public: void DoSomething(StatusInfo&amp;rStatus); StatusInfo&amp; rStatus(); constStatusInfo&amp; Status() const; // 这里返回的是常量引用，所以不符合本规则 private: StatusInfo&amp; mrStatus; } 1.10. 全局变量的命名前缀（适用于C/C++）² 全局变量总是以 ‘g(g_)’ 作为前缀。 例如： Logger g_Log; Logger* g_pLog; 1.11. 全局常量的命名（适用于C/C++）² 全局常量全部大写，并以下划线 ‘_’ 分隔单词。 例如： const intA_GLOBAL_CONSTANT = 5; 1.12. 静态变量的命名前缀（适用于C++）² 静态变量以 ‘s’ 作为前缀。 例如： class Test { public: private: staticStatusInfo m_sStatus; } 1.13. 自定义类型（typedef）的命名（适用于C/C++）² 类型定义名称指的是用typedef定义的名称。 ² 类型定义名称使用与类名相同的规则，并使用Type作为后缀。 例如： typedefuint16 ModuleType; typedefuint32 SystemType; 1.14. 宏定义的命名（适用于C/C++）² 所有单词的字母都用大写，并使用下划线 ‘_’ 分隔. 例如： #define MAX(a,b) blah #define IS_ERR(err) blah 1.15. C 函数的命名（适用于C/C++）² C++项目中，应尽量少用C函数。 ² C函数使用GNU规范，所有字母都使用小写，并用下划线 ‘_’ 作为单词的分隔。 例如： int some_bloody_function() { } ² 特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数： extern “C” int some_bloody_function(); ² 或在C/C++中推荐使用下面的格式： #ifdef__cplusplus__ extern “C”{ #endif int some_bloody_function() { } #ifdef__cplusplus__ } #endif 1.16. 枚举的命名（适用于C/C++）² 所有字母都大写，并用下划线 ‘_’ 作为单词分隔。 例如： enumPinStateType { PIN_OFF, PIN_ON }; enum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING}; 2. 排版规则2.1. 布局和模板2.1.1. 类的布局模板 （适用于C++）² 请使用下面的模板来创建一个新的类： /** * 用一行来描述类 * *#include &quot;XX.h&quot; &lt;BR&gt; *-llib * * 类的详细说明 * * @seesomething */ #ifndef SORUTION_PROJECT_CLASSNAME_H #define SORUTION_PROJECT_CLASSNAME_H // 在这里包含系统头文件 // // 在这里包含项目头文件 // // 在这里包含局部头文件 // // 在这里放置前置引用 // class XX { public: // 类的生命周期控制函数，如构造和析构，以及状态机 /** *Default constructor. */ XX(void); /** *Copy constructor. * *@param from The value to copy to this object. */ XX(const XX&amp; from); /** *Destructor. */ virtual ~XX(void); // 在这里放置类的运算操作符 /** *Assignment operator. * *@param from THe value to assign to this object. * *@return A reference to this object. */ XX&amp; operator=(XX&amp;from); // 在这里放置类的操作 // 在这里放置属性存取 // 在这里放置类的状态查询 protected: private: }; // 内联方法定义 // // 外部引用 // #endif // SORUTION_PROJECT_CLASSNAME_H ² 定义的顺序是: public, protected, private ² 要清楚public/protected/private都应该放置哪些东西 2.1.2. 源文件格式（适用于C++） #include &quot;XX.h&quot; // class implemented /////////////// PUBLIC/////////////////////// //================= 构造函数 ==================== XX::XX() { }// XX XX::XX(const XX&amp;) { }// XX XX::~XX() { }// ~XX //=============== 操作符========================= XX&amp; XX::operator=(XX&amp;); { return *this; }// = //==============类的操作 ===================== //==============属性存取 ===================== //==============状态查询 ===================== ///////////// PROTECTED ////////////////// ///////////// PRIVATE ////////////////// 2.1.3. 保护头文件不被重复包含 （适用于C/C++）² 应使用宏定义来保护头文件不被重复包含： #ifndef SORUTION_PROJECT_CLASSNAME_H #define SORUTION_PROJECT_CLASSNAME_H #endif // SORUTION_PROJECT_CLASSNAME_H ² 如果使用命名空间的时候，要把命名空间加到文件名前面： #ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H #define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H #endif 2.1.4. 方法和函数的布局 （适用于C/C++）² 对于有较多参数的函数的写法 如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐： int AnyMethod( int arg1, int arg2, int arg3, int arg4); 或 int AnyMethod( int arg1 , int arg2 , int arg3 , int arg4); 2.2. 缩进、制表符以及空格 （适用于C/C++）² 缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格） ² 不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。 ² 虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。 例如： void func() { if (something bad) { if (another thing bad) { while (more input) { } } } } 2.3. 尽量使一行不要超过78个字母 （适用于C/C++）² 有许多编辑器屏幕只有78个字母宽 2.4. 保证一行只写一条语句 （适用于C/C++）² 一行最多只写一条语句 ² 一行只定义一个变量 例如： 不要象下面这样: char** a, *x; int width, height; //widthand height of image 要象这样: char** a= 0; // 文档说明 char* x= 0; // 文档说明 2.5. 花括号 {} 规则 （适用于C/C++） 2.5.1. 花括号的位置 ² 在关键字的下一行单独放置括号，并且与关键字对齐，如： if (condition) { ... } while (condition) { … } 2.5.2. 什么时候应使用花括号所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。 ² 使用花括号格式： if (1 == somevalue) { somevalue = 2; } ² 单行格式： if (1 == somevalue) somevalue = 2; 或下面这样（对于这种写法，建议使用花括号）： if (1 == somevalue) { somevalue = 2; } 2.5.3. 在花括号结束的位置加上注释² 在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如： while(1) { if (valid) { } // if valid else { } // not valid } // end forever 2.5.4. 注意屏幕大小² 一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。 2.6.圆括号 () 规则 （适用于C/C++）² 圆括号与关键字之间应放一个空格。 ² 圆括号与函数名之间不要有空格。 ² Return 语句不要使用圆括号。 例如： if (condition) { } while(condition) { } strcpy(s, s1); return 1; 2.7.if else 语句的格式 （适用于C/C++）² 布局 if (条件) // 注释 { } else if (条件) // 注释 { } else // 注释 { } ² 条件格式 总是把常量放在等号或不等于号的左边： if ( 6 == errorNum ) ... 一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。 比如： if ( errorNum == 6) ... 错写成： if ( errorNum = 6) ... // 这是一个不容易发现的灾难 2.8.switch 格式 （适用于C/C++）² 直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。 ² 总是要写default语句，不管是否是需要。 ² 在case中需要定义变量的时候，应把所有代码放在语句块中。 例如： switch (...) { case 1: ... // 继续执行case2 case 2: { int v; ... } break; default: } 2.9. 使用goto,continue,break 和 ?: （适用于C/C++）2.9.1. Goto² 尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如： for (...) { while (...) { ... if (disaster) goto error; //跳出循环 } } ... error: clean up the mess ² 跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。 2.9.2. Continue and Break² Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。 2.9.3. ?:² 用括号把条件表达式括起来。 ² 不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。 ² 操作语句应分行写，除非它们能够简洁的放在一行当中。 例如： (condition) ?funct1() : func2(); 或 (condition) ? longstatement : anotherlong statement; 2.10. 运算符号的规则 （适用于C/C++）² 一元操作符如（!、~ 等等）应贴近操作对象。如： if (!IsOk) return ++v; ² 二元操作符如（+、*、%、== 等等）应在前后留空格。如： if ( v1 == v2) return v1 * 3; ² ++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。如： for(int i = 0; i &lt; 10; ++i) 2.11. 变量声明语句块 （适用于C/C++）² 变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。如： for(int i = 0; i &lt; 10; ++i) ² 声明语句块必须要对齐 类型，变量，等号和初始化值要分别对齐。 例如： DWORD mDword; DWORD* mpDword; char* mpChar; char mChar; mDword = 0; mpDword = NULL; mpChar = NULL; mChar = 0; 3. 文档及注释应当使用文档自动生成工具，来生成相关的程序文档。 3.1. 文件或程序库的文档注释（适用于C/C++）可以为整个文件编写文档。 例如： /** @file file.h * Abrief file description. * Amore elaborated file description. */ 3.2. 类文档注释（适用于C/C++）在类定义前面应加上类说明文档。 例如： /** WindowsNT * @brief Windows Nice Try. * @author Bill Gates * @author Several species of small furryanimals gathered together * in a cave and grooving with a pict. * @version 4.0 * @date 1996-1998 * @bug It crashes a lot and requires hugeamounts of memory. * @bug The class introduces the more bugs, thelonger it is used. * @warning This class may explode in your face. * @warning If you inherit anything from thisclass, you&#39;re doomed. */ class WindowsNT {}; 3.3. 函数文档注释（适用于C/C++）² 函数注释 所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如： /** * 赋值操作符 * *@param val 将要赋给本对象的值 * *@return 本对象的引用 */ XX&amp; operator =(XX&amp; val); ² 注释属性 一些自动文档工具定义的属性可以包含在文档中，常用的有： n 前提条件 (pre)定义调用这个函数的前提条件 n 警告说明 (warning)定义一些关于这个函数必须知道的事情。 n 备注说明 (remarks)定义一些关于这个函数的备注信息。 n 将要完成的工作 (todo)说明哪些事情将在不久以后完成 n 使用例子说明 (example)一个图片能表达100句话，一个好的例子能解答1000个问题。 例如： /** * 复制一个字串 * *@pre * - 需要保证(from != 0) * - 需要保证(to != 0) * *@warning * 缓冲区必需足够大，以便容纳的下要拷贝的字串。 * *@example teststrcpy.cpp * *@param from 要拷贝的字串 *@param to 用于容纳字串的缓冲区 *@return void */ void strcpy(constchar* from, char* to); 3.4. Include 语句注释 （适用于C/C++）² 如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。 3.5.语句块注释（适用于C/C++）² 语句块的注释可以用在语句块的开头和结束位置： { // Block1 (meaningful comment about Block1) ... some code { // Block2 (meaningful comment about Block2) ... somecode } // End Block2 } // End Block1 4. 编码要求4.1. 不要忽略编译器的警告（适用于C/C++）² 编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。 4.2. 应使用源代码管理器（适用于C/C++）² 根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。 4.3. 固有的类方法成员（适用于C++）² 默认构造函数(DefaultConstructor) 如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。 ² 虚析构函数(Virtual Destructor) 如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。 ² 拷贝构造函数(Copy Constructor) 如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。 ² 赋值操作(AssignmentOperator) 如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。 4.4. 使用命名空间 （适用于C++）² 命名规则 根名字一般是设计者的名字。比如公司名称等等。 ² 不要在全局空间使用using语句。 4.5. 初始化所有的变量 （适用于C/C++）² 无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。 4.6. 保持函数短小精悍（适用于C/C++）² 一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。 4.7.对空语句进行注释 （适用于C/C++）² For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如： while(*dest++ = *srC++) ; // VOID ² 不允许写成： while (*dest++ = *srC++) ; // 绝对不允许这么写 4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）² If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如： 建议使用： if (FAIL != f()) 不建议使用下面的表达式： if (f()) ² 宏定义的情况也一样： #define STREQ(a,b) (strcmp((a), (b)) == 0) 或者使用内联函数： inline bool StringEqual(char* a, char* b) { (strcmp(a, b)== 0) ? return true : return false; Or more compactly: returnstrcmp(a, b) == 0; } 4.9.布尔类型 （适用于C/C++）² 早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。 早期的布尔类型定义为： typedef int bool; #defineTRUE 1 #defineFALSE 0 或： const intTRUE = 1; const int FALSE= 0; ² 在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如： if (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？ 必须写成： if (FALSE !=func()) { ... 4.10. 避免在语句中内含赋值 （适用于C/C++）² 只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如： while (EOF != (c= getchar())) { process thecharacter } ² ++ 和 – 操作也是一种赋值语句 ² 内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如： a = b + c; d = a + r; 不应该写成： d = (a = b + c)+ r; 4.11. 正确的使用Const （适用于C/C++）² C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。 4.12. 不要在头文件定义数据（适用于C/C++）不要把数据定义放在头文件，如： /* * aheader.h */ int x = 0; 4.13. 不要直接使用数字 （适用于C/C++）² 直接使用数字，会使源代码难以理解和维护。如： if (22 ==foo) { start_thermo_nuclear_war(); } else if (19 == foo) {refund_lotso_money(); } else if (16 == foo) {infinite_loop(); } else { cry_cause_im_lost(); } 当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。 ² 我们可以用#define或者常量来改变这一状况，如： #define PRESIDENT_WENT_CRAZY (22) const int WE_GOOFED= 19; enum { THEY_DIDNT_PAY=16 }; if (PRESIDENT_WENT_CRAZY == foo) { start_thermo_nuclear_war(); } else if (WE_GOOFED == foo) {refund_lotso_money(); } else if (THEY_DIDNT_PAY == foo) { infinite_loop();} else {happy_days_i_know_why_im_here(); } 4.14. 宏（适用于C/C++）² 如果可以，使用内联函数代替宏。 例如： #ifndef MAX #define MAX(x,y) (((x) &gt; (y) ? (x) : (y)) // 取最大数 #endif 使用内联函数可以达到相同的效果，而且更安全： inline int max(int x, inty) { return (x&gt; y ? x : y); } ² 要注意副作用 必须小心副作用，因为在调用表达式时，会发生潜在的错误。 例如： MAX(f(x),z++); ² 表达式总是用括号括起来 在宏展开时，使用括号可以避免宏展开后产生的二义性。 例如： #define ADD(x,y) x + y 必须写成： #define ADD(x,y) ((x) + (y)) ² 保证宏名称的唯一性 和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题： n 在宏名称前加上库的名字避免使用简单而常用的名字，如：MAX 和MIN。","raw":"title: C/C++代码规范\ndate: 2017-03-07 17:53:42\ncategories:\n  - 代码规范\ntags:\n  - 代码规范\n---\n\n        命名规则\n        1 起个合适的名字\n            11    类的名称 适用于C\n            12    方法和函数的名称 适用于C++\n            13   含有度量单位的名称 适用于C++\n            14    缩写名称不要全部大写 适用于C++\n        2类的命名 适用于C\n        3类库或程序库命名 适用于C++\n        4方法和函数的命名 适用于C\n        5类属性的命名 适用于C\n        6方法和函数参数的命名 适用于C\n        7局部变量的命名 适用于C++\n        8指针变量的命名前缀 适用于C++\n        9引用变量和返回引用函数的命名前缀 适用于C\n        10   全局变量的命名前缀 适用于C++\n        11   全局常量的命名 适用于C+\n        命名规则\n        1 起个合适的名字\n            11    类的名称 适用于C\n            12    方法和函数的名称 适用于C++\n            13   含有度量单位的名称 适用于C++\n            14    缩写名称不要全部大写 适用于C++\n        2类的命名 适用于C\n        3类库或程序库命名 适用于C++\n        4方法和函数的命名 适用于C\n        5类属性的命名 适用于C\n        6方法和函数参数的命名 适用于C\n        7局部变量的命名 适用于C++\n        8指针变量的命名前缀 适用于C++\n        9引用变量和返回引用函数的命名前缀 适用于C\n        10   全局变量的命名前缀 适用于C++\n        11   全局常量的命名 适用于C++\n        12   静态变量的命名前缀 适用于C\n        13   自定义类型typedef的命名 适用于C++\n        14   宏定义的命名 适用于C++\n        15   C 函数的命名 适用于C++\n        16   枚举的命名 适用于C++\n        排版规则\n        1 布局和模板\n            11    类的布局模板 适用于C\n            12   源文件格式 适用于C\n            13    保护头文件不被重复包含 适用于C++\n            14    方法和函数的布局 适用于C++\n        2 缩进制表符以及空格 适用于C++\n        3 尽量使一行不要超过78个字母 适用于C++\n        4 保证一行只写一条语句 适用于C++\n        5 花括号 规则 适用于C++\n            51    花括号的位置\n            52    什么时候应使用花括号\n            53    在花括号结束的位置加上注释\n            54    注意屏幕大小 \n        6圆括号 规则 适用于C++\n        7if else 语句的格式 适用于C++\n        8switch 格式 适用于C++\n        9 使用gotocontinuebreak 和 适用于C++\n            91    Goto\n            92    Continue and Break\n            93    \n        10   运算符号的规则 适用于C++\n        11    变量声明语句块 适用于C++\n        文档及注释\n        1 文件或程序库的文档注释 适用于C++\n        2 类文档注释 适用于C++\n        3 函数文档注释 适用于C++\n        4 Include 语句注释 适用于C++\n        5语句块注释 适用于C++\n        编码要求\n        1 不要忽略编译器的警告 适用于C++\n        2 应使用源代码管理器 适用于C++\n        3 固有的类方法成员 适用于C\n        4 使用命名空间 适用于C\n        5 初始化所有的变量 适用于C++\n        6 保持函数短小精悍 适用于C++\n        7对空语句进行注释 适用于C++\n        8不要用if语句的默认方法测试非零值 适用于C++\n        9布尔类型 适用于C++\n        10避免在语句中内含赋值 适用于C++\n        11正确的使用Const 适用于C++\n        12不要在头文件定义数据适用于C++\n        13不要直接使用数字 适用于C++\n        14宏 适用于C++\n        \n <!--more--> \n \n# 1.    命名规则\n## 1.1. 起个合适的名字\n### 1.1.1.    类的名称（适用于C++）\n\n²  类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。\n\n²  类的名字不需要告诉我们，它从哪个类继承而来的。\n\n²  有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。\n### 1.1.2.    方法和函数的名称（适用于C/C++）\n\n²  方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。\n\n²  函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。\n\n²  可以加一些必要的后缀：\n\nMax – 表示取最大值\n\nCnt – 表示当前的计数值\n\nKey – 表示键值\n\n例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。\n\n²  前缀也同样有用：\n\nIs – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。\n\nGet – 用于获取一个值。\n\nSet – 用于设置一个值。\n\n例如：IsHitRetryLimit.\n### 1.1.3.   含有度量单位的名称（适用于C/C++）\n\n²  如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。\n\n例如：\n\n\tuint32 mTimeoutMsecs;\n\n\tuint32 mMyWeightLbs;\n### 1.1.4.    缩写名称不要全部大写（适用于C/C++）\n\n²  无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。\n\n例如：\n\n\tclass FluidOz;            // 而不是 FluidOZ\n\n\tclass NetworkAbcKey;      // 而不是 NetworkABCKey\n## 1.2.类的命名（适用于C++）\n\n²  用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。\n\n²  名字的第一个字母应大写\n\n²  不含有下划线 ('_')\n\n例如：\n\n   \tclass NameOneTwo; \n\n   \tclass Name;\n## 1.3.类库（或程序库）命名 （适用于C/C++）\n\n²  使用命名空间防止名字冲突。\n\n²  如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。\n\n例如：\n\nJohn Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样：\n\n   \tclass JjLinkList\n\n   \t{\n\n   \t}\n## 1.4.方法和函数的命名（适用于C++）\n\n²  使用与类名相同的规则\n\n例如：\n\n   \tclass NameOneTwo\n\n   \t{\n\n   \t\tpublic:\n\n      int     DoIt();\n\n      void    HandleError();\n\n   \t}\n   \n## 1.5.类属性的命名（适用于C++）\n\n²  属性（通常是非公有数据成员）名字以字母'm'开头。\n\n²  在 'm(m_)'  后面，使用与类名相同的规则。\n\n²  'm(m_)' 总是位于其它修饰符（如表示指针的 'p'）的前面。\n\n例如：\n\n       class NameOneTwo\n\n       {\n\n       public:\n\n          int     VarAbc();\n\n          int     ErrorNumber();\n\n       private:\n\n          int          mVarAbc;\n\n          int          mErrorNumber;\n\n          String*      mpName;\n\n       }\n## 1.6.方法和函数参数的命名（适用于C++）\n\n²  第一个字母必须小写。\n\n²  第一个字母后面的单词使用与类名相同的规则。\n\n例如：\n\n       class NameOneTwo\n\n       {\n\n       public:\n\n      int     StartYourEngines(\n\n                               Engine&rSomeEngine,\n\n                              Engine&rAnotherEngine);\n\n   \t}\n## 1.7.局部变量的命名（适用于C/C++）\n\n²  所有字母都用小写\n\n²  使用下划线 '_' 作为单词的分隔。\n\n例如：\n\n       int\n\n      NameOneTwo::HandleError(int errorNumber)\n\n       {\n\n      int            error= OsErr();\n\n      Time           time_of_error;\n\n     ErrorProcessor error_processor;\n\n   }\n## 1.8.指针变量的命名前缀（适用于C/C++）\n\n²  指针变量多数情况应在前面加 'p'。\n\n²  星号 '*' 应靠近类型，而不是变量名。\n\n例如：\n\n  \tString* pName=new String;\n\n \n\n  特别的：String* pName, name; 应分成两行来写：\n\n  \tString* pName;\n\n  \tString  name;\n## 1.9.引用变量和返回引用函数的命名前缀（适用于C++）\n\n²  引用必须用 'r'作前缀修饰。\n\n例如：\n\n   \tclass Test\n\n   \t{\n\n   \tpublic:\n\n      void               DoSomething(StatusInfo&rStatus);\n\n \n\n     StatusInfo&        rStatus();\n\n      constStatusInfo&  Status() const; // 这里返回的是常量引用，所以不符合本规则\n\n \n\n   \tprivate:\n\n     \tStatusInfo&        mrStatus;\n\n   \t}\n## 1.10.   全局变量的命名前缀（适用于C/C++）\n\n²  全局变量总是以 'g(g_)' 作为前缀。\n\n例如：\n\n    Logger g_Log;\n\n    Logger* g_pLog;\n## 1.11.   全局常量的命名（适用于C/C++）\n\n²  全局常量全部大写，并以下划线 '_' 分隔单词。\n\n例如：\n\n    const intA_GLOBAL_CONSTANT = 5;\n## 1.12.   静态变量的命名前缀（适用于C++）\n\n²  静态变量以 's' 作为前缀。\n\n例如：\n\n       class Test\n\n       {\n\n       public:\n\n       private:\n\n          staticStatusInfo m_sStatus;\n\n       }\n## 1.13.   自定义类型（typedef）的命名（适用于C/C++）\n\n²  类型定义名称指的是用typedef定义的名称。\n\n²  类型定义名称使用与类名相同的规则，并使用Type作为后缀。\n\n例如：\n\n       typedefuint16  ModuleType;\n\n       typedefuint32  SystemType;\n## 1.14.   宏定义的命名（适用于C/C++）\n\n²  所有单词的字母都用大写，并使用下划线 '_' 分隔.\n\n例如：\n\n\t#define MAX(a,b) blah\n\n\t#define IS_ERR(err) blah\n## 1.15.   C 函数的命名（适用于C/C++）\n\n²  C++项目中，应尽量少用C函数。\n\n²  C函数使用GNU规范，所有字母都使用小写，并用下划线 '_' 作为单词的分隔。\n\n例如：\n\n   \tint\n\n  \tsome_bloody_function()\n\n   \t{\n\n   \t}\n\n²  特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：\n\n       extern “C” int some_bloody_function();\n\n²  或在C/C++中推荐使用下面的格式：\n\n       #ifdef__cplusplus__\n\n       extern “C”{\n\n       #endif\n\n       int\n\n      some_bloody_function()\n\n       {\n\n       }\n\n       #ifdef__cplusplus__\n\n       }\n\n       #endif\n## 1.16.   枚举的命名（适用于C/C++）\n\n²  所有字母都大写，并用下划线 '_' 作为单词分隔。\n\n例如：\n\n   \tenumPinStateType\n\n   \t{\n\n      \tPIN_OFF,\n\n      \tPIN_ON\n\n   \t};\n\n\tenum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING};\n# 2.    排版规则\n## 2.1. 布局和模板\n### 2.1.1.    类的布局模板 （适用于C++）\n\n²  请使用下面的模板来创建一个新的类：\n\n\t/**     \n\n \t* 用一行来描述类\n\n \t*\n\n \t*#include \"XX.h\" <BR>\n\n \t*-llib\n\n \t*\n\n \t* 类的详细说明\n\n \t* \n\n \t* @seesomething\n\n \t*/\n\n \n\n\t#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n\t#define SORUTION_PROJECT_CLASSNAME_H\n\n \n\n\t// 在这里包含系统头文件\n\n\t//\n\n \n\n\t// 在这里包含项目头文件\n\n\t//\n\n \n\n\t// 在这里包含局部头文件\n\n\t//\n\n \n\n\t// 在这里放置前置引用\n\n\t//\n\n \n\n \n\n\t\tclass XX\n\n\t\t{\n\n\t\tpublic:\n\n    \t// 类的生命周期控制函数，如构造和析构，以及状态机\n\n \n\n    \t\t/**\n\n    \t\t*Default constructor.\n\n    \t\t*/\n\n    \t\tXX(void);\n\n \n\n    \t\t/**\n\n    \t\t*Copy constructor.\n\n    \t\t*\n\n    \t\t*@param from The value to copy to this object.\n\n    \t\t*/\n\n    \t\tXX(const XX& from);\n\n \n\n    \t\t/**\n\n    \t\t*Destructor.\n\n    \t\t*/\n\n\t\t    virtual ~XX(void);\n\n\t\t \n\n\t\t    // 在这里放置类的运算操作符\n\n\t\t \n\n\t\t    /**\n\n\t\t    *Assignment operator.\n\n\t\t    *\n\n\t\t    *@param from THe value to assign to this object.\n\n\t\t    *\n\n\t\t    *@return A reference to this object.\n\n\t\t    */\n\n\t\t    XX&                     operator=(XX&from); \n\n\t\t \n\n\t\t    // 在这里放置类的操作                      \n\n\t\t    // 在这里放置属性存取\n\n\t\t    // 在这里放置类的状态查询\n\n\t\t \n\n\t\t\tprotected:\n\n\t\t\tprivate:\n\n\t\t\t};\n\n \n\n\t\t// 内联方法定义\n\n\t\t//\n\n\t\t \n\n\t\t// 外部引用\n\n\t\t//\n\n\t\t \n\n\t\t#endif  // SORUTION_PROJECT_CLASSNAME_H\n\n \n\n²  定义的顺序是: public, protected, private\n\n²  要清楚public/protected/private都应该放置哪些东西\n### 2.1.2.   源文件格式（适用于C++）\n\n\t\t#include \"XX.h\"                               // class implemented\n\n \n\n \n\n/////////////// PUBLIC///////////////////////\n\n \n\n//================= 构造函数 ====================\n\n \n\n\t\tXX::XX()\n\n\t\t{\n\n\t\t}// XX\n\n\t\t \n\n\t\tXX::XX(const XX&)\n\n\t\t{\n\n\t\t}// XX\n\n\t\t \n\n\t\tXX::~XX()\n\n\t\t{\n\n\t\t}// ~XX\n\n\t\t \n\n \n\n//=============== 操作符=========================\n\n \n\n\t\tXX&\n\n\t\tXX::operator=(XX&);\n\n\t\t{\n\n\t\t   return *this;\n\n\t\t \n\n\t\t}// =\n\n\t\t \n\n//==============类的操作 =====================\n\n//==============属性存取 =====================\n\n//==============状态查询   =====================\n\n///////////// PROTECTED  //////////////////\n\n \n\n///////////// PRIVATE    //////////////////\n### 2.1.3.    保护头文件不被重复包含 （适用于C/C++）\n\n²  应使用宏定义来保护头文件不被重复包含：\n\n\t\t#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n\t\t#define SORUTION_PROJECT_CLASSNAME_H\n\n\t\t \n\n\t\t#endif // SORUTION_PROJECT_CLASSNAME_H\n\n \n\n \n\n²  如果使用命名空间的时候，要把命名空间加到文件名前面：\n\n\t\t#ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n\t\t#define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n \n\n#endif\n### 2.1.4.    方法和函数的布局 （适用于C/C++）\n\n²  对于有较多参数的函数的写法\n\n如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：\n\n\t\t   int AnyMethod(\n\n\t\t                 int  arg1, \n\n\t\t                 int   arg2,\n\n\t\t                 int   arg3,\n\n\t\t                 int   arg4); \n或\n\n\t\tint AnyMethod( int   arg1 \n\n\t\t               , int   arg2\n\n\t\t               , int   arg3\n\n\t\t               , int   arg4);\n\n \n## 2.2. 缩进、制表符以及空格 （适用于C/C++）\n\n²  缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格）\n\n²  不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。\n\n²  虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。\n\n例如：\n\n\t\t   void\n\n\t\t   func()\n\n\t\t   {\n\n\t\t      if (something bad)\n\n\t\t      {\n\n\t\t          if (another thing bad)\n\n\t\t          {\n\n\t\t              while (more input)\n\n\t\t              {\n\n\t\t              }\n\n\t\t          }\n\n\t\t      }\n\n\t\t   }\n## 2.3. 尽量使一行不要超过78个字母 （适用于C/C++）\n\n²  有许多编辑器屏幕只有78个字母宽\n## 2.4. 保证一行只写一条语句 （适用于C/C++）\n\n²  一行最多只写一条语句\n\n²  一行只定义一个变量\n\n例如：\n\n不要象下面这样:\n\n\t\tchar** a, *x;\n\n\t\t \n\n\t\tint width, height; //widthand height of image\n\n \n\n要象这样:\n\n\t\tchar** a= 0;  // 文档说明\n\n\t\tchar*  x= 0;  // 文档说明\n\t\t2.5. 花括号 {} 规则 （适用于C/C++）\n\t\t2.5.1.    花括号的位置\n\n²  在关键字的下一行单独放置括号，并且与关键字对齐，如：\n\n\t\tif (condition)       \n\n\t\t{\n\n\t\t    ...\n\n\t\t}\n\n\t\twhile (condition)\n\n\t\t{\n\n\t\t    …\n\n\t\t}\n### 2.5.2.    什么时候应使用花括号\n\n所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。\n\n²  使用花括号格式：\n\n\t\tif (1 == somevalue)\n\n\t\t{\n\n\t\t   somevalue = 2;\n\n\t\t}\n\n\t\t²  单行格式：\n\n\t\tif (1 == somevalue) somevalue = 2;\n\n\t\t或下面这样（对于这种写法，建议使用花括号）：\n\n\t\tif (1 == somevalue)\n\n\t\t{\n\t\tsomevalue = 2;\n\n\t\t}\n### 2.5.3.    在花括号结束的位置加上注释\n\n²  在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如：\n\n\t\twhile(1)\n\n\t\t{\n\n\t\t   if (valid)\n\n\t\t   {\n\n\t\t \n\n\t\t   } // if valid\n\n\t\t   else\n\n\t\t   {\n\n\t\t   } // not valid\n\n \n\n\t\t} // end forever\n### 2.5.4.    注意屏幕大小\n\n²  一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。\n## 2.6.圆括号 () 规则 （适用于C/C++）\n\n²  圆括号与关键字之间应放一个空格。\n\n²  圆括号与函数名之间不要有空格。\n\n²  Return 语句不要使用圆括号。\n\n例如：\n\n\t    if (condition)\n\n\t    {\n\n\t    }\n\n\t \n\n\t    while(condition)\n\n\t    {\n\n\t    }\n\n\t \n\n\t    strcpy(s, s1);\n\n \n\n    \treturn 1;\n## 2.7.if else 语句的格式 （适用于C/C++）\n\n²  布局\n\n\t\t   if (条件)               // 注释\n\n\t\t   {\n\n\t\t   }\n\n\t\t   else if (条件)           // 注释\n\n\t\t   {\n\n\t\t   }\n\n\t\t   else                   // 注释\n\n\t\t   {\n\n\t\t   }\n\n²  条件格式\n\n总是把常量放在等号或不等于号的左边：\n\n\t\tif ( 6 == errorNum ) ...\n\n一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。\n\n比如：\n\n\t\tif ( errorNum == 6) ...\n\n错写成：\n\n\t\tif ( errorNum = 6) ... // 这是一个不容易发现的灾难\n\n \n## 2.8.switch 格式 （适用于C/C++）\n\n²  直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。\n\n²  总是要写default语句，不管是否是需要。\n\n²  在case中需要定义变量的时候，应把所有代码放在语句块中。\n\n例如：\n\n\t\tswitch (...)\n\n\t\t{\n\n\t\tcase 1:\n\n\t\t    ...\n\n\t\t        // 继续执行case2\n\n\t\t \n\n\t\tcase 2:\n\n\t\t    {       \n\n\t\t        int v;\n\n\t\t        ...\n\n\t\t    }\n\n\t\t    break;\n\n\t\t \n\n\t\tdefault:\n\n\t\t}\n## 2.9. 使用goto,continue,break 和 ?: （适用于C/C++）\n### 2.9.1.    Goto\n\n²  尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如：\n\n\t\tfor (...)\n\n\t\t{\n\n\t\t    while (...)\n\n\t\t    {\n\n\t\t        ...\n\n\t\t            if (disaster)\n\n\t\tgoto error; //跳出循环\n\n\t\t    }\n\n\t\t}\n\n\t\t...\n\n\t\terror:\n\n\t\tclean up the mess\n\n²  跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。\n### 2.9.2.    Continue and Break\n\n²  Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。\n### 2.9.3.    ?:\n\n²  用括号把条件表达式括起来。\n\n²  不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。\n\n²  操作语句应分行写，除非它们能够简洁的放在一行当中。\n\n例如：\n\n   \t\t(condition) ?funct1() : func2();\n\n   或\n\n   \t\t(condition)\n\n     \t\t ? longstatement\n\n      \t\t: anotherlong statement;\n## 2.10.   运算符号的规则 （适用于C/C++）\n\n²  一元操作符如（!、~ 等等）应贴近操作对象。\n如：\n\n\t\tif (!IsOk)\n\n\t\t\treturn ++v;\n\n²  二元操作符如（+、*、%、== 等等）应在前后留空格。\n如：\n\n\t\tif ( v1 == v2)\n\n\t\t     return v1 * 3;\n\n²  ++ 和 -- 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。\n如：\n\t\tfor(int i = 0; i < 10; ++i)\n## 2.11.    变量声明语句块 （适用于C/C++）\n\n²  变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。\n如：\n\t\tfor(int i = 0; i < 10; ++i)\n\n \n\n²  声明语句块必须要对齐\n\n类型，变量，等号和初始化值要分别对齐。\n\n例如：\n\n\t\t   DWORD      mDword;\n\n\t\t   DWORD*     mpDword;\n\n\t\t   char*      mpChar;\n\n\t\t   char       mChar;\n\n\t\t \n\n\t\t   mDword     =    0;\n\n\t\t   mpDword    =    NULL;\n\n\t\t   mpChar      =    NULL;\n\n\t\t   mChar      =    0;\n# 3.    文档及注释\n\n应当使用文档自动生成工具，来生成相关的程序文档。\n## 3.1. 文件或程序库的文档注释（适用于C/C++）\n\n可以为整个文件编写文档。\n\n例如：\n\n\t\t/** @file file.h\n\n\t\t * Abrief file description.\n\n\t\t * Amore elaborated file description.\n\n\t\t */\n\n \n## 3.2. 类文档注释（适用于C/C++）\n\n在类定义前面应加上类说明文档。\n\n例如：\n\n\t\t/** WindowsNT\n\n\t\t *  @brief Windows Nice Try.\n\n\t\t *  @author Bill Gates\n\n\t\t *  @author Several species of small furryanimals gathered together\n\n\t\t *          in a cave and grooving with a pict.\n\n\t\t *  @version 4.0\n\n\t\t *  @date   1996-1998\n\n\t\t *  @bug It crashes a lot and requires hugeamounts of memory.\n\n\t\t *  @bug The class introduces the more bugs, thelonger it is used.\n\n\t\t *  @warning This class may explode in your face.\n\n\t\t *  @warning If you inherit anything from thisclass, you're doomed.\n\n\t\t */\n\n\t\tclass WindowsNT {};\n\n \n## 3.3. 函数文档注释（适用于C/C++）\n\n²  函数注释\n\n所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如：\n\n\t\t  /**\n\n\t\t   * 赋值操作符\n\n\t\t   *\n\n\t\t   *@param val 将要赋给本对象的值\n\n\t\t   *\n\n\t\t   *@return 本对象的引用\n\n\t\t   */\n\n\t\t  XX&  operator =(XX& val);\n\n²  注释属性\n\n一些自动文档工具定义的属性可以包含在文档中，常用的有：\n\nn  前提条件 (pre)\n定义调用这个函数的前提条件\n\nn  警告说明 (warning)\n定义一些关于这个函数必须知道的事情。\n\nn  备注说明 (remarks)\n定义一些关于这个函数的备注信息。\n\nn  将要完成的工作 (todo)\n说明哪些事情将在不久以后完成\n\nn  使用例子说明 (example)\n一个图片能表达100句话，一个好的例子能解答1000个问题。\n\n例如：\n\n\t\t  /**\n\n\t\t   * 复制一个字串\n\n\t\t   *\n\n\t\t   *@pre\n\n\t\t   *     - 需要保证(from != 0)\n\n\t\t   *     - 需要保证(to != 0)\n\n\t\t   *\n\n\t\t   *@warning\n\n\t\t   * 缓冲区必需足够大，以便容纳的下要拷贝的字串。\n\n\t\t   *\n\n\t\t   *@example teststrcpy.cpp\n\n\t\t   *\n\n\t\t   *@param from 要拷贝的字串\n\n\t\t   *@param to 用于容纳字串的缓冲区\n\n\t\t   *@return void\n\n\t\t   */\n\n\t\t  void  strcpy(constchar* from, char* to);\n## 3.4. Include 语句注释 （适用于C/C++）\n\n²  如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。\n## 3.5.语句块注释（适用于C/C++）\n\n²  语句块的注释可以用在语句块的开头和结束位置：\n\n\t\t{ \n\n\t\t    // Block1 (meaningful comment about Block1)\n\n\t\t    ... some code\n\n\t\t \n\n\t\t    { \n\n\t\t        // Block2 (meaningful comment about Block2)\n\n\t\t        ... somecode\n\n\t\t    }  // End Block2\n\n\t\t \n\n\t\t}  // End Block1\n# 4.    编码要求\n## 4.1. 不要忽略编译器的警告（适用于C/C++）\n\n²  编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。\n## 4.2. 应使用源代码管理器（适用于C/C++）\n\n²  根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。\n## 4.3. 固有的类方法成员（适用于C++）\n\n²  默认构造函数(DefaultConstructor)\n\n如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。\n\n²  虚析构函数(Virtual Destructor)\n\n如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。\n\n²  拷贝构造函数(Copy Constructor)\n\n如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。\n\n²  赋值操作(AssignmentOperator)\n\n如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。\n## 4.4. 使用命名空间 （适用于C++）\n\n²  命名规则\n\n根名字一般是设计者的名字。比如公司名称等等。\n\n²  不要在全局空间使用using语句。\n## 4.5. 初始化所有的变量 （适用于C/C++）\n\n²  无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。\n## 4.6. 保持函数短小精悍（适用于C/C++）\n\n²  一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。\n## 4.7.对空语句进行注释 （适用于C/C++）\n\n²  For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如：\n\n\t\t   while(*dest++ = *srC++)\n\n\t\t      ;         // VOID\n\n²  不允许写成：\n\n\t\t   while (*dest++ = *srC++) ;   // 绝对不允许这么写\n\n \n## 4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）\n\n²  If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如：\n\n建议使用：\n\n   \t\tif (FAIL != f())\n\n不建议使用下面的表达式：\n\n   \t\tif (f())\n\n \n\n²  宏定义的情况也一样：\n\n   \t\t#define STREQ(a,b) (strcmp((a), (b)) == 0)\n\n或者使用内联函数：\n\n\t\t   inline bool\n\n\t\t  StringEqual(char* a, char* b)\n\n\t\t   {\n\n\t\t      (strcmp(a, b)== 0) ? return true : return false;\n\n\t\t       Or more compactly:\n\n\t\t      returnstrcmp(a, b) == 0;\n\n\t\t   }\n## 4.9.布尔类型 （适用于C/C++）\n\n²  早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。\n\n \n\n早期的布尔类型定义为：\n\n\t\t   typedef int     bool;\n\n\t\t   #defineTRUE    1\n\n\t\t   #defineFALSE   0\n\n \n\n或：\n\n\t\t   const intTRUE  = 1;\n\n\t\t   const int FALSE= 0;\n\n \n\n²  在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如：\n\n   \t\tif (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？\n\n必须写成：\n\n   \t\tif (FALSE !=func()) { ...\n## 4.10.   避免在语句中内含赋值 （适用于C/C++）\n\n²  只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如：\n\n\t\t   while (EOF != (c= getchar()))\n\n\t\t   {\n\n\t\t      process thecharacter\n\n\t\t   }\n\n²  ++ 和 -- 操作也是一种赋值语句\n\n²  内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如：\n\n\t\t   a = b + c;\n\n\t\t   d = a + r;\n\n不应该写成：\n\n   \t\t\td = (a = b + c)+ r;\n## 4.11.   正确的使用Const （适用于C/C++）\n\n²  C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。\n## 4.12.    不要在头文件定义数据（适用于C/C++）\n\n不要把数据定义放在头文件，如：\n\n\t\t/*\n\n\t\t * aheader.h\n\n\t\t */\n\n\t\tint x = 0;\n## 4.13.   不要直接使用数字 （适用于C/C++）\n\n²  直接使用数字，会使源代码难以理解和维护。如：\n\n\t\tif      (22 ==foo)    { start_thermo_nuclear_war(); }\n\n\t\telse if (19 == foo)    {refund_lotso_money(); }\n\n\t\telse if (16 == foo)    {infinite_loop(); }\n\n\t\telse                   { cry_cause_im_lost(); }\n\n当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。\n\n²  我们可以用#define或者常量来改变这一状况，如：\n\n\t\t#define  PRESIDENT_WENT_CRAZY  (22)\n\n\t\tconst int WE_GOOFED= 19;\n\n\t\tenum\n\n\t\t{\n\n\t\t    THEY_DIDNT_PAY=16\n\n\t\t};\n\n\t\t \n\n\t\tif (PRESIDENT_WENT_CRAZY    == foo) { start_thermo_nuclear_war(); }\n\n\t\telse if (WE_GOOFED          == foo)  {refund_lotso_money(); }\n\n\t\telse if (THEY_DIDNT_PAY     == foo) { infinite_loop();}\n\n\t\telse                                 {happy_days_i_know_why_im_here(); }\n\n \n## 4.14.    宏（适用于C/C++）\n\n²  如果可以，使用内联函数代替宏。\n\n例如：\n\n\t\t#ifndef MAX\n\n\t\t#define  MAX(x,y)  (((x) > (y) ? (x) : (y))    // 取最大数\n\n\t\t#endif\n\n使用内联函数可以达到相同的效果，而且更安全：\n\n\t\t   inline int\n\n\t\t   max(int x, inty)\n\n\t\t   {\n\n\t\t      return (x> y ? x : y);\n\n\t\t   }\n\n²  要注意副作用\n\n必须小心副作用，因为在调用表达式时，会发生潜在的错误。\n\n例如：\n\n  \t\t MAX(f(x),z++);\n\n²  表达式总是用括号括起来\n\n在宏展开时，使用括号可以避免宏展开后产生的二义性。\n\n例如：\n\n\t\t#define ADD(x,y) x + y\n\n必须写成：\n\n\t\t#define ADD(x,y) ((x) + (y))\n\n²  保证宏名称的唯一性\n\n和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题：\n\nn  在宏名称前加上库的名字\n避免使用简单而常用的名字，如：MAX 和MIN。","content":"<pre><code>    命名规则\n    1 起个合适的名字\n        11    类的名称 适用于C\n        12    方法和函数的名称 适用于C++\n        13   含有度量单位的名称 适用于C++\n        14    缩写名称不要全部大写 适用于C++\n    2类的命名 适用于C\n    3类库或程序库命名 适用于C++\n    4方法和函数的命名 适用于C\n    5类属性的命名 适用于C\n    6方法和函数参数的命名 适用于C\n    7局部变量的命名 适用于C++\n    8指针变量的命名前缀 适用于C++\n    9引用变量和返回引用函数的命名前缀 适用于C\n    10   全局变量的命名前缀 适用于C++\n    11   全局常量的命名 适用于C+\n    命名规则\n    1 起个合适的名字\n        11    类的名称 适用于C\n        12    方法和函数的名称 适用于C++\n        13   含有度量单位的名称 适用于C++\n        14    缩写名称不要全部大写 适用于C++\n    2类的命名 适用于C\n    3类库或程序库命名 适用于C++\n    4方法和函数的命名 适用于C\n    5类属性的命名 适用于C\n    6方法和函数参数的命名 适用于C\n    7局部变量的命名 适用于C++\n    8指针变量的命名前缀 适用于C++\n    9引用变量和返回引用函数的命名前缀 适用于C\n    10   全局变量的命名前缀 适用于C++\n    11   全局常量的命名 适用于C++\n    12   静态变量的命名前缀 适用于C\n    13   自定义类型typedef的命名 适用于C++\n    14   宏定义的命名 适用于C++\n    15   C 函数的命名 适用于C++\n    16   枚举的命名 适用于C++\n    排版规则\n    1 布局和模板\n        11    类的布局模板 适用于C\n        12   源文件格式 适用于C\n        13    保护头文件不被重复包含 适用于C++\n        14    方法和函数的布局 适用于C++\n    2 缩进制表符以及空格 适用于C++\n    3 尽量使一行不要超过78个字母 适用于C++\n    4 保证一行只写一条语句 适用于C++\n    5 花括号 规则 适用于C++\n        51    花括号的位置\n        52    什么时候应使用花括号\n        53    在花括号结束的位置加上注释\n        54    注意屏幕大小 \n    6圆括号 规则 适用于C++\n    7if else 语句的格式 适用于C++\n    8switch 格式 适用于C++\n    9 使用gotocontinuebreak 和 适用于C++\n        91    Goto\n        92    Continue and Break\n        93    \n    10   运算符号的规则 适用于C++\n    11    变量声明语句块 适用于C++\n    文档及注释\n    1 文件或程序库的文档注释 适用于C++\n    2 类文档注释 适用于C++\n    3 函数文档注释 适用于C++\n    4 Include 语句注释 适用于C++\n    5语句块注释 适用于C++\n    编码要求\n    1 不要忽略编译器的警告 适用于C++\n    2 应使用源代码管理器 适用于C++\n    3 固有的类方法成员 适用于C\n    4 使用命名空间 适用于C\n    5 初始化所有的变量 适用于C++\n    6 保持函数短小精悍 适用于C++\n    7对空语句进行注释 适用于C++\n    8不要用if语句的默认方法测试非零值 适用于C++\n    9布尔类型 适用于C++\n    10避免在语句中内含赋值 适用于C++\n    11正确的使用Const 适用于C++\n    12不要在头文件定义数据适用于C++\n    13不要直接使用数字 适用于C++\n    14宏 适用于C++\n</code></pre> <a id=\"more\"></a> \n<h1 id=\"1-命名规则\"><a href=\"#1-命名规则\" class=\"headerlink\" title=\"1.    命名规则\"></a>1.    命名规则</h1><h2 id=\"1-1-起个合适的名字\"><a href=\"#1-1-起个合适的名字\" class=\"headerlink\" title=\"1.1. 起个合适的名字\"></a>1.1. 起个合适的名字</h2><h3 id=\"1-1-1-类的名称（适用于C-）\"><a href=\"#1-1-1-类的名称（适用于C-）\" class=\"headerlink\" title=\"1.1.1.    类的名称（适用于C++）\"></a>1.1.1.    类的名称（适用于C++）</h3><p>²  类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。</p>\n<p>²  类的名字不需要告诉我们，它从哪个类继承而来的。</p>\n<p>²  有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。</p>\n<h3 id=\"1-1-2-方法和函数的名称（适用于C-C-）\"><a href=\"#1-1-2-方法和函数的名称（适用于C-C-）\" class=\"headerlink\" title=\"1.1.2.    方法和函数的名称（适用于C/C++）\"></a>1.1.2.    方法和函数的名称（适用于C/C++）</h3><p>²  方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。</p>\n<p>²  函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。</p>\n<p>²  可以加一些必要的后缀：</p>\n<p>Max – 表示取最大值</p>\n<p>Cnt – 表示当前的计数值</p>\n<p>Key – 表示键值</p>\n<p>例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。</p>\n<p>²  前缀也同样有用：</p>\n<p>Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。</p>\n<p>Get – 用于获取一个值。</p>\n<p>Set – 用于设置一个值。</p>\n<p>例如：IsHitRetryLimit.</p>\n<h3 id=\"1-1-3-含有度量单位的名称（适用于C-C-）\"><a href=\"#1-1-3-含有度量单位的名称（适用于C-C-）\" class=\"headerlink\" title=\"1.1.3.   含有度量单位的名称（适用于C/C++）\"></a>1.1.3.   含有度量单位的名称（适用于C/C++）</h3><p>²  如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。</p>\n<p>例如：</p>\n<pre><code>uint32 mTimeoutMsecs;\n\nuint32 mMyWeightLbs;\n</code></pre><h3 id=\"1-1-4-缩写名称不要全部大写（适用于C-C-）\"><a href=\"#1-1-4-缩写名称不要全部大写（适用于C-C-）\" class=\"headerlink\" title=\"1.1.4.    缩写名称不要全部大写（适用于C/C++）\"></a>1.1.4.    缩写名称不要全部大写（适用于C/C++）</h3><p>²  无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。</p>\n<p>例如：</p>\n<pre><code>class FluidOz;            // 而不是 FluidOZ\n\nclass NetworkAbcKey;      // 而不是 NetworkABCKey\n</code></pre><h2 id=\"1-2-类的命名（适用于C-）\"><a href=\"#1-2-类的命名（适用于C-）\" class=\"headerlink\" title=\"1.2.类的命名（适用于C++）\"></a>1.2.类的命名（适用于C++）</h2><p>²  用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。</p>\n<p>²  名字的第一个字母应大写</p>\n<p>²  不含有下划线 (‘_’)</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo; \n\n   class Name;\n</code></pre><h2 id=\"1-3-类库（或程序库）命名-（适用于C-C-）\"><a href=\"#1-3-类库（或程序库）命名-（适用于C-C-）\" class=\"headerlink\" title=\"1.3.类库（或程序库）命名 （适用于C/C++）\"></a>1.3.类库（或程序库）命名 （适用于C/C++）</h2><p>²  使用命名空间防止名字冲突。</p>\n<p>²  如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。</p>\n<p>例如：</p>\n<p>John Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样：</p>\n<pre><code>   class JjLinkList\n\n   {\n\n   }\n</code></pre><h2 id=\"1-4-方法和函数的命名（适用于C-）\"><a href=\"#1-4-方法和函数的命名（适用于C-）\" class=\"headerlink\" title=\"1.4.方法和函数的命名（适用于C++）\"></a>1.4.方法和函数的命名（适用于C++）</h2><p>²  使用与类名相同的规则</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n       public:\n\n  int     DoIt();\n\n  void    HandleError();\n\n   }\n</code></pre><h2 id=\"1-5-类属性的命名（适用于C-）\"><a href=\"#1-5-类属性的命名（适用于C-）\" class=\"headerlink\" title=\"1.5.类属性的命名（适用于C++）\"></a>1.5.类属性的命名（适用于C++）</h2><p>²  属性（通常是非公有数据成员）名字以字母’m’开头。</p>\n<p>²  在 ‘m(m_)’  后面，使用与类名相同的规则。</p>\n<p>²  ‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n   public:\n\n      int     VarAbc();\n\n      int     ErrorNumber();\n\n   private:\n\n      int          mVarAbc;\n\n      int          mErrorNumber;\n\n      String*      mpName;\n\n   }\n</code></pre><h2 id=\"1-6-方法和函数参数的命名（适用于C-）\"><a href=\"#1-6-方法和函数参数的命名（适用于C-）\" class=\"headerlink\" title=\"1.6.方法和函数参数的命名（适用于C++）\"></a>1.6.方法和函数参数的命名（适用于C++）</h2><p>²  第一个字母必须小写。</p>\n<p>²  第一个字母后面的单词使用与类名相同的规则。</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n   public:\n\n  int     StartYourEngines(\n\n                           Engine&amp;rSomeEngine,\n\n                          Engine&amp;rAnotherEngine);\n\n   }\n</code></pre><h2 id=\"1-7-局部变量的命名（适用于C-C-）\"><a href=\"#1-7-局部变量的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.7.局部变量的命名（适用于C/C++）\"></a>1.7.局部变量的命名（适用于C/C++）</h2><p>²  所有字母都用小写</p>\n<p>²  使用下划线 ‘_’ 作为单词的分隔。</p>\n<p>例如：</p>\n<pre><code>   int\n\n  NameOneTwo::HandleError(int errorNumber)\n\n   {\n\n  int            error= OsErr();\n\n  Time           time_of_error;\n\n ErrorProcessor error_processor;\n</code></pre><p>   }</p>\n<h2 id=\"1-8-指针变量的命名前缀（适用于C-C-）\"><a href=\"#1-8-指针变量的命名前缀（适用于C-C-）\" class=\"headerlink\" title=\"1.8.指针变量的命名前缀（适用于C/C++）\"></a>1.8.指针变量的命名前缀（适用于C/C++）</h2><p>²  指针变量多数情况应在前面加 ‘p’。</p>\n<p>²  星号 ‘*’ 应靠近类型，而不是变量名。</p>\n<p>例如：</p>\n<pre><code>  String* pName=new String;\n</code></pre><p>  特别的：String* pName, name; 应分成两行来写：</p>\n<pre><code>  String* pName;\n\n  String  name;\n</code></pre><h2 id=\"1-9-引用变量和返回引用函数的命名前缀（适用于C-）\"><a href=\"#1-9-引用变量和返回引用函数的命名前缀（适用于C-）\" class=\"headerlink\" title=\"1.9.引用变量和返回引用函数的命名前缀（适用于C++）\"></a>1.9.引用变量和返回引用函数的命名前缀（适用于C++）</h2><p>²  引用必须用 ‘r’作前缀修饰。</p>\n<p>例如：</p>\n<pre><code>   class Test\n\n   {\n\n   public:\n\n  void               DoSomething(StatusInfo&amp;rStatus);\n\n\n\n StatusInfo&amp;        rStatus();\n\n  constStatusInfo&amp;  Status() const; // 这里返回的是常量引用，所以不符合本规则\n\n\n\n   private:\n\n     StatusInfo&amp;        mrStatus;\n\n   }\n</code></pre><h2 id=\"1-10-全局变量的命名前缀（适用于C-C-）\"><a href=\"#1-10-全局变量的命名前缀（适用于C-C-）\" class=\"headerlink\" title=\"1.10.   全局变量的命名前缀（适用于C/C++）\"></a>1.10.   全局变量的命名前缀（适用于C/C++）</h2><p>²  全局变量总是以 ‘g(g_)’ 作为前缀。</p>\n<p>例如：</p>\n<pre><code>Logger g_Log;\n\nLogger* g_pLog;\n</code></pre><h2 id=\"1-11-全局常量的命名（适用于C-C-）\"><a href=\"#1-11-全局常量的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.11.   全局常量的命名（适用于C/C++）\"></a>1.11.   全局常量的命名（适用于C/C++）</h2><p>²  全局常量全部大写，并以下划线 ‘_’ 分隔单词。</p>\n<p>例如：</p>\n<pre><code>const intA_GLOBAL_CONSTANT = 5;\n</code></pre><h2 id=\"1-12-静态变量的命名前缀（适用于C-）\"><a href=\"#1-12-静态变量的命名前缀（适用于C-）\" class=\"headerlink\" title=\"1.12.   静态变量的命名前缀（适用于C++）\"></a>1.12.   静态变量的命名前缀（适用于C++）</h2><p>²  静态变量以 ‘s’ 作为前缀。</p>\n<p>例如：</p>\n<pre><code>   class Test\n\n   {\n\n   public:\n\n   private:\n\n      staticStatusInfo m_sStatus;\n\n   }\n</code></pre><h2 id=\"1-13-自定义类型（typedef）的命名（适用于C-C-）\"><a href=\"#1-13-自定义类型（typedef）的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.13.   自定义类型（typedef）的命名（适用于C/C++）\"></a>1.13.   自定义类型（typedef）的命名（适用于C/C++）</h2><p>²  类型定义名称指的是用typedef定义的名称。</p>\n<p>²  类型定义名称使用与类名相同的规则，并使用Type作为后缀。</p>\n<p>例如：</p>\n<pre><code>   typedefuint16  ModuleType;\n\n   typedefuint32  SystemType;\n</code></pre><h2 id=\"1-14-宏定义的命名（适用于C-C-）\"><a href=\"#1-14-宏定义的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.14.   宏定义的命名（适用于C/C++）\"></a>1.14.   宏定义的命名（适用于C/C++）</h2><p>²  所有单词的字母都用大写，并使用下划线 ‘_’ 分隔.</p>\n<p>例如：</p>\n<pre><code>#define MAX(a,b) blah\n\n#define IS_ERR(err) blah\n</code></pre><h2 id=\"1-15-C-函数的命名（适用于C-C-）\"><a href=\"#1-15-C-函数的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.15.   C 函数的命名（适用于C/C++）\"></a>1.15.   C 函数的命名（适用于C/C++）</h2><p>²  C++项目中，应尽量少用C函数。</p>\n<p>²  C函数使用GNU规范，所有字母都使用小写，并用下划线 ‘_’ 作为单词的分隔。</p>\n<p>例如：</p>\n<pre><code>   int\n\n  some_bloody_function()\n\n   {\n\n   }\n</code></pre><p>²  特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：</p>\n<pre><code>   extern “C” int some_bloody_function();\n</code></pre><p>²  或在C/C++中推荐使用下面的格式：</p>\n<pre><code>   #ifdef__cplusplus__\n\n   extern “C”{\n\n   #endif\n\n   int\n\n  some_bloody_function()\n\n   {\n\n   }\n\n   #ifdef__cplusplus__\n\n   }\n\n   #endif\n</code></pre><h2 id=\"1-16-枚举的命名（适用于C-C-）\"><a href=\"#1-16-枚举的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.16.   枚举的命名（适用于C/C++）\"></a>1.16.   枚举的命名（适用于C/C++）</h2><p>²  所有字母都大写，并用下划线 ‘_’ 作为单词分隔。</p>\n<p>例如：</p>\n<pre><code>   enumPinStateType\n\n   {\n\n      PIN_OFF,\n\n      PIN_ON\n\n   };\n\nenum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING};\n</code></pre><h1 id=\"2-排版规则\"><a href=\"#2-排版规则\" class=\"headerlink\" title=\"2.    排版规则\"></a>2.    排版规则</h1><h2 id=\"2-1-布局和模板\"><a href=\"#2-1-布局和模板\" class=\"headerlink\" title=\"2.1. 布局和模板\"></a>2.1. 布局和模板</h2><h3 id=\"2-1-1-类的布局模板-（适用于C-）\"><a href=\"#2-1-1-类的布局模板-（适用于C-）\" class=\"headerlink\" title=\"2.1.1.    类的布局模板 （适用于C++）\"></a>2.1.1.    类的布局模板 （适用于C++）</h3><p>²  请使用下面的模板来创建一个新的类：</p>\n<pre><code>/**     \n\n * 用一行来描述类\n\n *\n\n *#include &quot;XX.h&quot; &lt;BR&gt;\n\n *-llib\n\n *\n\n * 类的详细说明\n\n * \n\n * @seesomething\n\n */\n\n\n\n#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n#define SORUTION_PROJECT_CLASSNAME_H\n\n\n\n// 在这里包含系统头文件\n\n//\n\n\n\n// 在这里包含项目头文件\n\n//\n\n\n\n// 在这里包含局部头文件\n\n//\n\n\n\n// 在这里放置前置引用\n\n//\n\n\n\n\n\n    class XX\n\n    {\n\n    public:\n\n    // 类的生命周期控制函数，如构造和析构，以及状态机\n\n\n\n        /**\n\n        *Default constructor.\n\n        */\n\n        XX(void);\n\n\n\n        /**\n\n        *Copy constructor.\n\n        *\n\n        *@param from The value to copy to this object.\n\n        */\n\n        XX(const XX&amp; from);\n\n\n\n        /**\n\n        *Destructor.\n\n        */\n\n        virtual ~XX(void);\n\n\n\n        // 在这里放置类的运算操作符\n\n\n\n        /**\n\n        *Assignment operator.\n\n        *\n\n        *@param from THe value to assign to this object.\n\n        *\n\n        *@return A reference to this object.\n\n        */\n\n        XX&amp;                     operator=(XX&amp;from); \n\n\n\n        // 在这里放置类的操作                      \n\n        // 在这里放置属性存取\n\n        // 在这里放置类的状态查询\n\n\n\n        protected:\n\n        private:\n\n        };\n\n\n\n    // 内联方法定义\n\n    //\n\n\n\n    // 外部引用\n\n    //\n\n\n\n    #endif  // SORUTION_PROJECT_CLASSNAME_H\n</code></pre><p>²  定义的顺序是: public, protected, private</p>\n<p>²  要清楚public/protected/private都应该放置哪些东西</p>\n<h3 id=\"2-1-2-源文件格式（适用于C-）\"><a href=\"#2-1-2-源文件格式（适用于C-）\" class=\"headerlink\" title=\"2.1.2.   源文件格式（适用于C++）\"></a>2.1.2.   源文件格式（适用于C++）</h3><pre><code>    #include &quot;XX.h&quot;                               // class implemented\n</code></pre><p>/////////////// PUBLIC///////////////////////</p>\n<p>//================= 构造函数 ====================</p>\n<pre><code>    XX::XX()\n\n    {\n\n    }// XX\n\n\n\n    XX::XX(const XX&amp;)\n\n    {\n\n    }// XX\n\n\n\n    XX::~XX()\n\n    {\n\n    }// ~XX\n</code></pre><p>//=============== 操作符=========================</p>\n<pre><code>    XX&amp;\n\n    XX::operator=(XX&amp;);\n\n    {\n\n       return *this;\n\n\n\n    }// =\n</code></pre><p>//==============类的操作 =====================</p>\n<p>//==============属性存取 =====================</p>\n<p>//==============状态查询   =====================</p>\n<p>///////////// PROTECTED  //////////////////</p>\n<p>///////////// PRIVATE    //////////////////</p>\n<h3 id=\"2-1-3-保护头文件不被重复包含-（适用于C-C-）\"><a href=\"#2-1-3-保护头文件不被重复包含-（适用于C-C-）\" class=\"headerlink\" title=\"2.1.3.    保护头文件不被重复包含 （适用于C/C++）\"></a>2.1.3.    保护头文件不被重复包含 （适用于C/C++）</h3><p>²  应使用宏定义来保护头文件不被重复包含：</p>\n<pre><code>    #ifndef SORUTION_PROJECT_CLASSNAME_H\n\n    #define SORUTION_PROJECT_CLASSNAME_H\n\n\n\n    #endif // SORUTION_PROJECT_CLASSNAME_H\n</code></pre><p>²  如果使用命名空间的时候，要把命名空间加到文件名前面：</p>\n<pre><code>    #ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n    #define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n</code></pre><p>#endif</p>\n<h3 id=\"2-1-4-方法和函数的布局-（适用于C-C-）\"><a href=\"#2-1-4-方法和函数的布局-（适用于C-C-）\" class=\"headerlink\" title=\"2.1.4.    方法和函数的布局 （适用于C/C++）\"></a>2.1.4.    方法和函数的布局 （适用于C/C++）</h3><p>²  对于有较多参数的函数的写法</p>\n<p>如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：</p>\n<pre><code>       int AnyMethod(\n\n                     int  arg1, \n\n                     int   arg2,\n\n                     int   arg3,\n\n                     int   arg4); \n</code></pre><p>或</p>\n<pre><code>    int AnyMethod( int   arg1 \n\n                   , int   arg2\n\n                   , int   arg3\n\n                   , int   arg4);\n</code></pre><h2 id=\"2-2-缩进、制表符以及空格-（适用于C-C-）\"><a href=\"#2-2-缩进、制表符以及空格-（适用于C-C-）\" class=\"headerlink\" title=\"2.2. 缩进、制表符以及空格 （适用于C/C++）\"></a>2.2. 缩进、制表符以及空格 （适用于C/C++）</h2><p>²  缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格）</p>\n<p>²  不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。</p>\n<p>²  虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。</p>\n<p>例如：</p>\n<pre><code>       void\n\n       func()\n\n       {\n\n          if (something bad)\n\n          {\n\n              if (another thing bad)\n\n              {\n\n                  while (more input)\n\n                  {\n\n                  }\n\n              }\n\n          }\n\n       }\n</code></pre><h2 id=\"2-3-尽量使一行不要超过78个字母-（适用于C-C-）\"><a href=\"#2-3-尽量使一行不要超过78个字母-（适用于C-C-）\" class=\"headerlink\" title=\"2.3. 尽量使一行不要超过78个字母 （适用于C/C++）\"></a>2.3. 尽量使一行不要超过78个字母 （适用于C/C++）</h2><p>²  有许多编辑器屏幕只有78个字母宽</p>\n<h2 id=\"2-4-保证一行只写一条语句-（适用于C-C-）\"><a href=\"#2-4-保证一行只写一条语句-（适用于C-C-）\" class=\"headerlink\" title=\"2.4. 保证一行只写一条语句 （适用于C/C++）\"></a>2.4. 保证一行只写一条语句 （适用于C/C++）</h2><p>²  一行最多只写一条语句</p>\n<p>²  一行只定义一个变量</p>\n<p>例如：</p>\n<p>不要象下面这样:</p>\n<pre><code>    char** a, *x;\n\n\n\n    int width, height; //widthand height of image\n</code></pre><p>要象这样:</p>\n<pre><code>    char** a= 0;  // 文档说明\n\n    char*  x= 0;  // 文档说明\n    2.5. 花括号 {} 规则 （适用于C/C++）\n    2.5.1.    花括号的位置\n</code></pre><p>²  在关键字的下一行单独放置括号，并且与关键字对齐，如：</p>\n<pre><code>    if (condition)       \n\n    {\n\n        ...\n\n    }\n\n    while (condition)\n\n    {\n\n        …\n\n    }\n</code></pre><h3 id=\"2-5-2-什么时候应使用花括号\"><a href=\"#2-5-2-什么时候应使用花括号\" class=\"headerlink\" title=\"2.5.2.    什么时候应使用花括号\"></a>2.5.2.    什么时候应使用花括号</h3><p>所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。</p>\n<p>²  使用花括号格式：</p>\n<pre><code>    if (1 == somevalue)\n\n    {\n\n       somevalue = 2;\n\n    }\n\n    ²  单行格式：\n\n    if (1 == somevalue) somevalue = 2;\n\n    或下面这样（对于这种写法，建议使用花括号）：\n\n    if (1 == somevalue)\n\n    {\n    somevalue = 2;\n\n    }\n</code></pre><h3 id=\"2-5-3-在花括号结束的位置加上注释\"><a href=\"#2-5-3-在花括号结束的位置加上注释\" class=\"headerlink\" title=\"2.5.3.    在花括号结束的位置加上注释\"></a>2.5.3.    在花括号结束的位置加上注释</h3><p>²  在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如：</p>\n<pre><code>    while(1)\n\n    {\n\n       if (valid)\n\n       {\n\n\n\n       } // if valid\n\n       else\n\n       {\n\n       } // not valid\n\n\n\n    } // end forever\n</code></pre><h3 id=\"2-5-4-注意屏幕大小\"><a href=\"#2-5-4-注意屏幕大小\" class=\"headerlink\" title=\"2.5.4.    注意屏幕大小\"></a>2.5.4.    注意屏幕大小</h3><p>²  一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。</p>\n<h2 id=\"2-6-圆括号-规则-（适用于C-C-）\"><a href=\"#2-6-圆括号-规则-（适用于C-C-）\" class=\"headerlink\" title=\"2.6.圆括号 () 规则 （适用于C/C++）\"></a>2.6.圆括号 () 规则 （适用于C/C++）</h2><p>²  圆括号与关键字之间应放一个空格。</p>\n<p>²  圆括号与函数名之间不要有空格。</p>\n<p>²  Return 语句不要使用圆括号。</p>\n<p>例如：</p>\n<pre><code>    if (condition)\n\n    {\n\n    }\n\n\n\n    while(condition)\n\n    {\n\n    }\n\n\n\n    strcpy(s, s1);\n\n\n\n    return 1;\n</code></pre><h2 id=\"2-7-if-else-语句的格式-（适用于C-C-）\"><a href=\"#2-7-if-else-语句的格式-（适用于C-C-）\" class=\"headerlink\" title=\"2.7.if else 语句的格式 （适用于C/C++）\"></a>2.7.if else 语句的格式 （适用于C/C++）</h2><p>²  布局</p>\n<pre><code>       if (条件)               // 注释\n\n       {\n\n       }\n\n       else if (条件)           // 注释\n\n       {\n\n       }\n\n       else                   // 注释\n\n       {\n\n       }\n</code></pre><p>²  条件格式</p>\n<p>总是把常量放在等号或不等于号的左边：</p>\n<pre><code>    if ( 6 == errorNum ) ...\n</code></pre><p>一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。</p>\n<p>比如：</p>\n<pre><code>    if ( errorNum == 6) ...\n</code></pre><p>错写成：</p>\n<pre><code>    if ( errorNum = 6) ... // 这是一个不容易发现的灾难\n</code></pre><h2 id=\"2-8-switch-格式-（适用于C-C-）\"><a href=\"#2-8-switch-格式-（适用于C-C-）\" class=\"headerlink\" title=\"2.8.switch 格式 （适用于C/C++）\"></a>2.8.switch 格式 （适用于C/C++）</h2><p>²  直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。</p>\n<p>²  总是要写default语句，不管是否是需要。</p>\n<p>²  在case中需要定义变量的时候，应把所有代码放在语句块中。</p>\n<p>例如：</p>\n<pre><code>    switch (...)\n\n    {\n\n    case 1:\n\n        ...\n\n            // 继续执行case2\n\n\n\n    case 2:\n\n        {       \n\n            int v;\n\n            ...\n\n        }\n\n        break;\n\n\n\n    default:\n\n    }\n</code></pre><h2 id=\"2-9-使用goto-continue-break-和-（适用于C-C-）\"><a href=\"#2-9-使用goto-continue-break-和-（适用于C-C-）\" class=\"headerlink\" title=\"2.9. 使用goto,continue,break 和 ?: （适用于C/C++）\"></a>2.9. 使用goto,continue,break 和 ?: （适用于C/C++）</h2><h3 id=\"2-9-1-Goto\"><a href=\"#2-9-1-Goto\" class=\"headerlink\" title=\"2.9.1.    Goto\"></a>2.9.1.    Goto</h3><p>²  尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如：</p>\n<pre><code>    for (...)\n\n    {\n\n        while (...)\n\n        {\n\n            ...\n\n                if (disaster)\n\n    goto error; //跳出循环\n\n        }\n\n    }\n\n    ...\n\n    error:\n\n    clean up the mess\n</code></pre><p>²  跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。</p>\n<h3 id=\"2-9-2-Continue-and-Break\"><a href=\"#2-9-2-Continue-and-Break\" class=\"headerlink\" title=\"2.9.2.    Continue and Break\"></a>2.9.2.    Continue and Break</h3><p>²  Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。</p>\n<h3 id=\"2-9-3\"><a href=\"#2-9-3\" class=\"headerlink\" title=\"2.9.3.    ?:\"></a>2.9.3.    ?:</h3><p>²  用括号把条件表达式括起来。</p>\n<p>²  不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。</p>\n<p>²  操作语句应分行写，除非它们能够简洁的放在一行当中。</p>\n<p>例如：</p>\n<pre><code>       (condition) ?funct1() : func2();\n</code></pre><p>   或</p>\n<pre><code>       (condition)\n\n          ? longstatement\n\n          : anotherlong statement;\n</code></pre><h2 id=\"2-10-运算符号的规则-（适用于C-C-）\"><a href=\"#2-10-运算符号的规则-（适用于C-C-）\" class=\"headerlink\" title=\"2.10.   运算符号的规则 （适用于C/C++）\"></a>2.10.   运算符号的规则 （适用于C/C++）</h2><p>²  一元操作符如（!、~ 等等）应贴近操作对象。<br>如：</p>\n<pre><code>    if (!IsOk)\n\n        return ++v;\n</code></pre><p>²  二元操作符如（+、*、%、== 等等）应在前后留空格。<br>如：</p>\n<pre><code>    if ( v1 == v2)\n\n         return v1 * 3;\n</code></pre><p>²  ++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。<br>如：<br>        for(int i = 0; i &lt; 10; ++i)</p>\n<h2 id=\"2-11-变量声明语句块-（适用于C-C-）\"><a href=\"#2-11-变量声明语句块-（适用于C-C-）\" class=\"headerlink\" title=\"2.11.    变量声明语句块 （适用于C/C++）\"></a>2.11.    变量声明语句块 （适用于C/C++）</h2><p>²  变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。<br>如：<br>        for(int i = 0; i &lt; 10; ++i)</p>\n<p>²  声明语句块必须要对齐</p>\n<p>类型，变量，等号和初始化值要分别对齐。</p>\n<p>例如：</p>\n<pre><code>       DWORD      mDword;\n\n       DWORD*     mpDword;\n\n       char*      mpChar;\n\n       char       mChar;\n\n\n\n       mDword     =    0;\n\n       mpDword    =    NULL;\n\n       mpChar      =    NULL;\n\n       mChar      =    0;\n</code></pre><h1 id=\"3-文档及注释\"><a href=\"#3-文档及注释\" class=\"headerlink\" title=\"3.    文档及注释\"></a>3.    文档及注释</h1><p>应当使用文档自动生成工具，来生成相关的程序文档。</p>\n<h2 id=\"3-1-文件或程序库的文档注释（适用于C-C-）\"><a href=\"#3-1-文件或程序库的文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.1. 文件或程序库的文档注释（适用于C/C++）\"></a>3.1. 文件或程序库的文档注释（适用于C/C++）</h2><p>可以为整个文件编写文档。</p>\n<p>例如：</p>\n<pre><code>    /** @file file.h\n\n     * Abrief file description.\n\n     * Amore elaborated file description.\n\n     */\n</code></pre><h2 id=\"3-2-类文档注释（适用于C-C-）\"><a href=\"#3-2-类文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.2. 类文档注释（适用于C/C++）\"></a>3.2. 类文档注释（适用于C/C++）</h2><p>在类定义前面应加上类说明文档。</p>\n<p>例如：</p>\n<pre><code>    /** WindowsNT\n\n     *  @brief Windows Nice Try.\n\n     *  @author Bill Gates\n\n     *  @author Several species of small furryanimals gathered together\n\n     *          in a cave and grooving with a pict.\n\n     *  @version 4.0\n\n     *  @date   1996-1998\n\n     *  @bug It crashes a lot and requires hugeamounts of memory.\n\n     *  @bug The class introduces the more bugs, thelonger it is used.\n\n     *  @warning This class may explode in your face.\n\n     *  @warning If you inherit anything from thisclass, you&#39;re doomed.\n\n     */\n\n    class WindowsNT {};\n</code></pre><h2 id=\"3-3-函数文档注释（适用于C-C-）\"><a href=\"#3-3-函数文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.3. 函数文档注释（适用于C/C++）\"></a>3.3. 函数文档注释（适用于C/C++）</h2><p>²  函数注释</p>\n<p>所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如：</p>\n<pre><code>      /**\n\n       * 赋值操作符\n\n       *\n\n       *@param val 将要赋给本对象的值\n\n       *\n\n       *@return 本对象的引用\n\n       */\n\n      XX&amp;  operator =(XX&amp; val);\n</code></pre><p>²  注释属性</p>\n<p>一些自动文档工具定义的属性可以包含在文档中，常用的有：</p>\n<p>n  前提条件 (pre)<br>定义调用这个函数的前提条件</p>\n<p>n  警告说明 (warning)<br>定义一些关于这个函数必须知道的事情。</p>\n<p>n  备注说明 (remarks)<br>定义一些关于这个函数的备注信息。</p>\n<p>n  将要完成的工作 (todo)<br>说明哪些事情将在不久以后完成</p>\n<p>n  使用例子说明 (example)<br>一个图片能表达100句话，一个好的例子能解答1000个问题。</p>\n<p>例如：</p>\n<pre><code>      /**\n\n       * 复制一个字串\n\n       *\n\n       *@pre\n\n       *     - 需要保证(from != 0)\n\n       *     - 需要保证(to != 0)\n\n       *\n\n       *@warning\n\n       * 缓冲区必需足够大，以便容纳的下要拷贝的字串。\n\n       *\n\n       *@example teststrcpy.cpp\n\n       *\n\n       *@param from 要拷贝的字串\n\n       *@param to 用于容纳字串的缓冲区\n\n       *@return void\n\n       */\n\n      void  strcpy(constchar* from, char* to);\n</code></pre><h2 id=\"3-4-Include-语句注释-（适用于C-C-）\"><a href=\"#3-4-Include-语句注释-（适用于C-C-）\" class=\"headerlink\" title=\"3.4. Include 语句注释 （适用于C/C++）\"></a>3.4. Include 语句注释 （适用于C/C++）</h2><p>²  如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。</p>\n<h2 id=\"3-5-语句块注释（适用于C-C-）\"><a href=\"#3-5-语句块注释（适用于C-C-）\" class=\"headerlink\" title=\"3.5.语句块注释（适用于C/C++）\"></a>3.5.语句块注释（适用于C/C++）</h2><p>²  语句块的注释可以用在语句块的开头和结束位置：</p>\n<pre><code>    { \n\n        // Block1 (meaningful comment about Block1)\n\n        ... some code\n\n\n\n        { \n\n            // Block2 (meaningful comment about Block2)\n\n            ... somecode\n\n        }  // End Block2\n\n\n\n    }  // End Block1\n</code></pre><h1 id=\"4-编码要求\"><a href=\"#4-编码要求\" class=\"headerlink\" title=\"4.    编码要求\"></a>4.    编码要求</h1><h2 id=\"4-1-不要忽略编译器的警告（适用于C-C-）\"><a href=\"#4-1-不要忽略编译器的警告（适用于C-C-）\" class=\"headerlink\" title=\"4.1. 不要忽略编译器的警告（适用于C/C++）\"></a>4.1. 不要忽略编译器的警告（适用于C/C++）</h2><p>²  编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。</p>\n<h2 id=\"4-2-应使用源代码管理器（适用于C-C-）\"><a href=\"#4-2-应使用源代码管理器（适用于C-C-）\" class=\"headerlink\" title=\"4.2. 应使用源代码管理器（适用于C/C++）\"></a>4.2. 应使用源代码管理器（适用于C/C++）</h2><p>²  根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。</p>\n<h2 id=\"4-3-固有的类方法成员（适用于C-）\"><a href=\"#4-3-固有的类方法成员（适用于C-）\" class=\"headerlink\" title=\"4.3. 固有的类方法成员（适用于C++）\"></a>4.3. 固有的类方法成员（适用于C++）</h2><p>²  默认构造函数(DefaultConstructor)</p>\n<p>如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。</p>\n<p>²  虚析构函数(Virtual Destructor)</p>\n<p>如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。</p>\n<p>²  拷贝构造函数(Copy Constructor)</p>\n<p>如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。</p>\n<p>²  赋值操作(AssignmentOperator)</p>\n<p>如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。</p>\n<h2 id=\"4-4-使用命名空间-（适用于C-）\"><a href=\"#4-4-使用命名空间-（适用于C-）\" class=\"headerlink\" title=\"4.4. 使用命名空间 （适用于C++）\"></a>4.4. 使用命名空间 （适用于C++）</h2><p>²  命名规则</p>\n<p>根名字一般是设计者的名字。比如公司名称等等。</p>\n<p>²  不要在全局空间使用using语句。</p>\n<h2 id=\"4-5-初始化所有的变量-（适用于C-C-）\"><a href=\"#4-5-初始化所有的变量-（适用于C-C-）\" class=\"headerlink\" title=\"4.5. 初始化所有的变量 （适用于C/C++）\"></a>4.5. 初始化所有的变量 （适用于C/C++）</h2><p>²  无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。</p>\n<h2 id=\"4-6-保持函数短小精悍（适用于C-C-）\"><a href=\"#4-6-保持函数短小精悍（适用于C-C-）\" class=\"headerlink\" title=\"4.6. 保持函数短小精悍（适用于C/C++）\"></a>4.6. 保持函数短小精悍（适用于C/C++）</h2><p>²  一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。</p>\n<h2 id=\"4-7-对空语句进行注释-（适用于C-C-）\"><a href=\"#4-7-对空语句进行注释-（适用于C-C-）\" class=\"headerlink\" title=\"4.7.对空语句进行注释 （适用于C/C++）\"></a>4.7.对空语句进行注释 （适用于C/C++）</h2><p>²  For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如：</p>\n<pre><code>       while(*dest++ = *srC++)\n\n          ;         // VOID\n</code></pre><p>²  不允许写成：</p>\n<pre><code>       while (*dest++ = *srC++) ;   // 绝对不允许这么写\n</code></pre><h2 id=\"4-8-不要用if语句的默认方法测试非零值（适用于C-C-）\"><a href=\"#4-8-不要用if语句的默认方法测试非零值（适用于C-C-）\" class=\"headerlink\" title=\"4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）\"></a>4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）</h2><p>²  If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如：</p>\n<p>建议使用：</p>\n<pre><code>       if (FAIL != f())\n</code></pre><p>不建议使用下面的表达式：</p>\n<pre><code>       if (f())\n</code></pre><p>²  宏定义的情况也一样：</p>\n<pre><code>       #define STREQ(a,b) (strcmp((a), (b)) == 0)\n</code></pre><p>或者使用内联函数：</p>\n<pre><code>       inline bool\n\n      StringEqual(char* a, char* b)\n\n       {\n\n          (strcmp(a, b)== 0) ? return true : return false;\n\n           Or more compactly:\n\n          returnstrcmp(a, b) == 0;\n\n       }\n</code></pre><h2 id=\"4-9-布尔类型-（适用于C-C-）\"><a href=\"#4-9-布尔类型-（适用于C-C-）\" class=\"headerlink\" title=\"4.9.布尔类型 （适用于C/C++）\"></a>4.9.布尔类型 （适用于C/C++）</h2><p>²  早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。</p>\n<p>早期的布尔类型定义为：</p>\n<pre><code>       typedef int     bool;\n\n       #defineTRUE    1\n\n       #defineFALSE   0\n</code></pre><p>或：</p>\n<pre><code>       const intTRUE  = 1;\n\n       const int FALSE= 0;\n</code></pre><p>²  在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如：</p>\n<pre><code>       if (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？\n</code></pre><p>必须写成：</p>\n<pre><code>       if (FALSE !=func()) { ...\n</code></pre><h2 id=\"4-10-避免在语句中内含赋值-（适用于C-C-）\"><a href=\"#4-10-避免在语句中内含赋值-（适用于C-C-）\" class=\"headerlink\" title=\"4.10.   避免在语句中内含赋值 （适用于C/C++）\"></a>4.10.   避免在语句中内含赋值 （适用于C/C++）</h2><p>²  只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如：</p>\n<pre><code>       while (EOF != (c= getchar()))\n\n       {\n\n          process thecharacter\n\n       }\n</code></pre><p>²  ++ 和 – 操作也是一种赋值语句</p>\n<p>²  内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如：</p>\n<pre><code>       a = b + c;\n\n       d = a + r;\n</code></pre><p>不应该写成：</p>\n<pre><code>           d = (a = b + c)+ r;\n</code></pre><h2 id=\"4-11-正确的使用Const-（适用于C-C-）\"><a href=\"#4-11-正确的使用Const-（适用于C-C-）\" class=\"headerlink\" title=\"4.11.   正确的使用Const （适用于C/C++）\"></a>4.11.   正确的使用Const （适用于C/C++）</h2><p>²  C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。</p>\n<h2 id=\"4-12-不要在头文件定义数据（适用于C-C-）\"><a href=\"#4-12-不要在头文件定义数据（适用于C-C-）\" class=\"headerlink\" title=\"4.12.    不要在头文件定义数据（适用于C/C++）\"></a>4.12.    不要在头文件定义数据（适用于C/C++）</h2><p>不要把数据定义放在头文件，如：</p>\n<pre><code>    /*\n\n     * aheader.h\n\n     */\n\n    int x = 0;\n</code></pre><h2 id=\"4-13-不要直接使用数字-（适用于C-C-）\"><a href=\"#4-13-不要直接使用数字-（适用于C-C-）\" class=\"headerlink\" title=\"4.13.   不要直接使用数字 （适用于C/C++）\"></a>4.13.   不要直接使用数字 （适用于C/C++）</h2><p>²  直接使用数字，会使源代码难以理解和维护。如：</p>\n<pre><code>    if      (22 ==foo)    { start_thermo_nuclear_war(); }\n\n    else if (19 == foo)    {refund_lotso_money(); }\n\n    else if (16 == foo)    {infinite_loop(); }\n\n    else                   { cry_cause_im_lost(); }\n</code></pre><p>当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。</p>\n<p>²  我们可以用#define或者常量来改变这一状况，如：</p>\n<pre><code>    #define  PRESIDENT_WENT_CRAZY  (22)\n\n    const int WE_GOOFED= 19;\n\n    enum\n\n    {\n\n        THEY_DIDNT_PAY=16\n\n    };\n\n\n\n    if (PRESIDENT_WENT_CRAZY    == foo) { start_thermo_nuclear_war(); }\n\n    else if (WE_GOOFED          == foo)  {refund_lotso_money(); }\n\n    else if (THEY_DIDNT_PAY     == foo) { infinite_loop();}\n\n    else                                 {happy_days_i_know_why_im_here(); }\n</code></pre><h2 id=\"4-14-宏（适用于C-C-）\"><a href=\"#4-14-宏（适用于C-C-）\" class=\"headerlink\" title=\"4.14.    宏（适用于C/C++）\"></a>4.14.    宏（适用于C/C++）</h2><p>²  如果可以，使用内联函数代替宏。</p>\n<p>例如：</p>\n<pre><code>    #ifndef MAX\n\n    #define  MAX(x,y)  (((x) &gt; (y) ? (x) : (y))    // 取最大数\n\n    #endif\n</code></pre><p>使用内联函数可以达到相同的效果，而且更安全：</p>\n<pre><code>       inline int\n\n       max(int x, inty)\n\n       {\n\n          return (x&gt; y ? x : y);\n\n       }\n</code></pre><p>²  要注意副作用</p>\n<p>必须小心副作用，因为在调用表达式时，会发生潜在的错误。</p>\n<p>例如：</p>\n<pre><code>       MAX(f(x),z++);\n</code></pre><p>²  表达式总是用括号括起来</p>\n<p>在宏展开时，使用括号可以避免宏展开后产生的二义性。</p>\n<p>例如：</p>\n<pre><code>    #define ADD(x,y) x + y\n</code></pre><p>必须写成：</p>\n<pre><code>    #define ADD(x,y) ((x) + (y))\n</code></pre><p>²  保证宏名称的唯一性</p>\n<p>和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题：</p>\n<p>n  在宏名称前加上库的名字<br>避免使用简单而常用的名字，如：MAX 和MIN。</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/07/c++代码规范/","excerpt":"命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C+ 命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C++ 12 静态变量的命名前缀 适用于C 13 自定义类型typedef的命名 适用于C++ 14 宏定义的命名 适用于C++ 15 C 函数的命名 适用于C++ 16 枚举的命名 适用于C++ 排版规则 1 布局和模板 11 类的布局模板 适用于C 12 源文件格式 适用于C 13 保护头文件不被重复包含 适用于C++ 14 方法和函数的布局 适用于C++ 2 缩进制表符以及空格 适用于C++ 3 尽量使一行不要超过78个字母 适用于C++ 4 保证一行只写一条语句 适用于C++ 5 花括号 规则 适用于C++ 51 花括号的位置 52 什么时候应使用花括号 53 在花括号结束的位置加上注释 54 注意屏幕大小 6圆括号 规则 适用于C++ 7if else 语句的格式 适用于C++ 8switch 格式 适用于C++ 9 使用gotocontinuebreak 和 适用于C++ 91 Goto 92 Continue and Break 93 10 运算符号的规则 适用于C++ 11 变量声明语句块 适用于C++ 文档及注释 1 文件或程序库的文档注释 适用于C++ 2 类文档注释 适用于C++ 3 函数文档注释 适用于C++ 4 Include 语句注释 适用于C++ 5语句块注释 适用于C++ 编码要求 1 不要忽略编译器的警告 适用于C++ 2 应使用源代码管理器 适用于C++ 3 固有的类方法成员 适用于C 4 使用命名空间 适用于C 5 初始化所有的变量 适用于C++ 6 保持函数短小精悍 适用于C++ 7对空语句进行注释 适用于C++ 8不要用if语句的默认方法测试非零值 适用于C++ 9布尔类型 适用于C++ 10避免在语句中内含赋值 适用于C++ 11正确的使用Const 适用于C++ 12不要在头文件定义数据适用于C++ 13不要直接使用数字 适用于C++ 14宏 适用于C++","categories":[{"name":"代码规范","slug":"代码规范","permalink":"https://prostkhala.github.io/categories/代码规范/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://prostkhala.github.io/tags/代码规范/"}]}]}