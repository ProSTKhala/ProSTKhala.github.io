{"meta":{"title":"ST","subtitle":"A HAOIER","description":"每一个不曾起舞的日子，都是对于生命的辜负。","author":"ST","url":"https://prostkhala.github.io"},"pages":[{},{},{}],"posts":[{"title":"HAOI2006 理想的正方形","date":"2017-03-14T07:36:17.000Z","path":"2017/03/14/理想的正方形/","text":"[HAOI2006] 理想的正方形BZOJ1047 洛谷2216 题目描述有一个ab的整数组成的矩阵，现请你从中找出一个nn的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 输入输出格式输入格式：第一行为3个整数，分别表示a,b,n的值 第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。 输出格式：仅一个整数，为ab矩阵中所有“nn正方形区域中的最大整数和最小整数的差值”的最小值。 输入输出样例输入样例#1：5 4 2 1 2 5 6 0 17 16 0 16 17 2 1 2 10 2 1 1 2 2 2 输出样例#1：1 数据范围矩阵中的所有数都不超过1,000,000,000 20%的数据2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10 100%的数据2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100 题解二维滑动窗口，先对每一行建立双端队列，记录每一个1n的长方体中的极值，将二维矩阵压缩成b-n+1列的矩阵，再对每一列依次建立双端队列，记录n1的长方体(在原矩阵中为nn的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的nn正方形的极值信息)，枚举即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int inf = 0x7fffffff; const int N =1e3+1; inline int get(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N]; int y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N]; int mapp[N][N],a,b,n; long long ans=inf; int main() { get(a),get(b),get(n); for(int i=1;i&lt;=a;++i)for(int t=1;t&lt;=b;++t)get(mapp[i][t]); for(int i=1;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1; for(int i=1;i&lt;=a;++i) for(int t=1;t&lt;=b;++t) { while(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--; x1[++tailx1[i]]=t; while(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++; minx[i][t]=mapp[i][x1[headx1[i]]]; } for(int i=1;i&lt;=a;++i) for(int t=1;t&lt;=b;++t) { while(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--; x2[++tailx2[i]]=t; while(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++; maxx[i][t]=mapp[i][x2[headx2[i]]]; } for(int t=n;t&lt;=b;++t) for(int i=1;i&lt;=a;++i) { while(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--; y1[++taily1[t]]=i; while(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++; miny[i][t]=minx[y1[heady1[t]]][t]; } for(int t=n;t&lt;=b;++t) for(int i=1;i&lt;=a;++i) { while(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--; y2[++taily2[t]]=i; while(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++; maxy[i][t]=maxx[y2[heady2[t]]][t]; } for(int t=n;t&lt;=b;++t) for(int i=n;i&lt;=a;++i) if(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t]; printf(&quot;%lld&quot;,ans); }","raw":"title: HAOI2006 理想的正方形\ndate: 2017-03-14 15:36:17\ncategories:\n  - 动态规划\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n---\n\n# [HAOI2006] 理想的正方形\n\n## [BZOJ1047](http://www.lydsy.com/JudgeOnline/problem.php?id=1047) [洛谷2216](https://www.luogu.org/problem/show?pid=2216)\n\n---\n## 题目描述\n\n有一个a*b的整数组成的矩阵，现请你从中找出一个n*n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。\n\n### 输入输出格式\n#### 输入格式：\n第一行为3个整数，分别表示a,b,n的值\n\n第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。\n\n\n#### 输出格式：\n仅一个整数，为a*b矩阵中所有“n*n正方形区域中的最大整数和最小整数的差值”的最小值。\n\n\n### 输入输出样例\n#### 输入样例#1：\n    5 4 2\n    1 2 5 6\n    0 17 16 0\n    16 17 2 1\n    2 10 2 1\n    1 2 2 2\n    \n\n#### 输出样例#1：\n\t1\n    \n\n### 数据范围\n矩阵中的所有数都不超过1,000,000,000\n\n20%的数据2<=a,b<=100,n<=a,n<=b,n<=10\n\n100%的数据2<=a,b<=1000,n<=a,n<=b,n<=100\n\n---\n\n## 题解\n二维滑动窗口，先对每一行建立双端队列，记录每一个1*n的长方体中的极值，\n将二维矩阵压缩成b-n+1列的矩阵，再对每一列依次建立双端队列，记录n*1的长方体(在原矩阵中为n*n的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的n*n正方形的极值信息)，枚举即可。\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<queue>\n    using namespace std;\n    const int inf = 0x7fffffff;\n    const int N =1e3+1;\n    inline int get(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];\n    int y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];\n    int mapp[N][N],a,b,n;\n    long long ans=inf;\n    int main()\n    {\n\n        get(a),get(b),get(n);\n        for(int i=1;i<=a;++i)for(int t=1;t<=b;++t)get(mapp[i][t]);\n        for(int i=1;i<N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1;\n        for(int i=1;i<=a;++i)\n        for(int t=1;t<=b;++t)\n        {\n            while(headx1[i]<=tailx1[i]&&mapp[i][x1[tailx1[i]]]>=mapp[i][t])tailx1[i]--;\n            x1[++tailx1[i]]=t;\n            while(headx1[i]<=tailx1[i]&&x1[headx1[i]]<=t-n)headx1[i]++;\n            minx[i][t]=mapp[i][x1[headx1[i]]];\n        }\n        for(int i=1;i<=a;++i)\n        for(int t=1;t<=b;++t)\n        {\n            while(headx2[i]<=tailx2[i]&&mapp[i][x2[tailx2[i]]]<=mapp[i][t])tailx2[i]--;\n            x2[++tailx2[i]]=t;\n            while(headx2[i]<=tailx2[i]&&x2[headx2[i]]<=t-n)headx2[i]++;\n            maxx[i][t]=mapp[i][x2[headx2[i]]];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=1;i<=a;++i)\n        {\n            while(heady1[t]<=taily1[t]&&minx[y1[taily1[t]]][t]>=minx[i][t])taily1[t]--;\n            y1[++taily1[t]]=i;\n            while(heady1[t]<=taily1[t]&&y1[heady1[t]]<=i-n)heady1[t]++;\n            miny[i][t]=minx[y1[heady1[t]]][t];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=1;i<=a;++i)\n        {\n            while(heady2[t]<=taily2[t]&&maxx[y2[taily2[t]]][t]<=maxx[i][t])taily2[t]--;\n            y2[++taily2[t]]=i;\n            while(heady2[t]<=taily2[t]&&y2[heady2[t]]<=i-n)heady2[t]++;\n            maxy[i][t]=maxx[y2[heady2[t]]][t];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=n;i<=a;++i)\n        if(maxy[i][t]-miny[i][t]<ans)ans=maxy[i][t]-miny[i][t];\n        printf(\"%lld\",ans);\n    }","content":"<h1 id=\"HAOI2006-理想的正方形\"><a href=\"#HAOI2006-理想的正方形\" class=\"headerlink\" title=\"[HAOI2006] 理想的正方形\"></a>[HAOI2006] 理想的正方形</h1><h2 id=\"BZOJ1047-洛谷2216\"><a href=\"#BZOJ1047-洛谷2216\" class=\"headerlink\" title=\"BZOJ1047 洛谷2216\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1047\" target=\"_blank\" rel=\"external\">BZOJ1047</a> <a href=\"https://www.luogu.org/problem/show?pid=2216\" target=\"_blank\" rel=\"external\">洛谷2216</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有一个a<em>b的整数组成的矩阵，现请你从中找出一个n</em>n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行为3个整数，分别表示a,b,n的值</p>\n<p>第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>仅一个整数，为a<em>b矩阵中所有“n</em>n正方形区域中的最大整数和最小整数的差值”的最小值。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>5 4 2\n1 2 5 6\n0 17 16 0\n16 17 2 1\n2 10 2 1\n1 2 2 2\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>1\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>矩阵中的所有数都不超过1,000,000,000</p>\n<p>20%的数据2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10</p>\n<p>100%的数据2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>二维滑动窗口，先对每一行建立双端队列，记录每一个1<em>n的长方体中的极值，<br>将二维矩阵压缩成b-n+1列的矩阵，再对每一列依次建立双端队列，记录n</em>1的长方体(在原矩阵中为n<em>n的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的n</em>n正方形的极值信息)，枚举即可。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int inf = 0x7fffffff;\nconst int N =1e3+1;\ninline int get(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];\nint y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];\nint mapp[N][N],a,b,n;\nlong long ans=inf;\nint main()\n{\n\n    get(a),get(b),get(n);\n    for(int i=1;i&lt;=a;++i)for(int t=1;t&lt;=b;++t)get(mapp[i][t]);\n    for(int i=1;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1;\n    for(int i=1;i&lt;=a;++i)\n    for(int t=1;t&lt;=b;++t)\n    {\n        while(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--;\n        x1[++tailx1[i]]=t;\n        while(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++;\n        minx[i][t]=mapp[i][x1[headx1[i]]];\n    }\n    for(int i=1;i&lt;=a;++i)\n    for(int t=1;t&lt;=b;++t)\n    {\n        while(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--;\n        x2[++tailx2[i]]=t;\n        while(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++;\n        maxx[i][t]=mapp[i][x2[headx2[i]]];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=1;i&lt;=a;++i)\n    {\n        while(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--;\n        y1[++taily1[t]]=i;\n        while(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++;\n        miny[i][t]=minx[y1[heady1[t]]][t];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=1;i&lt;=a;++i)\n    {\n        while(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--;\n        y2[++taily2[t]]=i;\n        while(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++;\n        maxy[i][t]=maxx[y2[heady2[t]]][t];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=n;i&lt;=a;++i)\n    if(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t];\n    printf(&quot;%lld&quot;,ans);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/14/理想的正方形/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"}],"tags":[{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"}]},{"title":"NOIP模拟赛 2017 3 12","date":"2017-03-13T10:01:11.000Z","path":"2017/03/13/NOIP模拟赛 2017 3 12/","text":"NOIP 模拟赛-2017-3-12By HJWJBSR&amp;duyege2016.9 T1 Blue题目描述Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。 他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。 当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。 输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。 输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。 样例输入5 10 9 16 30 2 4 6 9 11 15 18 19 25 27 10 1 23 30 10 11 13 14 15 16 18 26 27 29 10 7 28 30 2 3 7 9 12 15 20 24 27 28 10 3 18 30 1 6 9 14 18 19 22 27 28 29 10 7 10 30 1 2 4 6 18 19 20 22 23 26 样例输出5 Excited Excited Excited 0 数据范围对于 10%的数据保证 $m=1$. 对于另外 10%的数据保证 $D=L$. 对于另外 10%的数据保证 $n=L-1$. 对于另外 30%的数据保证 $n&lt;=100, L&lt;=10^5$. 对于 100%的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$.数据范围中的 n、m 皆代表题目描述中 n、m 的总和。 题解这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。 具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了…. CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N =1e6+1; inline void read(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int tt,n,m,d,l,a[N],b[N]; bool can(int ans) { for(int i=1;i&lt;=ans;++i)b[i]=0; int anss=0; for(int now=1;now&lt;=n;++now) { if(a[now]-b[++anss]&lt;=d)b[anss]=a[now]; if(anss==ans)anss=0; } for(int i=1;i&lt;=ans;++i) if(l-b[i]&gt;d)return 0; return 1; } int main() { // freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout); read(tt); while(tt--) { read(n),read(m),read(d),read(l); for(int i=1;i&lt;=n;++i)read(a[i]); int ll=0,rr=m,mid; while(ll!=rr) { mid=ll+rr+1&gt;&gt;1; if(can(mid)) ll=mid; else rr=mid-1; } if(rr==m) printf(&quot;Excited\\n&quot;); else printf(&quot;%d\\n&quot;,rr); } return 0; } T2 Weed题目描述duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。 电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上面没有金坷垃了。 duyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最终金坷垃的量有多少。 输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，后面 2 个数描述更改为这样的操作。 输出 q 行代表每次金坷垃的量为多少 样例输入10 5 0 10 1 5 0 13 0 18 0 2 1 1 0 8 0 9 1 3 0 7 9 0 3 10 1 7 6 0 8 10 0 5 8 1 2 样例输出58 0 0 66 41 数据范围对于 30%的数据，m&lt;=1000,q&lt;=1000. 对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。 对于 100%的数据，m&lt;=210^5,q&lt;=210^5,vi&lt;=10^4. 题解由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现… 题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; inline void read(int &amp;x) { x=0;int f=1;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} x*=f; } const int N =2e5+7; struct build{int sum,in,out;}tr[8*N]; int n,q,k,a[N],tot; int find(int x,int pot) { if(pot&gt;=tr[x].in) return 0; if(!pot) return tr[x].sum; if(pot&lt;=tr[x*2+1].in) return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot); return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out); } void update(int x) { tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out); tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in); tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out); } void build(int x,int l,int r) { if(l==r) { if(a[l]&lt;0) tr[x].out=-a[l]; else tr[x].in=1,tr[x].sum=a[l]; } else { int mid=l+r&gt;&gt;1; build(x*2,l,mid); build(x*2+1,mid+1,r); update(x); } } void change(int x,int pot,int w,int l,int r) { if(l==r) { memset(&amp;tr[x],0,sizeof(tr[x])); if(w&lt;0) tr[x].out=-w; else tr[x].in=1,tr[x].sum=w; } else { int mid=l+r&gt;&gt;1; if(pot&gt;mid) change(x*2+1,pot,w,mid+1,r); else change(x*2,pot,w,l,mid); update(x); } } int main() { // freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout); read(n),read(q); for(int i=1;i&lt;=n;++i) { read(k),read(a[i]); if(k)a[i]*=-1; } build(1,1,n); while(q--) { int x,w; read(x);read(k);read(w); if(k)w*=-1; change(1,x,w,1,n); printf(&quot;%d\\n&quot;,tr[1].sum); } } T3 Drink题目描述在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚不到这么多资本），所以决定用特殊的方法赏赐毒液哥。 Link的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财的他想知道最后棋盘内所有的宝物价值以方便他挑选。 作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）和资产阶级代表（Link）之间的贫富差距么。 输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c的正方形。 输出一个 N * M 的矩阵表示最后的棋盘。 样例输入4 4 3 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 1 3 3 3 2 2 2 2 样例输出1 5 1 4 2 7 6 8 3 7 2 3 5 6 8 4 数据范围对于 30%的数据，N, M, Q &lt;= 100. 对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。 对于 100%的数据, N, M, Q &lt;= 1000.所有数取值都为 0~9. 题解以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。 CODE","raw":"title: NOIP模拟赛 2017 3 12\ndate: 2017-03-13 18:01:11\ncategories:\n  - NOIP模拟赛\ntags:\n  - 二分答案\n  - 贪心\n  - 线段树\n  - 二维线段树\n---\n# NOIP 模拟赛-2017-3-12\n## By HJWJBSR&duyege\n### 2016.9\n---\n\n## T1 Blue\n### 题目描述\nBlue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。\n\n他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)\n中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。\n\n当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就\n会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。\n\n输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。\n第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。\n\n输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。\n\n\n#### 样例输入\n    5\n    10 9 16 30\n    2 4 6 9 11 15 18 19 25 27 \n    10 1 23 30\n    10 11 13 14 15 16 18 26 27 29 \n    10 7 28 30\n    2 3 7 9 12 15 20 24 27 28 \n    10 3 18 30\n    1 6 9 14 18 19 22 27 28 29 \n    10 7 10 30\n    1 2 4 6 18 19 20 22 23 26 \n#### 样例输出\n    5\n    Excited\n    Excited\n    Excited\n    0\n#### 数据范围\n对于 10%的数据保证 $m=1$.\n\n对于另外 10%的数据保证 $D=L$.\n\n对于另外 10%的数据保证 $n=L-1$.\n\n对于另外 30%的数据保证 $n<=100, L<=10^5$.\n\n对于 100%的数据保证 $m<=n<=10^6,D<=L<=10^9$.\n数据范围中的 n、m 皆代表题目描述中 n、m 的总和。\n\n---\n### 题解\n\n这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D<=L<=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。\n\n具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了....\n\n---\n#### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N =1e6+1;\n    inline void read(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int tt,n,m,d,l,a[N],b[N];\n    bool can(int ans)\n    {\n        for(int i=1;i<=ans;++i)b[i]=0;\n        int anss=0;\n        for(int now=1;now<=n;++now)\n        {\n            if(a[now]-b[++anss]<=d)b[anss]=a[now];\n            if(anss==ans)anss=0;\n        }\n        for(int i=1;i<=ans;++i)\n        if(l-b[i]>d)return 0;\n        return 1;\n    }\n    int main()\n    {\n    //    freopen(\"Blue.in\",\"r\",stdin);\n    //    freopen(\"Blue.out\",\"w\",stdout);\n        read(tt);\n        while(tt--)\n        {\n            read(n),read(m),read(d),read(l);\n            for(int i=1;i<=n;++i)read(a[i]);\n            int ll=0,rr=m,mid;\n            while(ll!=rr)\n            {\n                mid=ll+rr+1>>1;\n                if(can(mid))\tll=mid;\n                else\t\t\trr=mid-1;\n            }\n            if(rr==m)\tprintf(\"Excited\\n\");\n            else \t\tprintf(\"%d\\n\",rr);\n        }\n        return 0;\n    }\n\n\n---\n## T2 Weed\n### 题目描述\nduyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。\n为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。\n\n电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最\n新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上\n面没有金坷垃了。\n\nduyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行\n了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最\n终金坷垃的量有多少。\n\n输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，\n为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，\n后面 2 个数描述更改为这样的操作。\n\n输出 q 行代表每次金坷垃的量为多少\n#### 样例输入\n    10 5\n    0 10\n    1 5\n    0 13\n    0 18\n    0 2\n    1 1\n    0 8\n    0 9\n    1 3\n    0 7\n    9 0 3\n    10 1 7\n    6 0 8\n    10 0 5\n    8 1 2\n\n\n#### 样例输出\n    58\n    0\n    0\n    66\n    41\n\n#### 数据范围\n对于 30%的数据，m<=1000,q<=1000.\n\n对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。\n\n对于 100%的数据，m<=2*10^5,q<=2*10^5,vi<=10^4.\n\n---\n### 题解\n由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现...\n\n题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    inline void read(int &x)\n    {\n        x=0;int f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n        x*=f;\n    }\n    const int N =2e5+7;\n    struct build{int sum,in,out;}tr[8*N];\n    int n,q,k,a[N],tot;\n    int find(int x,int pot)\n    {\n        if(pot>=tr[x].in)\t\t\treturn 0;\n        if(!pot)\t\t\t\t\treturn tr[x].sum;\n        if(pot<=tr[x*2+1].in)\n        return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot);\n        return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out);\n    }\n    void update(int x)\n    {\n        tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out);\n        tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in);\n        tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out);\n    }\n    void build(int x,int l,int r)\n    {\n        if(l==r)\n        {\n            if(a[l]<0)\ttr[x].out=-a[l];\n            else\t\ttr[x].in=1,tr[x].sum=a[l];\n        }\n        else\n        {\n            int mid=l+r>>1;\n            build(x*2,l,mid);\n            build(x*2+1,mid+1,r);\n            update(x);\n        }\n    }\n    void change(int x,int pot,int w,int l,int r)\n    {\n        if(l==r)\n        {\n            memset(&tr[x],0,sizeof(tr[x]));\n            if(w<0)\t\ttr[x].out=-w;\n            else\t\ttr[x].in=1,tr[x].sum=w;\n        }\n        else\n        {\n            int mid=l+r>>1;\n            if(pot>mid)\tchange(x*2+1,pot,w,mid+1,r);\n            else\t\tchange(x*2,pot,w,l,mid);\n            update(x);\n        }\n    }\n    int main()\n    {\n    //    freopen(\"weed.in\", \"r\", stdin);\n    //    freopen(\"weed.out\", \"w\", stdout);\n        read(n),read(q);\n        for(int i=1;i<=n;++i)\n        {\n            read(k),read(a[i]);\n            if(k)a[i]*=-1;\n        }\n        build(1,1,n);\n        while(q--)\n        {\n            int x,w;\n            read(x);read(k);read(w);\n            if(k)w*=-1;\n            change(1,x,w,1,n);\n            printf(\"%d\\n\",tr[1].sum);\n        }\n    }\n---\n## T3 Drink\n### 题目描述\n在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份\n丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚\n不到这么多资本），所以决定用特殊的方法赏赐毒液哥。\n\nLink的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，\n每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。\n毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财\n的他想知道最后棋盘内所有的宝物价值以方便他挑选。\n\n作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）\n和资产阶级代表（Link）之间的贫富差距么。\n\n输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。\n接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。\n接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c\n的正方形。\n\n输出一个 N * M 的矩阵表示最后的棋盘。\n#### 样例输入\n    4 4 3\n    1 2 3 4\n    5 6 7 8\n    1 2 3 4\n    5 6 7 8\n    1 1 3\n    3 3 2\n    2 2 2\n\n\n#### 样例输出\n    1 5 1 4 \n    2 7 6 8 \n    3 7 2 3 \n    5 6 8 4 \n\n#### 数据范围\n对于 30%的数据，N, M, Q <= 100.\n\n对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。\n\n对于 100%的数据, N, M, Q <= 1000.所有数取值都为 0~9.\n\n---\n### 题解\n以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。\n\n### CODE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"NOIP-模拟赛-2017-3-12\"><a href=\"#NOIP-模拟赛-2017-3-12\" class=\"headerlink\" title=\"NOIP 模拟赛-2017-3-12\"></a>NOIP 模拟赛-2017-3-12</h1><h2 id=\"By-HJWJBSR-amp-duyege\"><a href=\"#By-HJWJBSR-amp-duyege\" class=\"headerlink\" title=\"By HJWJBSR&amp;duyege\"></a>By HJWJBSR&amp;duyege</h2><h3 id=\"2016-9\"><a href=\"#2016-9\" class=\"headerlink\" title=\"2016.9\"></a>2016.9</h3><hr>\n<h2 id=\"T1-Blue\"><a href=\"#T1-Blue\" class=\"headerlink\" title=\"T1 Blue\"></a>T1 Blue</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。</p>\n<p>他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)<br>中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。</p>\n<p>当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就<br>会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。</p>\n<p>输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。<br>第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。</p>\n<p>输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。</p>\n<h4 id=\"样例输入\"><a href=\"#样例输入\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>5\n10 9 16 30\n2 4 6 9 11 15 18 19 25 27 \n10 1 23 30\n10 11 13 14 15 16 18 26 27 29 \n10 7 28 30\n2 3 7 9 12 15 20 24 27 28 \n10 3 18 30\n1 6 9 14 18 19 22 27 28 29 \n10 7 10 30\n1 2 4 6 18 19 20 22 23 26 \n</code></pre><h4 id=\"样例输出\"><a href=\"#样例输出\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>5\nExcited\nExcited\nExcited\n0\n</code></pre><h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 10%的数据保证 $m=1$.</p>\n<p>对于另外 10%的数据保证 $D=L$.</p>\n<p>对于另外 10%的数据保证 $n=L-1$.</p>\n<p>对于另外 30%的数据保证 $n&lt;=100, L&lt;=10^5$.</p>\n<p>对于 100%的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$.<br>数据范围中的 n、m 皆代表题目描述中 n、m 的总和。</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。</p>\n<p>具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了….</p>\n<hr>\n<h4 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N =1e6+1;\ninline void read(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint tt,n,m,d,l,a[N],b[N];\nbool can(int ans)\n{\n    for(int i=1;i&lt;=ans;++i)b[i]=0;\n    int anss=0;\n    for(int now=1;now&lt;=n;++now)\n    {\n        if(a[now]-b[++anss]&lt;=d)b[anss]=a[now];\n        if(anss==ans)anss=0;\n    }\n    for(int i=1;i&lt;=ans;++i)\n    if(l-b[i]&gt;d)return 0;\n    return 1;\n}\nint main()\n{\n//    freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout);\n    read(tt);\n    while(tt--)\n    {\n        read(n),read(m),read(d),read(l);\n        for(int i=1;i&lt;=n;++i)read(a[i]);\n        int ll=0,rr=m,mid;\n        while(ll!=rr)\n        {\n            mid=ll+rr+1&gt;&gt;1;\n            if(can(mid))    ll=mid;\n            else            rr=mid-1;\n        }\n        if(rr==m)    printf(&quot;Excited\\n&quot;);\n        else         printf(&quot;%d\\n&quot;,rr);\n    }\n    return 0;\n}\n</code></pre><hr>\n<h2 id=\"T2-Weed\"><a href=\"#T2-Weed\" class=\"headerlink\" title=\"T2 Weed\"></a>T2 Weed</h2><h3 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。<br>为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。</p>\n<p>电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最<br>新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上<br>面没有金坷垃了。</p>\n<p>duyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行<br>了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最<br>终金坷垃的量有多少。</p>\n<p>输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，<br>为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，<br>后面 2 个数描述更改为这样的操作。</p>\n<p>输出 q 行代表每次金坷垃的量为多少</p>\n<h4 id=\"样例输入-1\"><a href=\"#样例输入-1\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>10 5\n0 10\n1 5\n0 13\n0 18\n0 2\n1 1\n0 8\n0 9\n1 3\n0 7\n9 0 3\n10 1 7\n6 0 8\n10 0 5\n8 1 2\n</code></pre><h4 id=\"样例输出-1\"><a href=\"#样例输出-1\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>58\n0\n0\n66\n41\n</code></pre><h4 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 30%的数据，m&lt;=1000,q&lt;=1000.</p>\n<p>对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。</p>\n<p>对于 100%的数据，m&lt;=2<em>10^5,q&lt;=2</em>10^5,vi&lt;=10^4.</p>\n<hr>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现…</p>\n<p>题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。</p>\n<hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ninline void read(int &amp;x)\n{\n    x=0;int f=1;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n    x*=f;\n}\nconst int N =2e5+7;\nstruct build{int sum,in,out;}tr[8*N];\nint n,q,k,a[N],tot;\nint find(int x,int pot)\n{\n    if(pot&gt;=tr[x].in)            return 0;\n    if(!pot)                    return tr[x].sum;\n    if(pot&lt;=tr[x*2+1].in)\n    return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot);\n    return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out);\n}\nvoid update(int x)\n{\n    tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out);\n    tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in);\n    tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out);\n}\nvoid build(int x,int l,int r)\n{\n    if(l==r)\n    {\n        if(a[l]&lt;0)    tr[x].out=-a[l];\n        else        tr[x].in=1,tr[x].sum=a[l];\n    }\n    else\n    {\n        int mid=l+r&gt;&gt;1;\n        build(x*2,l,mid);\n        build(x*2+1,mid+1,r);\n        update(x);\n    }\n}\nvoid change(int x,int pot,int w,int l,int r)\n{\n    if(l==r)\n    {\n        memset(&amp;tr[x],0,sizeof(tr[x]));\n        if(w&lt;0)        tr[x].out=-w;\n        else        tr[x].in=1,tr[x].sum=w;\n    }\n    else\n    {\n        int mid=l+r&gt;&gt;1;\n        if(pot&gt;mid)    change(x*2+1,pot,w,mid+1,r);\n        else        change(x*2,pot,w,l,mid);\n        update(x);\n    }\n}\nint main()\n{\n//    freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin);\n//    freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout);\n    read(n),read(q);\n    for(int i=1;i&lt;=n;++i)\n    {\n        read(k),read(a[i]);\n        if(k)a[i]*=-1;\n    }\n    build(1,1,n);\n    while(q--)\n    {\n        int x,w;\n        read(x);read(k);read(w);\n        if(k)w*=-1;\n        change(1,x,w,1,n);\n        printf(&quot;%d\\n&quot;,tr[1].sum);\n    }\n}\n</code></pre><hr>\n<h2 id=\"T3-Drink\"><a href=\"#T3-Drink\" class=\"headerlink\" title=\"T3 Drink\"></a>T3 Drink</h2><h3 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份<br>丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚<br>不到这么多资本），所以决定用特殊的方法赏赐毒液哥。</p>\n<p>Link的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，<br>每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。<br>毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财<br>的他想知道最后棋盘内所有的宝物价值以方便他挑选。</p>\n<p>作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）<br>和资产阶级代表（Link）之间的贫富差距么。</p>\n<p>输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。<br>接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。<br>接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c<br>的正方形。</p>\n<p>输出一个 N * M 的矩阵表示最后的棋盘。</p>\n<h4 id=\"样例输入-2\"><a href=\"#样例输入-2\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>4 4 3\n1 2 3 4\n5 6 7 8\n1 2 3 4\n5 6 7 8\n1 1 3\n3 3 2\n2 2 2\n</code></pre><h4 id=\"样例输出-2\"><a href=\"#样例输出-2\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>1 5 1 4 \n2 7 6 8 \n3 7 2 3 \n5 6 8 4 \n</code></pre><h4 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 30%的数据，N, M, Q &lt;= 100.</p>\n<p>对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。</p>\n<p>对于 100%的数据, N, M, Q &lt;= 1000.所有数取值都为 0~9.</p>\n<hr>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。</p>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/13/NOIP模拟赛 2017 3 12/","excerpt":"","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"https://prostkhala.github.io/categories/NOIP模拟赛/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://prostkhala.github.io/tags/二分答案/"},{"name":"贪心","slug":"贪心","permalink":"https://prostkhala.github.io/tags/贪心/"},{"name":"线段树","slug":"线段树","permalink":"https://prostkhala.github.io/tags/线段树/"},{"name":"二维线段树","slug":"二维线段树","permalink":"https://prostkhala.github.io/tags/二维线段树/"}]},{"title":"SCOI2010 股票交易","date":"2017-03-11T01:11:51.000Z","path":"2017/03/11/股票交易/","text":"[SCOI2010] 股票交易BZOJ1855 洛谷2569 题目描述最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。 通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi&gt;=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。 另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。 在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？ 输入输出格式输入格式：输入数据第一行包括3个整数，分别是T，MaxP，W。 接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。 输出格式：输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。 输入输出样例输入样例#1：5 2 0 2 1 1 1 2 1 1 1 3 2 1 1 4 3 1 1 5 4 1 1 输出样例#1：3 说明对于30%的数据，0&lt;=W&lt;T&lt;=50,1&lt;=MaxP&lt;=50 对于50%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=50 对于100%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=2000 对于所有的数据，1&lt;=BPi&lt;=APi&lt;=1000,1&lt;=ASi,BSi&lt;=MaxP $o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i]j$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。 $O(t*maxp^2)$算法：#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 2017; int n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w); for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i); memset(dp,-0x3f,sizeof(dp)); for(int i=1;i&lt;=n;++i) { for(int j=0;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。 for(int j=0;j&lt;=maxp;++j) { dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作 if(i-w-1&gt;=0) for(int k=j+1;k&lt;=min(j+bs[i],maxp);++k) dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出 if(i-w-1&gt;=0) for(int k=max(j-as[i],0);k&lt;j;++k) dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入 } } printf(&quot;%d&quot;,dp[n][0]); } 此题单调队列优化思想不难，但是还要注意各种细节。 $O(t*maxp)$算法(单调队列)：#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 2017; int n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w); for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i); memset(dp,-0x3f,sizeof(dp)); for(int i=1;i&lt;=n;++i) { for(int j=0;j&lt;=as[i];++j) dp[i][j]=-ap[i]*j; for(int j=0;j&lt;=maxp;++j) dp[i][j]=max(dp[i][j],dp[i-1][j]); if(i-w-1&gt;=0) { head=1,tail=0; for(int j=0;j&lt;=maxp;++j)//买入 { while(head&lt;=tail&amp;&amp;q[head]&lt;max(0,j-as[i]))head++; if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]); while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*ap[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--; q[++tail]=j; } head=1,tail=0; for(int j=maxp;j&gt;=0;--j)//卖出 { while(head&lt;=tail&amp;&amp;q[head]&gt;min(maxp,j+bs[i]))head++; if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]); while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*bp[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--; q[++tail]=j; } } } printf(&quot;%d&quot;,dp[n][0]); }","raw":"title: SCOI2010 股票交易\ndate: 2017-03-11 9:11:51\ncategories:\n  - 动态规划\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n---\n# [SCOI2010] 股票交易\n## [BZOJ1855](http://www.lydsy.com/JudgeOnline/problem.php?id=1855) [洛谷2569](https://www.luogu.org/problem/show?pid=2569)\n---\n\n## 题目描述\n\n最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。\n\n通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi>=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。\n\n另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。\n\n在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？\n### 输入输出格式\n#### 输入格式：\n\n输入数据第一行包括3个整数，分别是T，MaxP，W。\n\n接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。\n\n#### 输出格式：\n\n输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。\n\n### 输入输出样例\n#### 输入样例#1：\n\n    5 2 0\n    2 1 1 1\n    2 1 1 1\n    3 2 1 1\n    4 3 1 1\n    5 4 1 1\n\n#### 输出样例#1：\n\n    3\n\n### 说明\n\n对于30%的数据，0<=W<T<=50,1<=MaxP<=50\n\n对于50%的数据，0<=W<T<=2000,1<=MaxP<=50\n\n对于100%的数据，0<=W<T<=2000,1<=MaxP<=2000\n\n对于所有的数据，1<=BPi<=APi<=1000,1<=ASi,BSi<=MaxP\n\n---\n\n$o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i][j](j<=t，j<=maxp)$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。\n\n## $O(t*maxp^2)$算法：\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 2017;\n    int n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];\n    int main()\n    {\n      scanf(\"%d%d%d\",&n,&maxp,&w);\n        for(int i=1;i<=n;++i)scanf(\"%d%d%d%d\",ap+i,bp+i,as+i,bs+i);\n      memset(dp,-0x3f,sizeof(dp));\n      for(int i=1;i<=n;++i)\n      {\n          for(int j=0;j<=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。\n          for(int j=0;j<=maxp;++j)\n          {\n              dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作\n              if(i-w-1>=0)\n              for(int k=j+1;k<=min(j+bs[i],maxp);++k)\n              dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出\n              if(i-w-1>=0)\n              for(int k=max(j-as[i],0);k<j;++k)\n              dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入\n          }\n      }\n      printf(\"%d\",dp[n][0]);\n    }\n---\n此题单调队列优化思想不难，但是还要注意各种细节。\n## $O(t*maxp)$算法(单调队列)：\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 2017;\n    int n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N];\n    int main()\n    {\n        scanf(\"%d%d%d\",&n,&maxp,&w);\n        for(int i=1;i<=n;++i)scanf(\"%d%d%d%d\",ap+i,bp+i,as+i,bs+i);\n        memset(dp,-0x3f,sizeof(dp));\n        for(int i=1;i<=n;++i)\n        {\n            for(int j=0;j<=as[i];++j)\tdp[i][j]=-ap[i]*j;\n            for(int j=0;j<=maxp;++j)\tdp[i][j]=max(dp[i][j],dp[i-1][j]);\n            if(i-w-1>=0)\n            {\n                head=1,tail=0;\n                for(int j=0;j<=maxp;++j)//买入 \n                {\n                    while(head<=tail&&q[head]<max(0,j-as[i]))head++;\n                    if(head<=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]);\n                    while(head<=tail&&dp[i-w-1][j]+j*ap[i]>=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--;\n                    q[++tail]=j;\n                }\n                head=1,tail=0;\n                for(int j=maxp;j>=0;--j)//卖出 \n                {\n                    while(head<=tail&&q[head]>min(maxp,j+bs[i]))head++;\n                    if(head<=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]);\n                    while(head<=tail&&dp[i-w-1][j]+j*bp[i]>=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--;\n                    q[++tail]=j;\n                }\n            }\n        }\n        printf(\"%d\",dp[n][0]);\n    }","content":"<h1 id=\"SCOI2010-股票交易\"><a href=\"#SCOI2010-股票交易\" class=\"headerlink\" title=\"[SCOI2010] 股票交易\"></a>[SCOI2010] 股票交易</h1><h2 id=\"BZOJ1855-洛谷2569\"><a href=\"#BZOJ1855-洛谷2569\" class=\"headerlink\" title=\"BZOJ1855 洛谷2569\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1855\" target=\"_blank\" rel=\"external\">BZOJ1855</a> <a href=\"https://www.luogu.org/problem/show?pid=2569\" target=\"_blank\" rel=\"external\">洛谷2569</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。</p>\n<p>通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi&gt;=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。</p>\n<p>另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。</p>\n<p>在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入数据第一行包括3个整数，分别是T，MaxP，W。</p>\n<p>接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>5 2 0\n2 1 1 1\n2 1 1 1\n3 2 1 1\n4 3 1 1\n5 4 1 1\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>3\n</code></pre><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>对于30%的数据，0&lt;=W&lt;T&lt;=50,1&lt;=MaxP&lt;=50</p>\n<p>对于50%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=50</p>\n<p>对于100%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=2000</p>\n<p>对于所有的数据，1&lt;=BPi&lt;=APi&lt;=1000,1&lt;=ASi,BSi&lt;=MaxP</p>\n<hr>\n<p>$o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i]<a href=\"j&lt;=t，j&lt;=maxp\">j</a>$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。</p>\n<h2 id=\"O-t-maxp-2-算法：\"><a href=\"#O-t-maxp-2-算法：\" class=\"headerlink\" title=\"$O(t*maxp^2)$算法：\"></a>$O(t*maxp^2)$算法：</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 2017;\nint n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];\nint main()\n{\n  scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i);\n  memset(dp,-0x3f,sizeof(dp));\n  for(int i=1;i&lt;=n;++i)\n  {\n      for(int j=0;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。\n      for(int j=0;j&lt;=maxp;++j)\n      {\n          dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作\n          if(i-w-1&gt;=0)\n          for(int k=j+1;k&lt;=min(j+bs[i],maxp);++k)\n          dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出\n          if(i-w-1&gt;=0)\n          for(int k=max(j-as[i],0);k&lt;j;++k)\n          dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入\n      }\n  }\n  printf(&quot;%d&quot;,dp[n][0]);\n}\n</code></pre><hr>\n<p>此题单调队列优化思想不难，但是还要注意各种细节。</p>\n<h2 id=\"O-t-maxp-算法-单调队列-：\"><a href=\"#O-t-maxp-算法-单调队列-：\" class=\"headerlink\" title=\"$O(t*maxp)$算法(单调队列)：\"></a>$O(t*maxp)$算法(单调队列)：</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 2017;\nint n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N];\nint main()\n{\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i);\n    memset(dp,-0x3f,sizeof(dp));\n    for(int i=1;i&lt;=n;++i)\n    {\n        for(int j=0;j&lt;=as[i];++j)    dp[i][j]=-ap[i]*j;\n        for(int j=0;j&lt;=maxp;++j)    dp[i][j]=max(dp[i][j],dp[i-1][j]);\n        if(i-w-1&gt;=0)\n        {\n            head=1,tail=0;\n            for(int j=0;j&lt;=maxp;++j)//买入 \n            {\n                while(head&lt;=tail&amp;&amp;q[head]&lt;max(0,j-as[i]))head++;\n                if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]);\n                while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*ap[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--;\n                q[++tail]=j;\n            }\n            head=1,tail=0;\n            for(int j=maxp;j&gt;=0;--j)//卖出 \n            {\n                while(head&lt;=tail&amp;&amp;q[head]&gt;min(maxp,j+bs[i]))head++;\n                if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]);\n                while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*bp[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--;\n                q[++tail]=j;\n            }\n        }\n    }\n    printf(&quot;%d&quot;,dp[n][0]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/11/股票交易/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"}],"tags":[{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"}]},{"title":"动态规划优化 题目列表","date":"2017-03-10T14:12:24.000Z","path":"2017/03/10/动态规划 题目列表/","text":"单调队列优化dpBZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047 单调栈BZOJ 1057、BZOJ 1683、BZOJ 3956、BZOJ 3611 状压DPBZOJ 1879、BZOJ 1087、BZOJ 2669、BZOJ 3812 斜率优化+单调栈BZOJ 1096、BZOJ 4518、BZOJ 1010、BZOJ 675 dp+四边形不等式优化POJ1160 HDU2829 HDU3480 HDU3506 HDU3516http://blog.csdn.net/shiwei408/article/details/8791011 斜率优化DP和四边形不等式优化DP整理http://blog.csdn.net/tomorrowtodie/article/details/52279807 http://blog.csdn.net/u014800748/article/details/45750737","raw":"title: 动态规划优化 题目列表\ndate: 2017-03-10 22:12:24\ncategories:\n  - 动态规划\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n  - 斜率优化\n  - 单调栈\n---\n# 单调队列优化dp\nBZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047\n\n# 单调栈\nBZOJ 1057、BZOJ 1683、BZOJ 3956、BZOJ 3611\n\n# 状压DP\nBZOJ 1879、BZOJ 1087、BZOJ 2669、BZOJ 3812\n\n# 斜率优化+单调栈\nBZOJ 1096、BZOJ 4518、BZOJ 1010、BZOJ  675\n\n# dp+四边形不等式优化\nPOJ1160 HDU2829 HDU3480 HDU3506 HDU3516\nhttp://blog.csdn.net/shiwei408/article/details/8791011\n\n# 斜率优化DP和四边形不等式优化DP整理\nhttp://blog.csdn.net/tomorrowtodie/article/details/52279807\n\nhttp://blog.csdn.net/u014800748/article/details/45750737","content":"<h1 id=\"单调队列优化dp\"><a href=\"#单调队列优化dp\" class=\"headerlink\" title=\"单调队列优化dp\"></a>单调队列优化dp</h1><p>BZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047</p>\n<h1 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h1><p>BZOJ 1057、BZOJ 1683、BZOJ 3956、BZOJ 3611</p>\n<h1 id=\"状压DP\"><a href=\"#状压DP\" class=\"headerlink\" title=\"状压DP\"></a>状压DP</h1><p>BZOJ 1879、BZOJ 1087、BZOJ 2669、BZOJ 3812</p>\n<h1 id=\"斜率优化-单调栈\"><a href=\"#斜率优化-单调栈\" class=\"headerlink\" title=\"斜率优化+单调栈\"></a>斜率优化+单调栈</h1><p>BZOJ 1096、BZOJ 4518、BZOJ 1010、BZOJ  675</p>\n<h1 id=\"dp-四边形不等式优化\"><a href=\"#dp-四边形不等式优化\" class=\"headerlink\" title=\"dp+四边形不等式优化\"></a>dp+四边形不等式优化</h1><p>POJ1160 HDU2829 HDU3480 HDU3506 HDU3516<br><a href=\"http://blog.csdn.net/shiwei408/article/details/8791011\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/shiwei408/article/details/8791011</a></p>\n<h1 id=\"斜率优化DP和四边形不等式优化DP整理\"><a href=\"#斜率优化DP和四边形不等式优化DP整理\" class=\"headerlink\" title=\"斜率优化DP和四边形不等式优化DP整理\"></a>斜率优化DP和四边形不等式优化DP整理</h1><p><a href=\"http://blog.csdn.net/tomorrowtodie/article/details/52279807\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/tomorrowtodie/article/details/52279807</a></p>\n<p><a href=\"http://blog.csdn.net/u014800748/article/details/45750737\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u014800748/article/details/45750737</a></p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/10/动态规划 题目列表/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"}],"tags":[{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://prostkhala.github.io/tags/斜率优化/"},{"name":"单调栈","slug":"单调栈","permalink":"https://prostkhala.github.io/tags/单调栈/"}]},{"title":"HNOI2008     玩具装箱Toy(详解)","date":"2017-03-10T14:02:35.000Z","path":"2017/03/10/玩具装箱toy/","text":"[HNOI2008] 玩具装箱toyBZOJ1010 COGS1330 题目描述P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小. 输入输出格式输入格式：第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7 输出格式：输出最小费用. 输入输出样例输入样例#1：5 4 3 4 2 1 4 输出样例#1：1 题解设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0&lt;=i&lt;j&lt;=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N=50005; long long n,l,dp[N],a[N]; int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1]; memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l)); printf(&quot;%lld&quot;,dp[n]); } 观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。 斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，在某DP视频中，主讲人向同学们推荐了打出决策表的方法，对于此题来说，数据容易生成，可以尝试一下。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N=50005; long long n,l,dp[N],a[N],best[N]; int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1]; memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j; for(int i=1;i&lt;=n;i++)printf(&quot;%d&quot;,best[i]);//决策表 printf(&quot;%lld&quot;,dp[n]); } 易观察到best[i]单调不降，满足决策单调性。（证明见下文） 则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有 $dp[k]+(i-k-1+a[i]-a[k]-l)^2&lt;dp[j]+(i-j-1+a[i]-a[j]-l)^2$ $dp[k]-dp[j]&lt;(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$ 对于该方程，可设 $b[i]=a[i]+i$; $l=l+1$ 则有 $dp[k]-dp[j]&lt;(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$ 化简得 $((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])&lt;2b[i]-2l$ 此时的形式为点斜式方程： $(yk-yj)/(xk-xj)&lt;ansi$ 已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。 设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]&lt;b[i]-2l$时，由$A1$转移而来优于$A2$。 当$a&lt;b&lt;c$时，且$g[c,b]&lt;g[b,a]$,易证得b必不为最优决策。 证明1.$g[c,b]&lt;ansi$此时c决策优于b，则b一定不为最优决策。 2.$g[c,b]&gt;=ansi$此时b决策优于c，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时b决策不优于a决策。 综上所述，则可将所有满足$g[c,b]&lt;gb,a$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。 以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：1： 用单调队列维护点集信息。2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。AC代码如下： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 50005; long long n,l,a[N],b[N],dp[N],q[N]; double g(long long k,long long j) { return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]); } int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,a+i),a[i]+=a[i-1]; for(int i=1;i&lt;=n;++i)b[i]=a[i]+i; l++; int head=1,tail=1; q[1]=0; for(int i=1;i&lt;=n;++i) { while(head&lt;tail&amp;&amp;g(q[head+1],q[head])&lt;2*b[i]-2*l)head++; int j=q[head]; dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l); while(head&lt;tail&amp;&amp;g(i,q[tail])&lt;g(q[tail],q[tail-1]))tail--; q[++tail]=i; } printf(&quot;%lld&quot;,dp[n]); }","raw":"title: HNOI2008     玩具装箱toy(详解)\ndate: 2017-03-10 22:02:35\ncategories:\n  - 动态规划\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n  - 斜率优化\n---\n# [HNOI2008]  玩具装箱toy\n\n## [BZOJ1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010) [COGS1330](http://cogs.pro/cogs/problem/problem.php?pid=1330)\n\n---\n\n## 题目描述\n\nP教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1...N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i<=K<=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.\n### 输入输出格式\n#### 输入格式：\n\n第一行输入两个整数N，L.接下来N行输入Ci.1<=N<=50000,1<=L,Ci<=10^7\n\n#### 输出格式：\n\n输出最小费用.\n\n### 输入输出样例\n#### 输入样例#1：\n\n    5 4\n    3\n    4\n    2\n    1\n    4\n\n#### 输出样例#1：\n\n    1\n\n\n---\n## 题解\n设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0<=i<j<=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。\n```cpp\n    #include<cstdio>\n    #include<iostream>\n    #include<cstring>\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N];\n\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i<=n;i++)\n        for(int j=0;j<i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l));\n        printf(\"%lld\",dp[n]);\n    } \n```\n观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。\n\n斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，在某DP视频中，主讲人向同学们推荐了打出决策表的方法，对于此题来说，数据容易生成，可以尝试一下。\n\n    #include<cstdio>\n    #include<iostream>\n    #include<cstring>\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N],best[N];\n\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i<=n;i++)\n        for(int j=0;j<i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j;\n        for(int i=1;i<=n;i++)printf(\"%d\",best[i]);//决策表\n        printf(\"%lld\",dp[n]);\n    } \n\n易观察到best[i]单调不降，满足决策单调性。（证明见下文）\n\n\n则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有\n\n$dp[k]+(i-k-1+a[i]-a[k]-l)^2<dp[j]+(i-j-1+a[i]-a[j]-l)^2$\n\n$dp[k]-dp[j]<(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$\n\n对于该方程，可设\n\n$b[i]=a[i]+i$;\n\n$l=l+1$\n\n则有\n\n$dp[k]-dp[j]<(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$\n\n化简得\n\n$((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])<2b[i]-2l$\n\n此时的形式为点斜式方程：\n\n$(yk-yj)/(xk-xj)<ansi$\n\n已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。\n\n设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]<b[i]-2l$时，由$A1$转移而来优于$A2$。\n\n当$a<b<c$时，且$g[c,b]<g[b,a]$,易证得b必不为最优决策。\n## 证明\n### 1.$g[c,b]<ansi$\n此时c决策优于b，则b一定不为最优决策。\n### 2.$g[c,b]>=ansi$\n此时b决策优于c，但又有$g[b,a]>g[c,b]>=ansi$,此时b决策不优于a决策。\n\n综上所述，则可将所有满足$g[c,b]<g[b,a](a<b<c)$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。\n\n## 以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\n### 1： 用单调队列维护点集信息。\n### 2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)<ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。\n### 3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\n\nAC代码如下：\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 50005;\n    long long n,l,a[N],b[N],dp[N],q[N];\n    double g(long long k,long long j)\n    {\n        return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);\n    }\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;++i)scanf(\"%lld\",a+i),a[i]+=a[i-1];\n        for(int i=1;i<=n;++i)b[i]=a[i]+i;\n        l++;\n        int head=1,tail=1;\n        q[1]=0;\n        for(int i=1;i<=n;++i)\n        {\n            while(head<tail&&g(q[head+1],q[head])<2*b[i]-2*l)head++;\n            int j=q[head];\n            dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);\n            while(head<tail&&g(i,q[tail])<g(q[tail],q[tail-1]))tail--;\n            q[++tail]=i;\n        }\n        printf(\"%lld\",dp[n]);\n    }","content":"<h1 id=\"HNOI2008-玩具装箱toy\"><a href=\"#HNOI2008-玩具装箱toy\" class=\"headerlink\" title=\"[HNOI2008]  玩具装箱toy\"></a>[HNOI2008]  玩具装箱toy</h1><h2 id=\"BZOJ1010-COGS1330\"><a href=\"#BZOJ1010-COGS1330\" class=\"headerlink\" title=\"BZOJ1010 COGS1330\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1010\" target=\"_blank\" rel=\"external\">BZOJ1010</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1330\" target=\"_blank\" rel=\"external\">COGS1330</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出最小费用.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>5 4\n3\n4\n2\n1\n4\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>1\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0&lt;=i&lt;j&lt;=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。</p>\n<pre><code class=\"cpp\">    #include&lt;cstdio&gt;\n    #include&lt;iostream&gt;\n    #include&lt;cstring&gt;\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N];\n\n    int main()\n    {\n    //    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n    //    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n        for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i&lt;=n;i++)\n        for(int j=0;j&lt;i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l));\n        printf(&quot;%lld&quot;,dp[n]);\n    }\n</code></pre>\n<p>观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。</p>\n<p>斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，在某DP视频中，主讲人向同学们推荐了打出决策表的方法，对于此题来说，数据容易生成，可以尝试一下。</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N=50005;\n\nlong long n,l,dp[N],a[N],best[N];\n\nint main()\n{\n//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n    for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1];\n    memset(dp,0x3f,sizeof(dp));\n    dp[0]=0;\n    for(int i=1;i&lt;=n;i++)\n    for(int j=0;j&lt;i;j++)\n    dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j;\n    for(int i=1;i&lt;=n;i++)printf(&quot;%d&quot;,best[i]);//决策表\n    printf(&quot;%lld&quot;,dp[n]);\n} \n</code></pre><p>易观察到best[i]单调不降，满足决策单调性。（证明见下文）</p>\n<p>则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有</p>\n<p>$dp[k]+(i-k-1+a[i]-a[k]-l)^2&lt;dp[j]+(i-j-1+a[i]-a[j]-l)^2$</p>\n<p>$dp[k]-dp[j]&lt;(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$</p>\n<p>对于该方程，可设</p>\n<p>$b[i]=a[i]+i$;</p>\n<p>$l=l+1$</p>\n<p>则有</p>\n<p>$dp[k]-dp[j]&lt;(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$</p>\n<p>化简得</p>\n<p>$((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])&lt;2b[i]-2l$</p>\n<p>此时的形式为点斜式方程：</p>\n<p>$(yk-yj)/(xk-xj)&lt;ansi$</p>\n<p>已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。</p>\n<p>设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]&lt;b[i]-2l$时，由$A1$转移而来优于$A2$。</p>\n<p>当$a&lt;b&lt;c$时，且$g[c,b]&lt;g[b,a]$,易证得b必不为最优决策。</p>\n<h2 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h2><h3 id=\"1-g-c-b-lt-ansi\"><a href=\"#1-g-c-b-lt-ansi\" class=\"headerlink\" title=\"1.$g[c,b]&lt;ansi$\"></a>1.$g[c,b]&lt;ansi$</h3><p>此时c决策优于b，则b一定不为最优决策。</p>\n<h3 id=\"2-g-c-b-gt-ansi\"><a href=\"#2-g-c-b-gt-ansi\" class=\"headerlink\" title=\"2.$g[c,b]&gt;=ansi$\"></a>2.$g[c,b]&gt;=ansi$</h3><p>此时b决策优于c，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时b决策不优于a决策。</p>\n<p>综上所述，则可将所有满足$g[c,b]&lt;g<a href=\"a&lt;b&lt;c\">b,a</a>$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。</p>\n<h2 id=\"以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\"><a href=\"#以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\" class=\"headerlink\" title=\"以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\"></a>以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：</h2><h3 id=\"1：-用单调队列维护点集信息。\"><a href=\"#1：-用单调队列维护点集信息。\" class=\"headerlink\" title=\"1： 用单调队列维护点集信息。\"></a>1： 用单调队列维护点集信息。</h3><h3 id=\"2：-求解dp-i-可以从队首开始扫描，当g-head-1-head-lt-ansi时，可知head-1优于head，故继续扫描，直到不满足条件，此时bext-i-head-即使dp-i-最优的决策为队首。\"><a href=\"#2：-求解dp-i-可以从队首开始扫描，当g-head-1-head-lt-ansi时，可知head-1优于head，故继续扫描，直到不满足条件，此时bext-i-head-即使dp-i-最优的决策为队首。\" class=\"headerlink\" title=\"2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。\"></a>2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。</h3><h3 id=\"3：-当加入点i，我们要维护队列的上凸性质-即从队尾开始扫描，判断g-i-tail-是否小于g-tail，tail-1-，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\"><a href=\"#3：-当加入点i，我们要维护队列的上凸性质-即从队尾开始扫描，判断g-i-tail-是否小于g-tail，tail-1-，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\" class=\"headerlink\" title=\"3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\"></a>3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。</h3><p>AC代码如下：</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 50005;\nlong long n,l,a[N],b[N],dp[N],q[N];\ndouble g(long long k,long long j)\n{\n    return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);\n}\nint main()\n{\n//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,a+i),a[i]+=a[i-1];\n    for(int i=1;i&lt;=n;++i)b[i]=a[i]+i;\n    l++;\n    int head=1,tail=1;\n    q[1]=0;\n    for(int i=1;i&lt;=n;++i)\n    {\n        while(head&lt;tail&amp;&amp;g(q[head+1],q[head])&lt;2*b[i]-2*l)head++;\n        int j=q[head];\n        dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);\n        while(head&lt;tail&amp;&amp;g(i,q[tail])&lt;g(q[tail],q[tail-1]))tail--;\n        q[++tail]=i;\n    }\n    printf(&quot;%lld&quot;,dp[n]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/10/玩具装箱toy/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"}],"tags":[{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://prostkhala.github.io/tags/斜率优化/"}]},{"title":"后缀数组十三题","date":"2017-03-08T03:02:35.000Z","path":"2017/03/08/后缀数组13题/","text":"论文后缀数组——处理字符串的有力工具–罗穗骞 题目 例3 (1).cogs902:Musical Theme(poj1743)本题题目描述与论文略有差别。 应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..）） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; const int inf = 0x7fffffff; int wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N]; int s[N]; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(p=1,j=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } bool can(int k,int n) { int tmp=0,maxsa=-1,minsa=inf; for(int i=1;i&lt;=n;++i) { if(h[i]&lt;k)maxsa=-1,minsa=inf; if(sa[i]&lt;minsa)minsa=sa[i]; if(sa[i]&gt;maxsa)maxsa=sa[i]; if(maxsa-minsa&gt;k)return 1; } return 0; } int main() { // freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout); int n,x; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) { memset(h,0,sizeof(h)); memset(sa,0,sizeof(sa)); memset(rank,0,sizeof(rank)); if(!n)break; cin&gt;&gt;x; for(int i=1;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;s[i]); s[0]=s[1]-x; for(int i=1;i&lt;n-1;++i)s[i]=s[i+1]-s[i]; n--; for(int i=0;i&lt;n;++i)s[i]+=150; da(n+1,maxf); getheight(n); int l=0,r=1e6,ans; int mid=0; while(l!=r) { ans=l+r+1&gt;&gt;1; if(can(ans,n)) l=ans; else r=ans-1; } l++; printf(&quot;%d\\n&quot;,(l)&gt;=5?l:0); } } CODE 例4 (1).poj3261：Milk Patterns#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int maxf = 255; const int inf = 0x7fffffff; const int N = 1e5+5; int sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N]; int s[N],k; int cmp(int*r,int a,int b,int l) {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;height[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } bool can(int ans,int n) { int tot=0; for(int i=1;i&lt;=n;++i) { if(height[i]&lt;ans)tot=0; tot++; if(tot==k)return 1; } return 0; } int main() { int n; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,s+i); da(n+1,maxf); getheight(n); int l=1,r=n+1,ans,mid; while(l!=r) { int mid=(l+r&gt;&gt;1)+1; if(can(mid,n))ans=l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,ans); } CODE 例5 (1).spoj694：Distinct Substrings(Vjudge)这题论文中的方法不太好想，可以换一种思路。 易证长度为len的字符串一共有$（len+1）*len / 2$个子串。而其中重复的字串个数则为height数组的总和，减去即可。 以 sa[i-1] abba sa[i] abcd //height[i] = 2 这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。 这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为 bba bcd //height = 1 重复的子串 b 将在此处减掉。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; const int N =1e4+5; using namespace std; char s[N]; int sa[N],wa[N],wb[N],tong[N],wv[N]; int rank[N],height[N]; int cmp(int*r,int a,int b,int l) {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void calheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;i++) rank[sa[i]]=i; for(i=0;i&lt;n;height[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int i; scanf(&quot;%s&quot;,s); int n=strlen(s); da(n+1,128); calheight(n); long long ans=n*(n+1)/2; for(i=1;i&lt;=n;i++) ans-=height[i]; printf(&quot;%lld\\n&quot;,ans); } } CODE (2).cogs1709:不同的子串 （spoj705） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N]; char s[N]; bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } int main() { // freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%s&quot;,s); int n=strlen(s); da(n+1,maxf); getheight(n); for(int i=1;i&lt;=n;++i)sa[i]++; long long ans=0; for(int i=1;i&lt;=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1; printf(&quot;%d&quot;,ans); } CODE 例6 (1).ural1297：Palindrome(Vjudge)这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。 #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; const int N = 1e4+1; int tong[N],wv[N],wa[N],wb[N]; int rank1[N],height[N],sa[N]; char s[N]; int a[N],n; int dp[N][30]; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=a[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void calheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;i++)rank1[sa[i]]=i; for(i=0;i&lt;n;height[rank1[i++]]=k) for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++); return; } void preRMQ() { int i,j; memset(dp,127,sizeof(dp)); for(i=1;i&lt;=n*2+1;i++)dp[i][0]=height[i]; for(j=1;(1&lt;&lt;j)&lt;=2*n+1;j++) for(i=1;i+(1&lt;&lt;j)-1&lt;=2*n+1;i++) dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]); } int lcp(int l,int r) { int a=rank1[l],b=rank1[r]; if(a&gt;b) swap(a,b); a++; int t=(int)(log(double(b-a+1))/log(2.00)); return min(dp[a][t],dp[b-(1&lt;&lt;t)+1][t]); } int main() { int i,res,flag,max; while(scanf(&quot;%s&quot;,s)!=EOF) { max=0; n=strlen(s); for(i=0;i&lt;n;i++)a[i]=(int)s[i]; a[n]=1; for(i=0;i&lt;n;i++)a[i+n+1]=int(s[n-i-1]); a[2*n+1]=0; da(2*n+2,123); calheight(2*n+1); preRMQ(); for(i=0;i&lt;n;i++) { res=lcp(i,2*n-i)*2-1; if(max&lt;res) max=res,flag=i; if(i&gt;0) { res=lcp(i,2*n-i+1)*2; if(max&lt;res) max=res,flag=i; } } if(max%2==1)for(i=flag-max/2;i&lt;=flag+max/2;i++) printf(&quot;%c&quot;,s[i]); else for(i=flag-max/2;i&lt;=flag+max/2-1;i++) printf(&quot;%c&quot;,s[i]); printf(&quot;\\n&quot;); } } CODE 例7 (1).cogs1710:Power Strings （poj2406）本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。 例8 (1).poj3693:Maximum repetition substring #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N]; int k,now,jj,maxr,cnt; int d[N][21],ans[N]; char s[N*2]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } int prermq(int*a,int n) { for(int i=0;i&lt;n;++i)d[i][0]=a[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;++j) for(int i=0;i+(1&lt;&lt;j)-1&lt;n;++i) d[i][j]=min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]); } int askrmq(int l,int r) { l=rank[l],r=rank[r]; if(l&gt;r)swap(l,r); l++; int k=0; while((1&lt;&lt;(k+1))&lt;=r-l+1)k++; return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]); } int main() { int ccase=0; while(1) { memset(h,0,sizeof(h)); memset(d,0,sizeof(d)); memset(tong,0,sizeof(tong)); memset(rank,0,sizeof(rank)); memset(ans,0,sizeof(ans)); ccase++; k=now=jj=maxr=cnt=0; scanf(&quot;%s&quot;,s); if(s[0]==&#39;#&#39;)return 0; int n=strlen(s); da(n+1,maxf); getheight(n); prermq(h,n+1); for(int i=1;i&lt;n;++i) for(int j=0;j+i&lt;n;j+=i) { k=askrmq(j,j+i); now=k/i+1; jj=j-(i-k%i); if (jj&gt;=0&amp;&amp;askrmq(jj,jj+i)&gt;=(i-k%i))++now; if(now&gt;maxr) {cnt=0;maxr=now;ans[cnt++]=i;} else if(now==maxr) ans[cnt++]=i; } for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;cnt;++j) if(askrmq(sa[i],sa[i]+ans[j])&gt;=(maxr-1)*ans[j]) { jj=sa[i],k=ans[j]; goto dd; } dd:; printf(&quot;Case %d: &quot;,ccase); for (int i=0;i&lt;maxr*k;++i)putchar(s[jj++]); printf(&quot;\\n&quot;); } } CODE (2).cogs1711:重复的字符串 （spoj687） 例9 (1).cogs1713:Long Long Message （poj2774）#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 3e5+1; const int maxf = 255; const int inf =0x7fffffff; int sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N]; char s[N],ss[N]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;m=p,j&lt;&lt;=1) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } int main() { freopen(&quot;longlongmessage.in&quot;,&quot;r&quot;,stdin); freopen(&quot;longlongmessage.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%s&quot;,s); scanf(&quot;%s&quot;,ss); int n=strlen(s),m=strlen(ss); s[n]=&#39;*&#39;; for(int i=n+1;i&lt;=n+m;++i)s[i]=ss[i-n-1]; int l=n+m+1; da(l+1,maxf); geth(l); int maxx=0; for(int i=2;i&lt;=l;++i) { if(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i-1]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i-1]&lt;n))) maxx=h[i]; } cout&lt;&lt;maxx; } CODE 例10 (1).cogs1712:Common Substrings （poj3415） 例11 (1).cogs2128:生命形态 （poj3294）例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 2e5+1; const int inf =0x7fffffff; const int maxf = 255; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} int sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N]; char ss[111][10001],s[N]; int nn[111],tt; bool inq[111]; int ll[N]; void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(i=1,p=1,swap(x,y),x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++); } int k; int ansg; bool can(int ans,int n,int flag) { if(!flag) { int tot1=0; memset(inq,0,sizeof(inq)); for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { memset(inq,0,sizeof(inq)); tot1=0; } else { int nowq,nowt; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t; if(!inq[nowq])tot1++,inq[nowq]=true; if(!inq[nowt])tot1++,inq[nowt]=true; if(tot1&gt;=k)return 1; } } return 0; } if(flag) { int lll=inf,rrr=-1; int tot1=0; memset(inq,0,sizeof(inq)); for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { memset(inq,0,sizeof(inq)); tot1=0; lll=inf;rrr=-1; } else { int nowq,nowt; if(sa[i-1]&lt;lll)lll=sa[i-1];if(sa[i-1]&gt;rrr)rrr=sa[i-1]; if(sa[i]&lt;lll)lll=sa[i];if(sa[i]&gt;rrr)rrr=sa[i]; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t; if(!inq[nowq])tot1++,inq[nowq]=true; if(!inq[nowt])tot1++,inq[nowt]=true; if(tot1==k)ll[++ansg]=lll; } } } } int main() { // freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout); while(scanf(&quot;%d&quot;,&amp;tt)!=EOF) { if(!tt)return 0; memset(wa,0,sizeof(wa)); memset(wb,0,sizeof(wb)); memset(wv,0,sizeof(wv)); memset(rank,0,sizeof(rank)); memset(sa,0,sizeof(sa)); memset(h,0,sizeof(h)); memset(nn,0,sizeof(nn)); memset(s,0,sizeof(s)); int tot=0; int tmp=2; ansg=0; for(int i=1;i&lt;=tt;++i) { scanf(&quot;%s&quot;,ss[i]); nn[i]=strlen(ss[i]); nn[0]=-1; for(int t=0;t&lt;nn[i];++t)s[tot++]=ss[i][t]; nn[i]+=nn[i-1]+(i==tt?0:1); if(i!=tt)s[tot++]=tmp++; } nn[tt]++; int n=strlen(s); da(n+1,maxf); geth(n); k=(tt)/2+1; int l=0,r=n+1,mid; while(l!=r) { mid=(l+r+1)&gt;&gt;1; if(can(mid,n,0)) l=mid; else r=mid-1; } if(l==0){printf(&quot;?&quot;);goto dd;} can(l,n,1); for(int i=1;i&lt;=ansg;++i) { if(i!=1) { bool flag=0; for(int t=0;t&lt;l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;} if(!flag)continue; } for(int t=ll[i];t&lt;=ll[i]+l-1;++t)putchar(s[t]); printf(&quot;\\n&quot;); } dd:; } } CODE 例12 (1).cogs2120:破译进攻计划 （spoj220）#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; const int N = 2e5+500; const int maxf = 255; int sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N]; char s[N],ss[13][15031]; int inq[13],maxq[13],minq[13]; int tt,num; bool use[13]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),x[sa[0]]=0,i=1,p=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } bool can(int ans,int n) { int tot=0; for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { tot=0; memset(inq,0,sizeof(inq)); memset(maxq,0,sizeof(maxq)); memset(minq,0x3f,sizeof(minq)); memset(use,0,sizeof(use)); } else { for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t]) { inq[t]++; minq[t]=min(minq[t],sa[i]); maxq[t]=max(maxq[t],sa[i]); if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true; if(tot==num)return 1; } for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t]) { inq[t]++; minq[t]=min(minq[t],sa[i-1]); maxq[t]=max(maxq[t],sa[i-1]); if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true; if(tot==num)return 1; } } } return 0; } int main() { // freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout); nn[0]=-1; scanf(&quot;%d&quot;,&amp;tt); while(tt--) { memset(inq,0,sizeof(inq)); memset(wa,0,sizeof(wa)); memset(wb,0,sizeof(wb)); memset(wv,0,sizeof(wv)); memset(sa,0,sizeof(sa)); memset(rank,0,sizeof(rank)); memset(h,0,sizeof(h)); scanf(&quot;%d&quot;,&amp;num); int tot=0,qiguaizifu=2; for(int i=1;i&lt;=num;++i) { scanf(&quot;%s&quot;,ss[i]); nn[i]=strlen(ss[i]); } for(int i=1;i&lt;=num;++i) { for(int t=0;t&lt;nn[i];++t) s[tot++]=ss[i][t]; s[tot++]=qiguaizifu++; } for(int i=1;i&lt;=num;++i)nn[i]+=(nn[i-1]+1); int n=strlen(s); da(n+1,maxf); geth(n); int l=0,r=(n+1)/2; while(l!=r) { int mid=l+r+1&gt;&gt;1; if(can(mid,n)) l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,l); } } CODE 例13 (1).poj1226:Substrings","raw":"title: 后缀数组十三题\ndate: 2017-03-08 11:02:35\ncategories:\n  - Hollerith-type\ntags:\n  - 后缀数组\n  - 字符串问题\n---\n\n\n# 论文\n[后缀数组——处理字符串的有力工具--罗穗骞](https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/pdfs/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E4%B9%8B%E3%80%8A%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E5%8A%9B%E5%B7%A5%E5%85%B7%E3%80%8B.pdf)\n\n\n <!--more--> \n \n \n# 题目\n\n-----------------------------------------------------------------------------------------------------------\n## 例3         (1).[cogs902:Musical Theme](http://cogs.pro/cogs/problem/problem.php?pid=902)(poj1743)\n\n本题题目描述与论文略有差别。\n\n应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa > k，而不是maxsa - minsa > = k（然而POJ并没有卡我..））\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 1e5+1;\n    const int maxf = 255;\n    const int inf = 0x7fffffff;\n    int wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];\n    int s[N];\n    int cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i<m;i++)tong[i]=0;\n    for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i<m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n    for(p=1,j=1;p<n;j<<=1,m=p)\n    {\n        for(p=0,i=n-j;i<n;++i)y[p++]=i;\n        for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n        for(i=0;i<n;++i)wv[i]=x[y[i]];\n        for(i=0;i<m;i++)tong[i]=0;\n        for(i=0;i<n;++i)tong[wv[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n    }\n    void getheight(int n)\n    {\n    int i,j,k=0;\n    for(i=1;i<=n;++i)rank[sa[i]]=i;\n    for(i=0;i<n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    return;\n    }\n    bool can(int k,int n)\n    {\n    int tmp=0,maxsa=-1,minsa=inf;\n    for(int i=1;i<=n;++i)\n    {\n        if(h[i]<k)maxsa=-1,minsa=inf;\n        if(sa[i]<minsa)minsa=sa[i];\n        if(sa[i]>maxsa)maxsa=sa[i];\n        if(maxsa-minsa>k)return 1;\n    }\n    return 0;\n    }\n    int main()\n    {\n    //  freopen(\"theme.in\",\"r\",stdin);\n    //  freopen(\"theme.out\",\"w\",stdout);\n    int n,x;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        memset(h,0,sizeof(h));\n        memset(sa,0,sizeof(sa));\n        memset(rank,0,sizeof(rank));\n        if(!n)break;\n        cin>>x;\n        for(int i=1;i<n;++i)scanf(\"%d\",&s[i]);\n        s[0]=s[1]-x;\n        for(int i=1;i<n-1;++i)s[i]=s[i+1]-s[i];\n        n--;\n        for(int i=0;i<n;++i)s[i]+=150;\n        da(n+1,maxf);\n        getheight(n);\n        int l=0,r=1e6,ans;\n        int mid=0;\n        while(l!=r)\n        {\n            ans=l+r+1>>1;\n            if(can(ans,n))  l=ans;\n            else      r=ans-1;\n        }\n        l++;\n        printf(\"%d\\n\",(l)>=5?l:0);\n    }\n    }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B3.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例4         (1).[poj3261：Milk Patterns](http://poj.org/problem?id=3261)\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int maxf = 255;\n    const int inf = 0x7fffffff;\n    const int N = 1e5+5;\n    int sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];\n    int s[N],k;\n    int cmp(int*r,int a,int b,int l)\n    {return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;i++)tong[i]=0;\n            for(i=0;i<n;i++)tong[wv[i]]++;\n            for(i=1;i<m;i++)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void getheight(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;height[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n        return;\n    }\n    bool can(int ans,int n)\n    {\n        int tot=0;\n        for(int i=1;i<=n;++i)\n        {\n            if(height[i]<ans)tot=0;\n            tot++;\n            if(tot==k)return 1;\n        }\n        return 0;\n    }\n    int main()\n    {\n        int n;\n        scanf(\"%d%d\",&n,&k);\n        for(int i=0;i<n;++i)scanf(\"%d\",s+i);\n        da(n+1,maxf);\n        getheight(n);\n        int l=1,r=n+1,ans,mid;\n        while(l!=r)\n        {\n            int mid=(l+r>>1)+1;\n            if(can(mid,n))ans=l=mid;\n            else    r=mid-1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B4.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例5         (1).[spoj694：Distinct Substrings](https://vjudge.net/problem/SPOJ-DISUBSTR)(Vjudge)   \n\n这题论文中的方法不太好想，可以换一种思路。\n\n易证长度为len的字符串一共有$（len+1）*len / 2$个子串。\n而其中重复的字串个数则为height数组的总和，减去即可。\n\n以\n\n\tsa[i-1]  abba\n\n\tsa[i]    abcd //height[i] = 2\n\n这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。\n\n这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为\n   \n   \tbba\n       bcd //height = 1\n    \n    \n   重复的子串 b 将在此处减掉。\n   \n\n      #include<iostream> \n      #include<cstring>\n      #include<cstdio>\n      const int N =1e4+5;       \n      using namespace std;       \n      char s[N];   \n      int sa[N],wa[N],wb[N],tong[N],wv[N];      \n      int rank[N],height[N];      \n      int cmp(int*r,int a,int b,int l)\n      {return r[a]==r[b]&&r[a+l]==r[b+l];}\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<m;i++)tong[i]=0;\n              for(i=0;i<n;i++)tong[wv[i]]++;\n              for(i=1;i<m;i++)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n          return;\n      }\n      void calheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;i++) rank[sa[i]]=i;\n          for(i=0;i<n;height[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n          return;\n      }\n      int main()  \n      {  \n          int t;  \n          scanf(\"%d\",&t);  \n          while(t--)  \n          {  \n              int i;  \n              scanf(\"%s\",s);  \n              int n=strlen(s);   \n              da(n+1,128);  \n              calheight(n);  \n              long long ans=n*(n+1)/2;  \n              for(i=1;i<=n;i++)  \n              ans-=height[i];  \n              printf(\"%lld\\n\",ans);  \n          }  \n      }  \n\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.cpp)\n\n\n\n## (2).[cogs1709:不同的子串](http://cogs.pro/cogs/problem/problem.php?pid=1709) （spoj705）\n\n      #include<iostream>\n      #include<cstdio>\n      #include<cstring>\n      using namespace std;\n      const int N = 1e5+1;\n      const int maxf = 255;\n      int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];\n      char s[N];\n      bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;i--)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<m;++i)tong[i]=0;\n              for(i=0;i<n;++i)tong[wv[i]]++;\n              for(i=1;i<m;++i)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,i=1,x[sa[0]]=0;i<n;++i)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n          return;\n      }\n      void getheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;++i)rank[sa[i]]=i;\n          for(i=0;i<n;h[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n          return;\n      }\n      int main()\n      {\n      //  freopen(\"subst1.in\",\"r\",stdin);\n      //  freopen(\"subst1.out\",\"w\",stdout);\n          scanf(\"%s\",s);\n          int n=strlen(s);\n          da(n+1,maxf);\n          getheight(n);\n          for(int i=1;i<=n;++i)sa[i]++;\n          long long ans=0;\n          for(int i=1;i<=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1;\n          printf(\"%d\",ans);\n      }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.2.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例6         (1).[ural1297：Palindrome](https://vjudge.net/problem/URAL-1297)(Vjudge)\n\n这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]>=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。\n\n\n\n    #include<cstring>\n    #include<cstdlib>\n    #include<cstdio>\n    #include<iostream>\n    #include<cmath>\n    using namespace std;\n    const int N = 1e4+1;\n    int tong[N],wv[N],wa[N],wb[N];\n    int rank1[N],height[N],sa[N];\n    char s[N];\n    int a[N],n;\n    int dp[N][30];\n    int cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=a[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;i++)tong[i]=0;\n            for(i=0;i<n;i++)tong[wv[i]]++;\n            for(i=1;i<m;i++)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n      return;\n    }\n\n    void calheight(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;i++)rank1[sa[i]]=i;\n        for(i=0;i<n;height[rank1[i++]]=k)\n        for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++);\n        return;\n    }\n\n    void preRMQ()\n    {\n        int i,j;\n        memset(dp,127,sizeof(dp));\n        for(i=1;i<=n*2+1;i++)dp[i][0]=height[i];\n        for(j=1;(1<<j)<=2*n+1;j++)\n        for(i=1;i+(1<<j)-1<=2*n+1;i++)\n        dp[i][j]=min(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);\n    }\n\n    int lcp(int l,int r)\n    {\n        int a=rank1[l],b=rank1[r];\n        if(a>b)\n            swap(a,b);\n        a++;\n        int t=(int)(log(double(b-a+1))/log(2.00));\n        return min(dp[a][t],dp[b-(1<<t)+1][t]);\n    }\n\n    int main()\n    {\n        int i,res,flag,max;\n        while(scanf(\"%s\",s)!=EOF)\n        {\n            max=0;\n            n=strlen(s);\n            for(i=0;i<n;i++)a[i]=(int)s[i];\n            a[n]=1;\n            for(i=0;i<n;i++)a[i+n+1]=int(s[n-i-1]);\n            a[2*n+1]=0;\n            da(2*n+2,123);\n            calheight(2*n+1);\n            preRMQ();\n            for(i=0;i<n;i++)\n            {\n                res=lcp(i,2*n-i)*2-1;\n                if(max<res)   max=res,flag=i;\n                if(i>0)\n                {\n                    res=lcp(i,2*n-i+1)*2;\n                    if(max<res) max=res,flag=i;\n                }\n            }\n            if(max%2==1)for(i=flag-max/2;i<=flag+max/2;i++)   printf(\"%c\",s[i]);\n            else    for(i=flag-max/2;i<=flag+max/2-1;i++) printf(\"%c\",s[i]);\n            printf(\"\\n\");\n        }\n  }\n\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B6.cpp)\n\n-----------------------------------------------------------------------------------------------------------\n## 例7           (1).[cogs1710:Power Strings](http://cogs.pro/cogs/problem/problem.php?pid=1710)  （poj2406）\n\n本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n ## 例8       (1).[poj3693:Maximum repetition substring](http://poj.org/problem?id=3693)\n\n\n      #include<iostream>\n      #include<cstdio>\n      #include<cstring>\n      using namespace std;\n      const int N = 1e5+1;\n      const int maxf = 255;\n      int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];\n      int k,now,jj,maxr,cnt;\n      int d[N][21],ans[N];\n      char s[N*2];\n      bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<m;++i)tong[i]=0;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<n;++i)tong[wv[i]]++;\n              for(i=1;i<m;++i)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;++i)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n      }\n      void getheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;++i)rank[sa[i]]=i;\n          for(i=0;i<n;h[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      }\n      int prermq(int*a,int n)\n      {\n          for(int i=0;i<n;++i)d[i][0]=a[i];\n          for(int j=1;(1<<j)<=n;++j)\n          for(int i=0;i+(1<<j)-1<n;++i)\n          d[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n      }\n      int askrmq(int l,int r)\n      {\n          l=rank[l],r=rank[r];\n          if(l>r)swap(l,r);\n          l++;\n          int k=0;\n          while((1<<(k+1))<=r-l+1)k++;\n          return min(d[l][k],d[r-(1<<k)+1][k]);\n      }\n      int main()\n      {\n          int ccase=0;\n          while(1)\n          {\n          memset(h,0,sizeof(h));\n          memset(d,0,sizeof(d));\n          memset(tong,0,sizeof(tong));\n          memset(rank,0,sizeof(rank));\n          memset(ans,0,sizeof(ans));\n          ccase++;\n\n          k=now=jj=maxr=cnt=0;\n          scanf(\"%s\",s);\n          if(s[0]=='#')return 0;\n          int n=strlen(s);\n          da(n+1,maxf);\n          getheight(n);\n          prermq(h,n+1);\n          for(int i=1;i<n;++i) \n          for(int j=0;j+i<n;j+=i) \n          {\n              k=askrmq(j,j+i);\n              now=k/i+1;\n              jj=j-(i-k%i);\n              if (jj>=0&&askrmq(jj,jj+i)>=(i-k%i))++now;\n              if(now>maxr)    {cnt=0;maxr=now;ans[cnt++]=i;}\n              else if(now==maxr)  ans[cnt++]=i;\n          }\n              for(int i=1;i<=n;++i) \n              for(int j=0;j<cnt;++j)\n              if(askrmq(sa[i],sa[i]+ans[j])>=(maxr-1)*ans[j])\n              {\n                  jj=sa[i],k=ans[j];\n                  goto dd;\n              }\n              dd:;\n              printf(\"Case %d: \",ccase);\n              for (int i=0;i<maxr*k;++i)putchar(s[jj++]);\n              printf(\"\\n\");\n          }\n      }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B8.cpp)\n\n\n\n\n\n## (2).[cogs1711:重复的字符串](http://cogs.pro/cogs/problem/problem.php?pid=1711) （spoj687）\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例9      (1).[cogs1713:Long Long Message](http://cogs.pro/cogs/problem/problem.php?pid=1713)  （poj2774）\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 3e5+1;\n    const int maxf = 255;\n    const int inf =0x7fffffff;\n    int sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N];\n    char s[N],ss[N];\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;m=p,j<<=1)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,i=1,x[sa[0]]=0;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    }\n    int main()\n    {\n        freopen(\"longlongmessage.in\",\"r\",stdin);\n        freopen(\"longlongmessage.out\",\"w\",stdout);\n        scanf(\"%s\",s);\n        scanf(\"%s\",ss);\n        int n=strlen(s),m=strlen(ss);\n        s[n]='*';\n        for(int i=n+1;i<=n+m;++i)s[i]=ss[i-n-1];\n        int l=n+m+1;\n        da(l+1,maxf);\n        geth(l);\n        int maxx=0;\n        for(int i=2;i<=l;++i)\n        {\n            if(h[i]>maxx&&((sa[i]<n&&sa[i-1]>n)||(sa[i]>n&&sa[i-1]<n)))\n            maxx=h[i];\n        }\n        cout<<maxx;\n    }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B9.tag.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例10    (1).[cogs1712:Common Substrings](http://cogs.pro/cogs/problem/problem.php?pid=1712)  （poj3415）\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例11    (1).[cogs2128:生命形态](http://cogs.pro/cogs/problem/problem.php?pid=2128)   （poj3294）\n\n例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。\n\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N = 2e5+1;\n    const int inf =0x7fffffff;\n    const int maxf = 255;\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    int sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];\n    char ss[111][10001],s[N];\n    int nn[111],tt;\n    bool inq[111];\n    int ll[N];\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]=x[y[i]]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(i=1,p=1,swap(x,y),x[sa[0]]=0;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++);\n    }\n    int k;\n    int ansg;\n    bool can(int ans,int n,int flag)\n    {\n        if(!flag)\n        {\n            int tot1=0;\n            memset(inq,0,sizeof(inq));\n            for(int i=1;i<=n;++i)\n            {\n                if(h[i]<ans)\n                {\n                    memset(inq,0,sizeof(inq));  tot1=0;\n                }\n                else\n                {\n                    int nowq,nowt;\n                    for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])nowt=t;\n                    for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i]&&sa[i]<nn[t])nowq=t;\n                    if(!inq[nowq])tot1++,inq[nowq]=true;\n                    if(!inq[nowt])tot1++,inq[nowt]=true;\n                    if(tot1>=k)return 1;\n                }\n            }\n            return 0;\n        }\n        if(flag)\n        {\n          int lll=inf,rrr=-1;\n          int tot1=0;\n          memset(inq,0,sizeof(inq));\n          for(int i=1;i<=n;++i)\n          {\n              if(h[i]<ans)\n              {\n                  memset(inq,0,sizeof(inq));  tot1=0;\n                  lll=inf;rrr=-1;\n              }\n              else\n              {\n                  int nowq,nowt;\n                  if(sa[i-1]<lll)lll=sa[i-1];if(sa[i-1]>rrr)rrr=sa[i-1];\n                  if(sa[i]<lll)lll=sa[i];if(sa[i]>rrr)rrr=sa[i];\n                  for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])nowt=t;\n                  for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i]&&sa[i]<nn[t])nowq=t;\n                  if(!inq[nowq])tot1++,inq[nowq]=true;\n                  if(!inq[nowt])tot1++,inq[nowt]=true;\n                  if(tot1==k)ll[++ansg]=lll;\n              }\n          }\n      }\n    }\n      int main()\n      {\n      //  freopen(\"Lifeforms.in\",\"r\",stdin);\n      //  freopen(\"Lifeforms.out\",\"w\",stdout);\n          while(scanf(\"%d\",&tt)!=EOF)\n          {\n              if(!tt)return 0;\n              memset(wa,0,sizeof(wa));\n              memset(wb,0,sizeof(wb));\n              memset(wv,0,sizeof(wv));\n              memset(rank,0,sizeof(rank));\n              memset(sa,0,sizeof(sa));\n              memset(h,0,sizeof(h));\n              memset(nn,0,sizeof(nn));\n              memset(s,0,sizeof(s));\n              int tot=0;\n              int tmp=2;\n              ansg=0;\n              for(int i=1;i<=tt;++i)\n              {\n                  scanf(\"%s\",ss[i]);\n                  nn[i]=strlen(ss[i]);\n                  nn[0]=-1;\n                  for(int t=0;t<nn[i];++t)s[tot++]=ss[i][t];\n                  nn[i]+=nn[i-1]+(i==tt?0:1);\n                  if(i!=tt)s[tot++]=tmp++;\n              }\n              nn[tt]++;\n              int n=strlen(s);\n              da(n+1,maxf);\n              geth(n);\n              k=(tt)/2+1;\n              int l=0,r=n+1,mid;\n              while(l!=r)\n              {\n                  mid=(l+r+1)>>1;\n                  if(can(mid,n,0))  l=mid;\n                  else      r=mid-1;\n              }\n              if(l==0){printf(\"?\");goto dd;}\n              can(l,n,1);\n              for(int i=1;i<=ansg;++i)\n              {\n                  if(i!=1)\n                  {\n                  bool flag=0;\n                  for(int t=0;t<l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;}\n                  if(!flag)continue;\n                  }\n                  for(int t=ll[i];t<=ll[i]+l-1;++t)putchar(s[t]);\n                  printf(\"\\n\");\n              }\n              dd:;\n          }\n      }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B11.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例12    (1).[cogs2120:破译进攻计划](http://cogs.pro/cogs/problem/problem.php?pid=2120)   （spoj220）\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<cmath>\n    using namespace std;\n    const int N = 2e5+500;\n    const int maxf = 255;\n    int sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];\n    char s[N],ss[13][15031];\n    int inq[13],maxq[13],minq[13];\n    int tt,num;\n    bool use[13];\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;i--)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]=x[y[i]]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),x[sa[0]]=0,i=1,p=1;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    }\n    bool can(int ans,int n)\n    {\n        int tot=0;\n        for(int i=1;i<=n;++i)\n        {\n            if(h[i]<ans)\n            {\n                tot=0;\n                memset(inq,0,sizeof(inq));\n                memset(maxq,0,sizeof(maxq));\n                memset(minq,0x3f,sizeof(minq));\n                memset(use,0,sizeof(use));\n            }\n            else\n            {\n                for(int t=1;t<=num;++t)if(nn[t-1]<sa[i]&&sa[i]<=nn[t])\n                {\n                    inq[t]++;\n                    minq[t]=min(minq[t],sa[i]);\n                    maxq[t]=max(maxq[t],sa[i]);\n                    if(maxq[t]-minq[t]>=ans&&!use[t])tot++,use[t]=true;\n                    if(tot==num)return 1;\n                }\n                for(int t=1;t<=num;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])\n                {\n                    inq[t]++;\n                    minq[t]=min(minq[t],sa[i-1]);\n                    maxq[t]=max(maxq[t],sa[i-1]);\n                    if(maxq[t]-minq[t]>=ans&&!use[t])tot++,use[t]=true;\n                    if(tot==num)return 1;\n                }\n            } \n        }\n        return 0;\n    }\n    int main()\n    {\n    //  freopen(\"RelevantPhrasesofAnnihil.in\",\"r\",stdin);\n    //  freopen(\"RelevantPhrasesofAnnihil.out\",\"w\",stdout);\n        nn[0]=-1;\n        scanf(\"%d\",&tt);\n        while(tt--)\n        {\n            memset(inq,0,sizeof(inq));\n            memset(wa,0,sizeof(wa));\n            memset(wb,0,sizeof(wb));\n            memset(wv,0,sizeof(wv));\n            memset(sa,0,sizeof(sa));\n            memset(rank,0,sizeof(rank));\n            memset(h,0,sizeof(h));\n            scanf(\"%d\",&num);\n            int tot=0,qiguaizifu=2;\n            for(int i=1;i<=num;++i)\n            {\n                scanf(\"%s\",ss[i]);\n                nn[i]=strlen(ss[i]);\n            }\n            for(int i=1;i<=num;++i)\n            {\n                for(int t=0;t<nn[i];++t)\n                s[tot++]=ss[i][t];\n                s[tot++]=qiguaizifu++;\n            }\n            for(int i=1;i<=num;++i)nn[i]+=(nn[i-1]+1);\n            int n=strlen(s);\n            da(n+1,maxf);\n            geth(n);\n            int l=0,r=(n+1)/2;\n            while(l!=r)\n            {\n                int mid=l+r+1>>1;\n                if(can(mid,n))  l=mid;\n                else      r=mid-1;\n            }\n            printf(\"%d\\n\",l);\n        }\n    }\n\n\n[CODE](https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B12.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例13    (1).[poj1226:Substrings](http://poj.org/problem?id=1226)\n-------------------------------------------------------------\n\n    \n","content":"<h1 id=\"论文\"><a href=\"#论文\" class=\"headerlink\" title=\"论文\"></a>论文</h1><p><a href=\"https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/pdfs/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E4%B9%8B%E3%80%8A%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E5%8A%9B%E5%B7%A5%E5%85%B7%E3%80%8B.pdf\" target=\"_blank\" rel=\"external\">后缀数组——处理字符串的有力工具–罗穗骞</a></p>\n <a id=\"more\"></a> \n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><hr>\n<h2 id=\"例3-1-cogs902-Musical-Theme-poj1743\"><a href=\"#例3-1-cogs902-Musical-Theme-poj1743\" class=\"headerlink\" title=\"例3         (1).cogs902:Musical Theme(poj1743)\"></a>例3         (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=902\" target=\"_blank\" rel=\"external\">cogs902:Musical Theme</a>(poj1743)</h2><p>本题题目描述与论文略有差别。</p>\n<p>应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..））</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 1e5+1;\nconst int maxf = 255;\nconst int inf = 0x7fffffff;\nint wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];\nint s[N];\nint cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\nint i,j,p,*x=wa,*y=wb;\nfor(i=0;i&lt;m;i++)tong[i]=0;\nfor(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\nfor(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\nfor(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\nfor(p=1,j=1;p&lt;n;j&lt;&lt;=1,m=p)\n{\n    for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n    for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n    for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n    for(i=0;i&lt;m;i++)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[wv[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n    for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i)\n    x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n}\nreturn;\n}\nvoid getheight(int n)\n{\nint i,j,k=0;\nfor(i=1;i&lt;=n;++i)rank[sa[i]]=i;\nfor(i=0;i&lt;n;h[rank[i++]]=k)\nfor(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\nreturn;\n}\nbool can(int k,int n)\n{\nint tmp=0,maxsa=-1,minsa=inf;\nfor(int i=1;i&lt;=n;++i)\n{\n    if(h[i]&lt;k)maxsa=-1,minsa=inf;\n    if(sa[i]&lt;minsa)minsa=sa[i];\n    if(sa[i]&gt;maxsa)maxsa=sa[i];\n    if(maxsa-minsa&gt;k)return 1;\n}\nreturn 0;\n}\nint main()\n{\n//  freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin);\n//  freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout);\nint n,x;\nwhile(scanf(&quot;%d&quot;,&amp;n)!=EOF)\n{\n    memset(h,0,sizeof(h));\n    memset(sa,0,sizeof(sa));\n    memset(rank,0,sizeof(rank));\n    if(!n)break;\n    cin&gt;&gt;x;\n    for(int i=1;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;s[i]);\n    s[0]=s[1]-x;\n    for(int i=1;i&lt;n-1;++i)s[i]=s[i+1]-s[i];\n    n--;\n    for(int i=0;i&lt;n;++i)s[i]+=150;\n    da(n+1,maxf);\n    getheight(n);\n    int l=0,r=1e6,ans;\n    int mid=0;\n    while(l!=r)\n    {\n        ans=l+r+1&gt;&gt;1;\n        if(can(ans,n))  l=ans;\n        else      r=ans-1;\n    }\n    l++;\n    printf(&quot;%d\\n&quot;,(l)&gt;=5?l:0);\n}\n}\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B3.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例4-1-poj3261：Milk-Patterns\"><a href=\"#例4-1-poj3261：Milk-Patterns\" class=\"headerlink\" title=\"例4         (1).poj3261：Milk Patterns\"></a>例4         (1).<a href=\"http://poj.org/problem?id=3261\" target=\"_blank\" rel=\"external\">poj3261：Milk Patterns</a></h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxf = 255;\nconst int inf = 0x7fffffff;\nconst int N = 1e5+5;\nint sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];\nint s[N],k;\nint cmp(int*r,int a,int b,int l)\n{return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n        for(i=0;i&lt;m;i++)tong[i]=0;\n        for(i=0;i&lt;n;i++)tong[wv[i]]++;\n        for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n}\nvoid getheight(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;height[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    return;\n}\nbool can(int ans,int n)\n{\n    int tot=0;\n    for(int i=1;i&lt;=n;++i)\n    {\n        if(height[i]&lt;ans)tot=0;\n        tot++;\n        if(tot==k)return 1;\n    }\n    return 0;\n}\nint main()\n{\n    int n;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);\n    for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,s+i);\n    da(n+1,maxf);\n    getheight(n);\n    int l=1,r=n+1,ans,mid;\n    while(l!=r)\n    {\n        int mid=(l+r&gt;&gt;1)+1;\n        if(can(mid,n))ans=l=mid;\n        else    r=mid-1;\n    }\n    printf(&quot;%d\\n&quot;,ans);\n}\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B4.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例5-1-spoj694：Distinct-Substrings-Vjudge\"><a href=\"#例5-1-spoj694：Distinct-Substrings-Vjudge\" class=\"headerlink\" title=\"例5         (1).spoj694：Distinct Substrings(Vjudge)\"></a>例5         (1).<a href=\"https://vjudge.net/problem/SPOJ-DISUBSTR\" target=\"_blank\" rel=\"external\">spoj694：Distinct Substrings</a>(Vjudge)</h2><p>这题论文中的方法不太好想，可以换一种思路。</p>\n<p>易证长度为len的字符串一共有$（len+1）*len / 2$个子串。<br>而其中重复的字串个数则为height数组的总和，减去即可。</p>\n<p>以</p>\n<pre><code>sa[i-1]  abba\n\nsa[i]    abcd //height[i] = 2\n</code></pre><p>这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。</p>\n<p>这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为</p>\n<pre><code>   bba\n   bcd //height = 1\n</code></pre><p>   重复的子串 b 将在此处减掉。</p>\n<pre><code>  #include&lt;iostream&gt; \n  #include&lt;cstring&gt;\n  #include&lt;cstdio&gt;\n  const int N =1e4+5;       \n  using namespace std;       \n  char s[N];   \n  int sa[N],wa[N],wb[N],tong[N],wv[N];      \n  int rank[N],height[N];      \n  int cmp(int*r,int a,int b,int l)\n  {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n  void da(int n,int m)\n  {\n      int i,j,p,*x=wa,*y=wb;\n      for(i=0;i&lt;m;++i)tong[i]=0;\n      for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n      for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n      for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n      for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n      {\n          for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n          for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n          for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n          for(i=0;i&lt;m;i++)tong[i]=0;\n          for(i=0;i&lt;n;i++)tong[wv[i]]++;\n          for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n          for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n          x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n      }\n      return;\n  }\n  void calheight(int n)\n  {\n      int i,j,k=0;\n      for(i=1;i&lt;=n;i++) rank[sa[i]]=i;\n      for(i=0;i&lt;n;height[rank[i++]]=k)\n      for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      return;\n  }\n  int main()  \n  {  \n      int t;  \n      scanf(&quot;%d&quot;,&amp;t);  \n      while(t--)  \n      {  \n          int i;  \n          scanf(&quot;%s&quot;,s);  \n          int n=strlen(s);   \n          da(n+1,128);  \n          calheight(n);  \n          long long ans=n*(n+1)/2;  \n          for(i=1;i&lt;=n;i++)  \n          ans-=height[i];  \n          printf(&quot;%lld\\n&quot;,ans);  \n      }  \n  }  \n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<h2 id=\"2-cogs1709-不同的子串-（spoj705）\"><a href=\"#2-cogs1709-不同的子串-（spoj705）\" class=\"headerlink\" title=\"(2).cogs1709:不同的子串 （spoj705）\"></a>(2).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1709\" target=\"_blank\" rel=\"external\">cogs1709:不同的子串</a> （spoj705）</h2><pre><code>  #include&lt;iostream&gt;\n  #include&lt;cstdio&gt;\n  #include&lt;cstring&gt;\n  using namespace std;\n  const int N = 1e5+1;\n  const int maxf = 255;\n  int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];\n  char s[N];\n  bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n  void da(int n,int m)\n  {\n      int i,j,p,*x=wa,*y=wb;\n      for(i=0;i&lt;m;++i)tong[i]=0;\n      for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n      for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n      for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i;\n      for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n      {\n          for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n          for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n          for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n          for(i=0;i&lt;m;++i)tong[i]=0;\n          for(i=0;i&lt;n;++i)tong[wv[i]]++;\n          for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n          for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i)\n          x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n      }\n      return;\n  }\n  void getheight(int n)\n  {\n      int i,j,k=0;\n      for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n      for(i=0;i&lt;n;h[rank[i++]]=k)\n      for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      return;\n  }\n  int main()\n  {\n  //  freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin);\n  //  freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout);\n      scanf(&quot;%s&quot;,s);\n      int n=strlen(s);\n      da(n+1,maxf);\n      getheight(n);\n      for(int i=1;i&lt;=n;++i)sa[i]++;\n      long long ans=0;\n      for(int i=1;i&lt;=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1;\n      printf(&quot;%d&quot;,ans);\n  }\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.2.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例6-1-ural1297：Palindrome-Vjudge\"><a href=\"#例6-1-ural1297：Palindrome-Vjudge\" class=\"headerlink\" title=\"例6         (1).ural1297：Palindrome(Vjudge)\"></a>例6         (1).<a href=\"https://vjudge.net/problem/URAL-1297\" target=\"_blank\" rel=\"external\">ural1297：Palindrome</a>(Vjudge)</h2><p>这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。</p>\n<pre><code>#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nconst int N = 1e4+1;\nint tong[N],wv[N],wa[N],wb[N];\nint rank1[N],height[N],sa[N];\nchar s[N];\nint a[N],n;\nint dp[N][30];\nint cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=a[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n        for(i=0;i&lt;m;i++)tong[i]=0;\n        for(i=0;i&lt;n;i++)tong[wv[i]]++;\n        for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n  return;\n}\n\nvoid calheight(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;i++)rank1[sa[i]]=i;\n    for(i=0;i&lt;n;height[rank1[i++]]=k)\n    for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++);\n    return;\n}\n\nvoid preRMQ()\n{\n    int i,j;\n    memset(dp,127,sizeof(dp));\n    for(i=1;i&lt;=n*2+1;i++)dp[i][0]=height[i];\n    for(j=1;(1&lt;&lt;j)&lt;=2*n+1;j++)\n    for(i=1;i+(1&lt;&lt;j)-1&lt;=2*n+1;i++)\n    dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);\n}\n\nint lcp(int l,int r)\n{\n    int a=rank1[l],b=rank1[r];\n    if(a&gt;b)\n        swap(a,b);\n    a++;\n    int t=(int)(log(double(b-a+1))/log(2.00));\n    return min(dp[a][t],dp[b-(1&lt;&lt;t)+1][t]);\n}\n\nint main()\n{\n    int i,res,flag,max;\n    while(scanf(&quot;%s&quot;,s)!=EOF)\n    {\n        max=0;\n        n=strlen(s);\n        for(i=0;i&lt;n;i++)a[i]=(int)s[i];\n        a[n]=1;\n        for(i=0;i&lt;n;i++)a[i+n+1]=int(s[n-i-1]);\n        a[2*n+1]=0;\n        da(2*n+2,123);\n        calheight(2*n+1);\n        preRMQ();\n        for(i=0;i&lt;n;i++)\n        {\n            res=lcp(i,2*n-i)*2-1;\n            if(max&lt;res)   max=res,flag=i;\n            if(i&gt;0)\n            {\n                res=lcp(i,2*n-i+1)*2;\n                if(max&lt;res) max=res,flag=i;\n            }\n        }\n        if(max%2==1)for(i=flag-max/2;i&lt;=flag+max/2;i++)   printf(&quot;%c&quot;,s[i]);\n        else    for(i=flag-max/2;i&lt;=flag+max/2-1;i++) printf(&quot;%c&quot;,s[i]);\n        printf(&quot;\\n&quot;);\n    }\n</code></pre><p>  }</p>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B6.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例7-1-cogs1710-Power-Strings-（poj2406）\"><a href=\"#例7-1-cogs1710-Power-Strings-（poj2406）\" class=\"headerlink\" title=\"例7           (1).cogs1710:Power Strings  （poj2406）\"></a>例7           (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1710\" target=\"_blank\" rel=\"external\">cogs1710:Power Strings</a>  （poj2406）</h2><p>本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。</p>\n<hr>\n<h2 id=\"例8-1-poj3693-Maximum-repetition-substring\"><a href=\"#例8-1-poj3693-Maximum-repetition-substring\" class=\"headerlink\" title=\"例8       (1).poj3693:Maximum repetition substring\"></a>例8       (1).<a href=\"http://poj.org/problem?id=3693\" target=\"_blank\" rel=\"external\">poj3693:Maximum repetition substring</a></h2><pre><code>  #include&lt;iostream&gt;\n  #include&lt;cstdio&gt;\n  #include&lt;cstring&gt;\n  using namespace std;\n  const int N = 1e5+1;\n  const int maxf = 255;\n  int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];\n  int k,now,jj,maxr,cnt;\n  int d[N][21],ans[N];\n  char s[N*2];\n  bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n\n  void da(int n,int m)\n  {\n      int i,j,p,*x=wa,*y=wb;\n      for(i=0;i&lt;m;++i)tong[i]=0;\n      for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n      for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n      for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n      for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n      {\n          for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n          for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n          for(i=0;i&lt;m;++i)tong[i]=0;\n          for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n          for(i=0;i&lt;n;++i)tong[wv[i]]++;\n          for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n          for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i)\n          x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n      }\n  }\n  void getheight(int n)\n  {\n      int i,j,k=0;\n      for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n      for(i=0;i&lt;n;h[rank[i++]]=k)\n      for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n  }\n  int prermq(int*a,int n)\n  {\n      for(int i=0;i&lt;n;++i)d[i][0]=a[i];\n      for(int j=1;(1&lt;&lt;j)&lt;=n;++j)\n      for(int i=0;i+(1&lt;&lt;j)-1&lt;n;++i)\n      d[i][j]=min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]);\n  }\n  int askrmq(int l,int r)\n  {\n      l=rank[l],r=rank[r];\n      if(l&gt;r)swap(l,r);\n      l++;\n      int k=0;\n      while((1&lt;&lt;(k+1))&lt;=r-l+1)k++;\n      return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]);\n  }\n  int main()\n  {\n      int ccase=0;\n      while(1)\n      {\n      memset(h,0,sizeof(h));\n      memset(d,0,sizeof(d));\n      memset(tong,0,sizeof(tong));\n      memset(rank,0,sizeof(rank));\n      memset(ans,0,sizeof(ans));\n      ccase++;\n\n      k=now=jj=maxr=cnt=0;\n      scanf(&quot;%s&quot;,s);\n      if(s[0]==&#39;#&#39;)return 0;\n      int n=strlen(s);\n      da(n+1,maxf);\n      getheight(n);\n      prermq(h,n+1);\n      for(int i=1;i&lt;n;++i) \n      for(int j=0;j+i&lt;n;j+=i) \n      {\n          k=askrmq(j,j+i);\n          now=k/i+1;\n          jj=j-(i-k%i);\n          if (jj&gt;=0&amp;&amp;askrmq(jj,jj+i)&gt;=(i-k%i))++now;\n          if(now&gt;maxr)    {cnt=0;maxr=now;ans[cnt++]=i;}\n          else if(now==maxr)  ans[cnt++]=i;\n      }\n          for(int i=1;i&lt;=n;++i) \n          for(int j=0;j&lt;cnt;++j)\n          if(askrmq(sa[i],sa[i]+ans[j])&gt;=(maxr-1)*ans[j])\n          {\n              jj=sa[i],k=ans[j];\n              goto dd;\n          }\n          dd:;\n          printf(&quot;Case %d: &quot;,ccase);\n          for (int i=0;i&lt;maxr*k;++i)putchar(s[jj++]);\n          printf(&quot;\\n&quot;);\n      }\n  }\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B8.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<h2 id=\"2-cogs1711-重复的字符串-（spoj687）\"><a href=\"#2-cogs1711-重复的字符串-（spoj687）\" class=\"headerlink\" title=\"(2).cogs1711:重复的字符串 （spoj687）\"></a>(2).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1711\" target=\"_blank\" rel=\"external\">cogs1711:重复的字符串</a> （spoj687）</h2><hr>\n<h2 id=\"例9-1-cogs1713-Long-Long-Message-（poj2774）\"><a href=\"#例9-1-cogs1713-Long-Long-Message-（poj2774）\" class=\"headerlink\" title=\"例9      (1).cogs1713:Long Long Message  （poj2774）\"></a>例9      (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1713\" target=\"_blank\" rel=\"external\">cogs1713:Long Long Message</a>  （poj2774）</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 3e5+1;\nconst int maxf = 255;\nconst int inf =0x7fffffff;\nint sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N];\nchar s[N],ss[N];\nbool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;m=p,j&lt;&lt;=1)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[wv[i]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n}\nvoid geth(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n}\nint main()\n{\n    freopen(&quot;longlongmessage.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;longlongmessage.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%s&quot;,s);\n    scanf(&quot;%s&quot;,ss);\n    int n=strlen(s),m=strlen(ss);\n    s[n]=&#39;*&#39;;\n    for(int i=n+1;i&lt;=n+m;++i)s[i]=ss[i-n-1];\n    int l=n+m+1;\n    da(l+1,maxf);\n    geth(l);\n    int maxx=0;\n    for(int i=2;i&lt;=l;++i)\n    {\n        if(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i-1]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i-1]&lt;n)))\n        maxx=h[i];\n    }\n    cout&lt;&lt;maxx;\n}\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B9.tag.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例10-1-cogs1712-Common-Substrings-（poj3415）\"><a href=\"#例10-1-cogs1712-Common-Substrings-（poj3415）\" class=\"headerlink\" title=\"例10    (1).cogs1712:Common Substrings  （poj3415）\"></a>例10    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1712\" target=\"_blank\" rel=\"external\">cogs1712:Common Substrings</a>  （poj3415）</h2><hr>\n<h2 id=\"例11-1-cogs2128-生命形态-（poj3294）\"><a href=\"#例11-1-cogs2128-生命形态-（poj3294）\" class=\"headerlink\" title=\"例11    (1).cogs2128:生命形态   （poj3294）\"></a>例11    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=2128\" target=\"_blank\" rel=\"external\">cogs2128:生命形态</a>   （poj3294）</h2><p>例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N = 2e5+1;\nconst int inf =0x7fffffff;\nconst int maxf = 255;\nbool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nint sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];\nchar ss[111][10001],s[N];\nint nn[111],tt;\nbool inq[111];\nint ll[N];\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(i=1,p=1,swap(x,y),x[sa[0]]=0;i&lt;n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n}\nvoid geth(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;h[rank[i++]]=k)\n    for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++);\n}\nint k;\nint ansg;\nbool can(int ans,int n,int flag)\n{\n    if(!flag)\n    {\n        int tot1=0;\n        memset(inq,0,sizeof(inq));\n        for(int i=1;i&lt;=n;++i)\n        {\n            if(h[i]&lt;ans)\n            {\n                memset(inq,0,sizeof(inq));  tot1=0;\n            }\n            else\n            {\n                int nowq,nowt;\n                for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t;\n                for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;\n                if(!inq[nowq])tot1++,inq[nowq]=true;\n                if(!inq[nowt])tot1++,inq[nowt]=true;\n                if(tot1&gt;=k)return 1;\n            }\n        }\n        return 0;\n    }\n    if(flag)\n    {\n      int lll=inf,rrr=-1;\n      int tot1=0;\n      memset(inq,0,sizeof(inq));\n      for(int i=1;i&lt;=n;++i)\n      {\n          if(h[i]&lt;ans)\n          {\n              memset(inq,0,sizeof(inq));  tot1=0;\n              lll=inf;rrr=-1;\n          }\n          else\n          {\n              int nowq,nowt;\n              if(sa[i-1]&lt;lll)lll=sa[i-1];if(sa[i-1]&gt;rrr)rrr=sa[i-1];\n              if(sa[i]&lt;lll)lll=sa[i];if(sa[i]&gt;rrr)rrr=sa[i];\n              for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t;\n              for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;\n              if(!inq[nowq])tot1++,inq[nowq]=true;\n              if(!inq[nowt])tot1++,inq[nowt]=true;\n              if(tot1==k)ll[++ansg]=lll;\n          }\n      }\n  }\n}\n  int main()\n  {\n  //  freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin);\n  //  freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout);\n      while(scanf(&quot;%d&quot;,&amp;tt)!=EOF)\n      {\n          if(!tt)return 0;\n          memset(wa,0,sizeof(wa));\n          memset(wb,0,sizeof(wb));\n          memset(wv,0,sizeof(wv));\n          memset(rank,0,sizeof(rank));\n          memset(sa,0,sizeof(sa));\n          memset(h,0,sizeof(h));\n          memset(nn,0,sizeof(nn));\n          memset(s,0,sizeof(s));\n          int tot=0;\n          int tmp=2;\n          ansg=0;\n          for(int i=1;i&lt;=tt;++i)\n          {\n              scanf(&quot;%s&quot;,ss[i]);\n              nn[i]=strlen(ss[i]);\n              nn[0]=-1;\n              for(int t=0;t&lt;nn[i];++t)s[tot++]=ss[i][t];\n              nn[i]+=nn[i-1]+(i==tt?0:1);\n              if(i!=tt)s[tot++]=tmp++;\n          }\n          nn[tt]++;\n          int n=strlen(s);\n          da(n+1,maxf);\n          geth(n);\n          k=(tt)/2+1;\n          int l=0,r=n+1,mid;\n          while(l!=r)\n          {\n              mid=(l+r+1)&gt;&gt;1;\n              if(can(mid,n,0))  l=mid;\n              else      r=mid-1;\n          }\n          if(l==0){printf(&quot;?&quot;);goto dd;}\n          can(l,n,1);\n          for(int i=1;i&lt;=ansg;++i)\n          {\n              if(i!=1)\n              {\n              bool flag=0;\n              for(int t=0;t&lt;l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;}\n              if(!flag)continue;\n              }\n              for(int t=ll[i];t&lt;=ll[i]+l-1;++t)putchar(s[t]);\n              printf(&quot;\\n&quot;);\n          }\n          dd:;\n      }\n  }\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B11.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例12-1-cogs2120-破译进攻计划-（spoj220）\"><a href=\"#例12-1-cogs2120-破译进攻计划-（spoj220）\" class=\"headerlink\" title=\"例12    (1).cogs2120:破译进攻计划   （spoj220）\"></a>例12    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=2120\" target=\"_blank\" rel=\"external\">cogs2120:破译进攻计划</a>   （spoj220）</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nconst int N = 2e5+500;\nconst int maxf = 255;\nint sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];\nchar s[N],ss[13][15031];\nint inq[13],maxq[13],minq[13];\nint tt,num;\nbool use[13];\nbool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),x[sa[0]]=0,i=1,p=1;i&lt;n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n}\nvoid geth(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n}\nbool can(int ans,int n)\n{\n    int tot=0;\n    for(int i=1;i&lt;=n;++i)\n    {\n        if(h[i]&lt;ans)\n        {\n            tot=0;\n            memset(inq,0,sizeof(inq));\n            memset(maxq,0,sizeof(maxq));\n            memset(minq,0x3f,sizeof(minq));\n            memset(use,0,sizeof(use));\n        }\n        else\n        {\n            for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t])\n            {\n                inq[t]++;\n                minq[t]=min(minq[t],sa[i]);\n                maxq[t]=max(maxq[t],sa[i]);\n                if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true;\n                if(tot==num)return 1;\n            }\n            for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])\n            {\n                inq[t]++;\n                minq[t]=min(minq[t],sa[i-1]);\n                maxq[t]=max(maxq[t],sa[i-1]);\n                if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true;\n                if(tot==num)return 1;\n            }\n        } \n    }\n    return 0;\n}\nint main()\n{\n//  freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin);\n//  freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout);\n    nn[0]=-1;\n    scanf(&quot;%d&quot;,&amp;tt);\n    while(tt--)\n    {\n        memset(inq,0,sizeof(inq));\n        memset(wa,0,sizeof(wa));\n        memset(wb,0,sizeof(wb));\n        memset(wv,0,sizeof(wv));\n        memset(sa,0,sizeof(sa));\n        memset(rank,0,sizeof(rank));\n        memset(h,0,sizeof(h));\n        scanf(&quot;%d&quot;,&amp;num);\n        int tot=0,qiguaizifu=2;\n        for(int i=1;i&lt;=num;++i)\n        {\n            scanf(&quot;%s&quot;,ss[i]);\n            nn[i]=strlen(ss[i]);\n        }\n        for(int i=1;i&lt;=num;++i)\n        {\n            for(int t=0;t&lt;nn[i];++t)\n            s[tot++]=ss[i][t];\n            s[tot++]=qiguaizifu++;\n        }\n        for(int i=1;i&lt;=num;++i)nn[i]+=(nn[i-1]+1);\n        int n=strlen(s);\n        da(n+1,maxf);\n        geth(n);\n        int l=0,r=(n+1)/2;\n        while(l!=r)\n        {\n            int mid=l+r+1&gt;&gt;1;\n            if(can(mid,n))  l=mid;\n            else      r=mid-1;\n        }\n        printf(&quot;%d\\n&quot;,l);\n    }\n}\n</code></pre><p><a href=\"https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B12.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例13-1-poj1226-Substrings\"><a href=\"#例13-1-poj1226-Substrings\" class=\"headerlink\" title=\"例13    (1).poj1226:Substrings\"></a>例13    (1).<a href=\"http://poj.org/problem?id=1226\" target=\"_blank\" rel=\"external\">poj1226:Substrings</a></h2><hr>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/08/后缀数组13题/","excerpt":"论文后缀数组——处理字符串的有力工具–罗穗骞","categories":[{"name":"Hollerith-type","slug":"Hollerith-type","permalink":"https://prostkhala.github.io/categories/Hollerith-type/"}],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"https://prostkhala.github.io/tags/后缀数组/"},{"name":"字符串问题","slug":"字符串问题","permalink":"https://prostkhala.github.io/tags/字符串问题/"}]},{"title":"C/C++代码规范","date":"2017-03-07T09:53:42.000Z","path":"2017/03/07/c++代码规范/","text":"命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C+ 命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C++ 12 静态变量的命名前缀 适用于C 13 自定义类型typedef的命名 适用于C++ 14 宏定义的命名 适用于C++ 15 C 函数的命名 适用于C++ 16 枚举的命名 适用于C++ 排版规则 1 布局和模板 11 类的布局模板 适用于C 12 源文件格式 适用于C 13 保护头文件不被重复包含 适用于C++ 14 方法和函数的布局 适用于C++ 2 缩进制表符以及空格 适用于C++ 3 尽量使一行不要超过78个字母 适用于C++ 4 保证一行只写一条语句 适用于C++ 5 花括号 规则 适用于C++ 51 花括号的位置 52 什么时候应使用花括号 53 在花括号结束的位置加上注释 54 注意屏幕大小 6圆括号 规则 适用于C++ 7if else 语句的格式 适用于C++ 8switch 格式 适用于C++ 9 使用gotocontinuebreak 和 适用于C++ 91 Goto 92 Continue and Break 93 10 运算符号的规则 适用于C++ 11 变量声明语句块 适用于C++ 文档及注释 1 文件或程序库的文档注释 适用于C++ 2 类文档注释 适用于C++ 3 函数文档注释 适用于C++ 4 Include 语句注释 适用于C++ 5语句块注释 适用于C++ 编码要求 1 不要忽略编译器的警告 适用于C++ 2 应使用源代码管理器 适用于C++ 3 固有的类方法成员 适用于C 4 使用命名空间 适用于C 5 初始化所有的变量 适用于C++ 6 保持函数短小精悍 适用于C++ 7对空语句进行注释 适用于C++ 8不要用if语句的默认方法测试非零值 适用于C++ 9布尔类型 适用于C++ 10避免在语句中内含赋值 适用于C++ 11正确的使用Const 适用于C++ 12不要在头文件定义数据适用于C++ 13不要直接使用数字 适用于C++ 14宏 适用于C++ 1. 命名规则1.1. 起个合适的名字1.1.1. 类的名称（适用于C++）² 类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。 ² 类的名字不需要告诉我们，它从哪个类继承而来的。 ² 有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。 1.1.2. 方法和函数的名称（适用于C/C++）² 方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。 ² 函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。 ² 可以加一些必要的后缀： Max – 表示取最大值 Cnt – 表示当前的计数值 Key – 表示键值 例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。 ² 前缀也同样有用： Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。 Get – 用于获取一个值。 Set – 用于设置一个值。 例如：IsHitRetryLimit. 1.1.3. 含有度量单位的名称（适用于C/C++）² 如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。 例如： uint32 mTimeoutMsecs; uint32 mMyWeightLbs; 1.1.4. 缩写名称不要全部大写（适用于C/C++）² 无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。 例如： class FluidOz; // 而不是 FluidOZ class NetworkAbcKey; // 而不是 NetworkABCKey 1.2.类的命名（适用于C++）² 用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。 ² 名字的第一个字母应大写 ² 不含有下划线 (‘_’) 例如： class NameOneTwo; class Name; 1.3.类库（或程序库）命名 （适用于C/C++）² 使用命名空间防止名字冲突。 ² 如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。 例如： John Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样： class JjLinkList { } 1.4.方法和函数的命名（适用于C++）² 使用与类名相同的规则 例如： class NameOneTwo { public: int DoIt(); void HandleError(); } 1.5.类属性的命名（适用于C++）² 属性（通常是非公有数据成员）名字以字母’m’开头。 ² 在 ‘m(m_)’ 后面，使用与类名相同的规则。 ² ‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。 例如： class NameOneTwo { public: int VarAbc(); int ErrorNumber(); private: int mVarAbc; int mErrorNumber; String* mpName; } 1.6.方法和函数参数的命名（适用于C++）² 第一个字母必须小写。 ² 第一个字母后面的单词使用与类名相同的规则。 例如： class NameOneTwo { public: int StartYourEngines( Engine&amp;rSomeEngine, Engine&amp;rAnotherEngine); } 1.7.局部变量的命名（适用于C/C++）² 所有字母都用小写 ² 使用下划线 ‘_’ 作为单词的分隔。 例如： int NameOneTwo::HandleError(int errorNumber) { int error= OsErr(); Time time_of_error; ErrorProcessor error_processor; } 1.8.指针变量的命名前缀（适用于C/C++）² 指针变量多数情况应在前面加 ‘p’。 ² 星号 ‘*’ 应靠近类型，而不是变量名。 例如： String* pName=new String; 特别的：String* pName, name; 应分成两行来写： String* pName; String name; 1.9.引用变量和返回引用函数的命名前缀（适用于C++）² 引用必须用 ‘r’作前缀修饰。 例如： class Test { public: void DoSomething(StatusInfo&amp;rStatus); StatusInfo&amp; rStatus(); constStatusInfo&amp; Status() const; // 这里返回的是常量引用，所以不符合本规则 private: StatusInfo&amp; mrStatus; } 1.10. 全局变量的命名前缀（适用于C/C++）² 全局变量总是以 ‘g(g_)’ 作为前缀。 例如： Logger g_Log; Logger* g_pLog; 1.11. 全局常量的命名（适用于C/C++）² 全局常量全部大写，并以下划线 ‘_’ 分隔单词。 例如： const intA_GLOBAL_CONSTANT = 5; 1.12. 静态变量的命名前缀（适用于C++）² 静态变量以 ‘s’ 作为前缀。 例如： class Test { public: private: staticStatusInfo m_sStatus; } 1.13. 自定义类型（typedef）的命名（适用于C/C++）² 类型定义名称指的是用typedef定义的名称。 ² 类型定义名称使用与类名相同的规则，并使用Type作为后缀。 例如： typedefuint16 ModuleType; typedefuint32 SystemType; 1.14. 宏定义的命名（适用于C/C++）² 所有单词的字母都用大写，并使用下划线 ‘_’ 分隔. 例如： #define MAX(a,b) blah #define IS_ERR(err) blah 1.15. C 函数的命名（适用于C/C++）² C++项目中，应尽量少用C函数。 ² C函数使用GNU规范，所有字母都使用小写，并用下划线 ‘_’ 作为单词的分隔。 例如： int some_bloody_function() { } ² 特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数： extern “C” int some_bloody_function(); ² 或在C/C++中推荐使用下面的格式： #ifdef__cplusplus__ extern “C”{ #endif int some_bloody_function() { } #ifdef__cplusplus__ } #endif 1.16. 枚举的命名（适用于C/C++）² 所有字母都大写，并用下划线 ‘_’ 作为单词分隔。 例如： enumPinStateType { PIN_OFF, PIN_ON }; enum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING}; 2. 排版规则2.1. 布局和模板2.1.1. 类的布局模板 （适用于C++）² 请使用下面的模板来创建一个新的类： /** * 用一行来描述类 * *#include &quot;XX.h&quot; &lt;BR&gt; *-llib * * 类的详细说明 * * @seesomething */ #ifndef SORUTION_PROJECT_CLASSNAME_H #define SORUTION_PROJECT_CLASSNAME_H // 在这里包含系统头文件 // // 在这里包含项目头文件 // // 在这里包含局部头文件 // // 在这里放置前置引用 // class XX { public: // 类的生命周期控制函数，如构造和析构，以及状态机 /** *Default constructor. */ XX(void); /** *Copy constructor. * *@param from The value to copy to this object. */ XX(const XX&amp; from); /** *Destructor. */ virtual ~XX(void); // 在这里放置类的运算操作符 /** *Assignment operator. * *@param from THe value to assign to this object. * *@return A reference to this object. */ XX&amp; operator=(XX&amp;from); // 在这里放置类的操作 // 在这里放置属性存取 // 在这里放置类的状态查询 protected: private: }; // 内联方法定义 // // 外部引用 // #endif // SORUTION_PROJECT_CLASSNAME_H ² 定义的顺序是: public, protected, private ² 要清楚public/protected/private都应该放置哪些东西 2.1.2. 源文件格式（适用于C++） #include &quot;XX.h&quot; // class implemented /////////////// PUBLIC/////////////////////// //================= 构造函数 ==================== XX::XX() { }// XX XX::XX(const XX&amp;) { }// XX XX::~XX() { }// ~XX //=============== 操作符========================= XX&amp; XX::operator=(XX&amp;); { return *this; }// = //==============类的操作 ===================== //==============属性存取 ===================== //==============状态查询 ===================== ///////////// PROTECTED ////////////////// ///////////// PRIVATE ////////////////// 2.1.3. 保护头文件不被重复包含 （适用于C/C++）² 应使用宏定义来保护头文件不被重复包含： #ifndef SORUTION_PROJECT_CLASSNAME_H #define SORUTION_PROJECT_CLASSNAME_H #endif // SORUTION_PROJECT_CLASSNAME_H ² 如果使用命名空间的时候，要把命名空间加到文件名前面： #ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H #define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H #endif 2.1.4. 方法和函数的布局 （适用于C/C++）² 对于有较多参数的函数的写法 如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐： int AnyMethod( int arg1, int arg2, int arg3, int arg4); 或 int AnyMethod( int arg1 , int arg2 , int arg3 , int arg4); 2.2. 缩进、制表符以及空格 （适用于C/C++）² 缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格） ² 不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。 ² 虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。 例如： void func() { if (something bad) { if (another thing bad) { while (more input) { } } } } 2.3. 尽量使一行不要超过78个字母 （适用于C/C++）² 有许多编辑器屏幕只有78个字母宽 2.4. 保证一行只写一条语句 （适用于C/C++）² 一行最多只写一条语句 ² 一行只定义一个变量 例如： 不要象下面这样: char** a, *x; int width, height; //widthand height of image 要象这样: char** a= 0; // 文档说明 char* x= 0; // 文档说明 2.5. 花括号 {} 规则 （适用于C/C++） 2.5.1. 花括号的位置 ² 在关键字的下一行单独放置括号，并且与关键字对齐，如： if (condition) { ... } while (condition) { … } 2.5.2. 什么时候应使用花括号所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。 ² 使用花括号格式： if (1 == somevalue) { somevalue = 2; } ² 单行格式： if (1 == somevalue) somevalue = 2; 或下面这样（对于这种写法，建议使用花括号）： if (1 == somevalue) { somevalue = 2; } 2.5.3. 在花括号结束的位置加上注释² 在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如： while(1) { if (valid) { } // if valid else { } // not valid } // end forever 2.5.4. 注意屏幕大小² 一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。 2.6.圆括号 () 规则 （适用于C/C++）² 圆括号与关键字之间应放一个空格。 ² 圆括号与函数名之间不要有空格。 ² Return 语句不要使用圆括号。 例如： if (condition) { } while(condition) { } strcpy(s, s1); return 1; 2.7.if else 语句的格式 （适用于C/C++）² 布局 if (条件) // 注释 { } else if (条件) // 注释 { } else // 注释 { } ² 条件格式 总是把常量放在等号或不等于号的左边： if ( 6 == errorNum ) ... 一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。 比如： if ( errorNum == 6) ... 错写成： if ( errorNum = 6) ... // 这是一个不容易发现的灾难 2.8.switch 格式 （适用于C/C++）² 直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。 ² 总是要写default语句，不管是否是需要。 ² 在case中需要定义变量的时候，应把所有代码放在语句块中。 例如： switch (...) { case 1: ... // 继续执行case2 case 2: { int v; ... } break; default: } 2.9. 使用goto,continue,break 和 ?: （适用于C/C++）2.9.1. Goto² 尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如： for (...) { while (...) { ... if (disaster) goto error; //跳出循环 } } ... error: clean up the mess ² 跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。 2.9.2. Continue and Break² Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。 2.9.3. ?:² 用括号把条件表达式括起来。 ² 不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。 ² 操作语句应分行写，除非它们能够简洁的放在一行当中。 例如： (condition) ?funct1() : func2(); 或 (condition) ? longstatement : anotherlong statement; 2.10. 运算符号的规则 （适用于C/C++）² 一元操作符如（!、~ 等等）应贴近操作对象。如： if (!IsOk) return ++v; ² 二元操作符如（+、*、%、== 等等）应在前后留空格。如： if ( v1 == v2) return v1 * 3; ² ++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。如： for(int i = 0; i &lt; 10; ++i) 2.11. 变量声明语句块 （适用于C/C++）² 变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。如： for(int i = 0; i &lt; 10; ++i) ² 声明语句块必须要对齐 类型，变量，等号和初始化值要分别对齐。 例如： DWORD mDword; DWORD* mpDword; char* mpChar; char mChar; mDword = 0; mpDword = NULL; mpChar = NULL; mChar = 0; 3. 文档及注释应当使用文档自动生成工具，来生成相关的程序文档。 3.1. 文件或程序库的文档注释（适用于C/C++）可以为整个文件编写文档。 例如： /** @file file.h * Abrief file description. * Amore elaborated file description. */ 3.2. 类文档注释（适用于C/C++）在类定义前面应加上类说明文档。 例如： /** WindowsNT * @brief Windows Nice Try. * @author Bill Gates * @author Several species of small furryanimals gathered together * in a cave and grooving with a pict. * @version 4.0 * @date 1996-1998 * @bug It crashes a lot and requires hugeamounts of memory. * @bug The class introduces the more bugs, thelonger it is used. * @warning This class may explode in your face. * @warning If you inherit anything from thisclass, you&#39;re doomed. */ class WindowsNT {}; 3.3. 函数文档注释（适用于C/C++）² 函数注释 所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如： /** * 赋值操作符 * *@param val 将要赋给本对象的值 * *@return 本对象的引用 */ XX&amp; operator =(XX&amp; val); ² 注释属性 一些自动文档工具定义的属性可以包含在文档中，常用的有： n 前提条件 (pre)定义调用这个函数的前提条件 n 警告说明 (warning)定义一些关于这个函数必须知道的事情。 n 备注说明 (remarks)定义一些关于这个函数的备注信息。 n 将要完成的工作 (todo)说明哪些事情将在不久以后完成 n 使用例子说明 (example)一个图片能表达100句话，一个好的例子能解答1000个问题。 例如： /** * 复制一个字串 * *@pre * - 需要保证(from != 0) * - 需要保证(to != 0) * *@warning * 缓冲区必需足够大，以便容纳的下要拷贝的字串。 * *@example teststrcpy.cpp * *@param from 要拷贝的字串 *@param to 用于容纳字串的缓冲区 *@return void */ void strcpy(constchar* from, char* to); 3.4. Include 语句注释 （适用于C/C++）² 如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。 3.5.语句块注释（适用于C/C++）² 语句块的注释可以用在语句块的开头和结束位置： { // Block1 (meaningful comment about Block1) ... some code { // Block2 (meaningful comment about Block2) ... somecode } // End Block2 } // End Block1 4. 编码要求4.1. 不要忽略编译器的警告（适用于C/C++）² 编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。 4.2. 应使用源代码管理器（适用于C/C++）² 根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。 4.3. 固有的类方法成员（适用于C++）² 默认构造函数(DefaultConstructor) 如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。 ² 虚析构函数(Virtual Destructor) 如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。 ² 拷贝构造函数(Copy Constructor) 如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。 ² 赋值操作(AssignmentOperator) 如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。 4.4. 使用命名空间 （适用于C++）² 命名规则 根名字一般是设计者的名字。比如公司名称等等。 ² 不要在全局空间使用using语句。 4.5. 初始化所有的变量 （适用于C/C++）² 无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。 4.6. 保持函数短小精悍（适用于C/C++）² 一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。 4.7.对空语句进行注释 （适用于C/C++）² For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如： while(*dest++ = *srC++) ; // VOID ² 不允许写成： while (*dest++ = *srC++) ; // 绝对不允许这么写 4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）² If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如： 建议使用： if (FAIL != f()) 不建议使用下面的表达式： if (f()) ² 宏定义的情况也一样： #define STREQ(a,b) (strcmp((a), (b)) == 0) 或者使用内联函数： inline bool StringEqual(char* a, char* b) { (strcmp(a, b)== 0) ? return true : return false; Or more compactly: returnstrcmp(a, b) == 0; } 4.9.布尔类型 （适用于C/C++）² 早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。 早期的布尔类型定义为： typedef int bool; #defineTRUE 1 #defineFALSE 0 或： const intTRUE = 1; const int FALSE= 0; ² 在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如： if (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？ 必须写成： if (FALSE !=func()) { ... 4.10. 避免在语句中内含赋值 （适用于C/C++）² 只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如： while (EOF != (c= getchar())) { process thecharacter } ² ++ 和 – 操作也是一种赋值语句 ² 内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如： a = b + c; d = a + r; 不应该写成： d = (a = b + c)+ r; 4.11. 正确的使用Const （适用于C/C++）² C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。 4.12. 不要在头文件定义数据（适用于C/C++）不要把数据定义放在头文件，如： /* * aheader.h */ int x = 0; 4.13. 不要直接使用数字 （适用于C/C++）² 直接使用数字，会使源代码难以理解和维护。如： if (22 ==foo) { start_thermo_nuclear_war(); } else if (19 == foo) {refund_lotso_money(); } else if (16 == foo) {infinite_loop(); } else { cry_cause_im_lost(); } 当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。 ² 我们可以用#define或者常量来改变这一状况，如： #define PRESIDENT_WENT_CRAZY (22) const int WE_GOOFED= 19; enum { THEY_DIDNT_PAY=16 }; if (PRESIDENT_WENT_CRAZY == foo) { start_thermo_nuclear_war(); } else if (WE_GOOFED == foo) {refund_lotso_money(); } else if (THEY_DIDNT_PAY == foo) { infinite_loop();} else {happy_days_i_know_why_im_here(); } 4.14. 宏（适用于C/C++）² 如果可以，使用内联函数代替宏。 例如： #ifndef MAX #define MAX(x,y) (((x) &gt; (y) ? (x) : (y)) // 取最大数 #endif 使用内联函数可以达到相同的效果，而且更安全： inline int max(int x, inty) { return (x&gt; y ? x : y); } ² 要注意副作用 必须小心副作用，因为在调用表达式时，会发生潜在的错误。 例如： MAX(f(x),z++); ² 表达式总是用括号括起来 在宏展开时，使用括号可以避免宏展开后产生的二义性。 例如： #define ADD(x,y) x + y 必须写成： #define ADD(x,y) ((x) + (y)) ² 保证宏名称的唯一性 和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题： n 在宏名称前加上库的名字避免使用简单而常用的名字，如：MAX 和MIN。","raw":"title: C/C++代码规范\ndate: 2017-03-07 17:53:42\ncategories:\n  - 代码规范\ntags:\n  - 代码规范\n---\n\n        命名规则\n        1 起个合适的名字\n            11    类的名称 适用于C\n            12    方法和函数的名称 适用于C++\n            13   含有度量单位的名称 适用于C++\n            14    缩写名称不要全部大写 适用于C++\n        2类的命名 适用于C\n        3类库或程序库命名 适用于C++\n        4方法和函数的命名 适用于C\n        5类属性的命名 适用于C\n        6方法和函数参数的命名 适用于C\n        7局部变量的命名 适用于C++\n        8指针变量的命名前缀 适用于C++\n        9引用变量和返回引用函数的命名前缀 适用于C\n        10   全局变量的命名前缀 适用于C++\n        11   全局常量的命名 适用于C+\n        命名规则\n        1 起个合适的名字\n            11    类的名称 适用于C\n            12    方法和函数的名称 适用于C++\n            13   含有度量单位的名称 适用于C++\n            14    缩写名称不要全部大写 适用于C++\n        2类的命名 适用于C\n        3类库或程序库命名 适用于C++\n        4方法和函数的命名 适用于C\n        5类属性的命名 适用于C\n        6方法和函数参数的命名 适用于C\n        7局部变量的命名 适用于C++\n        8指针变量的命名前缀 适用于C++\n        9引用变量和返回引用函数的命名前缀 适用于C\n        10   全局变量的命名前缀 适用于C++\n        11   全局常量的命名 适用于C++\n        12   静态变量的命名前缀 适用于C\n        13   自定义类型typedef的命名 适用于C++\n        14   宏定义的命名 适用于C++\n        15   C 函数的命名 适用于C++\n        16   枚举的命名 适用于C++\n        排版规则\n        1 布局和模板\n            11    类的布局模板 适用于C\n            12   源文件格式 适用于C\n            13    保护头文件不被重复包含 适用于C++\n            14    方法和函数的布局 适用于C++\n        2 缩进制表符以及空格 适用于C++\n        3 尽量使一行不要超过78个字母 适用于C++\n        4 保证一行只写一条语句 适用于C++\n        5 花括号 规则 适用于C++\n            51    花括号的位置\n            52    什么时候应使用花括号\n            53    在花括号结束的位置加上注释\n            54    注意屏幕大小 \n        6圆括号 规则 适用于C++\n        7if else 语句的格式 适用于C++\n        8switch 格式 适用于C++\n        9 使用gotocontinuebreak 和 适用于C++\n            91    Goto\n            92    Continue and Break\n            93    \n        10   运算符号的规则 适用于C++\n        11    变量声明语句块 适用于C++\n        文档及注释\n        1 文件或程序库的文档注释 适用于C++\n        2 类文档注释 适用于C++\n        3 函数文档注释 适用于C++\n        4 Include 语句注释 适用于C++\n        5语句块注释 适用于C++\n        编码要求\n        1 不要忽略编译器的警告 适用于C++\n        2 应使用源代码管理器 适用于C++\n        3 固有的类方法成员 适用于C\n        4 使用命名空间 适用于C\n        5 初始化所有的变量 适用于C++\n        6 保持函数短小精悍 适用于C++\n        7对空语句进行注释 适用于C++\n        8不要用if语句的默认方法测试非零值 适用于C++\n        9布尔类型 适用于C++\n        10避免在语句中内含赋值 适用于C++\n        11正确的使用Const 适用于C++\n        12不要在头文件定义数据适用于C++\n        13不要直接使用数字 适用于C++\n        14宏 适用于C++\n        \n <!--more--> \n \n# 1.    命名规则\n## 1.1. 起个合适的名字\n### 1.1.1.    类的名称（适用于C++）\n\n²  类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。\n\n²  类的名字不需要告诉我们，它从哪个类继承而来的。\n\n²  有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。\n### 1.1.2.    方法和函数的名称（适用于C/C++）\n\n²  方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。\n\n²  函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。\n\n²  可以加一些必要的后缀：\n\nMax – 表示取最大值\n\nCnt – 表示当前的计数值\n\nKey – 表示键值\n\n例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。\n\n²  前缀也同样有用：\n\nIs – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。\n\nGet – 用于获取一个值。\n\nSet – 用于设置一个值。\n\n例如：IsHitRetryLimit.\n### 1.1.3.   含有度量单位的名称（适用于C/C++）\n\n²  如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。\n\n例如：\n\n\tuint32 mTimeoutMsecs;\n\n\tuint32 mMyWeightLbs;\n### 1.1.4.    缩写名称不要全部大写（适用于C/C++）\n\n²  无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。\n\n例如：\n\n\tclass FluidOz;            // 而不是 FluidOZ\n\n\tclass NetworkAbcKey;      // 而不是 NetworkABCKey\n## 1.2.类的命名（适用于C++）\n\n²  用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。\n\n²  名字的第一个字母应大写\n\n²  不含有下划线 ('_')\n\n例如：\n\n   \tclass NameOneTwo; \n\n   \tclass Name;\n## 1.3.类库（或程序库）命名 （适用于C/C++）\n\n²  使用命名空间防止名字冲突。\n\n²  如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。\n\n例如：\n\nJohn Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样：\n\n   \tclass JjLinkList\n\n   \t{\n\n   \t}\n## 1.4.方法和函数的命名（适用于C++）\n\n²  使用与类名相同的规则\n\n例如：\n\n   \tclass NameOneTwo\n\n   \t{\n\n   \t\tpublic:\n\n      int     DoIt();\n\n      void    HandleError();\n\n   \t}\n   \n## 1.5.类属性的命名（适用于C++）\n\n²  属性（通常是非公有数据成员）名字以字母'm'开头。\n\n²  在 'm(m_)'  后面，使用与类名相同的规则。\n\n²  'm(m_)' 总是位于其它修饰符（如表示指针的 'p'）的前面。\n\n例如：\n\n       class NameOneTwo\n\n       {\n\n       public:\n\n          int     VarAbc();\n\n          int     ErrorNumber();\n\n       private:\n\n          int          mVarAbc;\n\n          int          mErrorNumber;\n\n          String*      mpName;\n\n       }\n## 1.6.方法和函数参数的命名（适用于C++）\n\n²  第一个字母必须小写。\n\n²  第一个字母后面的单词使用与类名相同的规则。\n\n例如：\n\n       class NameOneTwo\n\n       {\n\n       public:\n\n      int     StartYourEngines(\n\n                               Engine&rSomeEngine,\n\n                              Engine&rAnotherEngine);\n\n   \t}\n## 1.7.局部变量的命名（适用于C/C++）\n\n²  所有字母都用小写\n\n²  使用下划线 '_' 作为单词的分隔。\n\n例如：\n\n       int\n\n      NameOneTwo::HandleError(int errorNumber)\n\n       {\n\n      int            error= OsErr();\n\n      Time           time_of_error;\n\n     ErrorProcessor error_processor;\n\n   }\n## 1.8.指针变量的命名前缀（适用于C/C++）\n\n²  指针变量多数情况应在前面加 'p'。\n\n²  星号 '*' 应靠近类型，而不是变量名。\n\n例如：\n\n  \tString* pName=new String;\n\n \n\n  特别的：String* pName, name; 应分成两行来写：\n\n  \tString* pName;\n\n  \tString  name;\n## 1.9.引用变量和返回引用函数的命名前缀（适用于C++）\n\n²  引用必须用 'r'作前缀修饰。\n\n例如：\n\n   \tclass Test\n\n   \t{\n\n   \tpublic:\n\n      void               DoSomething(StatusInfo&rStatus);\n\n \n\n     StatusInfo&        rStatus();\n\n      constStatusInfo&  Status() const; // 这里返回的是常量引用，所以不符合本规则\n\n \n\n   \tprivate:\n\n     \tStatusInfo&        mrStatus;\n\n   \t}\n## 1.10.   全局变量的命名前缀（适用于C/C++）\n\n²  全局变量总是以 'g(g_)' 作为前缀。\n\n例如：\n\n    Logger g_Log;\n\n    Logger* g_pLog;\n## 1.11.   全局常量的命名（适用于C/C++）\n\n²  全局常量全部大写，并以下划线 '_' 分隔单词。\n\n例如：\n\n    const intA_GLOBAL_CONSTANT = 5;\n## 1.12.   静态变量的命名前缀（适用于C++）\n\n²  静态变量以 's' 作为前缀。\n\n例如：\n\n       class Test\n\n       {\n\n       public:\n\n       private:\n\n          staticStatusInfo m_sStatus;\n\n       }\n## 1.13.   自定义类型（typedef）的命名（适用于C/C++）\n\n²  类型定义名称指的是用typedef定义的名称。\n\n²  类型定义名称使用与类名相同的规则，并使用Type作为后缀。\n\n例如：\n\n       typedefuint16  ModuleType;\n\n       typedefuint32  SystemType;\n## 1.14.   宏定义的命名（适用于C/C++）\n\n²  所有单词的字母都用大写，并使用下划线 '_' 分隔.\n\n例如：\n\n\t#define MAX(a,b) blah\n\n\t#define IS_ERR(err) blah\n## 1.15.   C 函数的命名（适用于C/C++）\n\n²  C++项目中，应尽量少用C函数。\n\n²  C函数使用GNU规范，所有字母都使用小写，并用下划线 '_' 作为单词的分隔。\n\n例如：\n\n   \tint\n\n  \tsome_bloody_function()\n\n   \t{\n\n   \t}\n\n²  特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：\n\n       extern “C” int some_bloody_function();\n\n²  或在C/C++中推荐使用下面的格式：\n\n       #ifdef__cplusplus__\n\n       extern “C”{\n\n       #endif\n\n       int\n\n      some_bloody_function()\n\n       {\n\n       }\n\n       #ifdef__cplusplus__\n\n       }\n\n       #endif\n## 1.16.   枚举的命名（适用于C/C++）\n\n²  所有字母都大写，并用下划线 '_' 作为单词分隔。\n\n例如：\n\n   \tenumPinStateType\n\n   \t{\n\n      \tPIN_OFF,\n\n      \tPIN_ON\n\n   \t};\n\n\tenum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING};\n# 2.    排版规则\n## 2.1. 布局和模板\n### 2.1.1.    类的布局模板 （适用于C++）\n\n²  请使用下面的模板来创建一个新的类：\n\n\t/**     \n\n \t* 用一行来描述类\n\n \t*\n\n \t*#include \"XX.h\" <BR>\n\n \t*-llib\n\n \t*\n\n \t* 类的详细说明\n\n \t* \n\n \t* @seesomething\n\n \t*/\n\n \n\n\t#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n\t#define SORUTION_PROJECT_CLASSNAME_H\n\n \n\n\t// 在这里包含系统头文件\n\n\t//\n\n \n\n\t// 在这里包含项目头文件\n\n\t//\n\n \n\n\t// 在这里包含局部头文件\n\n\t//\n\n \n\n\t// 在这里放置前置引用\n\n\t//\n\n \n\n \n\n\t\tclass XX\n\n\t\t{\n\n\t\tpublic:\n\n    \t// 类的生命周期控制函数，如构造和析构，以及状态机\n\n \n\n    \t\t/**\n\n    \t\t*Default constructor.\n\n    \t\t*/\n\n    \t\tXX(void);\n\n \n\n    \t\t/**\n\n    \t\t*Copy constructor.\n\n    \t\t*\n\n    \t\t*@param from The value to copy to this object.\n\n    \t\t*/\n\n    \t\tXX(const XX& from);\n\n \n\n    \t\t/**\n\n    \t\t*Destructor.\n\n    \t\t*/\n\n\t\t    virtual ~XX(void);\n\n\t\t \n\n\t\t    // 在这里放置类的运算操作符\n\n\t\t \n\n\t\t    /**\n\n\t\t    *Assignment operator.\n\n\t\t    *\n\n\t\t    *@param from THe value to assign to this object.\n\n\t\t    *\n\n\t\t    *@return A reference to this object.\n\n\t\t    */\n\n\t\t    XX&                     operator=(XX&from); \n\n\t\t \n\n\t\t    // 在这里放置类的操作                      \n\n\t\t    // 在这里放置属性存取\n\n\t\t    // 在这里放置类的状态查询\n\n\t\t \n\n\t\t\tprotected:\n\n\t\t\tprivate:\n\n\t\t\t};\n\n \n\n\t\t// 内联方法定义\n\n\t\t//\n\n\t\t \n\n\t\t// 外部引用\n\n\t\t//\n\n\t\t \n\n\t\t#endif  // SORUTION_PROJECT_CLASSNAME_H\n\n \n\n²  定义的顺序是: public, protected, private\n\n²  要清楚public/protected/private都应该放置哪些东西\n### 2.1.2.   源文件格式（适用于C++）\n\n\t\t#include \"XX.h\"                               // class implemented\n\n \n\n \n\n/////////////// PUBLIC///////////////////////\n\n \n\n//================= 构造函数 ====================\n\n \n\n\t\tXX::XX()\n\n\t\t{\n\n\t\t}// XX\n\n\t\t \n\n\t\tXX::XX(const XX&)\n\n\t\t{\n\n\t\t}// XX\n\n\t\t \n\n\t\tXX::~XX()\n\n\t\t{\n\n\t\t}// ~XX\n\n\t\t \n\n \n\n//=============== 操作符=========================\n\n \n\n\t\tXX&\n\n\t\tXX::operator=(XX&);\n\n\t\t{\n\n\t\t   return *this;\n\n\t\t \n\n\t\t}// =\n\n\t\t \n\n//==============类的操作 =====================\n\n//==============属性存取 =====================\n\n//==============状态查询   =====================\n\n///////////// PROTECTED  //////////////////\n\n \n\n///////////// PRIVATE    //////////////////\n### 2.1.3.    保护头文件不被重复包含 （适用于C/C++）\n\n²  应使用宏定义来保护头文件不被重复包含：\n\n\t\t#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n\t\t#define SORUTION_PROJECT_CLASSNAME_H\n\n\t\t \n\n\t\t#endif // SORUTION_PROJECT_CLASSNAME_H\n\n \n\n \n\n²  如果使用命名空间的时候，要把命名空间加到文件名前面：\n\n\t\t#ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n\t\t#define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n \n\n#endif\n### 2.1.4.    方法和函数的布局 （适用于C/C++）\n\n²  对于有较多参数的函数的写法\n\n如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：\n\n\t\t   int AnyMethod(\n\n\t\t                 int  arg1, \n\n\t\t                 int   arg2,\n\n\t\t                 int   arg3,\n\n\t\t                 int   arg4); \n或\n\n\t\tint AnyMethod( int   arg1 \n\n\t\t               , int   arg2\n\n\t\t               , int   arg3\n\n\t\t               , int   arg4);\n\n \n## 2.2. 缩进、制表符以及空格 （适用于C/C++）\n\n²  缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格）\n\n²  不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。\n\n²  虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。\n\n例如：\n\n\t\t   void\n\n\t\t   func()\n\n\t\t   {\n\n\t\t      if (something bad)\n\n\t\t      {\n\n\t\t          if (another thing bad)\n\n\t\t          {\n\n\t\t              while (more input)\n\n\t\t              {\n\n\t\t              }\n\n\t\t          }\n\n\t\t      }\n\n\t\t   }\n## 2.3. 尽量使一行不要超过78个字母 （适用于C/C++）\n\n²  有许多编辑器屏幕只有78个字母宽\n## 2.4. 保证一行只写一条语句 （适用于C/C++）\n\n²  一行最多只写一条语句\n\n²  一行只定义一个变量\n\n例如：\n\n不要象下面这样:\n\n\t\tchar** a, *x;\n\n\t\t \n\n\t\tint width, height; //widthand height of image\n\n \n\n要象这样:\n\n\t\tchar** a= 0;  // 文档说明\n\n\t\tchar*  x= 0;  // 文档说明\n\t\t2.5. 花括号 {} 规则 （适用于C/C++）\n\t\t2.5.1.    花括号的位置\n\n²  在关键字的下一行单独放置括号，并且与关键字对齐，如：\n\n\t\tif (condition)       \n\n\t\t{\n\n\t\t    ...\n\n\t\t}\n\n\t\twhile (condition)\n\n\t\t{\n\n\t\t    …\n\n\t\t}\n### 2.5.2.    什么时候应使用花括号\n\n所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。\n\n²  使用花括号格式：\n\n\t\tif (1 == somevalue)\n\n\t\t{\n\n\t\t   somevalue = 2;\n\n\t\t}\n\n\t\t²  单行格式：\n\n\t\tif (1 == somevalue) somevalue = 2;\n\n\t\t或下面这样（对于这种写法，建议使用花括号）：\n\n\t\tif (1 == somevalue)\n\n\t\t{\n\t\tsomevalue = 2;\n\n\t\t}\n### 2.5.3.    在花括号结束的位置加上注释\n\n²  在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如：\n\n\t\twhile(1)\n\n\t\t{\n\n\t\t   if (valid)\n\n\t\t   {\n\n\t\t \n\n\t\t   } // if valid\n\n\t\t   else\n\n\t\t   {\n\n\t\t   } // not valid\n\n \n\n\t\t} // end forever\n### 2.5.4.    注意屏幕大小\n\n²  一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。\n## 2.6.圆括号 () 规则 （适用于C/C++）\n\n²  圆括号与关键字之间应放一个空格。\n\n²  圆括号与函数名之间不要有空格。\n\n²  Return 语句不要使用圆括号。\n\n例如：\n\n\t    if (condition)\n\n\t    {\n\n\t    }\n\n\t \n\n\t    while(condition)\n\n\t    {\n\n\t    }\n\n\t \n\n\t    strcpy(s, s1);\n\n \n\n    \treturn 1;\n## 2.7.if else 语句的格式 （适用于C/C++）\n\n²  布局\n\n\t\t   if (条件)               // 注释\n\n\t\t   {\n\n\t\t   }\n\n\t\t   else if (条件)           // 注释\n\n\t\t   {\n\n\t\t   }\n\n\t\t   else                   // 注释\n\n\t\t   {\n\n\t\t   }\n\n²  条件格式\n\n总是把常量放在等号或不等于号的左边：\n\n\t\tif ( 6 == errorNum ) ...\n\n一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。\n\n比如：\n\n\t\tif ( errorNum == 6) ...\n\n错写成：\n\n\t\tif ( errorNum = 6) ... // 这是一个不容易发现的灾难\n\n \n## 2.8.switch 格式 （适用于C/C++）\n\n²  直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。\n\n²  总是要写default语句，不管是否是需要。\n\n²  在case中需要定义变量的时候，应把所有代码放在语句块中。\n\n例如：\n\n\t\tswitch (...)\n\n\t\t{\n\n\t\tcase 1:\n\n\t\t    ...\n\n\t\t        // 继续执行case2\n\n\t\t \n\n\t\tcase 2:\n\n\t\t    {       \n\n\t\t        int v;\n\n\t\t        ...\n\n\t\t    }\n\n\t\t    break;\n\n\t\t \n\n\t\tdefault:\n\n\t\t}\n## 2.9. 使用goto,continue,break 和 ?: （适用于C/C++）\n### 2.9.1.    Goto\n\n²  尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如：\n\n\t\tfor (...)\n\n\t\t{\n\n\t\t    while (...)\n\n\t\t    {\n\n\t\t        ...\n\n\t\t            if (disaster)\n\n\t\tgoto error; //跳出循环\n\n\t\t    }\n\n\t\t}\n\n\t\t...\n\n\t\terror:\n\n\t\tclean up the mess\n\n²  跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。\n### 2.9.2.    Continue and Break\n\n²  Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。\n### 2.9.3.    ?:\n\n²  用括号把条件表达式括起来。\n\n²  不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。\n\n²  操作语句应分行写，除非它们能够简洁的放在一行当中。\n\n例如：\n\n   \t\t(condition) ?funct1() : func2();\n\n   或\n\n   \t\t(condition)\n\n     \t\t ? longstatement\n\n      \t\t: anotherlong statement;\n## 2.10.   运算符号的规则 （适用于C/C++）\n\n²  一元操作符如（!、~ 等等）应贴近操作对象。\n如：\n\n\t\tif (!IsOk)\n\n\t\t\treturn ++v;\n\n²  二元操作符如（+、*、%、== 等等）应在前后留空格。\n如：\n\n\t\tif ( v1 == v2)\n\n\t\t     return v1 * 3;\n\n²  ++ 和 -- 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。\n如：\n\t\tfor(int i = 0; i < 10; ++i)\n## 2.11.    变量声明语句块 （适用于C/C++）\n\n²  变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。\n如：\n\t\tfor(int i = 0; i < 10; ++i)\n\n \n\n²  声明语句块必须要对齐\n\n类型，变量，等号和初始化值要分别对齐。\n\n例如：\n\n\t\t   DWORD      mDword;\n\n\t\t   DWORD*     mpDword;\n\n\t\t   char*      mpChar;\n\n\t\t   char       mChar;\n\n\t\t \n\n\t\t   mDword     =    0;\n\n\t\t   mpDword    =    NULL;\n\n\t\t   mpChar      =    NULL;\n\n\t\t   mChar      =    0;\n# 3.    文档及注释\n\n应当使用文档自动生成工具，来生成相关的程序文档。\n## 3.1. 文件或程序库的文档注释（适用于C/C++）\n\n可以为整个文件编写文档。\n\n例如：\n\n\t\t/** @file file.h\n\n\t\t * Abrief file description.\n\n\t\t * Amore elaborated file description.\n\n\t\t */\n\n \n## 3.2. 类文档注释（适用于C/C++）\n\n在类定义前面应加上类说明文档。\n\n例如：\n\n\t\t/** WindowsNT\n\n\t\t *  @brief Windows Nice Try.\n\n\t\t *  @author Bill Gates\n\n\t\t *  @author Several species of small furryanimals gathered together\n\n\t\t *          in a cave and grooving with a pict.\n\n\t\t *  @version 4.0\n\n\t\t *  @date   1996-1998\n\n\t\t *  @bug It crashes a lot and requires hugeamounts of memory.\n\n\t\t *  @bug The class introduces the more bugs, thelonger it is used.\n\n\t\t *  @warning This class may explode in your face.\n\n\t\t *  @warning If you inherit anything from thisclass, you're doomed.\n\n\t\t */\n\n\t\tclass WindowsNT {};\n\n \n## 3.3. 函数文档注释（适用于C/C++）\n\n²  函数注释\n\n所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如：\n\n\t\t  /**\n\n\t\t   * 赋值操作符\n\n\t\t   *\n\n\t\t   *@param val 将要赋给本对象的值\n\n\t\t   *\n\n\t\t   *@return 本对象的引用\n\n\t\t   */\n\n\t\t  XX&  operator =(XX& val);\n\n²  注释属性\n\n一些自动文档工具定义的属性可以包含在文档中，常用的有：\n\nn  前提条件 (pre)\n定义调用这个函数的前提条件\n\nn  警告说明 (warning)\n定义一些关于这个函数必须知道的事情。\n\nn  备注说明 (remarks)\n定义一些关于这个函数的备注信息。\n\nn  将要完成的工作 (todo)\n说明哪些事情将在不久以后完成\n\nn  使用例子说明 (example)\n一个图片能表达100句话，一个好的例子能解答1000个问题。\n\n例如：\n\n\t\t  /**\n\n\t\t   * 复制一个字串\n\n\t\t   *\n\n\t\t   *@pre\n\n\t\t   *     - 需要保证(from != 0)\n\n\t\t   *     - 需要保证(to != 0)\n\n\t\t   *\n\n\t\t   *@warning\n\n\t\t   * 缓冲区必需足够大，以便容纳的下要拷贝的字串。\n\n\t\t   *\n\n\t\t   *@example teststrcpy.cpp\n\n\t\t   *\n\n\t\t   *@param from 要拷贝的字串\n\n\t\t   *@param to 用于容纳字串的缓冲区\n\n\t\t   *@return void\n\n\t\t   */\n\n\t\t  void  strcpy(constchar* from, char* to);\n## 3.4. Include 语句注释 （适用于C/C++）\n\n²  如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。\n## 3.5.语句块注释（适用于C/C++）\n\n²  语句块的注释可以用在语句块的开头和结束位置：\n\n\t\t{ \n\n\t\t    // Block1 (meaningful comment about Block1)\n\n\t\t    ... some code\n\n\t\t \n\n\t\t    { \n\n\t\t        // Block2 (meaningful comment about Block2)\n\n\t\t        ... somecode\n\n\t\t    }  // End Block2\n\n\t\t \n\n\t\t}  // End Block1\n# 4.    编码要求\n## 4.1. 不要忽略编译器的警告（适用于C/C++）\n\n²  编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。\n## 4.2. 应使用源代码管理器（适用于C/C++）\n\n²  根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。\n## 4.3. 固有的类方法成员（适用于C++）\n\n²  默认构造函数(DefaultConstructor)\n\n如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。\n\n²  虚析构函数(Virtual Destructor)\n\n如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。\n\n²  拷贝构造函数(Copy Constructor)\n\n如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。\n\n²  赋值操作(AssignmentOperator)\n\n如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。\n## 4.4. 使用命名空间 （适用于C++）\n\n²  命名规则\n\n根名字一般是设计者的名字。比如公司名称等等。\n\n²  不要在全局空间使用using语句。\n## 4.5. 初始化所有的变量 （适用于C/C++）\n\n²  无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。\n## 4.6. 保持函数短小精悍（适用于C/C++）\n\n²  一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。\n## 4.7.对空语句进行注释 （适用于C/C++）\n\n²  For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如：\n\n\t\t   while(*dest++ = *srC++)\n\n\t\t      ;         // VOID\n\n²  不允许写成：\n\n\t\t   while (*dest++ = *srC++) ;   // 绝对不允许这么写\n\n \n## 4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）\n\n²  If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如：\n\n建议使用：\n\n   \t\tif (FAIL != f())\n\n不建议使用下面的表达式：\n\n   \t\tif (f())\n\n \n\n²  宏定义的情况也一样：\n\n   \t\t#define STREQ(a,b) (strcmp((a), (b)) == 0)\n\n或者使用内联函数：\n\n\t\t   inline bool\n\n\t\t  StringEqual(char* a, char* b)\n\n\t\t   {\n\n\t\t      (strcmp(a, b)== 0) ? return true : return false;\n\n\t\t       Or more compactly:\n\n\t\t      returnstrcmp(a, b) == 0;\n\n\t\t   }\n## 4.9.布尔类型 （适用于C/C++）\n\n²  早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。\n\n \n\n早期的布尔类型定义为：\n\n\t\t   typedef int     bool;\n\n\t\t   #defineTRUE    1\n\n\t\t   #defineFALSE   0\n\n \n\n或：\n\n\t\t   const intTRUE  = 1;\n\n\t\t   const int FALSE= 0;\n\n \n\n²  在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如：\n\n   \t\tif (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？\n\n必须写成：\n\n   \t\tif (FALSE !=func()) { ...\n## 4.10.   避免在语句中内含赋值 （适用于C/C++）\n\n²  只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如：\n\n\t\t   while (EOF != (c= getchar()))\n\n\t\t   {\n\n\t\t      process thecharacter\n\n\t\t   }\n\n²  ++ 和 -- 操作也是一种赋值语句\n\n²  内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如：\n\n\t\t   a = b + c;\n\n\t\t   d = a + r;\n\n不应该写成：\n\n   \t\t\td = (a = b + c)+ r;\n## 4.11.   正确的使用Const （适用于C/C++）\n\n²  C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。\n## 4.12.    不要在头文件定义数据（适用于C/C++）\n\n不要把数据定义放在头文件，如：\n\n\t\t/*\n\n\t\t * aheader.h\n\n\t\t */\n\n\t\tint x = 0;\n## 4.13.   不要直接使用数字 （适用于C/C++）\n\n²  直接使用数字，会使源代码难以理解和维护。如：\n\n\t\tif      (22 ==foo)    { start_thermo_nuclear_war(); }\n\n\t\telse if (19 == foo)    {refund_lotso_money(); }\n\n\t\telse if (16 == foo)    {infinite_loop(); }\n\n\t\telse                   { cry_cause_im_lost(); }\n\n当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。\n\n²  我们可以用#define或者常量来改变这一状况，如：\n\n\t\t#define  PRESIDENT_WENT_CRAZY  (22)\n\n\t\tconst int WE_GOOFED= 19;\n\n\t\tenum\n\n\t\t{\n\n\t\t    THEY_DIDNT_PAY=16\n\n\t\t};\n\n\t\t \n\n\t\tif (PRESIDENT_WENT_CRAZY    == foo) { start_thermo_nuclear_war(); }\n\n\t\telse if (WE_GOOFED          == foo)  {refund_lotso_money(); }\n\n\t\telse if (THEY_DIDNT_PAY     == foo) { infinite_loop();}\n\n\t\telse                                 {happy_days_i_know_why_im_here(); }\n\n \n## 4.14.    宏（适用于C/C++）\n\n²  如果可以，使用内联函数代替宏。\n\n例如：\n\n\t\t#ifndef MAX\n\n\t\t#define  MAX(x,y)  (((x) > (y) ? (x) : (y))    // 取最大数\n\n\t\t#endif\n\n使用内联函数可以达到相同的效果，而且更安全：\n\n\t\t   inline int\n\n\t\t   max(int x, inty)\n\n\t\t   {\n\n\t\t      return (x> y ? x : y);\n\n\t\t   }\n\n²  要注意副作用\n\n必须小心副作用，因为在调用表达式时，会发生潜在的错误。\n\n例如：\n\n  \t\t MAX(f(x),z++);\n\n²  表达式总是用括号括起来\n\n在宏展开时，使用括号可以避免宏展开后产生的二义性。\n\n例如：\n\n\t\t#define ADD(x,y) x + y\n\n必须写成：\n\n\t\t#define ADD(x,y) ((x) + (y))\n\n²  保证宏名称的唯一性\n\n和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题：\n\nn  在宏名称前加上库的名字\n避免使用简单而常用的名字，如：MAX 和MIN。","content":"<pre><code>    命名规则\n    1 起个合适的名字\n        11    类的名称 适用于C\n        12    方法和函数的名称 适用于C++\n        13   含有度量单位的名称 适用于C++\n        14    缩写名称不要全部大写 适用于C++\n    2类的命名 适用于C\n    3类库或程序库命名 适用于C++\n    4方法和函数的命名 适用于C\n    5类属性的命名 适用于C\n    6方法和函数参数的命名 适用于C\n    7局部变量的命名 适用于C++\n    8指针变量的命名前缀 适用于C++\n    9引用变量和返回引用函数的命名前缀 适用于C\n    10   全局变量的命名前缀 适用于C++\n    11   全局常量的命名 适用于C+\n    命名规则\n    1 起个合适的名字\n        11    类的名称 适用于C\n        12    方法和函数的名称 适用于C++\n        13   含有度量单位的名称 适用于C++\n        14    缩写名称不要全部大写 适用于C++\n    2类的命名 适用于C\n    3类库或程序库命名 适用于C++\n    4方法和函数的命名 适用于C\n    5类属性的命名 适用于C\n    6方法和函数参数的命名 适用于C\n    7局部变量的命名 适用于C++\n    8指针变量的命名前缀 适用于C++\n    9引用变量和返回引用函数的命名前缀 适用于C\n    10   全局变量的命名前缀 适用于C++\n    11   全局常量的命名 适用于C++\n    12   静态变量的命名前缀 适用于C\n    13   自定义类型typedef的命名 适用于C++\n    14   宏定义的命名 适用于C++\n    15   C 函数的命名 适用于C++\n    16   枚举的命名 适用于C++\n    排版规则\n    1 布局和模板\n        11    类的布局模板 适用于C\n        12   源文件格式 适用于C\n        13    保护头文件不被重复包含 适用于C++\n        14    方法和函数的布局 适用于C++\n    2 缩进制表符以及空格 适用于C++\n    3 尽量使一行不要超过78个字母 适用于C++\n    4 保证一行只写一条语句 适用于C++\n    5 花括号 规则 适用于C++\n        51    花括号的位置\n        52    什么时候应使用花括号\n        53    在花括号结束的位置加上注释\n        54    注意屏幕大小 \n    6圆括号 规则 适用于C++\n    7if else 语句的格式 适用于C++\n    8switch 格式 适用于C++\n    9 使用gotocontinuebreak 和 适用于C++\n        91    Goto\n        92    Continue and Break\n        93    \n    10   运算符号的规则 适用于C++\n    11    变量声明语句块 适用于C++\n    文档及注释\n    1 文件或程序库的文档注释 适用于C++\n    2 类文档注释 适用于C++\n    3 函数文档注释 适用于C++\n    4 Include 语句注释 适用于C++\n    5语句块注释 适用于C++\n    编码要求\n    1 不要忽略编译器的警告 适用于C++\n    2 应使用源代码管理器 适用于C++\n    3 固有的类方法成员 适用于C\n    4 使用命名空间 适用于C\n    5 初始化所有的变量 适用于C++\n    6 保持函数短小精悍 适用于C++\n    7对空语句进行注释 适用于C++\n    8不要用if语句的默认方法测试非零值 适用于C++\n    9布尔类型 适用于C++\n    10避免在语句中内含赋值 适用于C++\n    11正确的使用Const 适用于C++\n    12不要在头文件定义数据适用于C++\n    13不要直接使用数字 适用于C++\n    14宏 适用于C++\n</code></pre> <a id=\"more\"></a> \n<h1 id=\"1-命名规则\"><a href=\"#1-命名规则\" class=\"headerlink\" title=\"1.    命名规则\"></a>1.    命名规则</h1><h2 id=\"1-1-起个合适的名字\"><a href=\"#1-1-起个合适的名字\" class=\"headerlink\" title=\"1.1. 起个合适的名字\"></a>1.1. 起个合适的名字</h2><h3 id=\"1-1-1-类的名称（适用于C-）\"><a href=\"#1-1-1-类的名称（适用于C-）\" class=\"headerlink\" title=\"1.1.1.    类的名称（适用于C++）\"></a>1.1.1.    类的名称（适用于C++）</h3><p>²  类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。</p>\n<p>²  类的名字不需要告诉我们，它从哪个类继承而来的。</p>\n<p>²  有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。</p>\n<h3 id=\"1-1-2-方法和函数的名称（适用于C-C-）\"><a href=\"#1-1-2-方法和函数的名称（适用于C-C-）\" class=\"headerlink\" title=\"1.1.2.    方法和函数的名称（适用于C/C++）\"></a>1.1.2.    方法和函数的名称（适用于C/C++）</h3><p>²  方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。</p>\n<p>²  函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。</p>\n<p>²  可以加一些必要的后缀：</p>\n<p>Max – 表示取最大值</p>\n<p>Cnt – 表示当前的计数值</p>\n<p>Key – 表示键值</p>\n<p>例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。</p>\n<p>²  前缀也同样有用：</p>\n<p>Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。</p>\n<p>Get – 用于获取一个值。</p>\n<p>Set – 用于设置一个值。</p>\n<p>例如：IsHitRetryLimit.</p>\n<h3 id=\"1-1-3-含有度量单位的名称（适用于C-C-）\"><a href=\"#1-1-3-含有度量单位的名称（适用于C-C-）\" class=\"headerlink\" title=\"1.1.3.   含有度量单位的名称（适用于C/C++）\"></a>1.1.3.   含有度量单位的名称（适用于C/C++）</h3><p>²  如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。</p>\n<p>例如：</p>\n<pre><code>uint32 mTimeoutMsecs;\n\nuint32 mMyWeightLbs;\n</code></pre><h3 id=\"1-1-4-缩写名称不要全部大写（适用于C-C-）\"><a href=\"#1-1-4-缩写名称不要全部大写（适用于C-C-）\" class=\"headerlink\" title=\"1.1.4.    缩写名称不要全部大写（适用于C/C++）\"></a>1.1.4.    缩写名称不要全部大写（适用于C/C++）</h3><p>²  无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。</p>\n<p>例如：</p>\n<pre><code>class FluidOz;            // 而不是 FluidOZ\n\nclass NetworkAbcKey;      // 而不是 NetworkABCKey\n</code></pre><h2 id=\"1-2-类的命名（适用于C-）\"><a href=\"#1-2-类的命名（适用于C-）\" class=\"headerlink\" title=\"1.2.类的命名（适用于C++）\"></a>1.2.类的命名（适用于C++）</h2><p>²  用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。</p>\n<p>²  名字的第一个字母应大写</p>\n<p>²  不含有下划线 (‘_’)</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo; \n\n   class Name;\n</code></pre><h2 id=\"1-3-类库（或程序库）命名-（适用于C-C-）\"><a href=\"#1-3-类库（或程序库）命名-（适用于C-C-）\" class=\"headerlink\" title=\"1.3.类库（或程序库）命名 （适用于C/C++）\"></a>1.3.类库（或程序库）命名 （适用于C/C++）</h2><p>²  使用命名空间防止名字冲突。</p>\n<p>²  如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。</p>\n<p>例如：</p>\n<p>John Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样：</p>\n<pre><code>   class JjLinkList\n\n   {\n\n   }\n</code></pre><h2 id=\"1-4-方法和函数的命名（适用于C-）\"><a href=\"#1-4-方法和函数的命名（适用于C-）\" class=\"headerlink\" title=\"1.4.方法和函数的命名（适用于C++）\"></a>1.4.方法和函数的命名（适用于C++）</h2><p>²  使用与类名相同的规则</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n       public:\n\n  int     DoIt();\n\n  void    HandleError();\n\n   }\n</code></pre><h2 id=\"1-5-类属性的命名（适用于C-）\"><a href=\"#1-5-类属性的命名（适用于C-）\" class=\"headerlink\" title=\"1.5.类属性的命名（适用于C++）\"></a>1.5.类属性的命名（适用于C++）</h2><p>²  属性（通常是非公有数据成员）名字以字母’m’开头。</p>\n<p>²  在 ‘m(m_)’  后面，使用与类名相同的规则。</p>\n<p>²  ‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n   public:\n\n      int     VarAbc();\n\n      int     ErrorNumber();\n\n   private:\n\n      int          mVarAbc;\n\n      int          mErrorNumber;\n\n      String*      mpName;\n\n   }\n</code></pre><h2 id=\"1-6-方法和函数参数的命名（适用于C-）\"><a href=\"#1-6-方法和函数参数的命名（适用于C-）\" class=\"headerlink\" title=\"1.6.方法和函数参数的命名（适用于C++）\"></a>1.6.方法和函数参数的命名（适用于C++）</h2><p>²  第一个字母必须小写。</p>\n<p>²  第一个字母后面的单词使用与类名相同的规则。</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n   public:\n\n  int     StartYourEngines(\n\n                           Engine&amp;rSomeEngine,\n\n                          Engine&amp;rAnotherEngine);\n\n   }\n</code></pre><h2 id=\"1-7-局部变量的命名（适用于C-C-）\"><a href=\"#1-7-局部变量的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.7.局部变量的命名（适用于C/C++）\"></a>1.7.局部变量的命名（适用于C/C++）</h2><p>²  所有字母都用小写</p>\n<p>²  使用下划线 ‘_’ 作为单词的分隔。</p>\n<p>例如：</p>\n<pre><code>   int\n\n  NameOneTwo::HandleError(int errorNumber)\n\n   {\n\n  int            error= OsErr();\n\n  Time           time_of_error;\n\n ErrorProcessor error_processor;\n</code></pre><p>   }</p>\n<h2 id=\"1-8-指针变量的命名前缀（适用于C-C-）\"><a href=\"#1-8-指针变量的命名前缀（适用于C-C-）\" class=\"headerlink\" title=\"1.8.指针变量的命名前缀（适用于C/C++）\"></a>1.8.指针变量的命名前缀（适用于C/C++）</h2><p>²  指针变量多数情况应在前面加 ‘p’。</p>\n<p>²  星号 ‘*’ 应靠近类型，而不是变量名。</p>\n<p>例如：</p>\n<pre><code>  String* pName=new String;\n</code></pre><p>  特别的：String* pName, name; 应分成两行来写：</p>\n<pre><code>  String* pName;\n\n  String  name;\n</code></pre><h2 id=\"1-9-引用变量和返回引用函数的命名前缀（适用于C-）\"><a href=\"#1-9-引用变量和返回引用函数的命名前缀（适用于C-）\" class=\"headerlink\" title=\"1.9.引用变量和返回引用函数的命名前缀（适用于C++）\"></a>1.9.引用变量和返回引用函数的命名前缀（适用于C++）</h2><p>²  引用必须用 ‘r’作前缀修饰。</p>\n<p>例如：</p>\n<pre><code>   class Test\n\n   {\n\n   public:\n\n  void               DoSomething(StatusInfo&amp;rStatus);\n\n\n\n StatusInfo&amp;        rStatus();\n\n  constStatusInfo&amp;  Status() const; // 这里返回的是常量引用，所以不符合本规则\n\n\n\n   private:\n\n     StatusInfo&amp;        mrStatus;\n\n   }\n</code></pre><h2 id=\"1-10-全局变量的命名前缀（适用于C-C-）\"><a href=\"#1-10-全局变量的命名前缀（适用于C-C-）\" class=\"headerlink\" title=\"1.10.   全局变量的命名前缀（适用于C/C++）\"></a>1.10.   全局变量的命名前缀（适用于C/C++）</h2><p>²  全局变量总是以 ‘g(g_)’ 作为前缀。</p>\n<p>例如：</p>\n<pre><code>Logger g_Log;\n\nLogger* g_pLog;\n</code></pre><h2 id=\"1-11-全局常量的命名（适用于C-C-）\"><a href=\"#1-11-全局常量的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.11.   全局常量的命名（适用于C/C++）\"></a>1.11.   全局常量的命名（适用于C/C++）</h2><p>²  全局常量全部大写，并以下划线 ‘_’ 分隔单词。</p>\n<p>例如：</p>\n<pre><code>const intA_GLOBAL_CONSTANT = 5;\n</code></pre><h2 id=\"1-12-静态变量的命名前缀（适用于C-）\"><a href=\"#1-12-静态变量的命名前缀（适用于C-）\" class=\"headerlink\" title=\"1.12.   静态变量的命名前缀（适用于C++）\"></a>1.12.   静态变量的命名前缀（适用于C++）</h2><p>²  静态变量以 ‘s’ 作为前缀。</p>\n<p>例如：</p>\n<pre><code>   class Test\n\n   {\n\n   public:\n\n   private:\n\n      staticStatusInfo m_sStatus;\n\n   }\n</code></pre><h2 id=\"1-13-自定义类型（typedef）的命名（适用于C-C-）\"><a href=\"#1-13-自定义类型（typedef）的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.13.   自定义类型（typedef）的命名（适用于C/C++）\"></a>1.13.   自定义类型（typedef）的命名（适用于C/C++）</h2><p>²  类型定义名称指的是用typedef定义的名称。</p>\n<p>²  类型定义名称使用与类名相同的规则，并使用Type作为后缀。</p>\n<p>例如：</p>\n<pre><code>   typedefuint16  ModuleType;\n\n   typedefuint32  SystemType;\n</code></pre><h2 id=\"1-14-宏定义的命名（适用于C-C-）\"><a href=\"#1-14-宏定义的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.14.   宏定义的命名（适用于C/C++）\"></a>1.14.   宏定义的命名（适用于C/C++）</h2><p>²  所有单词的字母都用大写，并使用下划线 ‘_’ 分隔.</p>\n<p>例如：</p>\n<pre><code>#define MAX(a,b) blah\n\n#define IS_ERR(err) blah\n</code></pre><h2 id=\"1-15-C-函数的命名（适用于C-C-）\"><a href=\"#1-15-C-函数的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.15.   C 函数的命名（适用于C/C++）\"></a>1.15.   C 函数的命名（适用于C/C++）</h2><p>²  C++项目中，应尽量少用C函数。</p>\n<p>²  C函数使用GNU规范，所有字母都使用小写，并用下划线 ‘_’ 作为单词的分隔。</p>\n<p>例如：</p>\n<pre><code>   int\n\n  some_bloody_function()\n\n   {\n\n   }\n</code></pre><p>²  特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：</p>\n<pre><code>   extern “C” int some_bloody_function();\n</code></pre><p>²  或在C/C++中推荐使用下面的格式：</p>\n<pre><code>   #ifdef__cplusplus__\n\n   extern “C”{\n\n   #endif\n\n   int\n\n  some_bloody_function()\n\n   {\n\n   }\n\n   #ifdef__cplusplus__\n\n   }\n\n   #endif\n</code></pre><h2 id=\"1-16-枚举的命名（适用于C-C-）\"><a href=\"#1-16-枚举的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.16.   枚举的命名（适用于C/C++）\"></a>1.16.   枚举的命名（适用于C/C++）</h2><p>²  所有字母都大写，并用下划线 ‘_’ 作为单词分隔。</p>\n<p>例如：</p>\n<pre><code>   enumPinStateType\n\n   {\n\n      PIN_OFF,\n\n      PIN_ON\n\n   };\n\nenum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING};\n</code></pre><h1 id=\"2-排版规则\"><a href=\"#2-排版规则\" class=\"headerlink\" title=\"2.    排版规则\"></a>2.    排版规则</h1><h2 id=\"2-1-布局和模板\"><a href=\"#2-1-布局和模板\" class=\"headerlink\" title=\"2.1. 布局和模板\"></a>2.1. 布局和模板</h2><h3 id=\"2-1-1-类的布局模板-（适用于C-）\"><a href=\"#2-1-1-类的布局模板-（适用于C-）\" class=\"headerlink\" title=\"2.1.1.    类的布局模板 （适用于C++）\"></a>2.1.1.    类的布局模板 （适用于C++）</h3><p>²  请使用下面的模板来创建一个新的类：</p>\n<pre><code>/**     \n\n * 用一行来描述类\n\n *\n\n *#include &quot;XX.h&quot; &lt;BR&gt;\n\n *-llib\n\n *\n\n * 类的详细说明\n\n * \n\n * @seesomething\n\n */\n\n\n\n#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n#define SORUTION_PROJECT_CLASSNAME_H\n\n\n\n// 在这里包含系统头文件\n\n//\n\n\n\n// 在这里包含项目头文件\n\n//\n\n\n\n// 在这里包含局部头文件\n\n//\n\n\n\n// 在这里放置前置引用\n\n//\n\n\n\n\n\n    class XX\n\n    {\n\n    public:\n\n    // 类的生命周期控制函数，如构造和析构，以及状态机\n\n\n\n        /**\n\n        *Default constructor.\n\n        */\n\n        XX(void);\n\n\n\n        /**\n\n        *Copy constructor.\n\n        *\n\n        *@param from The value to copy to this object.\n\n        */\n\n        XX(const XX&amp; from);\n\n\n\n        /**\n\n        *Destructor.\n\n        */\n\n        virtual ~XX(void);\n\n\n\n        // 在这里放置类的运算操作符\n\n\n\n        /**\n\n        *Assignment operator.\n\n        *\n\n        *@param from THe value to assign to this object.\n\n        *\n\n        *@return A reference to this object.\n\n        */\n\n        XX&amp;                     operator=(XX&amp;from); \n\n\n\n        // 在这里放置类的操作                      \n\n        // 在这里放置属性存取\n\n        // 在这里放置类的状态查询\n\n\n\n        protected:\n\n        private:\n\n        };\n\n\n\n    // 内联方法定义\n\n    //\n\n\n\n    // 外部引用\n\n    //\n\n\n\n    #endif  // SORUTION_PROJECT_CLASSNAME_H\n</code></pre><p>²  定义的顺序是: public, protected, private</p>\n<p>²  要清楚public/protected/private都应该放置哪些东西</p>\n<h3 id=\"2-1-2-源文件格式（适用于C-）\"><a href=\"#2-1-2-源文件格式（适用于C-）\" class=\"headerlink\" title=\"2.1.2.   源文件格式（适用于C++）\"></a>2.1.2.   源文件格式（适用于C++）</h3><pre><code>    #include &quot;XX.h&quot;                               // class implemented\n</code></pre><p>/////////////// PUBLIC///////////////////////</p>\n<p>//================= 构造函数 ====================</p>\n<pre><code>    XX::XX()\n\n    {\n\n    }// XX\n\n\n\n    XX::XX(const XX&amp;)\n\n    {\n\n    }// XX\n\n\n\n    XX::~XX()\n\n    {\n\n    }// ~XX\n</code></pre><p>//=============== 操作符=========================</p>\n<pre><code>    XX&amp;\n\n    XX::operator=(XX&amp;);\n\n    {\n\n       return *this;\n\n\n\n    }// =\n</code></pre><p>//==============类的操作 =====================</p>\n<p>//==============属性存取 =====================</p>\n<p>//==============状态查询   =====================</p>\n<p>///////////// PROTECTED  //////////////////</p>\n<p>///////////// PRIVATE    //////////////////</p>\n<h3 id=\"2-1-3-保护头文件不被重复包含-（适用于C-C-）\"><a href=\"#2-1-3-保护头文件不被重复包含-（适用于C-C-）\" class=\"headerlink\" title=\"2.1.3.    保护头文件不被重复包含 （适用于C/C++）\"></a>2.1.3.    保护头文件不被重复包含 （适用于C/C++）</h3><p>²  应使用宏定义来保护头文件不被重复包含：</p>\n<pre><code>    #ifndef SORUTION_PROJECT_CLASSNAME_H\n\n    #define SORUTION_PROJECT_CLASSNAME_H\n\n\n\n    #endif // SORUTION_PROJECT_CLASSNAME_H\n</code></pre><p>²  如果使用命名空间的时候，要把命名空间加到文件名前面：</p>\n<pre><code>    #ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n    #define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n</code></pre><p>#endif</p>\n<h3 id=\"2-1-4-方法和函数的布局-（适用于C-C-）\"><a href=\"#2-1-4-方法和函数的布局-（适用于C-C-）\" class=\"headerlink\" title=\"2.1.4.    方法和函数的布局 （适用于C/C++）\"></a>2.1.4.    方法和函数的布局 （适用于C/C++）</h3><p>²  对于有较多参数的函数的写法</p>\n<p>如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：</p>\n<pre><code>       int AnyMethod(\n\n                     int  arg1, \n\n                     int   arg2,\n\n                     int   arg3,\n\n                     int   arg4); \n</code></pre><p>或</p>\n<pre><code>    int AnyMethod( int   arg1 \n\n                   , int   arg2\n\n                   , int   arg3\n\n                   , int   arg4);\n</code></pre><h2 id=\"2-2-缩进、制表符以及空格-（适用于C-C-）\"><a href=\"#2-2-缩进、制表符以及空格-（适用于C-C-）\" class=\"headerlink\" title=\"2.2. 缩进、制表符以及空格 （适用于C/C++）\"></a>2.2. 缩进、制表符以及空格 （适用于C/C++）</h2><p>²  缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格）</p>\n<p>²  不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。</p>\n<p>²  虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。</p>\n<p>例如：</p>\n<pre><code>       void\n\n       func()\n\n       {\n\n          if (something bad)\n\n          {\n\n              if (another thing bad)\n\n              {\n\n                  while (more input)\n\n                  {\n\n                  }\n\n              }\n\n          }\n\n       }\n</code></pre><h2 id=\"2-3-尽量使一行不要超过78个字母-（适用于C-C-）\"><a href=\"#2-3-尽量使一行不要超过78个字母-（适用于C-C-）\" class=\"headerlink\" title=\"2.3. 尽量使一行不要超过78个字母 （适用于C/C++）\"></a>2.3. 尽量使一行不要超过78个字母 （适用于C/C++）</h2><p>²  有许多编辑器屏幕只有78个字母宽</p>\n<h2 id=\"2-4-保证一行只写一条语句-（适用于C-C-）\"><a href=\"#2-4-保证一行只写一条语句-（适用于C-C-）\" class=\"headerlink\" title=\"2.4. 保证一行只写一条语句 （适用于C/C++）\"></a>2.4. 保证一行只写一条语句 （适用于C/C++）</h2><p>²  一行最多只写一条语句</p>\n<p>²  一行只定义一个变量</p>\n<p>例如：</p>\n<p>不要象下面这样:</p>\n<pre><code>    char** a, *x;\n\n\n\n    int width, height; //widthand height of image\n</code></pre><p>要象这样:</p>\n<pre><code>    char** a= 0;  // 文档说明\n\n    char*  x= 0;  // 文档说明\n    2.5. 花括号 {} 规则 （适用于C/C++）\n    2.5.1.    花括号的位置\n</code></pre><p>²  在关键字的下一行单独放置括号，并且与关键字对齐，如：</p>\n<pre><code>    if (condition)       \n\n    {\n\n        ...\n\n    }\n\n    while (condition)\n\n    {\n\n        …\n\n    }\n</code></pre><h3 id=\"2-5-2-什么时候应使用花括号\"><a href=\"#2-5-2-什么时候应使用花括号\" class=\"headerlink\" title=\"2.5.2.    什么时候应使用花括号\"></a>2.5.2.    什么时候应使用花括号</h3><p>所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。</p>\n<p>²  使用花括号格式：</p>\n<pre><code>    if (1 == somevalue)\n\n    {\n\n       somevalue = 2;\n\n    }\n\n    ²  单行格式：\n\n    if (1 == somevalue) somevalue = 2;\n\n    或下面这样（对于这种写法，建议使用花括号）：\n\n    if (1 == somevalue)\n\n    {\n    somevalue = 2;\n\n    }\n</code></pre><h3 id=\"2-5-3-在花括号结束的位置加上注释\"><a href=\"#2-5-3-在花括号结束的位置加上注释\" class=\"headerlink\" title=\"2.5.3.    在花括号结束的位置加上注释\"></a>2.5.3.    在花括号结束的位置加上注释</h3><p>²  在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如：</p>\n<pre><code>    while(1)\n\n    {\n\n       if (valid)\n\n       {\n\n\n\n       } // if valid\n\n       else\n\n       {\n\n       } // not valid\n\n\n\n    } // end forever\n</code></pre><h3 id=\"2-5-4-注意屏幕大小\"><a href=\"#2-5-4-注意屏幕大小\" class=\"headerlink\" title=\"2.5.4.    注意屏幕大小\"></a>2.5.4.    注意屏幕大小</h3><p>²  一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。</p>\n<h2 id=\"2-6-圆括号-规则-（适用于C-C-）\"><a href=\"#2-6-圆括号-规则-（适用于C-C-）\" class=\"headerlink\" title=\"2.6.圆括号 () 规则 （适用于C/C++）\"></a>2.6.圆括号 () 规则 （适用于C/C++）</h2><p>²  圆括号与关键字之间应放一个空格。</p>\n<p>²  圆括号与函数名之间不要有空格。</p>\n<p>²  Return 语句不要使用圆括号。</p>\n<p>例如：</p>\n<pre><code>    if (condition)\n\n    {\n\n    }\n\n\n\n    while(condition)\n\n    {\n\n    }\n\n\n\n    strcpy(s, s1);\n\n\n\n    return 1;\n</code></pre><h2 id=\"2-7-if-else-语句的格式-（适用于C-C-）\"><a href=\"#2-7-if-else-语句的格式-（适用于C-C-）\" class=\"headerlink\" title=\"2.7.if else 语句的格式 （适用于C/C++）\"></a>2.7.if else 语句的格式 （适用于C/C++）</h2><p>²  布局</p>\n<pre><code>       if (条件)               // 注释\n\n       {\n\n       }\n\n       else if (条件)           // 注释\n\n       {\n\n       }\n\n       else                   // 注释\n\n       {\n\n       }\n</code></pre><p>²  条件格式</p>\n<p>总是把常量放在等号或不等于号的左边：</p>\n<pre><code>    if ( 6 == errorNum ) ...\n</code></pre><p>一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。</p>\n<p>比如：</p>\n<pre><code>    if ( errorNum == 6) ...\n</code></pre><p>错写成：</p>\n<pre><code>    if ( errorNum = 6) ... // 这是一个不容易发现的灾难\n</code></pre><h2 id=\"2-8-switch-格式-（适用于C-C-）\"><a href=\"#2-8-switch-格式-（适用于C-C-）\" class=\"headerlink\" title=\"2.8.switch 格式 （适用于C/C++）\"></a>2.8.switch 格式 （适用于C/C++）</h2><p>²  直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。</p>\n<p>²  总是要写default语句，不管是否是需要。</p>\n<p>²  在case中需要定义变量的时候，应把所有代码放在语句块中。</p>\n<p>例如：</p>\n<pre><code>    switch (...)\n\n    {\n\n    case 1:\n\n        ...\n\n            // 继续执行case2\n\n\n\n    case 2:\n\n        {       \n\n            int v;\n\n            ...\n\n        }\n\n        break;\n\n\n\n    default:\n\n    }\n</code></pre><h2 id=\"2-9-使用goto-continue-break-和-（适用于C-C-）\"><a href=\"#2-9-使用goto-continue-break-和-（适用于C-C-）\" class=\"headerlink\" title=\"2.9. 使用goto,continue,break 和 ?: （适用于C/C++）\"></a>2.9. 使用goto,continue,break 和 ?: （适用于C/C++）</h2><h3 id=\"2-9-1-Goto\"><a href=\"#2-9-1-Goto\" class=\"headerlink\" title=\"2.9.1.    Goto\"></a>2.9.1.    Goto</h3><p>²  尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如：</p>\n<pre><code>    for (...)\n\n    {\n\n        while (...)\n\n        {\n\n            ...\n\n                if (disaster)\n\n    goto error; //跳出循环\n\n        }\n\n    }\n\n    ...\n\n    error:\n\n    clean up the mess\n</code></pre><p>²  跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。</p>\n<h3 id=\"2-9-2-Continue-and-Break\"><a href=\"#2-9-2-Continue-and-Break\" class=\"headerlink\" title=\"2.9.2.    Continue and Break\"></a>2.9.2.    Continue and Break</h3><p>²  Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。</p>\n<h3 id=\"2-9-3\"><a href=\"#2-9-3\" class=\"headerlink\" title=\"2.9.3.    ?:\"></a>2.9.3.    ?:</h3><p>²  用括号把条件表达式括起来。</p>\n<p>²  不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。</p>\n<p>²  操作语句应分行写，除非它们能够简洁的放在一行当中。</p>\n<p>例如：</p>\n<pre><code>       (condition) ?funct1() : func2();\n</code></pre><p>   或</p>\n<pre><code>       (condition)\n\n          ? longstatement\n\n          : anotherlong statement;\n</code></pre><h2 id=\"2-10-运算符号的规则-（适用于C-C-）\"><a href=\"#2-10-运算符号的规则-（适用于C-C-）\" class=\"headerlink\" title=\"2.10.   运算符号的规则 （适用于C/C++）\"></a>2.10.   运算符号的规则 （适用于C/C++）</h2><p>²  一元操作符如（!、~ 等等）应贴近操作对象。<br>如：</p>\n<pre><code>    if (!IsOk)\n\n        return ++v;\n</code></pre><p>²  二元操作符如（+、*、%、== 等等）应在前后留空格。<br>如：</p>\n<pre><code>    if ( v1 == v2)\n\n         return v1 * 3;\n</code></pre><p>²  ++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。<br>如：<br>        for(int i = 0; i &lt; 10; ++i)</p>\n<h2 id=\"2-11-变量声明语句块-（适用于C-C-）\"><a href=\"#2-11-变量声明语句块-（适用于C-C-）\" class=\"headerlink\" title=\"2.11.    变量声明语句块 （适用于C/C++）\"></a>2.11.    变量声明语句块 （适用于C/C++）</h2><p>²  变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。<br>如：<br>        for(int i = 0; i &lt; 10; ++i)</p>\n<p>²  声明语句块必须要对齐</p>\n<p>类型，变量，等号和初始化值要分别对齐。</p>\n<p>例如：</p>\n<pre><code>       DWORD      mDword;\n\n       DWORD*     mpDword;\n\n       char*      mpChar;\n\n       char       mChar;\n\n\n\n       mDword     =    0;\n\n       mpDword    =    NULL;\n\n       mpChar      =    NULL;\n\n       mChar      =    0;\n</code></pre><h1 id=\"3-文档及注释\"><a href=\"#3-文档及注释\" class=\"headerlink\" title=\"3.    文档及注释\"></a>3.    文档及注释</h1><p>应当使用文档自动生成工具，来生成相关的程序文档。</p>\n<h2 id=\"3-1-文件或程序库的文档注释（适用于C-C-）\"><a href=\"#3-1-文件或程序库的文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.1. 文件或程序库的文档注释（适用于C/C++）\"></a>3.1. 文件或程序库的文档注释（适用于C/C++）</h2><p>可以为整个文件编写文档。</p>\n<p>例如：</p>\n<pre><code>    /** @file file.h\n\n     * Abrief file description.\n\n     * Amore elaborated file description.\n\n     */\n</code></pre><h2 id=\"3-2-类文档注释（适用于C-C-）\"><a href=\"#3-2-类文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.2. 类文档注释（适用于C/C++）\"></a>3.2. 类文档注释（适用于C/C++）</h2><p>在类定义前面应加上类说明文档。</p>\n<p>例如：</p>\n<pre><code>    /** WindowsNT\n\n     *  @brief Windows Nice Try.\n\n     *  @author Bill Gates\n\n     *  @author Several species of small furryanimals gathered together\n\n     *          in a cave and grooving with a pict.\n\n     *  @version 4.0\n\n     *  @date   1996-1998\n\n     *  @bug It crashes a lot and requires hugeamounts of memory.\n\n     *  @bug The class introduces the more bugs, thelonger it is used.\n\n     *  @warning This class may explode in your face.\n\n     *  @warning If you inherit anything from thisclass, you&#39;re doomed.\n\n     */\n\n    class WindowsNT {};\n</code></pre><h2 id=\"3-3-函数文档注释（适用于C-C-）\"><a href=\"#3-3-函数文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.3. 函数文档注释（适用于C/C++）\"></a>3.3. 函数文档注释（适用于C/C++）</h2><p>²  函数注释</p>\n<p>所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如：</p>\n<pre><code>      /**\n\n       * 赋值操作符\n\n       *\n\n       *@param val 将要赋给本对象的值\n\n       *\n\n       *@return 本对象的引用\n\n       */\n\n      XX&amp;  operator =(XX&amp; val);\n</code></pre><p>²  注释属性</p>\n<p>一些自动文档工具定义的属性可以包含在文档中，常用的有：</p>\n<p>n  前提条件 (pre)<br>定义调用这个函数的前提条件</p>\n<p>n  警告说明 (warning)<br>定义一些关于这个函数必须知道的事情。</p>\n<p>n  备注说明 (remarks)<br>定义一些关于这个函数的备注信息。</p>\n<p>n  将要完成的工作 (todo)<br>说明哪些事情将在不久以后完成</p>\n<p>n  使用例子说明 (example)<br>一个图片能表达100句话，一个好的例子能解答1000个问题。</p>\n<p>例如：</p>\n<pre><code>      /**\n\n       * 复制一个字串\n\n       *\n\n       *@pre\n\n       *     - 需要保证(from != 0)\n\n       *     - 需要保证(to != 0)\n\n       *\n\n       *@warning\n\n       * 缓冲区必需足够大，以便容纳的下要拷贝的字串。\n\n       *\n\n       *@example teststrcpy.cpp\n\n       *\n\n       *@param from 要拷贝的字串\n\n       *@param to 用于容纳字串的缓冲区\n\n       *@return void\n\n       */\n\n      void  strcpy(constchar* from, char* to);\n</code></pre><h2 id=\"3-4-Include-语句注释-（适用于C-C-）\"><a href=\"#3-4-Include-语句注释-（适用于C-C-）\" class=\"headerlink\" title=\"3.4. Include 语句注释 （适用于C/C++）\"></a>3.4. Include 语句注释 （适用于C/C++）</h2><p>²  如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。</p>\n<h2 id=\"3-5-语句块注释（适用于C-C-）\"><a href=\"#3-5-语句块注释（适用于C-C-）\" class=\"headerlink\" title=\"3.5.语句块注释（适用于C/C++）\"></a>3.5.语句块注释（适用于C/C++）</h2><p>²  语句块的注释可以用在语句块的开头和结束位置：</p>\n<pre><code>    { \n\n        // Block1 (meaningful comment about Block1)\n\n        ... some code\n\n\n\n        { \n\n            // Block2 (meaningful comment about Block2)\n\n            ... somecode\n\n        }  // End Block2\n\n\n\n    }  // End Block1\n</code></pre><h1 id=\"4-编码要求\"><a href=\"#4-编码要求\" class=\"headerlink\" title=\"4.    编码要求\"></a>4.    编码要求</h1><h2 id=\"4-1-不要忽略编译器的警告（适用于C-C-）\"><a href=\"#4-1-不要忽略编译器的警告（适用于C-C-）\" class=\"headerlink\" title=\"4.1. 不要忽略编译器的警告（适用于C/C++）\"></a>4.1. 不要忽略编译器的警告（适用于C/C++）</h2><p>²  编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。</p>\n<h2 id=\"4-2-应使用源代码管理器（适用于C-C-）\"><a href=\"#4-2-应使用源代码管理器（适用于C-C-）\" class=\"headerlink\" title=\"4.2. 应使用源代码管理器（适用于C/C++）\"></a>4.2. 应使用源代码管理器（适用于C/C++）</h2><p>²  根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。</p>\n<h2 id=\"4-3-固有的类方法成员（适用于C-）\"><a href=\"#4-3-固有的类方法成员（适用于C-）\" class=\"headerlink\" title=\"4.3. 固有的类方法成员（适用于C++）\"></a>4.3. 固有的类方法成员（适用于C++）</h2><p>²  默认构造函数(DefaultConstructor)</p>\n<p>如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。</p>\n<p>²  虚析构函数(Virtual Destructor)</p>\n<p>如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。</p>\n<p>²  拷贝构造函数(Copy Constructor)</p>\n<p>如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。</p>\n<p>²  赋值操作(AssignmentOperator)</p>\n<p>如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。</p>\n<h2 id=\"4-4-使用命名空间-（适用于C-）\"><a href=\"#4-4-使用命名空间-（适用于C-）\" class=\"headerlink\" title=\"4.4. 使用命名空间 （适用于C++）\"></a>4.4. 使用命名空间 （适用于C++）</h2><p>²  命名规则</p>\n<p>根名字一般是设计者的名字。比如公司名称等等。</p>\n<p>²  不要在全局空间使用using语句。</p>\n<h2 id=\"4-5-初始化所有的变量-（适用于C-C-）\"><a href=\"#4-5-初始化所有的变量-（适用于C-C-）\" class=\"headerlink\" title=\"4.5. 初始化所有的变量 （适用于C/C++）\"></a>4.5. 初始化所有的变量 （适用于C/C++）</h2><p>²  无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。</p>\n<h2 id=\"4-6-保持函数短小精悍（适用于C-C-）\"><a href=\"#4-6-保持函数短小精悍（适用于C-C-）\" class=\"headerlink\" title=\"4.6. 保持函数短小精悍（适用于C/C++）\"></a>4.6. 保持函数短小精悍（适用于C/C++）</h2><p>²  一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。</p>\n<h2 id=\"4-7-对空语句进行注释-（适用于C-C-）\"><a href=\"#4-7-对空语句进行注释-（适用于C-C-）\" class=\"headerlink\" title=\"4.7.对空语句进行注释 （适用于C/C++）\"></a>4.7.对空语句进行注释 （适用于C/C++）</h2><p>²  For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如：</p>\n<pre><code>       while(*dest++ = *srC++)\n\n          ;         // VOID\n</code></pre><p>²  不允许写成：</p>\n<pre><code>       while (*dest++ = *srC++) ;   // 绝对不允许这么写\n</code></pre><h2 id=\"4-8-不要用if语句的默认方法测试非零值（适用于C-C-）\"><a href=\"#4-8-不要用if语句的默认方法测试非零值（适用于C-C-）\" class=\"headerlink\" title=\"4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）\"></a>4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）</h2><p>²  If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如：</p>\n<p>建议使用：</p>\n<pre><code>       if (FAIL != f())\n</code></pre><p>不建议使用下面的表达式：</p>\n<pre><code>       if (f())\n</code></pre><p>²  宏定义的情况也一样：</p>\n<pre><code>       #define STREQ(a,b) (strcmp((a), (b)) == 0)\n</code></pre><p>或者使用内联函数：</p>\n<pre><code>       inline bool\n\n      StringEqual(char* a, char* b)\n\n       {\n\n          (strcmp(a, b)== 0) ? return true : return false;\n\n           Or more compactly:\n\n          returnstrcmp(a, b) == 0;\n\n       }\n</code></pre><h2 id=\"4-9-布尔类型-（适用于C-C-）\"><a href=\"#4-9-布尔类型-（适用于C-C-）\" class=\"headerlink\" title=\"4.9.布尔类型 （适用于C/C++）\"></a>4.9.布尔类型 （适用于C/C++）</h2><p>²  早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。</p>\n<p>早期的布尔类型定义为：</p>\n<pre><code>       typedef int     bool;\n\n       #defineTRUE    1\n\n       #defineFALSE   0\n</code></pre><p>或：</p>\n<pre><code>       const intTRUE  = 1;\n\n       const int FALSE= 0;\n</code></pre><p>²  在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如：</p>\n<pre><code>       if (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？\n</code></pre><p>必须写成：</p>\n<pre><code>       if (FALSE !=func()) { ...\n</code></pre><h2 id=\"4-10-避免在语句中内含赋值-（适用于C-C-）\"><a href=\"#4-10-避免在语句中内含赋值-（适用于C-C-）\" class=\"headerlink\" title=\"4.10.   避免在语句中内含赋值 （适用于C/C++）\"></a>4.10.   避免在语句中内含赋值 （适用于C/C++）</h2><p>²  只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如：</p>\n<pre><code>       while (EOF != (c= getchar()))\n\n       {\n\n          process thecharacter\n\n       }\n</code></pre><p>²  ++ 和 – 操作也是一种赋值语句</p>\n<p>²  内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如：</p>\n<pre><code>       a = b + c;\n\n       d = a + r;\n</code></pre><p>不应该写成：</p>\n<pre><code>           d = (a = b + c)+ r;\n</code></pre><h2 id=\"4-11-正确的使用Const-（适用于C-C-）\"><a href=\"#4-11-正确的使用Const-（适用于C-C-）\" class=\"headerlink\" title=\"4.11.   正确的使用Const （适用于C/C++）\"></a>4.11.   正确的使用Const （适用于C/C++）</h2><p>²  C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。</p>\n<h2 id=\"4-12-不要在头文件定义数据（适用于C-C-）\"><a href=\"#4-12-不要在头文件定义数据（适用于C-C-）\" class=\"headerlink\" title=\"4.12.    不要在头文件定义数据（适用于C/C++）\"></a>4.12.    不要在头文件定义数据（适用于C/C++）</h2><p>不要把数据定义放在头文件，如：</p>\n<pre><code>    /*\n\n     * aheader.h\n\n     */\n\n    int x = 0;\n</code></pre><h2 id=\"4-13-不要直接使用数字-（适用于C-C-）\"><a href=\"#4-13-不要直接使用数字-（适用于C-C-）\" class=\"headerlink\" title=\"4.13.   不要直接使用数字 （适用于C/C++）\"></a>4.13.   不要直接使用数字 （适用于C/C++）</h2><p>²  直接使用数字，会使源代码难以理解和维护。如：</p>\n<pre><code>    if      (22 ==foo)    { start_thermo_nuclear_war(); }\n\n    else if (19 == foo)    {refund_lotso_money(); }\n\n    else if (16 == foo)    {infinite_loop(); }\n\n    else                   { cry_cause_im_lost(); }\n</code></pre><p>当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。</p>\n<p>²  我们可以用#define或者常量来改变这一状况，如：</p>\n<pre><code>    #define  PRESIDENT_WENT_CRAZY  (22)\n\n    const int WE_GOOFED= 19;\n\n    enum\n\n    {\n\n        THEY_DIDNT_PAY=16\n\n    };\n\n\n\n    if (PRESIDENT_WENT_CRAZY    == foo) { start_thermo_nuclear_war(); }\n\n    else if (WE_GOOFED          == foo)  {refund_lotso_money(); }\n\n    else if (THEY_DIDNT_PAY     == foo) { infinite_loop();}\n\n    else                                 {happy_days_i_know_why_im_here(); }\n</code></pre><h2 id=\"4-14-宏（适用于C-C-）\"><a href=\"#4-14-宏（适用于C-C-）\" class=\"headerlink\" title=\"4.14.    宏（适用于C/C++）\"></a>4.14.    宏（适用于C/C++）</h2><p>²  如果可以，使用内联函数代替宏。</p>\n<p>例如：</p>\n<pre><code>    #ifndef MAX\n\n    #define  MAX(x,y)  (((x) &gt; (y) ? (x) : (y))    // 取最大数\n\n    #endif\n</code></pre><p>使用内联函数可以达到相同的效果，而且更安全：</p>\n<pre><code>       inline int\n\n       max(int x, inty)\n\n       {\n\n          return (x&gt; y ? x : y);\n\n       }\n</code></pre><p>²  要注意副作用</p>\n<p>必须小心副作用，因为在调用表达式时，会发生潜在的错误。</p>\n<p>例如：</p>\n<pre><code>       MAX(f(x),z++);\n</code></pre><p>²  表达式总是用括号括起来</p>\n<p>在宏展开时，使用括号可以避免宏展开后产生的二义性。</p>\n<p>例如：</p>\n<pre><code>    #define ADD(x,y) x + y\n</code></pre><p>必须写成：</p>\n<pre><code>    #define ADD(x,y) ((x) + (y))\n</code></pre><p>²  保证宏名称的唯一性</p>\n<p>和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题：</p>\n<p>n  在宏名称前加上库的名字<br>避免使用简单而常用的名字，如：MAX 和MIN。</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/07/c++代码规范/","excerpt":"命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C+ 命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C++ 12 静态变量的命名前缀 适用于C 13 自定义类型typedef的命名 适用于C++ 14 宏定义的命名 适用于C++ 15 C 函数的命名 适用于C++ 16 枚举的命名 适用于C++ 排版规则 1 布局和模板 11 类的布局模板 适用于C 12 源文件格式 适用于C 13 保护头文件不被重复包含 适用于C++ 14 方法和函数的布局 适用于C++ 2 缩进制表符以及空格 适用于C++ 3 尽量使一行不要超过78个字母 适用于C++ 4 保证一行只写一条语句 适用于C++ 5 花括号 规则 适用于C++ 51 花括号的位置 52 什么时候应使用花括号 53 在花括号结束的位置加上注释 54 注意屏幕大小 6圆括号 规则 适用于C++ 7if else 语句的格式 适用于C++ 8switch 格式 适用于C++ 9 使用gotocontinuebreak 和 适用于C++ 91 Goto 92 Continue and Break 93 10 运算符号的规则 适用于C++ 11 变量声明语句块 适用于C++ 文档及注释 1 文件或程序库的文档注释 适用于C++ 2 类文档注释 适用于C++ 3 函数文档注释 适用于C++ 4 Include 语句注释 适用于C++ 5语句块注释 适用于C++ 编码要求 1 不要忽略编译器的警告 适用于C++ 2 应使用源代码管理器 适用于C++ 3 固有的类方法成员 适用于C 4 使用命名空间 适用于C 5 初始化所有的变量 适用于C++ 6 保持函数短小精悍 适用于C++ 7对空语句进行注释 适用于C++ 8不要用if语句的默认方法测试非零值 适用于C++ 9布尔类型 适用于C++ 10避免在语句中内含赋值 适用于C++ 11正确的使用Const 适用于C++ 12不要在头文件定义数据适用于C++ 13不要直接使用数字 适用于C++ 14宏 适用于C++","categories":[{"name":"代码规范","slug":"代码规范","permalink":"https://prostkhala.github.io/categories/代码规范/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://prostkhala.github.io/tags/代码规范/"}]}]}