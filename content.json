{"meta":{"title":"ST","subtitle":"A HAOIER","description":"每一个不曾起舞的日子，都是对于生命的辜负。","author":"ST","url":"https://prostkhala.github.io"},"pages":[{},{},{}],"posts":[{"title":"JSOI2006 同构","date":"2017-04-08T03:02:12.000Z","path":"2017/04/08/同构/","text":"JSOI2006 同构COGS1609 SGU282 题目描述 我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。 给你$N$,$M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 输入输出格式输入格式：输入一行三个整数$N,M,P(1&lt;=N&lt;=53,1&lt;=M&lt;=1000,P$是素数且$P&lt;=10^6)$。 输出格式：输出一行一个正整数，即互不同构的染色图数量模P的值。 输入输出样例输入样例：sample 1: 1 1 2 sample 2: 3 2 97 sample 3: 3 4 97 输出样例：sample 1: 1 sample 2: 4 sample 3: 20 题解对于本题来说，存在的置换共有 $n!$ 种（即n个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对n进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$ 以内。 对于每个置换，循环节的个数和长度已知，不妨设大小为$k$ 的循环有$c_k$个，则符合该结构的置换即为$\\frac {n!} {\\prod c_k!*k^{c_k}}$个。 再结合Polya定理，设第$k$个循环节的大小为$d_k$则该置换不动方案为$\\prod_k a^{dk/2} * \\prod{j&lt;k}a^{gcd()d_j,d_k}$个。 关于取模的问题，已知p是质数（p&gt;53???），易证两者互质，则可通过费马小定理求逆。 CODE#include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int N = 1e4+1; ll num[N],cnt[N],res,fac[N],n,m,p,ans; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} ll qpow(ll a,ll b) { ll ans=1; while(b) { if(b&amp;1)ans=(ans*a)%p; b&gt;&gt;=1;a=(a*a)%p; } return ans; } int dfs(ll now,ll maxl) { if(maxl==0) { ll a=1,b=0; for(int i=0;i&lt;res;i++) { a=a*qpow(num[i],cnt[i])%p*fac[cnt[i]]%p; b+=cnt[i]*(cnt[i]-1)/2*num[i]+num[i]/2*cnt[i]; for(ll j=i+1;j&lt;res;j++)b+=cnt[i]*cnt[j]*gcd(num[i],num[j]); } a=qpow(a,p-2)*fac[n]%p; ans=(ans+a*qpow(m,b)%p)%p; } if(now&gt;maxl)return 0; dfs(now+1,maxl); for(int i=1;i*now&lt;=maxl;i++) { num[res]=now,cnt[res++]=i; dfs(now+1,maxl-i*now); res--; } } int main() { // freopen(&quot;isomorphism.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;isomorphism.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;p); fac[0]=1;for(int i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%p; dfs(1,n); ans=ans*qpow(fac[n],p-2)%p; printf(&quot;%lld\\n&quot;,ans); }","raw":"title: JSOI2006 同构\ndate: 2017-04-08 11:02:12\ncategories:\n  - 群论\ntags:\n  - 群论\n  - 组合数学\n  - polya定理\n---\n\n# JSOI2006 同构\n\n## [COGS1609](http://cogs.pro/cogs/problem/problem.php?pid=1609)  [SGU282](http://acm.sgu.ru/problem.php?problem=282)\n\n---\n## 题目描述\n 我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。\n\n给你$N$,$M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 \n### 输入输出格式\n#### 输入格式：\n输入一行三个整数$N,M,P(1<=N<=53,1<=M<=1000,P$是素数且$P<=10^6)$。 \n\n#### 输出格式：\n\n输出一行一个正整数，即互不同构的染色图数量模P的值。 \n\n### 输入输出样例\n#### 输入样例：\n    sample 1:\n\n    1 1 2\n\n\n    sample 2:\n\n    3 2 97\n\n\n    sample 3:\n\n    3 4 97 \n\n#### 输出样例：\n    sample 1:\n\n    1\n\n\n    sample 2:\n\n    4\n\n\n    sample 3:\n\n    20 \n---\n\n## 题解\n对于本题来说，存在的置换共有 $n!$ 种（即n个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对n进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$ 以内。\n\n对于每个置换，循环节的个数和长度已知，不妨设大小为$k$ 的循环有$c_k$个，则符合该结构的置换即为$\\frac {n!}  {\\prod c_k!*k^{c_k}}$个。\n\n再结合Polya定理，设第$k$个循环节的大小为$d_k$\n则该置换不动方案为$\\prod_k a^{d_k/2} * \\prod_{j<k}a^{gcd()d_j,d_k}$个。\n\n关于取模的问题，已知p是质数（p>53???），易证两者互质，则可通过费马小定理求逆。\n\n\n---\n### CODE\n\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e4+1;\n    ll num[N],cnt[N],res,fac[N],n,m,p,ans;\n    ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} \n    ll qpow(ll a,ll b)\n    {\n        ll ans=1;\n        while(b)\n        {\n            if(b&1)ans=(ans*a)%p;\n            b>>=1;a=(a*a)%p;\n        }\n        return ans;\n    }\n    int dfs(ll now,ll maxl)\n    {\n        if(maxl==0)\n        {\n            ll a=1,b=0;\n            for(int i=0;i<res;i++)\n            {\n                a=a*qpow(num[i],cnt[i])%p*fac[cnt[i]]%p;\n                b+=cnt[i]*(cnt[i]-1)/2*num[i]+num[i]/2*cnt[i];\n                for(ll j=i+1;j<res;j++)b+=cnt[i]*cnt[j]*gcd(num[i],num[j]);\n            }\n            a=qpow(a,p-2)*fac[n]%p;\n            ans=(ans+a*qpow(m,b)%p)%p;\n        }\n        if(now>maxl)return 0;\n        dfs(now+1,maxl);\n        for(int i=1;i*now<=maxl;i++)\n        {\n            num[res]=now,cnt[res++]=i;\n            dfs(now+1,maxl-i*now);\n            res--;\n        }\n    }\n    int main()\n    {\t\n    //\tfreopen(\"isomorphism.in\",\"r\",stdin);\n    //\tfreopen(\"isomorphism.out\",\"w\",stdout);\n        scanf(\"%lld%lld%lld\",&n,&m,&p);\n        fac[0]=1;for(int i=1;i<N;i++)fac[i]=fac[i-1]*i%p;\n        dfs(1,n);\n        ans=ans*qpow(fac[n],p-2)%p;\n        printf(\"%lld\\n\",ans);\n    }","content":"<h1 id=\"JSOI2006-同构\"><a href=\"#JSOI2006-同构\" class=\"headerlink\" title=\"JSOI2006 同构\"></a>JSOI2006 同构</h1><h2 id=\"COGS1609-SGU282\"><a href=\"#COGS1609-SGU282\" class=\"headerlink\" title=\"COGS1609  SGU282\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1609\" target=\"_blank\" rel=\"external\">COGS1609</a>  <a href=\"http://acm.sgu.ru/problem.php?problem=282\" target=\"_blank\" rel=\"external\">SGU282</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p> 我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。</p>\n<p>给你$N$,$M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入一行三个整数$N,M,P(1&lt;=N&lt;=53,1&lt;=M&lt;=1000,P$是素数且$P&lt;=10^6)$。 </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出一行一个正整数，即互不同构的染色图数量模P的值。 </p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>sample 1:\n\n1 1 2\n\n\nsample 2:\n\n3 2 97\n\n\nsample 3:\n\n3 4 97 \n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>sample 1:\n\n1\n\n\nsample 2:\n\n4\n\n\nsample 3:\n\n20 \n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>对于本题来说，存在的置换共有 $n!$ 种（即n个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对n进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$ 以内。</p>\n<p>对于每个置换，循环节的个数和长度已知，不妨设大小为$k$ 的循环有$c_k$个，则符合该结构的置换即为$\\frac {n!}  {\\prod c_k!*k^{c_k}}$个。</p>\n<p>再结合Polya定理，设第$k$个循环节的大小为$d_k$<br>则该置换不动方案为$\\prod_k a^{d<em>k/2} * \\prod</em>{j&lt;k}a^{gcd()d_j,d_k}$个。</p>\n<p>关于取模的问题，已知p是质数（p&gt;53???），易证两者互质，则可通过费马小定理求逆。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e4+1;\nll num[N],cnt[N],res,fac[N],n,m,p,ans;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;} \nll qpow(ll a,ll b)\n{\n    ll ans=1;\n    while(b)\n    {\n        if(b&amp;1)ans=(ans*a)%p;\n        b&gt;&gt;=1;a=(a*a)%p;\n    }\n    return ans;\n}\nint dfs(ll now,ll maxl)\n{\n    if(maxl==0)\n    {\n        ll a=1,b=0;\n        for(int i=0;i&lt;res;i++)\n        {\n            a=a*qpow(num[i],cnt[i])%p*fac[cnt[i]]%p;\n            b+=cnt[i]*(cnt[i]-1)/2*num[i]+num[i]/2*cnt[i];\n            for(ll j=i+1;j&lt;res;j++)b+=cnt[i]*cnt[j]*gcd(num[i],num[j]);\n        }\n        a=qpow(a,p-2)*fac[n]%p;\n        ans=(ans+a*qpow(m,b)%p)%p;\n    }\n    if(now&gt;maxl)return 0;\n    dfs(now+1,maxl);\n    for(int i=1;i*now&lt;=maxl;i++)\n    {\n        num[res]=now,cnt[res++]=i;\n        dfs(now+1,maxl-i*now);\n        res--;\n    }\n}\nint main()\n{    \n//    freopen(&quot;isomorphism.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;isomorphism.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;p);\n    fac[0]=1;for(int i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%p;\n    dfs(1,n);\n    ans=ans*qpow(fac[n],p-2)%p;\n    printf(&quot;%lld\\n&quot;,ans);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/08/同构/","excerpt":"","categories":[{"name":"群论","slug":"群论","permalink":"https://prostkhala.github.io/categories/群论/"}],"tags":[{"name":"群论","slug":"群论","permalink":"https://prostkhala.github.io/tags/群论/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"},{"name":"polya定理","slug":"polya定理","permalink":"https://prostkhala.github.io/tags/polya定理/"}]},{"title":"裴蜀定理总结","date":"2017-03-28T09:42:15.000Z","path":"2017/03/28/裴蜀定理总结/","text":"裴蜀定理已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b) | d$。特别的，一定存在整数$x,y$使得$ax+by=gcd(a,b)$成立。","raw":"title: 裴蜀定理总结\ndate: 2017-03-28 17:42:15\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 最小公约数\n  - 扩展欧几里得\n  - 裴蜀定理\n---\n\n# 裴蜀定理\n\n已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b) | d$。特别的，一定存在整数$x,y$使得\n$ax+by=gcd(a,b)$成立。\n","content":"<h1 id=\"裴蜀定理\"><a href=\"#裴蜀定理\" class=\"headerlink\" title=\"裴蜀定理\"></a>裴蜀定理</h1><p>已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b) | d$。特别的，一定存在整数$x,y$使得<br>$ax+by=gcd(a,b)$成立。</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/28/裴蜀定理总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://prostkhala.github.io/tags/扩展欧几里得/"},{"name":"裴蜀定理","slug":"裴蜀定理","permalink":"https://prostkhala.github.io/tags/裴蜀定理/"},{"name":"最小公约数","slug":"最小公约数","permalink":"https://prostkhala.github.io/tags/最小公约数/"}]},{"title":"欧拉函数总结","date":"2017-03-28T02:33:17.000Z","path":"2017/03/28/欧拉函数总结/","text":"欧拉函数的定义 $\\varphi(n)$ 定义为1到n中与n互质的数的个数。 欧拉函数的求解1 . 通项公式 $ \\varphi(n)=n(1-1/p_1)(1-1/p2)…(1-1/p{tot}) $ (其中p为n的质因子，tot为质因子个数) int euler_phi(int n) { int m=(int)sqrt(n); int ans=n; for(int i=2;i&lt;=m;i++) { if(n%i==0) { ans=ans/i*(i-1);//ans*=(1-inv[i])？？； while(n%i==0) n/=i;//与分解质因数相结合 } } if(n&gt;1) ans=ans/n*(n-1); return ans; } 2 . 线性筛法逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前n项欧拉函数。 int prime[2*sqrt(N)+1],phi[N]; bool vis[N]; int tot; int getprime() { for(int i=2;i&lt;=N;++i) { if(!vis[i]) { prime[++tot]=i; phi[i]=i-1; } for(int t=1;t&lt;=tot&amp;&amp;prime[t]*i&lt;=N;++t) { vis[i*prime[t]]=true; if(i%prime[t]==0){phi[i*prime[t]]=phi[i]*prime[t];break;} phi[i*prime[t]]=phi[i]*(prime[t]-1); } } } 相关习题T1已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$ 证明设$T=lcm(1,2,…,p-1)$ 则有 $\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$ 此时只需证明 $T/1+T/2+…+T/(p-1)≡0(modp)$ 根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为 $1+2+…+(p-1)≡0(modp)$ $p*(p-1)≡0(modp)$ 得证。 T1 SDOI2008 沙拉公主的困惑题目描述大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。 输入输出格式输入格式第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n 输出格式共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值 输入输出样例输入样例1 11 4 2 输出样例1 数据范围对于100%的数据，1 &lt; = N , M &lt; = 10000000 题解题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$ 对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。 CODE#include&lt;cstdio&gt; #include&lt;iostream&gt; const int M = 1e6+1; using namespace std; bool vis[M+100]; long long prime[500500],ans[M+100],fac[M+100],rev[M+100]; int n,m,p,T,tot; int main() { scanf(&quot;%d%d&quot;,&amp;T,&amp;p); for(int i=2;i&lt;=M;i++) { if(!vis[i])prime[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++) { vis[prime[j]*i]=1; if(i%prime[j]==0) break; } } fac[1]=1; for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p; rev[1]=1; for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p; ans[1]=1; for(int i=2;i&lt;=M;i++) { if(!vis[i]) ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p; else ans[i]=ans[i-1]; } while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p); } }","raw":"title: 欧拉函数总结\ndate: 2017-03-28 10:33:17\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 线性筛法\n  - 欧拉函数\n---\n\n# 欧拉函数的定义\n $\\varphi(n)$ 定义为1到n中与n互质的数的个数。\n\n---\n# 欧拉函数的求解\n## 1 . 通项公式\n\n $ \\varphi(n)=n(1-1/p_1)(1-1/p_2)...(1-1/p_{tot}) $ (其中p为n的质因子，tot为质因子个数)\n\n    int euler_phi(int n)\n    {\n        int m=(int)sqrt(n);\n        int ans=n;\n        for(int i=2;i<=m;i++)\n        {\n            if(n%i==0)\n            {\n                ans=ans/i*(i-1);//ans*=(1-inv[i])？？；\n                while(n%i==0) n/=i;//与分解质因数相结合\n            }\n        }\n        if(n>1) ans=ans/n*(n-1);\n        return ans;\n    }\n## 2 . 线性筛法\n逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前n项欧拉函数。\n\n    int prime[2*sqrt(N)+1],phi[N];\n\n    bool vis[N];\n\n    int tot;\n    int getprime()\n    {\n        for(int i=2;i<=N;++i)\n        {\n            if(!vis[i])\n            {\n                prime[++tot]=i;\n                phi[i]=i-1;\n            }\n            for(int t=1;t<=tot&&prime[t]*i<=N;++t)\n            {\n                vis[i*prime[t]]=true;\n                if(i%prime[t]==0){phi[i*prime[t]]=phi[i]*prime[t];break;}\n                phi[i*prime[t]]=phi[i]*(prime[t]-1);\n            }\n        }\n    }\n---\n# 相关习题\n\n## T1\n已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$\n\n### 证明\n\n设$T=lcm(1,2,...,p-1)$\n\n则有\n\n$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+...+T/(p-1))/T$\n\n此时只需证明\n\n$T/1+T/2+...+T/(p-1)≡0(modp)$\n\n根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为\n\n$1+2+...+(p-1)≡0(modp)$\n\n$p*(p-1)≡0(modp)$\n\n得证。\n\n---\n## T1 SDOI2008 沙拉公主的困惑\n\n### 题目描述\n大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。\n### 输入输出格式\n#### 输入格式\n第一行为两个整数T，R。R<=10^9+10，T<=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m<=n\n#### 输出格式\n共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值\n### 输入输出样例\n#### 输入样例\n    1 11\n    4 2\n#### 输出样例\n\t1\n### 数据范围\n对于100%的数据，1 < = N , M < = 10000000\n\n---\n### 题解\n题意明确$n>=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$\n\n对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。\n\n---\n### CODE\n    #include<cstdio>\n    #include<iostream>\n    const int M = 1e6+1;\n    using namespace std;\n    bool vis[M+100];\n    long long prime[500500],ans[M+100],fac[M+100],rev[M+100];\n    int n,m,p,T,tot;\n    int main()\n    {\n        scanf(\"%d%d\",&T,&p);\n\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])prime[++tot]=i;\n            for(int j=1;j<=tot&&prime[j]*i<=M;j++)\n            {\n                vis[prime[j]*i]=1;\n                if(i%prime[j]==0)\n                    break;\n            }\n        }\n        fac[1]=1;\n        for(int i=2;i<=M;i++)fac[i]=fac[i-1]*i%p;\n        rev[1]=1;\n        for(int i=2;i<=M&&i<p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n        ans[1]=1;\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])\tans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n            else\t\t\t\tans[i]=ans[i-1];\n        }\n        while(T--)\n        {\n            scanf(\"%d%d\",&n,&m);\n            printf(\"%d\\n\",fac[n]*ans[m]%p);\n        }\n    }\n\n\n\n","content":"<h1 id=\"欧拉函数的定义\"><a href=\"#欧拉函数的定义\" class=\"headerlink\" title=\"欧拉函数的定义\"></a>欧拉函数的定义</h1><p> $\\varphi(n)$ 定义为1到n中与n互质的数的个数。</p>\n<hr>\n<h1 id=\"欧拉函数的求解\"><a href=\"#欧拉函数的求解\" class=\"headerlink\" title=\"欧拉函数的求解\"></a>欧拉函数的求解</h1><h2 id=\"1-通项公式\"><a href=\"#1-通项公式\" class=\"headerlink\" title=\"1 . 通项公式\"></a>1 . 通项公式</h2><p> $ \\varphi(n)=n(1-1/p_1)(1-1/p<em>2)…(1-1/p</em>{tot}) $ (其中p为n的质因子，tot为质因子个数)</p>\n<pre><code>int euler_phi(int n)\n{\n    int m=(int)sqrt(n);\n    int ans=n;\n    for(int i=2;i&lt;=m;i++)\n    {\n        if(n%i==0)\n        {\n            ans=ans/i*(i-1);//ans*=(1-inv[i])？？；\n            while(n%i==0) n/=i;//与分解质因数相结合\n        }\n    }\n    if(n&gt;1) ans=ans/n*(n-1);\n    return ans;\n}\n</code></pre><h2 id=\"2-线性筛法\"><a href=\"#2-线性筛法\" class=\"headerlink\" title=\"2 . 线性筛法\"></a>2 . 线性筛法</h2><p>逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前n项欧拉函数。</p>\n<pre><code>int prime[2*sqrt(N)+1],phi[N];\n\nbool vis[N];\n\nint tot;\nint getprime()\n{\n    for(int i=2;i&lt;=N;++i)\n    {\n        if(!vis[i])\n        {\n            prime[++tot]=i;\n            phi[i]=i-1;\n        }\n        for(int t=1;t&lt;=tot&amp;&amp;prime[t]*i&lt;=N;++t)\n        {\n            vis[i*prime[t]]=true;\n            if(i%prime[t]==0){phi[i*prime[t]]=phi[i]*prime[t];break;}\n            phi[i*prime[t]]=phi[i]*(prime[t]-1);\n        }\n    }\n}\n</code></pre><hr>\n<h1 id=\"相关习题\"><a href=\"#相关习题\" class=\"headerlink\" title=\"相关习题\"></a>相关习题</h1><h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a>T1</h2><p>已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$</p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>设$T=lcm(1,2,…,p-1)$</p>\n<p>则有</p>\n<p>$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$</p>\n<p>此时只需证明</p>\n<p>$T/1+T/2+…+T/(p-1)≡0(modp)$</p>\n<p>根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为</p>\n<p>$1+2+…+(p-1)≡0(modp)$</p>\n<p>$p*(p-1)≡0(modp)$</p>\n<p>得证。</p>\n<hr>\n<h2 id=\"T1-SDOI2008-沙拉公主的困惑\"><a href=\"#T1-SDOI2008-沙拉公主的困惑\" class=\"headerlink\" title=\"T1 SDOI2008 沙拉公主的困惑\"></a>T1 SDOI2008 沙拉公主的困惑</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h4><pre><code>1 11\n4 2\n</code></pre><h4 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h4><pre><code>1\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于100%的数据，1 &lt; = N , M &lt; = 10000000</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$</p>\n<p>对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\nconst int M = 1e6+1;\nusing namespace std;\nbool vis[M+100];\nlong long prime[500500],ans[M+100],fac[M+100],rev[M+100];\nint n,m,p,T,tot;\nint main()\n{\n    scanf(&quot;%d%d&quot;,&amp;T,&amp;p);\n\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])prime[++tot]=i;\n        for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++)\n        {\n            vis[prime[j]*i]=1;\n            if(i%prime[j]==0)\n                break;\n        }\n    }\n    fac[1]=1;\n    for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p;\n    rev[1]=1;\n    for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n    ans[1]=1;\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])    ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n        else                ans[i]=ans[i-1];\n    }\n    while(T--)\n    {\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p);\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/28/欧拉函数总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"线性筛法","slug":"线性筛法","permalink":"https://prostkhala.github.io/tags/线性筛法/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://prostkhala.github.io/tags/欧拉函数/"}]},{"title":"乘法逆元总结","date":"2017-03-28T02:33:17.000Z","path":"2017/03/28/乘法逆元总结/","text":"乘法逆元的定义若$ax≡1 (mod p)$, 则称a关于模p的乘法逆元为x。也可表示为$ax≡1(mod p)$。 当a与p互质时，a关于模p的乘法逆元有解。如果不互质，则无解。如果p为质数，则从1到p-1的任意数都与p互质，即在1到p-1之间都恰好有一个关于模p的乘法逆元。且1到p-1中的所有数的逆元对应1到p-1中的所有数，既是单射也是满射。 逆元的求解1 . 扩展欧几里得算法逆元一般通过EXGCD求解，该方法的时间复杂度为$O(logn)$。 int x, y;//NOIP 同余方程 int extgcd(int a, int b, int &amp;x, int &amp;y) { if (b == 0) { x = 1; y = 0; return a; } int gcd = exgcd(b, a % b, x, y); int tmp = x; x = y; y = tmp - (a/b) * y; return gcd; } //inv[n]=(x%p+x)%p; 2 . 费马小定理当$n$为质数时，同样可以通过费马小定理求解。已知$n^{p-1}≡ 1(mod p)$(费马小定理) 那么$inv[n]=n^{p-2} (mod p)$。该方法的时间复杂度为$O(logn)$（快速幂）。 3 . 线性求前$n$项的逆元 该方法时间复杂度为$O(n)$，可以同时处理前$n$个数在$modp$意义下的逆元。 递推式： $inv[1] = 1$ $inv[n] = inv [ p(mod n)]*(p-p/n)(modp)（n&gt;1）$ 证明： 设$t=p/n$，$k=p(modn)$ 则有 $t*n+k≡0(modp)$ $-t*n≡k(modp)$ 对原式除以$i*k$，得到 $-t*inv[k]≡invn$ 即 $-p/n*inv[p(modn)]≡invn$ $inv[n] = inv [ p(mod n)]*(p-p/n)(modp)$ 得证。 4 . 利用阶乘递推求前$n$项的逆元该方法较简单易懂，理论复杂度是方法3的3倍。据说在某些奇怪的时刻会跑的比上面快。(因为数组的连续访问) //fac为阶乘，rev为阶乘的逆元。 fac[0]=fac[1]=1; for(int i=2;i&lt;=N;i++)fac[i]=fac[i-1]*i%mod; rev[N]=mod_pow(fac[N],mod-2);//mod_pow为带取模的快速幂 for(int i=N-1;i&gt;=0;i--)rev[i]=rev[i+1]*(i+1)%mod; 相关习题T1已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$ 证明设$T=lcm(1,2,…,p-1)$ 则有 $\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$ 此时只需证明 $T/1+T/2+…+T/(p-1)≡0(modp)$ 根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为 $1+2+…+(p-1)≡0(modp)$ $p*(p-1)≡0(modp)$ 得证。 T2 SDOI2008 沙拉公主的困惑题目描述大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。 输入输出格式输入格式第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n 输出格式共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值 输入输出样例输入样例1 11 4 2 输出样例1 数据范围对于100%的数据，1 &lt; = N , M &lt; = 10000000 题解题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$ 对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。 CODE#include&lt;cstdio&gt; #include&lt;iostream&gt; const int M = 1e6+1; using namespace std; bool vis[M+100]; long long prime[500500],ans[M+100],fac[M+100],rev[M+100]; int n,m,p,T,tot; int main() { scanf(&quot;%d%d&quot;,&amp;T,&amp;p); for(int i=2;i&lt;=M;i++) { if(!vis[i])prime[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++) { vis[prime[j]*i]=1; if(i%prime[j]==0) break; } } fac[1]=1; for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p; rev[1]=1; for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p; ans[1]=1; for(int i=2;i&lt;=M;i++) { if(!vis[i]) ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p; else ans[i]=ans[i-1]; } while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p); } }","raw":"title: 乘法逆元总结\ndate: 2017-03-28 10:33:17\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 逆元\n  - 线性筛法\n  - 扩展欧几里得\n  - 欧拉函数\n---\n\n# 乘法逆元的定义\n若$ax≡1 (mod p)$, 则称a关于模p的乘法逆元为x。也可表示为$ax≡1(mod p)$。\n\n当a与p互质时，a关于模p的乘法逆元有解。如果不互质，则无解。如果p为质数，则从1到p-1的任意数都与p互质，即在1到p-1之间都恰好有一个关于模p的乘法逆元。且1到p-1中的所有数的逆元对应1到p-1中的所有数，既是单射也是满射。\n\n---\n# 逆元的求解\n## 1 . 扩展欧几里得算法\n逆元一般通过EXGCD求解，该方法的时间复杂度为$O(logn)$。\n\n    int x, y;//NOIP 同余方程    \n    int extgcd(int a, int b, int &x, int &y)    \n    {    \n        if (b == 0)\n        {    \n            x = 1;    \n            y = 0;    \n            return a;    \n        }    \n        int gcd = exgcd(b, a % b, x, y);    \n        int tmp = x;    \n        x = y;    \n        y = tmp - (a/b) * y;    \n        return gcd;    \n    }    //inv[n]=(x%p+x)%p;\n ---\n## 2 . 费马小定理\n当$n$为质数时，同样可以通过费马小定理求解。\n已知$n^{p-1}≡ 1(mod p)$(费马小定理)\n 那么$inv[n]=n^{p-2} (mod p)$。该方法的时间复杂度为$O(logn)$（快速幂）。\n \n ---\n ## 3 . 线性求前$n$项的逆元\n 该方法时间复杂度为$O(n)$，可以同时处理前$n$个数在$modp$意义下的逆元。\n \n 递推式：\n \n $inv[1] = 1$\n \n $inv[n] = inv [ p(mod n)]*(p-p/n)(modp)（n>1）$\n \n ### 证明：\n \n 设$t=p/n$，$k=p(modn)$\n\n则有\n\n$t*n+k≡0(modp)$\n\n$-t*n≡k(modp)$\n\n对原式除以$i*k$，得到\n\n$-t*inv[k]≡inv[n](modp)$\n\n即\n\n$-p/n*inv[p(modn)]≡inv[n](modp)$\n\n$inv[n] = inv [ p(mod n)]*(p-p/n)(modp)$\n\n得证。\n\n---\n## 4 . 利用阶乘递推求前$n$项的逆元\n该方法较简单易懂，理论复杂度是方法3的3倍。据说在某些奇怪的时刻会跑的比上面快。(因为数组的连续访问)\n\n\t//fac为阶乘，rev为阶乘的逆元。\n    fac[0]=fac[1]=1;\n\n    for(int i=2;i<=N;i++)fac[i]=fac[i-1]*i%mod;\n\n    rev[N]=mod_pow(fac[N],mod-2);//mod_pow为带取模的快速幂\n\n    for(int i=N-1;i>=0;i--)rev[i]=rev[i+1]*(i+1)%mod;\n\n---\n# 相关习题\n\n## T1\n已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$\n\n### 证明\n\n设$T=lcm(1,2,...,p-1)$\n\n则有\n\n$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+...+T/(p-1))/T$\n\n此时只需证明\n\n$T/1+T/2+...+T/(p-1)≡0(modp)$\n\n根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为\n\n$1+2+...+(p-1)≡0(modp)$\n\n$p*(p-1)≡0(modp)$\n\n得证。\n\n---\n## T2 SDOI2008 沙拉公主的困惑\n\n### 题目描述\n大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。\n### 输入输出格式\n#### 输入格式\n第一行为两个整数T，R。R<=10^9+10，T<=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m<=n\n#### 输出格式\n共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值\n### 输入输出样例\n#### 输入样例\n    1 11\n    4 2\n#### 输出样例\n\t1\n### 数据范围\n对于100%的数据，1 < = N , M < = 10000000\n\n---\n### 题解\n题意明确$n>=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$\n\n对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。\n\n---\n### CODE\n    #include<cstdio>\n    #include<iostream>\n    const int M = 1e6+1;\n    using namespace std;\n    bool vis[M+100];\n    long long prime[500500],ans[M+100],fac[M+100],rev[M+100];\n    int n,m,p,T,tot;\n    int main()\n    {\n        scanf(\"%d%d\",&T,&p);\n\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])prime[++tot]=i;\n            for(int j=1;j<=tot&&prime[j]*i<=M;j++)\n            {\n                vis[prime[j]*i]=1;\n                if(i%prime[j]==0)\n                    break;\n            }\n        }\n        fac[1]=1;\n        for(int i=2;i<=M;i++)fac[i]=fac[i-1]*i%p;\n        rev[1]=1;\n        for(int i=2;i<=M&&i<p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n        ans[1]=1;\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])\tans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n            else\t\t\t\tans[i]=ans[i-1];\n        }\n        while(T--)\n        {\n            scanf(\"%d%d\",&n,&m);\n            printf(\"%d\\n\",fac[n]*ans[m]%p);\n        }\n    }\n","content":"<h1 id=\"乘法逆元的定义\"><a href=\"#乘法逆元的定义\" class=\"headerlink\" title=\"乘法逆元的定义\"></a>乘法逆元的定义</h1><p>若$ax≡1 (mod p)$, 则称a关于模p的乘法逆元为x。也可表示为$ax≡1(mod p)$。</p>\n<p>当a与p互质时，a关于模p的乘法逆元有解。如果不互质，则无解。如果p为质数，则从1到p-1的任意数都与p互质，即在1到p-1之间都恰好有一个关于模p的乘法逆元。且1到p-1中的所有数的逆元对应1到p-1中的所有数，既是单射也是满射。</p>\n<hr>\n<h1 id=\"逆元的求解\"><a href=\"#逆元的求解\" class=\"headerlink\" title=\"逆元的求解\"></a>逆元的求解</h1><h2 id=\"1-扩展欧几里得算法\"><a href=\"#1-扩展欧几里得算法\" class=\"headerlink\" title=\"1 . 扩展欧几里得算法\"></a>1 . 扩展欧几里得算法</h2><p>逆元一般通过EXGCD求解，该方法的时间复杂度为$O(logn)$。</p>\n<pre><code>int x, y;//NOIP 同余方程    \nint extgcd(int a, int b, int &amp;x, int &amp;y)    \n{    \n    if (b == 0)\n    {    \n        x = 1;    \n        y = 0;    \n        return a;    \n    }    \n    int gcd = exgcd(b, a % b, x, y);    \n    int tmp = x;    \n    x = y;    \n    y = tmp - (a/b) * y;    \n    return gcd;    \n}    //inv[n]=(x%p+x)%p;\n</code></pre><hr>\n<h2 id=\"2-费马小定理\"><a href=\"#2-费马小定理\" class=\"headerlink\" title=\"2 . 费马小定理\"></a>2 . 费马小定理</h2><p>当$n$为质数时，同样可以通过费马小定理求解。<br>已知$n^{p-1}≡ 1(mod p)$(费马小定理)<br> 那么$inv[n]=n^{p-2} (mod p)$。该方法的时间复杂度为$O(logn)$（快速幂）。</p>\n<hr>\n<h2 id=\"3-线性求前-n-项的逆元\"><a href=\"#3-线性求前-n-项的逆元\" class=\"headerlink\" title=\"3 . 线性求前$n$项的逆元\"></a>3 . 线性求前$n$项的逆元</h2><p> 该方法时间复杂度为$O(n)$，可以同时处理前$n$个数在$modp$意义下的逆元。</p>\n<p> 递推式：</p>\n<p> $inv[1] = 1$</p>\n<p> $inv[n] = inv [ p(mod n)]*(p-p/n)(modp)（n&gt;1）$</p>\n<h3 id=\"证明：\"><a href=\"#证明：\" class=\"headerlink\" title=\"证明：\"></a>证明：</h3><p> 设$t=p/n$，$k=p(modn)$</p>\n<p>则有</p>\n<p>$t*n+k≡0(modp)$</p>\n<p>$-t*n≡k(modp)$</p>\n<p>对原式除以$i*k$，得到</p>\n<p>$-t*inv[k]≡inv<a href=\"modp\">n</a>$</p>\n<p>即</p>\n<p>$-p/n*inv[p(modn)]≡inv<a href=\"modp\">n</a>$</p>\n<p>$inv[n] = inv [ p(mod n)]*(p-p/n)(modp)$</p>\n<p>得证。</p>\n<hr>\n<h2 id=\"4-利用阶乘递推求前-n-项的逆元\"><a href=\"#4-利用阶乘递推求前-n-项的逆元\" class=\"headerlink\" title=\"4 . 利用阶乘递推求前$n$项的逆元\"></a>4 . 利用阶乘递推求前$n$项的逆元</h2><p>该方法较简单易懂，理论复杂度是方法3的3倍。据说在某些奇怪的时刻会跑的比上面快。(因为数组的连续访问)</p>\n<pre><code>//fac为阶乘，rev为阶乘的逆元。\nfac[0]=fac[1]=1;\n\nfor(int i=2;i&lt;=N;i++)fac[i]=fac[i-1]*i%mod;\n\nrev[N]=mod_pow(fac[N],mod-2);//mod_pow为带取模的快速幂\n\nfor(int i=N-1;i&gt;=0;i--)rev[i]=rev[i+1]*(i+1)%mod;\n</code></pre><hr>\n<h1 id=\"相关习题\"><a href=\"#相关习题\" class=\"headerlink\" title=\"相关习题\"></a>相关习题</h1><h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a>T1</h2><p>已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$</p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>设$T=lcm(1,2,…,p-1)$</p>\n<p>则有</p>\n<p>$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$</p>\n<p>此时只需证明</p>\n<p>$T/1+T/2+…+T/(p-1)≡0(modp)$</p>\n<p>根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为</p>\n<p>$1+2+…+(p-1)≡0(modp)$</p>\n<p>$p*(p-1)≡0(modp)$</p>\n<p>得证。</p>\n<hr>\n<h2 id=\"T2-SDOI2008-沙拉公主的困惑\"><a href=\"#T2-SDOI2008-沙拉公主的困惑\" class=\"headerlink\" title=\"T2 SDOI2008 沙拉公主的困惑\"></a>T2 SDOI2008 沙拉公主的困惑</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h4><pre><code>1 11\n4 2\n</code></pre><h4 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h4><pre><code>1\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于100%的数据，1 &lt; = N , M &lt; = 10000000</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$</p>\n<p>对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\nconst int M = 1e6+1;\nusing namespace std;\nbool vis[M+100];\nlong long prime[500500],ans[M+100],fac[M+100],rev[M+100];\nint n,m,p,T,tot;\nint main()\n{\n    scanf(&quot;%d%d&quot;,&amp;T,&amp;p);\n\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])prime[++tot]=i;\n        for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++)\n        {\n            vis[prime[j]*i]=1;\n            if(i%prime[j]==0)\n                break;\n        }\n    }\n    fac[1]=1;\n    for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p;\n    rev[1]=1;\n    for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n    ans[1]=1;\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])    ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n        else                ans[i]=ans[i-1];\n    }\n    while(T--)\n    {\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p);\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/28/乘法逆元总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"逆元","slug":"逆元","permalink":"https://prostkhala.github.io/tags/逆元/"},{"name":"线性筛法","slug":"线性筛法","permalink":"https://prostkhala.github.io/tags/线性筛法/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://prostkhala.github.io/tags/扩展欧几里得/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://prostkhala.github.io/tags/欧拉函数/"}]},{"title":"NOI2005 维修数列","date":"2017-03-21T14:13:15.000Z","path":"2017/03/21/维护队列/","text":"NOI2005 维护数列洛谷2042 COGS339 题目描述 请写一个程序，要求维护一个数列，支持以下 6 种操作：（请注意，格式栏 中的下划线‘ _ ’表示实际输入文件中的空格） 操作编号 输入文件中的格式 说明 1. 插入 INSERT_posi_tot_c1_c2_..._ctot 在当前数列的第 posi 个数字后插入 tot个数字：c1, c2, …, ctot；若在数列首插入，则 posi 为 0 2. 删除 DELETE_posi_tot 从当前数列的第 posi 个数字开始连续删除 tot 个数字 3. 修改 MAKE-SAME_posi_tot_c 将当前数列的第 posi 个数字开始的连续 tot 个数字统一修改为 c 4. 翻转 REVERSE_posi_tot 取出从当前数列的第 posi 个数字开始的 tot 个数字，翻转后放入原来的位置 5. 求和 GET-SUM_posi_tot 计算从当前数列开始的第 posi 个数字开始的 tot 个数字的和并输出 6. 求和最大的子列 MAX-SUM 求出当前数列中和最大的一段子列，并输出最大和 输入输出格式输入格式： 输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M表示要进行的操作数目。 第 2 行包含 N 个数字，描述初始时的数列。 以下 M 行，每行一条命令，格式参见问题描述中的表格。 输出格式：对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结果，每个答案（数字）占一行。 输入输出样例输入样例：9 8 2 -6 3 5 1 -5 -3 6 3 GET-SUM 5 4 MAX-SUM INSERT 8 3 -5 7 2 DELETE 12 1 MAKE-SAME 3 3 2 REVERSE 3 6 GET-SUM 5 4 MAX-SUM 输出样例：-1 10 1 10 数据范围你可以认为在任何时刻，数列中至少有 1 个数。 输入数据一定是正确的，即指定位置的数在数列中一定存在。 50%的数据中，任何时刻数列中最多含有 30 000 个数； 100%的数据中，任何时刻数列中最多含有 500 000 个数。 100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。 100%的数据中，M ≤20 000，插入的数字总数不超过 4 000 000 个，输入文件大小不超过 20MBytes。 题解对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立二分搜索树，而不应直接插入，否则会导致时间复杂度过高，同时操作后也要注意更新信息。 对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。 对于求和操作，具体实现与线段树相同。 对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。 （一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入4e6个元素，但同时也说明队列中最多只有5e5个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用。） CODE V1（暴力）#include&lt;iostream&gt; #include&lt;cstdio&gt; const int N = 4e6+5; const int inf = 0x7fffffff; using namespace std; int tot,root,rev[N],size[N],w[N],fa[N],son[N][2],id[N]; void update(int x) { size[x]=size[son[x][0]]+size[son[x][1]]+1; } void pushdown(int x) { if(rev[x]) { swap(son[x][0],son[x][1]); rev[son[x][0]]^=1; rev[son[x][1]]^=1; rev[x]=0; } return; } void zg(int x) { pushdown(fa[x]),pushdown(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(z) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; update(y);update(x); } void splay(int x,int f) { while(fa[x]!=f) { int y=fa[x],z=fa[y]; if(z!=f) { if(son[z][0]==y^son[y][0]==x) zg(x); else zg(y); } zg(x); } if(!f) root=x; } void insert(int &amp;x,int v,int f) { if(!x) { x=++tot; son[x][0]=son[x][1]=0; size[x]=1; w[x]=v;fa[x]=f; splay(x,0); return; } insert(son[x][v&gt;w[x]],v,x); update(x); } int get(int v) { int x=root; while(x&amp;&amp;v!=w[x]) x=son[x][v&gt;w[x]]; return x; } int find(int k,int rank) { pushdown(k); int l=son[k][0],r=son[k][1]; if(size[l]+1==rank)return k; else if(size[l]&gt;=rank)return find(l,rank); else return find(r,rank-size[l]-1); } int a[N]; char op[19]; int sum1,ans1,max1; int inorder(int x) { pushdown(x); if(son[x][0])inorder(son[x][0]); if(w[x]!=inf&amp;&amp;w[x]!=-inf)printf(&quot;%d &quot;,a[w[x]]); if(son[x][1])inorder(son[x][1]); } int inordermax(int x) { pushdown(x); if(son[x][0])inordermax(son[x][0]); if(w[x]!=inf&amp;&amp;w[x]!=-inf) { max1=max(max1,a[w[x]]); sum1+=a[w[x]]*num[x]; if(sum1&gt;0)ans1=max(ans1,sum1); else sum1=0; } if(son[x][1])inordermax(son[x][1]); } int main() { // freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout); int n,m,tmp; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); insert(root,-inf,0);insert(root,inf,0); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i); for(int i=1;i&lt;=n;++i)insert(root,i,0); tmp=n; for(int i=1,pos,tt,x;i&lt;=m;++i) { scanf(&quot;%s&quot;,op); if(op[0]==&#39;I&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int now=find(root,pos+1),ne=find(root,pos+2); update(now),update(ne); splay(now,0);splay(ne,root); for(int i=1;i&lt;=tt;++i)scanf(&quot;%d&quot;,&amp;a[++tmp]),insert(son[ne][0],tmp,ne); update(root),update(son[root][1]); } if(op[0]==&#39;D&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int now=find(root,pos),ne=find(root,pos+tt+1); splay(now,0);splay(ne,root); fa[son[ne][0]]=0; son[ne][0]=0; update(ne);update(now); } if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;) { scanf(&quot;%d%d%d&quot;,&amp;pos,&amp;tt,&amp;x); for(int t=pos+1;t&lt;=pos+tt;++t) a[w[find(root,t)]]=x; } if(op[0]==&#39;R&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int now=find(root,pos),ne=find(root,pos+tt+1); update(now),update(ne); splay(now,0);splay(ne,root); int s=son[ne][0]; rev[s]^=1; } if(op[0]==&#39;G&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int sum=0; for(int t=1;t&lt;=tt;++t) sum+=a[find(root,pos+t)-2]; printf(&quot;%d\\n&quot;,sum); } if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;) { sum1=ans1=0;max1=-0x7fffffff; inordermax(root); printf(&quot;%d\\n&quot;,ans1==0?max1:ans1); } } // inorder(root); } CODE V2#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; const int inf = 1e9; const int N = 1e6+1; inline int read() { int x=0,f=1;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} return x*f; } int n,m,root,cnt; int sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][2];; bool tag[N],rev[N]; queue&lt;int&gt;q; void pushdown(int x) { int sonl=son[x][0],sonr=son[x][1]; if(tag[x]) { if(sonl)tag[sonl]=true,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl]; if(sonr)tag[sonr]=true,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr]; if(v[x]&gt;=0) { if(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl]; if(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr]; } else { if(sonl)lx[sonl]=rx[sonl]=0,mx[sonl]=v[x]; if(sonr)lx[sonr]=rx[sonr]=0,mx[sonr]=v[x]; } rev[x]=tag[x]=0; } if(rev[x]) { rev[x]^=1;rev[sonl]^=1;rev[sonr]^=1; swap(lx[sonl],rx[sonl]);swap(lx[sonr],rx[sonr]); swap(son[sonl][0],son[sonl][1]);swap(son[sonr][0],son[sonr][1]); } } int inorder(int x) { pushdown(x); if(son[x][0])inorder(son[x][0]); if(v[x]!=inf&amp;&amp;v[x]!=-inf)printf(&quot;%d &quot;,v[x]); if(son[x][1])inorder(son[x][1]); } void update(int x) { int sonl=son[x][0],sonr=son[x][1]; sum[x]=sum[sonl]+sum[sonr]+v[x]; size[x]=size[sonl]+size[sonr]+1; mx[x]=max(mx[sonl],mx[sonr]); mx[x]=max(mx[x],rx[sonl]+v[x]+lx[sonr]); lx[x]=max(lx[sonl],sum[sonl]+v[x]+lx[sonr]); rx[x]=max(rx[sonr],sum[sonr]+v[x]+rx[sonl]); } void rotate(int x,int &amp;k) { int y=fa[x],z=fa[y],l,r; l=(son[y][1]==x);r=l^1; if(y==k)k=x; else son[z][son[z][1]==y]=x; fa[son[x][r]]=y;fa[y]=x;fa[x]=z; son[y][l]=son[x][r];son[x][r]=y; update(y);update(x); } void splay(int x,int &amp;k) { while(x!=k) { int y=fa[x],z=fa[y]; if(y!=k) { if(son[y][0]==x^son[z][0]==y)rotate(x,k); else rotate(y,k); } rotate(x,k); } } int find(int x,int rk) { pushdown(x); int l=son[x][0],r=son[x][1]; if(size[l]+1==rk)return x; if(size[l]&gt;=rk)return find(l,rk); return find(r,rk-size[l]-1); } void rec(int x) { if(!x)return; int l=son[x][0],r=son[x][1]; rec(l);rec(r);q.push(x); fa[x]=son[x][0]=son[x][1]=0; tag[x]=rev[x]=0; } int split(int k,int tt) { int x=find(root,k),y=find(root,k+tt+1); splay(x,root);splay(y,son[x][1]); return son[y][0]; } void modify(int k,int tt,int val) { int x=split(k,tt),y=fa[x]; v[x]=val;tag[x]=1;sum[x]=size[x]*val; if(val&gt;=0)lx[x]=rx[x]=mx[x]=sum[x]; else lx[x]=rx[x]=0,mx[x]=val; update(y);update(fa[y]); } void rever(int k,int tt) { int x=split(k,tt),y=fa[x]; if(!tag[x]) { rev[x]^=1; swap(son[x][0],son[x][1]); swap(lx[x],rx[x]); update(y);update(fa[y]); } } void delet(int k,int tt) { int x=split(k,tt),y=fa[x]; rec(x);son[y][0]=0; update(y);update(fa[y]); } void build(int l,int r,int s) { if(l&gt;r)return; int mid=(l+r)&gt;&gt;1,now=id[mid],last=id[s]; if(l==r) { sum[now]=a[l];size[now]=1; tag[now]=rev[now]=0; if(a[l]&gt;=0)lx[now]=rx[now]=mx[now]=a[l]; else lx[now]=rx[now]=0,mx[now]=a[l]; } else build(l,mid-1,mid),build(mid+1,r,mid); v[now]=a[mid];fa[now]=last;update(now); son[last][mid&gt;=s]=now; } void insert(int k,int tt) { for(int i=1;i&lt;=tt;i++)a[i]=read(); for(int i=1;i&lt;=tt;i++) if(!q.empty())id[i]=q.front(),q.pop(); else id[i]=++cnt; build(1,tt,0);int z=id[(1+tt)&gt;&gt;1]; int x=find(root,k+1),y=find(root,k+2); splay(x,root);splay(y,son[x][1]); fa[z]=y;son[y][0]=z; update(y);update(x); } int main() { // freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); mx[0]=a[1]=a[n+2]=-inf; for(int i=2;i&lt;=n+1;i++)a[i]=read(); for(int i=1;i&lt;=n+2;i++)id[i]=i; build(1,n+2,0); root=(n+3)&gt;&gt;1;cnt=n+2; int k,tt,val; char op[19]; for(int i=1;i&lt;=m;++i) { scanf(&quot;%s&quot;,op); if(op[0]==&#39;I&#39;)k=read(),tt=read(),insert(k,tt); if(op[0]==&#39;D&#39;)k=read(),tt=read(),delet(k,tt); if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;)printf(&quot;%d\\n&quot;,mx[root]); if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;)k=read(),tt=read(),val=read(),modify(k,tt,val); if(op[0]==&#39;R&#39;)k=read(),tt=read(),rever(k,tt); if(op[0]==&#39;G&#39;){k=read(),tt=read();printf(&quot;%d\\n&quot;,sum[split(k,tt)]);} } // inorder(root); }","raw":"title: NOI2005 维修数列\ndate: 2017-03-21 22:13:15\ncategories:\n  - 平衡树\n  - SPLAY\ntags:\n  - SPLAY\n---\n\n# NOI2005 维护数列\n\n## [洛谷2042](https://www.luogu.org/problem/show?pid=2042) [COGS339](http://cogs.pro/cogs/problem/problem.php?pid=339)\n\n---\n## 题目描述\n 请写一个程序，要求维护一个数列，支持以下 6 种操作：（请注意，格式栏 中的下划线‘ _ ’表示实际输入文件中的空格）\n\n    操作编号\t输入文件中的格式\t说明\n\n\n    1.  插入\tINSERT_posi_tot_c1_c2_..._ctot\n\t在当前数列的第 posi 个数字后插入 tot个数字：c1, c2, …, ctot；若在数列首插入，则 posi 为 0\n\n    2.  删除\tDELETE_posi_tot\n    从当前数列的第 posi 个数字开始连续删除 tot 个数字\n\n    3.  修改\tMAKE-SAME_posi_tot_c\n\t 将当前数列的第 posi 个数字开始的连续 tot 个数字统一修改为 c\n\n    4.  翻转\tREVERSE_posi_tot\n \t取出从当前数列的第 posi 个数字开始的 tot 个数字，翻转后放入原来的位置\n    \n    5.  求和\tGET-SUM_posi_tot\n\t计算从当前数列开始的第 posi 个数字开始的 tot 个数字的和并输出\n\n    6.  求和最大的子列\tMAX-SUM\n\t求出当前数列中和最大的一段子列，并输出最大和 \n### 输入输出格式\n#### 输入格式：\n 输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M表示要进行的操作数目。\n\n第 2 行包含 N 个数字，描述初始时的数列。\n\n以下 M 行，每行一条命令，格式参见问题描述中的表格。 \n\n\n#### 输出格式：\n\n对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结果，每个答案（数字）占一行。 \n\n### 输入输出样例\n#### 输入样例：\n    9 8\n    2 -6 3 5 1 -5 -3 6 3\n    GET-SUM 5 4\n    MAX-SUM INSERT 8 3 -5 7 2\n    DELETE 12 1\n    MAKE-SAME 3 3 2\n    REVERSE 3 6\n    GET-SUM 5 4\n    MAX-SUM\n    \n\n#### 输出样例：\n    -1\n    10\n    1\n    10\n    \n\n### 数据范围\n\n你可以认为在任何时刻，数列中至少有 1 个数。\n\n输入数据一定是正确的，即指定位置的数在数列中一定存在。\n\n50%的数据中，任何时刻数列中最多含有 30 000 个数；\n\n100%的数据中，任何时刻数列中最多含有 500 000 个数。\n\n100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。\n\n100%的数据中，M ≤20 000，插入的数字总数不超过 4 000 000 个，输入文件大小不超过 20MBytes。\n\n---\n\n## 题解\n对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立二分搜索树，而不应直接插入，否则会导致时间复杂度过高，同时操作后也要注意更新信息。\n\n对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。\n\n对于求和操作，具体实现与线段树相同。\n\n对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。\n\n（一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入4e6个元素，但同时也说明队列中最多只有5e5个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用。）\n\n---\n### CODE V1（暴力）\n    #include<iostream>\n    #include<cstdio>\n    const int N = 4e6+5;\n    const int inf = 0x7fffffff;\n    using namespace std;\n    int tot,root,rev[N],size[N],w[N],fa[N],son[N][2],id[N];\n    void update(int x)\n    {\n        size[x]=size[son[x][0]]+size[son[x][1]]+1;\n    }\n    void pushdown(int x)\n    {\n        if(rev[x])\n        {\n            swap(son[x][0],son[x][1]);\n            rev[son[x][0]]^=1;\n            rev[son[x][1]]^=1;\n            rev[x]=0;\n        }\n        return;\n    }\n    void zg(int x)\n    {\n        pushdown(fa[x]),pushdown(x);\n        int y=fa[x],z=fa[y],t=(son[y][0]==x);\n        if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n        son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n        son[x][t]=y;fa[y]=x;\n        update(y);update(x);\n    }\n    void splay(int x,int f)\n    {\n        while(fa[x]!=f)\n        {\n            int y=fa[x],z=fa[y];\n            if(z!=f)\n            {\n                if(son[z][0]==y^son[y][0]==x) zg(x);\n                else zg(y);\n            } \n            zg(x);\t\n        }\n        if(!f) root=x;\n    }\n    void insert(int &x,int v,int f)\n    {\n        if(!x)\n        {\n            x=++tot;\n            son[x][0]=son[x][1]=0;\n            size[x]=1;\n            w[x]=v;fa[x]=f;\n            splay(x,0);\n            return;\n        }\n        insert(son[x][v>w[x]],v,x);\n        update(x);\n    }\n    int get(int v)\n    {\n        int x=root;\n        while(x&&v!=w[x]) x=son[x][v>w[x]];\n        return x;\n    }\n    int find(int k,int rank)\n    {\n        pushdown(k);\n        int l=son[k][0],r=son[k][1];\n        if(size[l]+1==rank)return k;\n        else if(size[l]>=rank)return find(l,rank);\n        else return find(r,rank-size[l]-1);\n    }\n    int a[N];\n    char op[19];\n    int sum1,ans1,max1;\n    int inorder(int x)\n    {\n        pushdown(x);\n        if(son[x][0])inorder(son[x][0]);\n        if(w[x]!=inf&&w[x]!=-inf)printf(\"%d \",a[w[x]]);\n        if(son[x][1])inorder(son[x][1]);\n    }\n    int inordermax(int x)\n    {\n        pushdown(x);\n        if(son[x][0])inordermax(son[x][0]);\n        if(w[x]!=inf&&w[x]!=-inf)\n        {\n            max1=max(max1,a[w[x]]);\n            sum1+=a[w[x]]*num[x];\n            if(sum1>0)ans1=max(ans1,sum1);\n            else\tsum1=0;\n        }\n        if(son[x][1])inordermax(son[x][1]);\n    }\n\n    int main()\n    {\n    //\tfreopen(\"seq2005.in\",\"r\",stdin);\n    //\tfreopen(\"seq2005.out\",\"w\",stdout);\n        int n,m,tmp;\n        scanf(\"%d%d\",&n,&m);\n        insert(root,-inf,0);insert(root,inf,0);\n        for(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n        for(int i=1;i<=n;++i)insert(root,i,0);\n        tmp=n;\n        for(int i=1,pos,tt,x;i<=m;++i)\n        {\n            scanf(\"%s\",op);\n            if(op[0]=='I')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int now=find(root,pos+1),ne=find(root,pos+2);\n                update(now),update(ne);\n                splay(now,0);splay(ne,root);\n                for(int i=1;i<=tt;++i)scanf(\"%d\",&a[++tmp]),insert(son[ne][0],tmp,ne);\n                update(root),update(son[root][1]);\n            }\n            if(op[0]=='D')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int now=find(root,pos),ne=find(root,pos+tt+1);\n                splay(now,0);splay(ne,root);\n                fa[son[ne][0]]=0;\n                son[ne][0]=0;\n                update(ne);update(now);\n            }\n            if(op[0]=='M'&&op[2]=='K')\n            {\n                scanf(\"%d%d%d\",&pos,&tt,&x);\n                for(int t=pos+1;t<=pos+tt;++t)\n                a[w[find(root,t)]]=x;\n            }\n            if(op[0]=='R')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int now=find(root,pos),ne=find(root,pos+tt+1);\n                update(now),update(ne);\n                splay(now,0);splay(ne,root);\n                int s=son[ne][0];\n                rev[s]^=1;\n            }\n            if(op[0]=='G')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int sum=0;\n                for(int t=1;t<=tt;++t)\n                sum+=a[find(root,pos+t)-2];\n                printf(\"%d\\n\",sum);\n            }\n            if(op[0]=='M'&&op[2]=='X')\n            {\n                sum1=ans1=0;max1=-0x7fffffff;\n                inordermax(root);\n                printf(\"%d\\n\",ans1==0?max1:ans1);\n            }\n        }\n        //\tinorder(root);\n    }\n    \n    \n ---\n ### CODE V2\n \n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #include<queue>\n    using namespace std;\n    const int inf = 1e9;\n    const int N = 1e6+1;\n    inline int read()\n    {\n        int x=0,f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n        return x*f;\n    }\n    int n,m,root,cnt;\n    int sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][2];;\n    bool tag[N],rev[N];\n    queue<int>q;\n    void pushdown(int x)\n    {\n        int sonl=son[x][0],sonr=son[x][1];\n        if(tag[x])\n        {\n\n            if(sonl)tag[sonl]=true,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl];\n            if(sonr)tag[sonr]=true,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr];\n            if(v[x]>=0)\n            {\n                if(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl];\n                if(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr];\n            }\n            else \n            {\n                if(sonl)lx[sonl]=rx[sonl]=0,mx[sonl]=v[x];\n                if(sonr)lx[sonr]=rx[sonr]=0,mx[sonr]=v[x];\n            }\n            rev[x]=tag[x]=0;\n        }\n        if(rev[x])\n        {\n            rev[x]^=1;rev[sonl]^=1;rev[sonr]^=1;\n            swap(lx[sonl],rx[sonl]);swap(lx[sonr],rx[sonr]);\n            swap(son[sonl][0],son[sonl][1]);swap(son[sonr][0],son[sonr][1]);\n        }\n    }\n    int inorder(int x)\n    {\n        pushdown(x);\n        if(son[x][0])inorder(son[x][0]);\n        if(v[x]!=inf&&v[x]!=-inf)printf(\"%d \",v[x]);\n        if(son[x][1])inorder(son[x][1]);\n    }\n    void update(int x)\n    {\n        int sonl=son[x][0],sonr=son[x][1];\n        sum[x]=sum[sonl]+sum[sonr]+v[x];\n        size[x]=size[sonl]+size[sonr]+1;\n        mx[x]=max(mx[sonl],mx[sonr]);\n        mx[x]=max(mx[x],rx[sonl]+v[x]+lx[sonr]);\n        lx[x]=max(lx[sonl],sum[sonl]+v[x]+lx[sonr]);\n        rx[x]=max(rx[sonr],sum[sonr]+v[x]+rx[sonl]);\n    }\n\n    void rotate(int x,int &k)\n    {\n        int y=fa[x],z=fa[y],l,r;\n        l=(son[y][1]==x);r=l^1;\n        if(y==k)k=x;\n        else son[z][son[z][1]==y]=x;\n        fa[son[x][r]]=y;fa[y]=x;fa[x]=z;\n        son[y][l]=son[x][r];son[x][r]=y;\n        update(y);update(x);\n    }\n    void splay(int x,int &k)\n    {\n        while(x!=k)\n        {\n            int y=fa[x],z=fa[y];\n            if(y!=k)\n            {\n                if(son[y][0]==x^son[z][0]==y)rotate(x,k);\n                else rotate(y,k);\n            }\n            rotate(x,k);\n        }\n    }\n    int find(int x,int rk)\n    {\n        pushdown(x);\n        int l=son[x][0],r=son[x][1];\n        if(size[l]+1==rk)return x;\n        if(size[l]>=rk)return find(l,rk);\n        return find(r,rk-size[l]-1);\n    }\n    void rec(int x)\n    {\n        if(!x)return;\n        int l=son[x][0],r=son[x][1];\n        rec(l);rec(r);q.push(x);\n        fa[x]=son[x][0]=son[x][1]=0;\n        tag[x]=rev[x]=0;\n    }\n    int split(int k,int tt)\n    {\n        int x=find(root,k),y=find(root,k+tt+1);\n        splay(x,root);splay(y,son[x][1]);\n        return son[y][0];\n    }\n    void modify(int k,int tt,int val)\n    {\n        int x=split(k,tt),y=fa[x];\n        v[x]=val;tag[x]=1;sum[x]=size[x]*val;\n        if(val>=0)lx[x]=rx[x]=mx[x]=sum[x];\n        else lx[x]=rx[x]=0,mx[x]=val;\n        update(y);update(fa[y]);\n    }\n    void rever(int k,int tt)\n    {\n        int x=split(k,tt),y=fa[x];\n        if(!tag[x])\n        {\n            rev[x]^=1;\n            swap(son[x][0],son[x][1]);\n            swap(lx[x],rx[x]);\n            update(y);update(fa[y]);\n        }\n    }\n    void delet(int k,int tt)\n    {\n        int x=split(k,tt),y=fa[x];\n        rec(x);son[y][0]=0;\n        update(y);update(fa[y]);\n    }\n    void build(int l,int r,int s)\n    {\n        if(l>r)return;\n        int mid=(l+r)>>1,now=id[mid],last=id[s];\n        if(l==r)\n        {\n            sum[now]=a[l];size[now]=1;\n            tag[now]=rev[now]=0;\n            if(a[l]>=0)lx[now]=rx[now]=mx[now]=a[l];\n            else lx[now]=rx[now]=0,mx[now]=a[l];\n        }\n        else build(l,mid-1,mid),build(mid+1,r,mid);\n        v[now]=a[mid];fa[now]=last;update(now);\n        son[last][mid>=s]=now;\n       }\n    void insert(int k,int tt)\n    {\n        for(int i=1;i<=tt;i++)a[i]=read();\n        for(int i=1;i<=tt;i++)\n        if(!q.empty())id[i]=q.front(),q.pop();\n        else id[i]=++cnt;\n        build(1,tt,0);int z=id[(1+tt)>>1];\n        int x=find(root,k+1),y=find(root,k+2);\n        splay(x,root);splay(y,son[x][1]);\n        fa[z]=y;son[y][0]=z;\n        update(y);update(x);\n    }\n    int main()\n    {\n    //\tfreopen(\"seq2005.in\",\"r\",stdin);\n    //\tfreopen(\"seq2005.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        mx[0]=a[1]=a[n+2]=-inf;\n        for(int i=2;i<=n+1;i++)a[i]=read();\n        for(int i=1;i<=n+2;i++)id[i]=i;\n        build(1,n+2,0);\n        root=(n+3)>>1;cnt=n+2;\n        int k,tt,val;\n        char op[19];\n        for(int i=1;i<=m;++i)\n        {\n            scanf(\"%s\",op);\n            if(op[0]=='I')k=read(),tt=read(),insert(k,tt);\n            if(op[0]=='D')k=read(),tt=read(),delet(k,tt);\n            if(op[0]=='M'&&op[2]=='X')printf(\"%d\\n\",mx[root]);\n            if(op[0]=='M'&&op[2]=='K')k=read(),tt=read(),val=read(),modify(k,tt,val);\n            if(op[0]=='R')k=read(),tt=read(),rever(k,tt);\n            if(op[0]=='G'){k=read(),tt=read();printf(\"%d\\n\",sum[split(k,tt)]);}\n        }\n    //\t\tinorder(root);\n    }\n\n \n","content":"<h1 id=\"NOI2005-维护数列\"><a href=\"#NOI2005-维护数列\" class=\"headerlink\" title=\"NOI2005 维护数列\"></a>NOI2005 维护数列</h1><h2 id=\"洛谷2042-COGS339\"><a href=\"#洛谷2042-COGS339\" class=\"headerlink\" title=\"洛谷2042 COGS339\"></a><a href=\"https://www.luogu.org/problem/show?pid=2042\" target=\"_blank\" rel=\"external\">洛谷2042</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=339\" target=\"_blank\" rel=\"external\">COGS339</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p> 请写一个程序，要求维护一个数列，支持以下 6 种操作：（请注意，格式栏 中的下划线‘ _ ’表示实际输入文件中的空格）</p>\n<pre><code>操作编号    输入文件中的格式    说明\n\n\n1.  插入    INSERT_posi_tot_c1_c2_..._ctot\n在当前数列的第 posi 个数字后插入 tot个数字：c1, c2, …, ctot；若在数列首插入，则 posi 为 0\n\n2.  删除    DELETE_posi_tot\n从当前数列的第 posi 个数字开始连续删除 tot 个数字\n\n3.  修改    MAKE-SAME_posi_tot_c\n 将当前数列的第 posi 个数字开始的连续 tot 个数字统一修改为 c\n\n4.  翻转    REVERSE_posi_tot\n 取出从当前数列的第 posi 个数字开始的 tot 个数字，翻转后放入原来的位置\n\n5.  求和    GET-SUM_posi_tot\n计算从当前数列开始的第 posi 个数字开始的 tot 个数字的和并输出\n\n6.  求和最大的子列    MAX-SUM\n求出当前数列中和最大的一段子列，并输出最大和 \n</code></pre><h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p> 输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M表示要进行的操作数目。</p>\n<p>第 2 行包含 N 个数字，描述初始时的数列。</p>\n<p>以下 M 行，每行一条命令，格式参见问题描述中的表格。 </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结果，每个答案（数字）占一行。 </p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>9 8\n2 -6 3 5 1 -5 -3 6 3\nGET-SUM 5 4\nMAX-SUM INSERT 8 3 -5 7 2\nDELETE 12 1\nMAKE-SAME 3 3 2\nREVERSE 3 6\nGET-SUM 5 4\nMAX-SUM\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>-1\n10\n1\n10\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>你可以认为在任何时刻，数列中至少有 1 个数。</p>\n<p>输入数据一定是正确的，即指定位置的数在数列中一定存在。</p>\n<p>50%的数据中，任何时刻数列中最多含有 30 000 个数；</p>\n<p>100%的数据中，任何时刻数列中最多含有 500 000 个数。</p>\n<p>100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。</p>\n<p>100%的数据中，M ≤20 000，插入的数字总数不超过 4 000 000 个，输入文件大小不超过 20MBytes。</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立二分搜索树，而不应直接插入，否则会导致时间复杂度过高，同时操作后也要注意更新信息。</p>\n<p>对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。</p>\n<p>对于求和操作，具体实现与线段树相同。</p>\n<p>对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。</p>\n<p>（一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入4e6个元素，但同时也说明队列中最多只有5e5个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用。）</p>\n<hr>\n<h3 id=\"CODE-V1（暴力）\"><a href=\"#CODE-V1（暴力）\" class=\"headerlink\" title=\"CODE V1（暴力）\"></a>CODE V1（暴力）</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nconst int N = 4e6+5;\nconst int inf = 0x7fffffff;\nusing namespace std;\nint tot,root,rev[N],size[N],w[N],fa[N],son[N][2],id[N];\nvoid update(int x)\n{\n    size[x]=size[son[x][0]]+size[son[x][1]]+1;\n}\nvoid pushdown(int x)\n{\n    if(rev[x])\n    {\n        swap(son[x][0],son[x][1]);\n        rev[son[x][0]]^=1;\n        rev[son[x][1]]^=1;\n        rev[x]=0;\n    }\n    return;\n}\nvoid zg(int x)\n{\n    pushdown(fa[x]),pushdown(x);\n    int y=fa[x],z=fa[y],t=(son[y][0]==x);\n    if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n    son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n    son[x][t]=y;fa[y]=x;\n    update(y);update(x);\n}\nvoid splay(int x,int f)\n{\n    while(fa[x]!=f)\n    {\n        int y=fa[x],z=fa[y];\n        if(z!=f)\n        {\n            if(son[z][0]==y^son[y][0]==x) zg(x);\n            else zg(y);\n        } \n        zg(x);    \n    }\n    if(!f) root=x;\n}\nvoid insert(int &amp;x,int v,int f)\n{\n    if(!x)\n    {\n        x=++tot;\n        son[x][0]=son[x][1]=0;\n        size[x]=1;\n        w[x]=v;fa[x]=f;\n        splay(x,0);\n        return;\n    }\n    insert(son[x][v&gt;w[x]],v,x);\n    update(x);\n}\nint get(int v)\n{\n    int x=root;\n    while(x&amp;&amp;v!=w[x]) x=son[x][v&gt;w[x]];\n    return x;\n}\nint find(int k,int rank)\n{\n    pushdown(k);\n    int l=son[k][0],r=son[k][1];\n    if(size[l]+1==rank)return k;\n    else if(size[l]&gt;=rank)return find(l,rank);\n    else return find(r,rank-size[l]-1);\n}\nint a[N];\nchar op[19];\nint sum1,ans1,max1;\nint inorder(int x)\n{\n    pushdown(x);\n    if(son[x][0])inorder(son[x][0]);\n    if(w[x]!=inf&amp;&amp;w[x]!=-inf)printf(&quot;%d &quot;,a[w[x]]);\n    if(son[x][1])inorder(son[x][1]);\n}\nint inordermax(int x)\n{\n    pushdown(x);\n    if(son[x][0])inordermax(son[x][0]);\n    if(w[x]!=inf&amp;&amp;w[x]!=-inf)\n    {\n        max1=max(max1,a[w[x]]);\n        sum1+=a[w[x]]*num[x];\n        if(sum1&gt;0)ans1=max(ans1,sum1);\n        else    sum1=0;\n    }\n    if(son[x][1])inordermax(son[x][1]);\n}\n\nint main()\n{\n//    freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout);\n    int n,m,tmp;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    insert(root,-inf,0);insert(root,inf,0);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i);\n    for(int i=1;i&lt;=n;++i)insert(root,i,0);\n    tmp=n;\n    for(int i=1,pos,tt,x;i&lt;=m;++i)\n    {\n        scanf(&quot;%s&quot;,op);\n        if(op[0]==&#39;I&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int now=find(root,pos+1),ne=find(root,pos+2);\n            update(now),update(ne);\n            splay(now,0);splay(ne,root);\n            for(int i=1;i&lt;=tt;++i)scanf(&quot;%d&quot;,&amp;a[++tmp]),insert(son[ne][0],tmp,ne);\n            update(root),update(son[root][1]);\n        }\n        if(op[0]==&#39;D&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int now=find(root,pos),ne=find(root,pos+tt+1);\n            splay(now,0);splay(ne,root);\n            fa[son[ne][0]]=0;\n            son[ne][0]=0;\n            update(ne);update(now);\n        }\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;)\n        {\n            scanf(&quot;%d%d%d&quot;,&amp;pos,&amp;tt,&amp;x);\n            for(int t=pos+1;t&lt;=pos+tt;++t)\n            a[w[find(root,t)]]=x;\n        }\n        if(op[0]==&#39;R&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int now=find(root,pos),ne=find(root,pos+tt+1);\n            update(now),update(ne);\n            splay(now,0);splay(ne,root);\n            int s=son[ne][0];\n            rev[s]^=1;\n        }\n        if(op[0]==&#39;G&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int sum=0;\n            for(int t=1;t&lt;=tt;++t)\n            sum+=a[find(root,pos+t)-2];\n            printf(&quot;%d\\n&quot;,sum);\n        }\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;)\n        {\n            sum1=ans1=0;max1=-0x7fffffff;\n            inordermax(root);\n            printf(&quot;%d\\n&quot;,ans1==0?max1:ans1);\n        }\n    }\n    //    inorder(root);\n}\n</code></pre><hr>\n<h3 id=\"CODE-V2\"><a href=\"#CODE-V2\" class=\"headerlink\" title=\"CODE V2\"></a>CODE V2</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int inf = 1e9;\nconst int N = 1e6+1;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n    return x*f;\n}\nint n,m,root,cnt;\nint sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][2];;\nbool tag[N],rev[N];\nqueue&lt;int&gt;q;\nvoid pushdown(int x)\n{\n    int sonl=son[x][0],sonr=son[x][1];\n    if(tag[x])\n    {\n\n        if(sonl)tag[sonl]=true,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl];\n        if(sonr)tag[sonr]=true,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr];\n        if(v[x]&gt;=0)\n        {\n            if(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl];\n            if(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr];\n        }\n        else \n        {\n            if(sonl)lx[sonl]=rx[sonl]=0,mx[sonl]=v[x];\n            if(sonr)lx[sonr]=rx[sonr]=0,mx[sonr]=v[x];\n        }\n        rev[x]=tag[x]=0;\n    }\n    if(rev[x])\n    {\n        rev[x]^=1;rev[sonl]^=1;rev[sonr]^=1;\n        swap(lx[sonl],rx[sonl]);swap(lx[sonr],rx[sonr]);\n        swap(son[sonl][0],son[sonl][1]);swap(son[sonr][0],son[sonr][1]);\n    }\n}\nint inorder(int x)\n{\n    pushdown(x);\n    if(son[x][0])inorder(son[x][0]);\n    if(v[x]!=inf&amp;&amp;v[x]!=-inf)printf(&quot;%d &quot;,v[x]);\n    if(son[x][1])inorder(son[x][1]);\n}\nvoid update(int x)\n{\n    int sonl=son[x][0],sonr=son[x][1];\n    sum[x]=sum[sonl]+sum[sonr]+v[x];\n    size[x]=size[sonl]+size[sonr]+1;\n    mx[x]=max(mx[sonl],mx[sonr]);\n    mx[x]=max(mx[x],rx[sonl]+v[x]+lx[sonr]);\n    lx[x]=max(lx[sonl],sum[sonl]+v[x]+lx[sonr]);\n    rx[x]=max(rx[sonr],sum[sonr]+v[x]+rx[sonl]);\n}\n\nvoid rotate(int x,int &amp;k)\n{\n    int y=fa[x],z=fa[y],l,r;\n    l=(son[y][1]==x);r=l^1;\n    if(y==k)k=x;\n    else son[z][son[z][1]==y]=x;\n    fa[son[x][r]]=y;fa[y]=x;fa[x]=z;\n    son[y][l]=son[x][r];son[x][r]=y;\n    update(y);update(x);\n}\nvoid splay(int x,int &amp;k)\n{\n    while(x!=k)\n    {\n        int y=fa[x],z=fa[y];\n        if(y!=k)\n        {\n            if(son[y][0]==x^son[z][0]==y)rotate(x,k);\n            else rotate(y,k);\n        }\n        rotate(x,k);\n    }\n}\nint find(int x,int rk)\n{\n    pushdown(x);\n    int l=son[x][0],r=son[x][1];\n    if(size[l]+1==rk)return x;\n    if(size[l]&gt;=rk)return find(l,rk);\n    return find(r,rk-size[l]-1);\n}\nvoid rec(int x)\n{\n    if(!x)return;\n    int l=son[x][0],r=son[x][1];\n    rec(l);rec(r);q.push(x);\n    fa[x]=son[x][0]=son[x][1]=0;\n    tag[x]=rev[x]=0;\n}\nint split(int k,int tt)\n{\n    int x=find(root,k),y=find(root,k+tt+1);\n    splay(x,root);splay(y,son[x][1]);\n    return son[y][0];\n}\nvoid modify(int k,int tt,int val)\n{\n    int x=split(k,tt),y=fa[x];\n    v[x]=val;tag[x]=1;sum[x]=size[x]*val;\n    if(val&gt;=0)lx[x]=rx[x]=mx[x]=sum[x];\n    else lx[x]=rx[x]=0,mx[x]=val;\n    update(y);update(fa[y]);\n}\nvoid rever(int k,int tt)\n{\n    int x=split(k,tt),y=fa[x];\n    if(!tag[x])\n    {\n        rev[x]^=1;\n        swap(son[x][0],son[x][1]);\n        swap(lx[x],rx[x]);\n        update(y);update(fa[y]);\n    }\n}\nvoid delet(int k,int tt)\n{\n    int x=split(k,tt),y=fa[x];\n    rec(x);son[y][0]=0;\n    update(y);update(fa[y]);\n}\nvoid build(int l,int r,int s)\n{\n    if(l&gt;r)return;\n    int mid=(l+r)&gt;&gt;1,now=id[mid],last=id[s];\n    if(l==r)\n    {\n        sum[now]=a[l];size[now]=1;\n        tag[now]=rev[now]=0;\n        if(a[l]&gt;=0)lx[now]=rx[now]=mx[now]=a[l];\n        else lx[now]=rx[now]=0,mx[now]=a[l];\n    }\n    else build(l,mid-1,mid),build(mid+1,r,mid);\n    v[now]=a[mid];fa[now]=last;update(now);\n    son[last][mid&gt;=s]=now;\n   }\nvoid insert(int k,int tt)\n{\n    for(int i=1;i&lt;=tt;i++)a[i]=read();\n    for(int i=1;i&lt;=tt;i++)\n    if(!q.empty())id[i]=q.front(),q.pop();\n    else id[i]=++cnt;\n    build(1,tt,0);int z=id[(1+tt)&gt;&gt;1];\n    int x=find(root,k+1),y=find(root,k+2);\n    splay(x,root);splay(y,son[x][1]);\n    fa[z]=y;son[y][0]=z;\n    update(y);update(x);\n}\nint main()\n{\n//    freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    mx[0]=a[1]=a[n+2]=-inf;\n    for(int i=2;i&lt;=n+1;i++)a[i]=read();\n    for(int i=1;i&lt;=n+2;i++)id[i]=i;\n    build(1,n+2,0);\n    root=(n+3)&gt;&gt;1;cnt=n+2;\n    int k,tt,val;\n    char op[19];\n    for(int i=1;i&lt;=m;++i)\n    {\n        scanf(&quot;%s&quot;,op);\n        if(op[0]==&#39;I&#39;)k=read(),tt=read(),insert(k,tt);\n        if(op[0]==&#39;D&#39;)k=read(),tt=read(),delet(k,tt);\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;)printf(&quot;%d\\n&quot;,mx[root]);\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;)k=read(),tt=read(),val=read(),modify(k,tt,val);\n        if(op[0]==&#39;R&#39;)k=read(),tt=read(),rever(k,tt);\n        if(op[0]==&#39;G&#39;){k=read(),tt=read();printf(&quot;%d\\n&quot;,sum[split(k,tt)]);}\n    }\n//        inorder(root);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/21/维护队列/","excerpt":"","categories":[{"name":"平衡树","slug":"平衡树","permalink":"https://prostkhala.github.io/categories/平衡树/"},{"name":"SPLAY","slug":"平衡树/SPLAY","permalink":"https://prostkhala.github.io/categories/平衡树/SPLAY/"}],"tags":[{"name":"SPLAY","slug":"SPLAY","permalink":"https://prostkhala.github.io/tags/SPLAY/"}]},{"title":"普通平衡树","date":"2017-03-19T12:21:17.000Z","path":"2017/03/19/普通平衡树/","text":"普通平衡树BZOJ3224 COGS1829 题目描述您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 插入x数 删除x数(若有多个相同的数，因只删除一个) 查询x数的排名(若有多个相同的数，因输出最小的排名) 查询排名为x的数 求x的前驱(前驱定义为小于x，且最大的数) 求x的后继(后继定义为大于x，且最小的数)输入输出格式输入格式：第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号$(1&lt;=opt&lt;=6)$ 输出格式：对于操作3,4,5,6每行输出一个数，表示对应答案 输入输出样例输入样例：10 1 106465 4 1 1 317721 1 460929 1 644985 1 84185 1 89851 6 81968 1 492737 5 493598 输出样例：106465 84185 492737 数据范围1.n的数据范围：$n&lt;=100000$ 2.每个数的数据范围：$[-1e7,1e7]$（BZOJ3224:$[-2e9,2e9]$） 题解各种平衡树的模板题（然而只会SPLAY） CODE#include #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; const int inf = 0x7fffffff; const int N = 1e5+1; struct splay{int data,ls,rs,fa,size;}a[N]; int q,root=0,tot=0; void pushup(int x){a[x].size=a[a[x].ls].size+a[a[x].rs].size+1;} void zig(int x) { int y=a[x].fa; int z=a[y].fa; a[y].fa=x;a[x].fa=z; a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y; if(y==a[z].ls) a[z].ls=x; else a[z].rs=x; pushup(y); } void zag(int x) { int y=a[x].fa; int z=a[y].fa; a[y].fa=x,a[x].fa=z; a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y; if(y==a[z].ls) a[z].ls=x; else a[z].rs=x; pushup(y); } void splay(int x,int s) { while (a[x].fa!=s) { int y=a[x].fa; int z=a[y].fa; if(z==s) { if(x==a[y].ls) zig(x); else zag(x); break; } if(y==a[z].ls) { if(x==a[y].ls) zig(y),zig(x); else zag(x),zig(x); } else { if(x==a[y].rs) zag(y),zag(x); else zig(x),zag(x); } } pushup(x); if (s==0) root=x; } int Search(int w) { int p,x=root; while (x) { p=x; if (a[x].data&gt;w) x=a[x].ls; else x=a[x].rs; } return p; } void newnode(int &amp;x,int fa,int key) { x=++tot; a[x].ls=a[x].rs=0; a[x].fa=fa; a[x].data=key; } void insert(int w) { if (root==0) { newnode(root,0,w); return; } int i=Search(w); if (w&lt;a[i].data) newnode(a[i].ls,i,w); else newnode(a[i].rs,i,w); splay(tot,0); } int get(int w) { int x=root,ans=tot+1; while(x) { if(a[x].data&gt;w){x=a[x].ls;continue;} if(a[x].data&lt;w){x=a[x].rs;continue;} if(a[x].data==w) { ans=x; x=a[x].ls; } } if(ans==tot+1) return -1; return ans; } int getmax(int x){while(a[x].rs)x=a[x].rs;return x;} int getmin(int x){while (a[x].ls)x=a[x].ls;return x;} int getpre1(int x){return getmax(a[root].ls);} int getne1(int x){return getmin(a[root].rs);} void delet(int w) { int x=get(w); splay(x,0); int pp=getpre1(x),nn=getne1(x); splay(pp,0); splay(nn,root); int y=a[x].fa; a[x].fa=0; if(x==a[y].ls) a[y].ls=0; else a[x].ls=0; pushup(y);pushup(root); } int find(int w) { int x=get(w); splay(x,0); return a[a[x].ls].size; } int findkth(int x,int k) { int s=a[a[x].ls].size; if (k==s+1) return a[x].data; if (s&gt;=k) return findkth(a[x].ls,k); else return findkth(a[x].rs,k-s-1); } int getpre(int w) { int y=get(w); insert(w); if(y!=-1)splay(y,0); int ans=getmax(a[root].ls); delet(w); return a[ans].data; } int getne(int w) { insert(w); int ans=getmin(a[root].rs); delet(w); return a[ans].data; } int main() { root=tot=0; insert(-inf);insert(inf); scanf(&quot;%d&quot;,&amp;q); while(q--) { int x,k; scanf(&quot;%d%d&quot;,&amp;x,&amp;k); if(x==1) insert(k); else if(x==2) delet(k); else if(x==3) printf(&quot;%d\\n&quot;,find(k)); else if(x==4) printf(&quot;%d\\n&quot;,findkth(root,k+1)); else if(x==5) printf(&quot;%d\\n&quot;,getpre(k)); else if(x==6) printf(&quot;%d\\n&quot;,getne(k)); } return 0; } CODE V2 #include&lt;cstdio&gt; #include&lt;iostream&gt; const int N=1e5+5; int tot,root,size[N],num[N],key[N],fa[N],son[N][2]; void pushup(int x) { size[x]=size[son[x][0]]+size[son[x][1]]+num[x]; } void zg(int x) { //push_down(fa[x]);push_down(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(z) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; pushup(y);pushup(x); } void splay(int x,int f) { while(fa[x]!=f) { int y=fa[x],z=fa[y]; if(z!=f) { if(son[z][0]==y^son[y][0]==x) zg(x); else zg(y); } zg(x); } if(!f) root=x; } void insert(int &amp;x,int v,int f) { if(!x) { x=++tot; son[x][0]=son[x][1]=0; size[x]=num[x]=1; key[x]=v;fa[x]=f; splay(x,0); return; } if(v==key[x]) { num[x]++;size[x]++; splay(x,0); return; } insert(son[x][v&gt;key[x]],v,x); pushup(x); } int get(int v) { int x=root; while(x&amp;&amp;v!=key[x]) x=son[x][v&gt;key[x]]; return x; } void delet(int x) { x=get(x);if(!x) return; splay(x,0); if(num[x]&gt;1) {num[x]--;size[x]--;return;} if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1]; else { int y=son[x][1];while(son[y][0]) y=son[y][0]; splay(y,x); son[y][0]=son[x][0];fa[son[y][0]]=y; root=y; } fa[root]=0; pushup(root); } int getrank(int v) { insert(root,v,0); int ans=size[son[root][0]]+1; delet(v); return ans; } int kth(int x) { int y=root; while(x&lt;=size[son[y][0]]||x&gt;size[son[y][0]]+num[y]) { if(x&lt;=size[son[y][0]]) y=son[y][0]; else x-=size[son[y][0]]+num[y],y=son[y][1]; } return key[y]; } int pre(int v) { insert(root,v,0); int x=son[root][0];while(son[x][1]) x=son[x][1]; delet(v); return key[x]; } int ne(int v) { insert(root,v,0); int x=son[root][1];while(son[x][0]) x=son[x][0]; delet(v); return key[x]; } int main() { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1,x,y;i&lt;=n;++i) { if(x==1) insert(root,y,0); if(x==2) delet(y); if(x==3) printf(&quot;%d\\n&quot;,getrank(y)); if(x==4) printf(&quot;%d\\n&quot;,kth(y)); if(x==5) printf(&quot;%d\\n&quot;,pre(y)); if(x==6) printf(&quot;%d\\n&quot;,ne(y)); } }","raw":"title: 普通平衡树\ndate: 2017-03-19 20:21:17\ncategories:\n  - 平衡树\n  - SPLAY\ntags:\n  - SPLAY\n  - TREAP\n  - 模板\n---\n\n# 普通平衡树\n\n## [BZOJ3224](http://www.lydsy.com/JudgeOnline/problem.php?id=3224) [COGS1829](http://cogs.pro/cogs/problem/problem.php?pid=1829)\n\n---\n## 题目描述\n您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：\n1. 插入x数\n2. 删除x数(若有多个相同的数，因只删除一个)\n3. 查询x数的排名(若有多个相同的数，因输出最小的排名)\n4. 查询排名为x的数\n5. 求x的前驱(前驱定义为小于x，且最大的数)\n6. 求x的后继(后继定义为大于x，且最小的数)\n### 输入输出格式\n#### 输入格式：\n第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号$(1<=opt<=6)$\n\n#### 输出格式：\n对于操作3,4,5,6每行输出一个数，表示对应答案\n\n\n### 输入输出样例\n#### 输入样例：\n    10\n    1 106465\n    4 1\n    1 317721\n    1 460929\n    1 644985\n    1 84185\n    1 89851\n    6 81968\n    1 492737\n    5 493598\n    \n\n#### 输出样例：\n    106465\n    84185\n    492737\n    \n\n### 数据范围\n\n1.n的数据范围：$n<=100000$\n\n2.每个数的数据范围：$[-1e7,1e7]$（BZOJ3224:$[-2e9,2e9]$）\n\n---\n\n## 题解\n各种平衡树的模板题（然而只会SPLAY）\n\n---\n### CODE\n#include <iostream>\n\t#include<cstring>\n\t#include<algorithm>\n\t#include<cstdio>\n\tusing namespace std;\n\tconst int inf = 0x7fffffff;\n\tconst int N = 1e5+1;\n\tstruct splay{int data,ls,rs,fa,size;}a[N];  \n\tint q,root=0,tot=0;\n\tvoid pushup(int x){a[x].size=a[a[x].ls].size+a[a[x].rs].size+1;}  \n\tvoid zig(int x)  \n\t{  \n\t    int y=a[x].fa; \n\t    int z=a[y].fa; \n\t    a[y].fa=x;a[x].fa=z;  \n\t    a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y;  \n\t    if(y==a[z].ls)\ta[z].ls=x;\n\t    else \t\t\ta[z].rs=x;\n\t    pushup(y);\n\t}\n\tvoid zag(int x)\n\t{\n\t    int y=a[x].fa;  \n\t    int z=a[y].fa;\n\t    a[y].fa=x,a[x].fa=z;\n\t    a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y;\n\t    if(y==a[z].ls) \ta[z].ls=x;\n\t    else \t\t\ta[z].rs=x;\n\t    pushup(y);\n\t}\n\tvoid splay(int x,int s)  \n\t{  \n\t    while (a[x].fa!=s)  \n\t    {  \n\t        int y=a[x].fa;  \n\t        int z=a[y].fa;  \n\t        if(z==s)  \n\t        {\n\t            if(x==a[y].ls) zig(x);  \n\t            else \t\t  zag(x);  \n\t            break;  \n\t        }  \n\t        if(y==a[z].ls)  \n\t        {  \n\t            if(x==a[y].ls) zig(y),zig(x);  \n\t            else \t\t  zag(x),zig(x);  \n\t        }  \n\t        else \n\t        {  \n\t            if(x==a[y].rs) zag(y),zag(x);  \n\t            else \t\t  zig(x),zag(x);  \n\t        }  \n\t    }\n\t    pushup(x);  \n\t    if (s==0) root=x;  \n\t}  \n\tint Search(int w)  \n\t{  \n\t    int p,x=root;  \n\t    while (x)  \n\t    {  \n\t        p=x;  \n\t        if (a[x].data>w) x=a[x].ls;  \n\t        else x=a[x].rs;  \n\t    }  \n\t    return p;  \n\t}  \n\tvoid newnode(int &x,int fa,int key)  \n\t{  \n\t    x=++tot;  \n\t    a[x].ls=a[x].rs=0;  \n\t    a[x].fa=fa;  \n\t    a[x].data=key;  \n\t}  \n\tvoid insert(int w)  \n\t{  \n\t    if (root==0)  \n\t    {  \n\t        newnode(root,0,w);  \n\t        return;  \n\t    }  \n\t    int i=Search(w);  \n\t    if (w<a[i].data) newnode(a[i].ls,i,w);     \n\t    else newnode(a[i].rs,i,w);\n\t    splay(tot,0);  \n\t}  \n\tint get(int w)\n\t{\n\t    int x=root,ans=tot+1;  \n\t    while(x)  \n\t    {  \n\t        if(a[x].data>w){x=a[x].ls;continue;}  \n\t        if(a[x].data<w){x=a[x].rs;continue;}  \n\t        if(a[x].data==w)  \n\t        {  \n\t            ans=x;\n\t            x=a[x].ls; \n\t        }  \n\t    }  \n\t    if(ans==tot+1) return -1;\n\t    return ans;  \n\t}\n\tint getmax(int x){while(a[x].rs)x=a[x].rs;return x;}  \n\tint getmin(int x){while (a[x].ls)x=a[x].ls;return x;}  \n\tint getpre1(int x){return getmax(a[root].ls);}  \n\tint getne1(int x){return getmin(a[root].rs);}\n\tvoid delet(int w)  \n\t{  \n\t    int x=get(w);  \n\t    splay(x,0);  \n\t    int pp=getpre1(x),nn=getne1(x);  \n\t    splay(pp,0);  \n\t    splay(nn,root);  \n\t    int y=a[x].fa;  \n\t    a[x].fa=0;  \n\t    if(x==a[y].ls) a[y].ls=0;\n\t    else \t\t  a[x].ls=0;\n\t    pushup(y);pushup(root);  \n\t}  \n\tint find(int w)  \n\t{  \n\t    int x=get(w);  \n\t    splay(x,0);  \n\t    return a[a[x].ls].size;  \n\t}  \n\tint findkth(int x,int k)  \n\t{  \n\t    int s=a[a[x].ls].size;  \n\t    if (k==s+1) return a[x].data;  \n\t    if (s>=k) return findkth(a[x].ls,k);  \n\t    else return findkth(a[x].rs,k-s-1);  \n\t}  \n\tint getpre(int w) \n\t{  \n\t    int y=get(w);  \n\t    insert(w);  \n\t    if(y!=-1)splay(y,0);  \n\t    int ans=getmax(a[root].ls);  \n\t    delet(w);  \n\t    return a[ans].data;  \n\t}  \n\tint getne(int w)  \n\t{  \n\t    insert(w);\n\t    int ans=getmin(a[root].rs);\n\t    delet(w);\n\t    return a[ans].data;\n\t}\n\tint main()\n\t{\n\t    root=tot=0;\n\t    insert(-inf);insert(inf);\n\t    scanf(\"%d\",&q);\n\t    while(q--)\n\t    {\n\t        int x,k;\n\t        scanf(\"%d%d\",&x,&k);\n\t        if(x==1) \t  insert(k);\n\t        else if(x==2) delet(k);\n\t        else if(x==3) printf(\"%d\\n\",find(k));\n\t        else if(x==4) printf(\"%d\\n\",findkth(root,k+1));\n\t        else if(x==5) printf(\"%d\\n\",getpre(k));\n\t        else if(x==6) printf(\"%d\\n\",getne(k));\n\t    }\n\t    return 0;\n\t}    \n    \n    \n ---\n ### CODE V2\n \n     #include<cstdio>\n     #include<iostream>\n    const int N=1e5+5;\n    int tot,root,size[N],num[N],key[N],fa[N],son[N][2];\n    void pushup(int x)\n    {\n        size[x]=size[son[x][0]]+size[son[x][1]]+num[x];\n    }\n    void zg(int x)\n    {\n        //push_down(fa[x]);push_down(x); \n        int y=fa[x],z=fa[y],t=(son[y][0]==x);\n        if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n        son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n        son[x][t]=y;fa[y]=x;\n        pushup(y);pushup(x);\n    }\n    void splay(int x,int f)\n    {\n        while(fa[x]!=f)\n        {\n            int y=fa[x],z=fa[y];\n            if(z!=f)\n            {\n                if(son[z][0]==y^son[y][0]==x) zg(x);\n                else zg(y);\n            } \n            zg(x);\t\n        }\n        if(!f) root=x;\n    }\n    void insert(int &x,int v,int f)\n    {\n        if(!x)\n        {\n            x=++tot;\n            son[x][0]=son[x][1]=0;\n            size[x]=num[x]=1;\n            key[x]=v;fa[x]=f;\n            splay(x,0);\n            return;\n        }\n        if(v==key[x])\n        {\n            num[x]++;size[x]++;\n            splay(x,0);\n            return;\n        }\n        insert(son[x][v>key[x]],v,x);\n        pushup(x);\n    }\n    int get(int v)\n    {\n        int x=root;\n        while(x&&v!=key[x]) x=son[x][v>key[x]];\n        return x;\n    }\n    void delet(int x)\n    {\n        x=get(x);if(!x) return;\n        splay(x,0);\n        if(num[x]>1) {num[x]--;size[x]--;return;}\n        if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1];\n        else\n        {\n            int y=son[x][1];while(son[y][0]) y=son[y][0];\n            splay(y,x);\n            son[y][0]=son[x][0];fa[son[y][0]]=y;\n            root=y;\n        }\n        fa[root]=0;\n        pushup(root);\n    }\n    int getrank(int v)\n    {\n        insert(root,v,0);\n        int ans=size[son[root][0]]+1;\n        delet(v);\n        return ans;\n    }\n    int kth(int x)\n    {\n        int y=root;\n        while(x<=size[son[y][0]]||x>size[son[y][0]]+num[y])\n        {\n            if(x<=size[son[y][0]]) y=son[y][0];\n            else x-=size[son[y][0]]+num[y],y=son[y][1];\n        }\n        return key[y];\n    }\n    int pre(int v)\n    {\n        insert(root,v,0);\n        int x=son[root][0];while(son[x][1]) x=son[x][1];\n        delet(v);\n        return key[x];\n    }\n    int ne(int v)\n    {\n        insert(root,v,0);\n        int x=son[root][1];while(son[x][0]) x=son[x][0];\n        delet(v);\n        return key[x];\n    }\n    int main()\n    {\n        int n;\n        scanf(\"%d\",&n);\n        for(int i=1,x,y;i<=n;++i)\n        {\n            if(x==1) \t\tinsert(root,y,0);\n            if(x==2) \t\tdelet(y);\n            if(x==3) \t\tprintf(\"%d\\n\",getrank(y));\n            if(x==4) \t\tprintf(\"%d\\n\",kth(y));\n            if(x==5) \t\tprintf(\"%d\\n\",pre(y));\n            if(x==6)\t\tprintf(\"%d\\n\",ne(y));\n        }\n    }","content":"<h1 id=\"普通平衡树\"><a href=\"#普通平衡树\" class=\"headerlink\" title=\"普通平衡树\"></a>普通平衡树</h1><h2 id=\"BZOJ3224-COGS1829\"><a href=\"#BZOJ3224-COGS1829\" class=\"headerlink\" title=\"BZOJ3224 COGS1829\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=3224\" target=\"_blank\" rel=\"external\">BZOJ3224</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1829\" target=\"_blank\" rel=\"external\">COGS1829</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：</p>\n<ol>\n<li>插入x数</li>\n<li>删除x数(若有多个相同的数，因只删除一个)</li>\n<li>查询x数的排名(若有多个相同的数，因输出最小的排名)</li>\n<li>查询排名为x的数</li>\n<li>求x的前驱(前驱定义为小于x，且最大的数)</li>\n<li>求x的后继(后继定义为大于x，且最小的数)<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4>第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号$(1&lt;=opt&lt;=6)$</li>\n</ol>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于操作3,4,5,6每行输出一个数，表示对应答案</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>10\n1 106465\n4 1\n1 317721\n1 460929\n1 644985\n1 84185\n1 89851\n6 81968\n1 492737\n5 493598\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>106465\n84185\n492737\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>1.n的数据范围：$n&lt;=100000$</p>\n<p>2.每个数的数据范围：$[-1e7,1e7]$（BZOJ3224:$[-2e9,2e9]$）</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>各种平衡树的模板题（然而只会SPLAY）</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><p>#include <iostream></iostream></p>\n<pre><code>#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nconst int inf = 0x7fffffff;\nconst int N = 1e5+1;\nstruct splay{int data,ls,rs,fa,size;}a[N];  \nint q,root=0,tot=0;\nvoid pushup(int x){a[x].size=a[a[x].ls].size+a[a[x].rs].size+1;}  \nvoid zig(int x)  \n{  \n    int y=a[x].fa; \n    int z=a[y].fa; \n    a[y].fa=x;a[x].fa=z;  \n    a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y;  \n    if(y==a[z].ls)    a[z].ls=x;\n    else             a[z].rs=x;\n    pushup(y);\n}\nvoid zag(int x)\n{\n    int y=a[x].fa;  \n    int z=a[y].fa;\n    a[y].fa=x,a[x].fa=z;\n    a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y;\n    if(y==a[z].ls)     a[z].ls=x;\n    else             a[z].rs=x;\n    pushup(y);\n}\nvoid splay(int x,int s)  \n{  \n    while (a[x].fa!=s)  \n    {  \n        int y=a[x].fa;  \n        int z=a[y].fa;  \n        if(z==s)  \n        {\n            if(x==a[y].ls) zig(x);  \n            else           zag(x);  \n            break;  \n        }  \n        if(y==a[z].ls)  \n        {  \n            if(x==a[y].ls) zig(y),zig(x);  \n            else           zag(x),zig(x);  \n        }  \n        else \n        {  \n            if(x==a[y].rs) zag(y),zag(x);  \n            else           zig(x),zag(x);  \n        }  \n    }\n    pushup(x);  \n    if (s==0) root=x;  \n}  \nint Search(int w)  \n{  \n    int p,x=root;  \n    while (x)  \n    {  \n        p=x;  \n        if (a[x].data&gt;w) x=a[x].ls;  \n        else x=a[x].rs;  \n    }  \n    return p;  \n}  \nvoid newnode(int &amp;x,int fa,int key)  \n{  \n    x=++tot;  \n    a[x].ls=a[x].rs=0;  \n    a[x].fa=fa;  \n    a[x].data=key;  \n}  \nvoid insert(int w)  \n{  \n    if (root==0)  \n    {  \n        newnode(root,0,w);  \n        return;  \n    }  \n    int i=Search(w);  \n    if (w&lt;a[i].data) newnode(a[i].ls,i,w);     \n    else newnode(a[i].rs,i,w);\n    splay(tot,0);  \n}  \nint get(int w)\n{\n    int x=root,ans=tot+1;  \n    while(x)  \n    {  \n        if(a[x].data&gt;w){x=a[x].ls;continue;}  \n        if(a[x].data&lt;w){x=a[x].rs;continue;}  \n        if(a[x].data==w)  \n        {  \n            ans=x;\n            x=a[x].ls; \n        }  \n    }  \n    if(ans==tot+1) return -1;\n    return ans;  \n}\nint getmax(int x){while(a[x].rs)x=a[x].rs;return x;}  \nint getmin(int x){while (a[x].ls)x=a[x].ls;return x;}  \nint getpre1(int x){return getmax(a[root].ls);}  \nint getne1(int x){return getmin(a[root].rs);}\nvoid delet(int w)  \n{  \n    int x=get(w);  \n    splay(x,0);  \n    int pp=getpre1(x),nn=getne1(x);  \n    splay(pp,0);  \n    splay(nn,root);  \n    int y=a[x].fa;  \n    a[x].fa=0;  \n    if(x==a[y].ls) a[y].ls=0;\n    else           a[x].ls=0;\n    pushup(y);pushup(root);  \n}  \nint find(int w)  \n{  \n    int x=get(w);  \n    splay(x,0);  \n    return a[a[x].ls].size;  \n}  \nint findkth(int x,int k)  \n{  \n    int s=a[a[x].ls].size;  \n    if (k==s+1) return a[x].data;  \n    if (s&gt;=k) return findkth(a[x].ls,k);  \n    else return findkth(a[x].rs,k-s-1);  \n}  \nint getpre(int w) \n{  \n    int y=get(w);  \n    insert(w);  \n    if(y!=-1)splay(y,0);  \n    int ans=getmax(a[root].ls);  \n    delet(w);  \n    return a[ans].data;  \n}  \nint getne(int w)  \n{  \n    insert(w);\n    int ans=getmin(a[root].rs);\n    delet(w);\n    return a[ans].data;\n}\nint main()\n{\n    root=tot=0;\n    insert(-inf);insert(inf);\n    scanf(&quot;%d&quot;,&amp;q);\n    while(q--)\n    {\n        int x,k;\n        scanf(&quot;%d%d&quot;,&amp;x,&amp;k);\n        if(x==1)       insert(k);\n        else if(x==2) delet(k);\n        else if(x==3) printf(&quot;%d\\n&quot;,find(k));\n        else if(x==4) printf(&quot;%d\\n&quot;,findkth(root,k+1));\n        else if(x==5) printf(&quot;%d\\n&quot;,getpre(k));\n        else if(x==6) printf(&quot;%d\\n&quot;,getne(k));\n    }\n    return 0;\n}    \n</code></pre><hr>\n<h3 id=\"CODE-V2\"><a href=\"#CODE-V2\" class=\"headerlink\" title=\"CODE V2\"></a>CODE V2</h3><pre><code> #include&lt;cstdio&gt;\n #include&lt;iostream&gt;\nconst int N=1e5+5;\nint tot,root,size[N],num[N],key[N],fa[N],son[N][2];\nvoid pushup(int x)\n{\n    size[x]=size[son[x][0]]+size[son[x][1]]+num[x];\n}\nvoid zg(int x)\n{\n    //push_down(fa[x]);push_down(x); \n    int y=fa[x],z=fa[y],t=(son[y][0]==x);\n    if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n    son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n    son[x][t]=y;fa[y]=x;\n    pushup(y);pushup(x);\n}\nvoid splay(int x,int f)\n{\n    while(fa[x]!=f)\n    {\n        int y=fa[x],z=fa[y];\n        if(z!=f)\n        {\n            if(son[z][0]==y^son[y][0]==x) zg(x);\n            else zg(y);\n        } \n        zg(x);    \n    }\n    if(!f) root=x;\n}\nvoid insert(int &amp;x,int v,int f)\n{\n    if(!x)\n    {\n        x=++tot;\n        son[x][0]=son[x][1]=0;\n        size[x]=num[x]=1;\n        key[x]=v;fa[x]=f;\n        splay(x,0);\n        return;\n    }\n    if(v==key[x])\n    {\n        num[x]++;size[x]++;\n        splay(x,0);\n        return;\n    }\n    insert(son[x][v&gt;key[x]],v,x);\n    pushup(x);\n}\nint get(int v)\n{\n    int x=root;\n    while(x&amp;&amp;v!=key[x]) x=son[x][v&gt;key[x]];\n    return x;\n}\nvoid delet(int x)\n{\n    x=get(x);if(!x) return;\n    splay(x,0);\n    if(num[x]&gt;1) {num[x]--;size[x]--;return;}\n    if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1];\n    else\n    {\n        int y=son[x][1];while(son[y][0]) y=son[y][0];\n        splay(y,x);\n        son[y][0]=son[x][0];fa[son[y][0]]=y;\n        root=y;\n    }\n    fa[root]=0;\n    pushup(root);\n}\nint getrank(int v)\n{\n    insert(root,v,0);\n    int ans=size[son[root][0]]+1;\n    delet(v);\n    return ans;\n}\nint kth(int x)\n{\n    int y=root;\n    while(x&lt;=size[son[y][0]]||x&gt;size[son[y][0]]+num[y])\n    {\n        if(x&lt;=size[son[y][0]]) y=son[y][0];\n        else x-=size[son[y][0]]+num[y],y=son[y][1];\n    }\n    return key[y];\n}\nint pre(int v)\n{\n    insert(root,v,0);\n    int x=son[root][0];while(son[x][1]) x=son[x][1];\n    delet(v);\n    return key[x];\n}\nint ne(int v)\n{\n    insert(root,v,0);\n    int x=son[root][1];while(son[x][0]) x=son[x][0];\n    delet(v);\n    return key[x];\n}\nint main()\n{\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1,x,y;i&lt;=n;++i)\n    {\n        if(x==1)         insert(root,y,0);\n        if(x==2)         delet(y);\n        if(x==3)         printf(&quot;%d\\n&quot;,getrank(y));\n        if(x==4)         printf(&quot;%d\\n&quot;,kth(y));\n        if(x==5)         printf(&quot;%d\\n&quot;,pre(y));\n        if(x==6)        printf(&quot;%d\\n&quot;,ne(y));\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/19/普通平衡树/","excerpt":"","categories":[{"name":"平衡树","slug":"平衡树","permalink":"https://prostkhala.github.io/categories/平衡树/"},{"name":"SPLAY","slug":"平衡树/SPLAY","permalink":"https://prostkhala.github.io/categories/平衡树/SPLAY/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://prostkhala.github.io/tags/模板/"},{"name":"SPLAY","slug":"SPLAY","permalink":"https://prostkhala.github.io/tags/SPLAY/"},{"name":"TREAP","slug":"TREAP","permalink":"https://prostkhala.github.io/tags/TREAP/"}]},{"title":"DNA Sequence","date":"2017-03-18T02:51:23.000Z","path":"2017/03/18/DNA Sequence/","text":"DNA SequencePOJ2778 题目描述It’s well known that DNA Sequence is a sequence only contains A, C, T and G, and it’s very useful to analyze a segment of DNA Sequence，For example, if a animal’s DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don’t contain those segments. Suppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. 输入输出格式输入格式：First line contains two integer m (0 &lt;= m &lt;= 10), n (1 &lt;= n &lt;=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences. Next m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. 输出格式：An integer, the number of DNA sequences, mod 100000. 输入输出样例输入样例：4 3 AT AC AG AA 输出样例：36 题解题目大意为给定n个病毒串，求不包含这些病毒串且长度为m的资源串个数（均由A,G,C,T组成）。 这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即$res [ i ] [ t ]$存的是从i到t恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res’=res^m$时，$res’[i][t]$表示从i到t恰好走m步能到达的方案数。 有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点（0）到叶节点（i）的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为将赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其fail指针指向病毒串），只需要特判一下即可。 刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了…后来因为取模操作过多又TLE了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int N =200+1; const int mod =100000; const int maxf =255; long long n,m,tr[N][4],tot,tmp,fail[N]; int idd[N]; bool tag[N]; char s[N]; int ss[4]={&#39;A&#39;,&#39;G&#39;,&#39;C&#39;,&#39;T&#39;}; struct martix{long long a[N][N];}res,ans; martix operator * (martix c,martix b) { martix ret; memset(ret.a,0,sizeof(ret.a)); for(int i=0;i&lt;=tot;++i) for(int t=0;t&lt;=tot;++t) { for(int k=0;k&lt;=tot;++k) ret.a[i][t]+=c.a[i][k]*b.a[k][t]; ret.a[i][t]%=mod; } return ret; } void init(){idd[ss[0]]=0;idd[ss[1]]=1;idd[ss[2]]=2;idd[ss[3]]=3;} void insert(int num) { int now=0; int n=strlen(s); for(int i=0;i&lt;n;++i) { if(tr[now][idd[s[i]]]==-1) { tr[now][idd[s[i]]]=++tot; for(int j=0;j&lt;4;++j)tr[tot][j]=-1; // tag[tot]=0; } now=tr[now][idd[s[i]]]; } tag[now]=true; } void getfail() { queue&lt;int&gt;q;fail[0]=0; for(int j=0;j&lt;4;++j) if(tr[0][j]!=-1)q.push(tr[0][j]),fail[tr[0][j]]=0; else tr[0][j]=0; while(!q.empty()) { int x=q.front();q.pop(); if(tag[fail[x]])tag[x]=true; for(int j=0;j&lt;4;++j) if(tr[x][j]!=-1) fail[tr[x][j]]=tr[fail[x]][j],q.push(tr[x][j]); else tr[x][j] =tr[fail[x]][j]; } } void slove() { for(int i=0;i&lt;=tot;i++) for(int j=0;j&lt;4;j++) if(!tag[i]&amp;&amp;!tag[tr[i][j]]) res.a[i][tr[i][j]]++; } int main() { init(); scanf(&quot;%d&quot;,&amp;n);scanf(&quot;%d&quot;,&amp;m); for(int i=0;i&lt;4;++i)tr[0][i]=-1; for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s),insert(i); getfail(); slove(); for(int i=0;i&lt;=tot;++i)ans.a[i][i]=1; if(!m){cout&lt;&lt;0;return 0;} while(m) { if(m&amp;1) ans=ans*res; m/=2; res=res*res; } int anss=0; for(int i=0;i&lt;=tot;++i)(anss+=ans.a[0][i])%=mod; cout&lt;&lt;anss; }","raw":"title: DNA Sequence\ndate: 2017-03-18 10:51:23\ncategories:\n  - Hollerith-type\n  - AC自动机\ntags:\n  - AC自动机\n  - 矩阵快速幂\n  - KMP\n---\n\n# DNA Sequence\n\n## [POJ2778](http://poj.org/problem?id=2778)\n\n---\n## 题目描述\nIt's well known that DNA Sequence is a sequence only contains A, C, T and G, and it's very useful to analyze a segment of DNA Sequence，For example, if a animal's DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don't contain those segments.\n\nSuppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. \n### 输入输出格式\n#### 输入格式：\nFirst line contains two integer m (0 <= m <= 10), n (1 <= n <=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences.\n\nNext m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. \n\n\n#### 输出格式：\nAn integer, the number of DNA sequences, mod 100000.\n\n\n### 输入输出样例\n#### 输入样例：\n    4 3\n    AT\n    AC\n    AG\n    AA\n    \n\n#### 输出样例：\n\t36\n---\n\n## 题解\n\n题目大意为给定n个病毒串，求不包含这些病毒串且长度为m的资源串个数（均由A,G,C,T组成）。\n\n这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即\n$res [ i ] [ t ]$存的是从i到t恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res'=res^m$时，$res'[i][t]$表示从i到t恰好走m步能到达的方案数。\n\n有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点（0）\n到叶节点（i）的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为将赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其fail指针指向病毒串），只需要特判一下即可。\n\n刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了...后来因为取模操作过多又TLE了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。\n\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<queue>\n    using namespace std;\n    const int  N =200+1;\n    const int mod =100000;\n    const int maxf =255;\n    long long n,m,tr[N][4],tot,tmp,fail[N];\n    int idd[N];\n    bool tag[N];\n    char s[N];\n    int ss[4]={'A','G','C','T'};\n    struct martix{long long a[N][N];}res,ans;\n    martix operator * (martix c,martix b)\n    {\n        martix ret;\n        memset(ret.a,0,sizeof(ret.a));\n        for(int i=0;i<=tot;++i)\n        for(int t=0;t<=tot;++t)\n        {\n            for(int k=0;k<=tot;++k)\n            ret.a[i][t]+=c.a[i][k]*b.a[k][t];\n            ret.a[i][t]%=mod;\n        }\n        return ret;\n    }\n    void init(){idd[ss[0]]=0;idd[ss[1]]=1;idd[ss[2]]=2;idd[ss[3]]=3;}\n    void insert(int num)\n    {\n        int now=0;\n        int n=strlen(s);\n        for(int i=0;i<n;++i)\n        {\n            if(tr[now][idd[s[i]]]==-1)\n            {\n                tr[now][idd[s[i]]]=++tot;\n                for(int j=0;j<4;++j)tr[tot][j]=-1;\t\n            //\ttag[tot]=0;\n            }\n            now=tr[now][idd[s[i]]];\n        }\n        tag[now]=true;\n    }\n    void getfail()\n    {\n        queue<int>q;fail[0]=0;\n        for(int j=0;j<4;++j)\n        if(tr[0][j]!=-1)q.push(tr[0][j]),fail[tr[0][j]]=0;\n        else\t\t\ttr[0][j]=0;\n\n        while(!q.empty())\n        {\n            int x=q.front();q.pop();\n            if(tag[fail[x]])tag[x]=true;\n            for(int j=0;j<4;++j)\n            if(tr[x][j]!=-1)\tfail[tr[x][j]]=tr[fail[x]][j],q.push(tr[x][j]);\t\n            else\t\t\t\t\t tr[x][j] =tr[fail[x]][j];\n        }\n    }\n    void slove()\n    {\n        for(int i=0;i<=tot;i++)\n        for(int j=0;j<4;j++)\n        if(!tag[i]&&!tag[tr[i][j]]) res.a[i][tr[i][j]]++;\n\n    }\n    int main()\n    {\n        init();\n        scanf(\"%d\",&n);scanf(\"%d\",&m);\n        for(int i=0;i<4;++i)tr[0][i]=-1;\n        for(int i=1;i<=n;++i)scanf(\"%s\",s),insert(i);\n        getfail();\n        slove();\n        for(int i=0;i<=tot;++i)ans.a[i][i]=1;\n        if(!m){cout<<0;return 0;}\n        while(m)\n        {\n            if(m&1) ans=ans*res;\n            m/=2;\n            res=res*res;\n        }\n        int anss=0;\n        for(int i=0;i<=tot;++i)(anss+=ans.a[0][i])%=mod;\n        cout<<anss;\n    }\n\n","content":"<h1 id=\"DNA-Sequence\"><a href=\"#DNA-Sequence\" class=\"headerlink\" title=\"DNA Sequence\"></a>DNA Sequence</h1><h2 id=\"POJ2778\"><a href=\"#POJ2778\" class=\"headerlink\" title=\"POJ2778\"></a><a href=\"http://poj.org/problem?id=2778\" target=\"_blank\" rel=\"external\">POJ2778</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>It’s well known that DNA Sequence is a sequence only contains A, C, T and G, and it’s very useful to analyze a segment of DNA Sequence，For example, if a animal’s DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don’t contain those segments.</p>\n<p>Suppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>First line contains two integer m (0 &lt;= m &lt;= 10), n (1 &lt;= n &lt;=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences.</p>\n<p>Next m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>An integer, the number of DNA sequences, mod 100000.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>4 3\nAT\nAC\nAG\nAA\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>36\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意为给定n个病毒串，求不包含这些病毒串且长度为m的资源串个数（均由A,G,C,T组成）。</p>\n<p>这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即<br>$res [ i ] [ t ]$存的是从i到t恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res’=res^m$时，$res’[i][t]$表示从i到t恰好走m步能到达的方案数。</p>\n<p>有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点（0）<br>到叶节点（i）的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为将赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其fail指针指向病毒串），只需要特判一下即可。</p>\n<p>刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了…后来因为取模操作过多又TLE了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int  N =200+1;\nconst int mod =100000;\nconst int maxf =255;\nlong long n,m,tr[N][4],tot,tmp,fail[N];\nint idd[N];\nbool tag[N];\nchar s[N];\nint ss[4]={&#39;A&#39;,&#39;G&#39;,&#39;C&#39;,&#39;T&#39;};\nstruct martix{long long a[N][N];}res,ans;\nmartix operator * (martix c,martix b)\n{\n    martix ret;\n    memset(ret.a,0,sizeof(ret.a));\n    for(int i=0;i&lt;=tot;++i)\n    for(int t=0;t&lt;=tot;++t)\n    {\n        for(int k=0;k&lt;=tot;++k)\n        ret.a[i][t]+=c.a[i][k]*b.a[k][t];\n        ret.a[i][t]%=mod;\n    }\n    return ret;\n}\nvoid init(){idd[ss[0]]=0;idd[ss[1]]=1;idd[ss[2]]=2;idd[ss[3]]=3;}\nvoid insert(int num)\n{\n    int now=0;\n    int n=strlen(s);\n    for(int i=0;i&lt;n;++i)\n    {\n        if(tr[now][idd[s[i]]]==-1)\n        {\n            tr[now][idd[s[i]]]=++tot;\n            for(int j=0;j&lt;4;++j)tr[tot][j]=-1;    \n        //    tag[tot]=0;\n        }\n        now=tr[now][idd[s[i]]];\n    }\n    tag[now]=true;\n}\nvoid getfail()\n{\n    queue&lt;int&gt;q;fail[0]=0;\n    for(int j=0;j&lt;4;++j)\n    if(tr[0][j]!=-1)q.push(tr[0][j]),fail[tr[0][j]]=0;\n    else            tr[0][j]=0;\n\n    while(!q.empty())\n    {\n        int x=q.front();q.pop();\n        if(tag[fail[x]])tag[x]=true;\n        for(int j=0;j&lt;4;++j)\n        if(tr[x][j]!=-1)    fail[tr[x][j]]=tr[fail[x]][j],q.push(tr[x][j]);    \n        else                     tr[x][j] =tr[fail[x]][j];\n    }\n}\nvoid slove()\n{\n    for(int i=0;i&lt;=tot;i++)\n    for(int j=0;j&lt;4;j++)\n    if(!tag[i]&amp;&amp;!tag[tr[i][j]]) res.a[i][tr[i][j]]++;\n\n}\nint main()\n{\n    init();\n    scanf(&quot;%d&quot;,&amp;n);scanf(&quot;%d&quot;,&amp;m);\n    for(int i=0;i&lt;4;++i)tr[0][i]=-1;\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s),insert(i);\n    getfail();\n    slove();\n    for(int i=0;i&lt;=tot;++i)ans.a[i][i]=1;\n    if(!m){cout&lt;&lt;0;return 0;}\n    while(m)\n    {\n        if(m&amp;1) ans=ans*res;\n        m/=2;\n        res=res*res;\n    }\n    int anss=0;\n    for(int i=0;i&lt;=tot;++i)(anss+=ans.a[0][i])%=mod;\n    cout&lt;&lt;anss;\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/18/DNA Sequence/","excerpt":"","categories":[{"name":"Hollerith-type","slug":"Hollerith-type","permalink":"https://prostkhala.github.io/categories/Hollerith-type/"},{"name":"AC自动机","slug":"Hollerith-type/AC自动机","permalink":"https://prostkhala.github.io/categories/Hollerith-type/AC自动机/"}],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://prostkhala.github.io/tags/AC自动机/"},{"name":"KMP","slug":"KMP","permalink":"https://prostkhala.github.io/tags/KMP/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://prostkhala.github.io/tags/矩阵快速幂/"}]},{"title":"NOIP模拟赛 2017 3 17","date":"2017-03-17T12:50:23.000Z","path":"2017/03/17/NOIP模拟赛 2017 3 17/","text":"T1 计算几何 题目描述花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问题。今天，他想到了一个十分有意思的题目： 首先，花花会在 x 轴正半轴和 y 轴正半轴分别挑选 n 个点。随后，他将 x 轴的点与 y 轴的点一一连接，形成 n 条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅有一种。最后，花花会给出 m 个询问。对于每个询问，将会给定一个点 P($x_p$ ,$y_p$ )，问线段OP（O 为坐标原点）与 n 条线段会产生多少个交点？ 输入输出格式输入格式：第 1 行包含一个正整数 n，表示线段的数量； 第 2 行包含 n 个正整数，表示花花在 x 轴选取的点的横坐标； 第 3 行包含 n 个正整数，表示花花在 y 轴选取的点的纵坐标； 第 4 行包含一个正整数 m，表示询问数量； 随后 m 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。 输出格式：共 m 行，每行包含一个非负整数，表示你对这条询问给出的答案。 输入输出样例输入样例：3 4 5 3 3 5 4 2 1 1 3 3 输出样例：0 3 数据范围对于 40% 的数据：n,m ≤ $10$； 另有 20% 的数据：n,m ≤ $100$； 另有 20% 的数据：n,m ≤ $1000$； 对于 100% 的数据：n,m ≤ $10^5$,y &lt; $2^{31}$ 题解本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $yp$ 与 $y{mid}$ 大小即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N =1e5+1; int n,m,x[N],y[N]; double a[N]; typedef double db; inline void get(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int main() { // freopen(&quot;geometry.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;geometry.out&quot;,&quot;w&quot;,stdout); get(n); for(int i=1;i&lt;=n;++i)get(x[i]);sort(x+1,x+n+1); for(int i=1;i&lt;=n;++i)get(y[i]);sort(y+1,y+n+1); get(m); for(int i=1,xx,yy;i&lt;=m;++i) { get(xx);get(yy); int l=0,r=n,mid; while(l!=r) { mid=l+r+1&gt;&gt;1; if(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid])); double yt=a[mid]*(db)xx+y[mid]; if(yt&lt;=(db)yy) l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,l); } } T2 花花的聚会 题目描述花花住在 H 国。H 国有 n 个城市，其中 1 号城市为其首都。城市间有 n − 1 条单向道路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市走到首都的路径是唯一的。 过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 m 种过路券，每张过路券以三个整数表示：v k w：你可以在城市 v 以价格 w 买到一张过路券。这张券可以使用 k 次。这意味着，拿着这张券通过了 k 条道路之后，这张券就不能再使用了。 请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，并且在所在的城市再买一张。 花花家在首都。他有 q 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。 花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮他么？ 输入输出格式输入格式：输入的第一行包含两个空格隔开的整数 n 和 m，表示 H 国的城市数量和过路券的种数。 之后的 n − 1 行各自包含两个数 a i 和 b i ，代表城市 a i 到城市 b i 间有一条单向道路。 之后的 m 行每行包括三个整数 v i ,k i 和 w i ，表示一种过路券。 下一行包含一个整数 q，表示花花朋友的数量。 之后的 q 行各自包含一个整数，表示花花朋友的所在城市。 输出格式：输出共 q 行，每一行代表一位朋友的路费。 输入输出样例输入样例：7 7 3 1 2 1 7 6 6 3 5 3 4 3 7 2 3 7 1 1 2 3 5 3 6 2 4 2 4 5 3 10 6 1 20 3 5 6 7 输出样例：10 22 5 数据范围对于 40% 的数据：n,m,q ≤ 10,w i ≤ 10； 另有 20% 的数据：n,m,q ≤ 500,w i ≤ 100； 另有 20% 的数据：n,m,q ≤ 5000,w i ≤ 1000； 对于 100% 的数据：n,m,q ≤ 10 5 ,w i ≤ 10000,1 ≤ v i ,k i ≤ n。 题解树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：$f[y] = min ( f[x] + w[y][i] )( x 为 y 祖先 &amp;&amp; dep[x] - dep[y] &gt; = k[y][i] )$ 先进行拓扑排序，顺序进行操作。对于寻找$min(f[x])$的操作，则可以通过LCA或树链剖分实现。(要开 long long 不然会爆) CODE#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; const int inf =0x7fffffff; const int N =1e5+1; const int maxlogn =21; using namespace std; int deep[N],head[N],head2[N]; long long st[N][maxlogn],minn[N][maxlogn],f[N]; int tot,tot2,n,m,qu; struct edg{int t,ne;}e[N*2]; struct edg2{int k,w,ne;}e2[N*2]; void in(int x,int y) { e[++tot].t=y; e[tot].ne=head[x]; head[x]=tot; return; } void in2(int x,int k,int w) { e2[++tot2].k=k; e2[tot2].w=w; e2[tot2].ne=head2[x]; head2[x]=tot2; return; } void getf(int x,int pre) { st[x][0]=pre;minn[x][0]=f[pre]; for(int i=1;i&lt;maxlogn;i++) { st[x][i]=st[st[x][i-1]][i-1]; minn[x][i]=min(minn[x][i-1],minn[st[x][i-1]][i-1]); } f[x]=x==1?0:inf; for(int i=head2[x];i;i=e2[i].ne) { long long tmp=inf,y=x,k=e2[i].k,p=0; while(k) { if(k&amp;1)tmp=min(tmp,minn[y][p]),y=st[y][p]; p++;k&gt;&gt;=1; } f[x]=min(f[x],tmp+e2[i].w); } for(int i=head[x];i;i=e[i].ne) { int y=e[i].t; if(y!=pre)getf(y,x); } return; } int main() { // freopen(&quot;party.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;party.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x,y;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x); for(int i=1,x,k,w;i&lt;=m;i++)scanf(&quot;%d%d%d&quot;,&amp;x,&amp;k,&amp;w),in2(x,k,w); scanf(&quot;%d&quot;,&amp;qu);getf(1,1); for(int i=1,x;i&lt;=qu;i++){scanf(&quot;%d&quot;,&amp;x);printf(&quot;%d\\n&quot;,f[x]);} } T3 文本编辑器 题目描述九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一些功能。 功能列表如下： &lt; w w 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。 该命令将选定光标向左移动，如果已经是最左端则不移动。 命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。 &gt; w w 同上。 与&lt; 命令不同的是，该命令将光标向右移动。 命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。 I w c w 同上。 c 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。 该命令始终输出“T”。 D w w 同上。 代表删除该光标右侧的一个字符。 命令执行成功时输出“T”，若光标右侧没有字符输出“F”。 R 代表翻转左光标和右光标之间的字符。 该命令只有左光标在右光标左侧时才能执行。 （两光标重合时也不能执行） 命令执行成功时输出“T”，否则输“F”。 S 代表显示当前处理的文本。 该命令只输出文本，不输出“T”和“F”。 开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。 注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。 输入输出格式输入格式：第一行是初始时文本编辑器内容。 第二行是一个正整数 N，N 表示操作次数。 接下来有 N 行，每行有一个命令，命令格式如上方表格。 输出格式：对于每个命令，按上方表格要求执行并输出。 输入输出样例输入样例：goodykc 11 I R u I R l &gt; L &gt; L &gt; L &gt; L R D R &lt; R D R S 输出样例：T T T T T T T F T T goodluck 数据范围对于 40% 的数据：1 ≤ N , 初始文本长度 ≤ 100，数据不包含翻转（Reverse）操作； 另有 30% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据不包含翻转（Reverse）操作； 另有 20% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据包含翻转（Reverse）操作； 对于 100% 的数据：1 ≤ N , 初始文本长度 ≤ 4 × 10 6 ，输出文件大小 ≤ 20MB; 题解用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。 具体的实现代码十分清楚，但还有许多细节要注意，因为l，r的相对位置可能互换，所以只能写左开右开或左闭右闭区间。 CODE#include&lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int N=1e7+1; int tot,m,pos[2],cnt[2],pre[N],next[N]; char opreator,ch[N],str[N]; int move(){getchar();return getchar()==&#39;L&#39;?0:1;} void in(int opreator,char c) { ++tot; ch[tot]=c; int u=pos[opreator],v=next[u]; pre[tot]=u;next[tot]=v; next[u]=tot;pre[v]=tot; if (cnt[opreator^1]&gt;=cnt[opreator])cnt[opreator^1]++; pos[opreator]=tot;cnt[opreator]++; if (pos[opreator^1]==u)pos[opreator^1]=tot; printf(&quot;T\\n&quot;); } void ll(int opreator) { if (pos[opreator]==1){printf(&quot;F\\n&quot;);return;} int u=pos[opreator],v=pre[u]; if (next[v]!=u)swap(next[v],pre[v]); pos[opreator]=v; cnt[opreator]--; printf(&quot;T\\n&quot;); } void rl(int opreator) { if (next[pos[opreator]]==2){printf(&quot;F\\n&quot;);return;} int u=next[pos[opreator]],v=next[u]; if(pre[v]!=u)swap(next[v],pre[v]); pos[opreator]=u;cnt[opreator]++; printf(&quot;T\\n&quot;); } void D(int opreator) { if (next[pos[opreator]]== 2){printf(&quot;F\\n&quot;);return;} int u = pos[opreator], v = next[u], w = next[v]; if (pre[w]!=v) swap(next[w], pre[w]); if (cnt[opreator^1]&gt;cnt[opreator])cnt[opreator^1]--; if (pos[opreator^1]==v)pos[opreator^1]=u; next[u]= w;pre[w]=u; printf(&quot;T\\n&quot;); } void R() { if (cnt[1]-cnt[0]&lt;=0){printf(&quot;F\\n&quot;);return;} if (cnt[1]-cnt[0]==1){printf(&quot;T\\n&quot;);return;} int now=pos[0],ne=next[now],c=pos[1],d=next[c]; swap(pre[ne], next[ne]);swap(pre[c],next[c]); next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne; pos[1]=ne; printf(&quot;T\\n&quot;); } void show() { int u=1; while(true) { if(pre[next[u]]!= u)swap(pre[next[u]],next[next[u]]); u=next[u]; if (u==2)break; putchar(ch[u]); } printf(&quot;\\n&quot;); } void init() { tot=2; pre[1]=-1;next[1]= 2; pre[2]=1;next[2]=-1; pos[0]=pos[1]=cnt[0]=cnt[1]=1; int len=strlen(str); for(int i=0;i&lt;len;i++) { ++tot; ch[tot]=str[i]; pre[tot]= i==0?1:tot-1; next[tot]= i==len-1?2:tot+1; } if(len&gt;0) { next[1]=3;pre[2]=tot; pos[1]=tot;cnt[1]=len+1; } } int act() { if(opreator==&#39;&lt;&#39;) ll(move()); if(opreator==&#39;&gt;&#39;) rl(move()); if(opreator==&#39;I&#39;) { int d=move(); char c=getchar(); while (c&lt;33||c&gt;126)c=getchar(); in(d,c); } if (opreator==&#39;D&#39;) D(move()); if (opreator==&#39;R&#39;) R(); if (opreator==&#39;S&#39;) show(); } int main() { // freopen(&quot;editor.in&quot;,&quot;r&quot;, stdin); // freopen(&quot;editor.out&quot;,&quot;w&quot;, stdout); scanf(&quot;%s&quot;,str); init(); scanf(&quot;%d&quot;,&amp;m); for (int i=1;i&lt;=m;i++) { getchar(); opreator=getchar(); while (opreator!=&#39;&lt;&#39;&amp;&amp; opreator!=&#39;&gt;&#39;&amp;&amp;!(opreator &gt;=&#39;A&#39;&amp;&amp; opreator &lt;=&#39;Z&#39;))opreator=getchar(); act(); } return 0; }","raw":"title: NOIP模拟赛 2017 3 17\ndate: 2017-03-17 20:50:23\ncategories:\n  - NOIP模拟赛\ntags:\n  - 二分答案\n  - 计算几何\n  - 树形动态规划\n  - 动态规划\n  - 链表\n  - 树链剖分\n---\n\n# T1 计算几何\n\n---\n## 题目描述\n花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问\n题。今天，他想到了一个十分有意思的题目：\n\n首先，花花会在 x 轴正半轴和 y 轴正半轴分别挑选 n 个点。随后，他将 x 轴的点与 y 轴\n的点一一连接，形成 n 条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅\n有一种。最后，花花会给出 m 个询问。对于每个询问，将会给定一个点 P($x_p$ ,$y_p$ )，问线段\nOP（O 为坐标原点）与 n 条线段会产生多少个交点？\n\n### 输入输出格式\n#### 输入格式：\n第 1 行包含一个正整数 n，表示线段的数量；\n\n第 2 行包含 n 个正整数，表示花花在 x 轴选取的点的横坐标；\n\n第 3 行包含 n 个正整数，表示花花在 y 轴选取的点的纵坐标；\n\n第 4 行包含一个正整数 m，表示询问数量；\n\n随后 m 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。\n\n\n#### 输出格式：\n\n共 m 行，每行包含一个非负整数，表示你对这条询问给出的答案。\n\n### 输入输出样例\n#### 输入样例：\n    3\n    4 5 3\n    3 5 4\n    2\n    1 1\n    3 3\n    \n\n#### 输出样例：\n    0\n\t3\n\n### 数据范围\n对于 40% 的数据：n,m ≤ $10$；\n\n另有 20% 的数据：n,m ≤ $100$；\n\n另有 20% 的数据：n,m ≤ $1000$；\n\n对于 100% 的数据：n,m ≤ $10^5$,y < $2^{31}$\n\n---\n\n## 题解\n\n本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $y_p$ 与 $y_{mid}$ 大小即可。\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N =1e5+1;\n    int n,m,x[N],y[N];\n    double a[N];\n    typedef double db;\n    inline void get(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int main()\n    {\n    //    freopen(\"geometry.in\",\"r\",stdin);\n    //    freopen(\"geometry.out\",\"w\",stdout);\n        get(n);\n        for(int i=1;i<=n;++i)get(x[i]);sort(x+1,x+n+1);\n        for(int i=1;i<=n;++i)get(y[i]);sort(y+1,y+n+1);\n\n        get(m);\n        for(int i=1,xx,yy;i<=m;++i)\n        {\n            get(xx);get(yy);\n            int l=0,r=n,mid;\n            while(l!=r)\n            {\n                mid=l+r+1>>1;\n                if(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid]));\n                double yt=a[mid]*(db)xx+y[mid];\n                if(yt<=(db)yy) l=mid;\n                else\t\t  r=mid-1;\n            }\n            printf(\"%d\\n\",l);\n        }\n    }\n    \n---\n# T2 花花的聚会\n\n---\n## 题目描述\n花花住在 H 国。H 国有 n 个城市，其中 1 号城市为其首都。城市间有 n − 1 条单向道\n路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市\n走到首都的路径是唯一的。\n\n过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 m 种过\n路券，每张过路券以三个整数表示：v k w：你可以在城市 v 以价格 w 买到一张过路券。这\n张券可以使用 k 次。这意味着，拿着这张券通过了 k 条道路之后，这张券就不能再使用了。\n\n请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，\n并且在所在的城市再买一张。\n\n花花家在首都。他有 q 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道\n每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。\n\n花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮\n他么？\n### 输入输出格式\n#### 输入格式：\n输入的第一行包含两个空格隔开的整数 n 和 m，表示 H 国的城市数量和过路券的种数。\n\n之后的 n − 1 行各自包含两个数 a i 和 b i ，代表城市 a i 到城市 b i 间有一条单向道路。\n\n之后的 m 行每行包括三个整数 v i ,k i 和 w i ，表示一种过路券。\n\n下一行包含一个整数 q，表示花花朋友的数量。\n\n之后的 q 行各自包含一个整数，表示花花朋友的所在城市。\n\n\n\n#### 输出格式：\n\n输出共 q 行，每一行代表一位朋友的路费。\n\n### 输入输出样例\n#### 输入样例：\n    7 7\n    3 1\n    2 1\n    7 6\n    6 3\n    5 3\n    4 3\n    7 2 3\n    7 1 1\n    2 3 5\n    3 6 2\n    4 2 4\n    5 3 10\n    6 1 20\n    3\n    5\n    6\n    7\n\n#### 输出样例：\n    10\n    22\n    5\n    \n\n### 数据范围\n对于 40% 的数据：n,m,q ≤ 10,w i ≤ 10；\n \n另有 20% 的数据：n,m,q ≤ 500,w i ≤ 100；\n\n另有 20% 的数据：n,m,q ≤ 5000,w i ≤ 1000；\n\n对于 100% 的数据：n,m,q ≤ 10 5 ,w i ≤ 10000,1 ≤ v i ,k i ≤ n。\n \n---\n\n## 题解\n\n树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：\n$f[y] = min ( f[x] + w[y][i] )( x 为 y 祖先 && dep[x] - dep[y] > = k[y][i] )$\n\n先进行拓扑排序，顺序进行操作。对于寻找$min(f[x])$的操作，则可以通过LCA或树链剖分实现。(要开 long long 不然会爆)\n\n---\n### CODE\n    #include<iostream>\n    #include<algorithm>\n    #include<cstdio>\n    const int inf =0x7fffffff;\n    const int N =1e5+1;\n    const int maxlogn =21;\n    using namespace std;\n    int deep[N],head[N],head2[N];\n    long long st[N][maxlogn],minn[N][maxlogn],f[N];\n    int tot,tot2,n,m,qu;\n    struct edg{int t,ne;}e[N*2];\n    struct edg2{int k,w,ne;}e2[N*2];\n    void in(int x,int y)\n    {\n        e[++tot].t=y;\n        e[tot].ne=head[x];\n        head[x]=tot;\n        return;\n    }\n\n    void in2(int x,int k,int w)\n    {\n        e2[++tot2].k=k;\n        e2[tot2].w=w;\n        e2[tot2].ne=head2[x];\n        head2[x]=tot2;\n        return;\n    }\n\n    void getf(int x,int pre)\n    {\n        st[x][0]=pre;minn[x][0]=f[pre];\n        for(int i=1;i<maxlogn;i++)\n        {\n            st[x][i]=st[st[x][i-1]][i-1];\n            minn[x][i]=min(minn[x][i-1],minn[st[x][i-1]][i-1]);\n        }\n        f[x]=x==1?0:inf;\n        for(int i=head2[x];i;i=e2[i].ne)\n        {\n            long long tmp=inf,y=x,k=e2[i].k,p=0;\n            while(k)\n            {\n                if(k&1)tmp=min(tmp,minn[y][p]),y=st[y][p];\n                p++;k>>=1;\n            }\n            f[x]=min(f[x],tmp+e2[i].w);\n        }\n        for(int i=head[x];i;i=e[i].ne)\n        {\n            int y=e[i].t;\n            if(y!=pre)getf(y,x);\n        }\n        return;\n    }\n\n    int main()\n    {\n    //    freopen(\"party.in\",\"r\",stdin);\n    //    freopen(\"party.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1,x,y;i<n;i++)scanf(\"%d%d\",&x,&y),in(x,y),in(y,x);\n        for(int i=1,x,k,w;i<=m;i++)scanf(\"%d%d%d\",&x,&k,&w),in2(x,k,w);\n        scanf(\"%d\",&qu);getf(1,1);\n        for(int i=1,x;i<=qu;i++){scanf(\"%d\",&x);printf(\"%d\\n\",f[x]);}\n    }\n---\n# T3 文本编辑器\n\n---\n## 题目描述\n九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时\n在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用\n处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但\n是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一\n些功能。\n\n功能列表如下：\n\n\n    < w\n    \n    w 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。\n    该命令将选定光标向左移动，如果已经是最左端则不移动。\n    命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。\n    \n    > w\n    \n    w 同上。\n    与< 命令不同的是，该命令将光标向右移动。\n    命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。\n    \n    I w c\n    \n    w 同上。\n    c 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。\n    该命令始终输出“T”。\n    \n    D w\n    \n    w 同上。\n    代表删除该光标右侧的一个字符。\n    命令执行成功时输出“T”，若光标右侧没有字符输出“F”。\n    \n    R\n    \n    代表翻转左光标和右光标之间的字符。\n    该命令只有左光标在右光标左侧时才能执行。\n    （两光标重合时也不能执行）\n    命令执行成功时输出“T”，否则输“F”。\n    \n    S\n    \n    代表显示当前处理的文本。\n    该命令只输出文本，不输出“T”和“F”。\n    \n开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。\n\n注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。\n### 输入输出格式\n#### 输入格式：\n第一行是初始时文本编辑器内容。\n\n第二行是一个正整数 N，N 表示操作次数。\n\n接下来有 N 行，每行有一个命令，命令格式如上方表格。\n\n#### 输出格式：\n对于每个命令，按上方表格要求执行并输出。\n\n\n### 输入输出样例\n#### 输入样例：\n    goodykc\n    11\n    I R u\n    I R l\n    > L\n    > L\n    > L\n    > L\n    R\n    D R\n    < R\n    D R\n    S\n\n\n#### 输出样例：\n    T\n    T\n    T\n    T\n    T\n    T\n    T\n    F\n    T\n    T\n    goodluck\n    \n\n### 数据范围\n对于 40% 的数据：1 ≤ N , 初始文本长度 ≤ 100，数据不包含翻转（Reverse）操作；\n\n另有 30% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据不包含翻转（Reverse）操作；\n\n另有 20% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据包含翻转（Reverse）操作；\n\n对于 100% 的数据：1 ≤ N , 初始文本长度 ≤ 4 × 10 6 ，输出文件大小 ≤ 20MB;\n\n---\n\n## 题解\n用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。\n\n具体的实现代码十分清楚，但还有许多细节要注意，因为l，r的相对位置可能互换，所以只能写左开右开或左闭右闭区间。\n\n---\n### CODE\n    #include<iostream>\n    #include <cstdio>\n    #include <cstring>\n    using namespace std;\n    const int N=1e7+1;\n\n    int tot,m,pos[2],cnt[2],pre[N],next[N];\n\n    char opreator,ch[N],str[N];\n\n    int move(){getchar();return getchar()=='L'?0:1;}\n\n    void in(int opreator,char c)\n    {\n        ++tot;\n        ch[tot]=c;\n        int u=pos[opreator],v=next[u];\n\n        pre[tot]=u;next[tot]=v;\n        next[u]=tot;pre[v]=tot;\n\n        if (cnt[opreator^1]>=cnt[opreator])cnt[opreator^1]++;\n\n        pos[opreator]=tot;cnt[opreator]++;\n        if (pos[opreator^1]==u)pos[opreator^1]=tot;\n        printf(\"T\\n\");\n    }\n\n    void ll(int opreator)\n    {\n        if (pos[opreator]==1){printf(\"F\\n\");return;}\n        int u=pos[opreator],v=pre[u];\n\n        if (next[v]!=u)swap(next[v],pre[v]);\n\n        pos[opreator]=v; cnt[opreator]--;\n        printf(\"T\\n\");\n    }\n\n    void rl(int opreator)\n    {\n        if (next[pos[opreator]]==2){printf(\"F\\n\");return;}\n        int u=next[pos[opreator]],v=next[u];\n\n        if(pre[v]!=u)swap(next[v],pre[v]);\n\n        pos[opreator]=u;cnt[opreator]++;\n        printf(\"T\\n\");\t\n    }\n\n    void D(int opreator)\n    {\n        if (next[pos[opreator]]== 2){printf(\"F\\n\");return;}\n        int u = pos[opreator], v = next[u], w = next[v];\n\n        if (pre[w]!=v) swap(next[w], pre[w]);\n        if (cnt[opreator^1]>cnt[opreator])cnt[opreator^1]--;\n        if (pos[opreator^1]==v)pos[opreator^1]=u;\n\n        next[u]= w;pre[w]=u;\n        printf(\"T\\n\");\n    }\n\n    void R()\n    {\n        if (cnt[1]-cnt[0]<=0){printf(\"F\\n\");return;}\n        if (cnt[1]-cnt[0]==1){printf(\"T\\n\");return;}\n        int now=pos[0],ne=next[now],c=pos[1],d=next[c];\n\n        swap(pre[ne], next[ne]);swap(pre[c],next[c]);\n        next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne;\n        pos[1]=ne;\n        printf(\"T\\n\");\n    }\n\n    void show()\n    {\n        int u=1;\n        while(true)\n        {\n            if(pre[next[u]]!= u)swap(pre[next[u]],next[next[u]]);\n            u=next[u];\n            if (u==2)break;\n            putchar(ch[u]);\n        }\n        printf(\"\\n\");\n    }\n\n    void init()\n    {\n        tot=2;\n        pre[1]=-1;next[1]= 2;\n        pre[2]=1;next[2]=-1;\n        pos[0]=pos[1]=cnt[0]=cnt[1]=1;\n        int len=strlen(str);\n        for(int i=0;i<len;i++)\n        {\n            ++tot;\n            ch[tot]=str[i];\n            pre[tot]= i==0?1:tot-1;\n            next[tot]= i==len-1?2:tot+1;\n        }\n        if(len>0)\n        {\n            next[1]=3;pre[2]=tot;\n            pos[1]=tot;cnt[1]=len+1;\n        }\n    }\n\n    int act()\n    {\n        if(opreator=='<') \t\tll(move());\n        if(opreator=='>') \t\trl(move());\n        if(opreator=='I')\n        {\n            int d=move();\n            char c=getchar();\n            while (c<33||c>126)c=getchar();\n            in(d,c);\n        }\n        if (opreator=='D') \t\tD(move());\n        if (opreator=='R') \t\tR();\n        if (opreator=='S') \t\tshow();\n    }\n    int main()\n    {\n    //    freopen(\"editor.in\",\"r\", stdin);\n    //    freopen(\"editor.out\",\"w\", stdout);\n        scanf(\"%s\",str);\n        init();\n        scanf(\"%d\",&m);\n        for (int i=1;i<=m;i++)\n        {\n            getchar();\n            opreator=getchar();\n            while (opreator!='<'&& opreator!='>'&&!(opreator >='A'&& opreator <='Z'))opreator=getchar();\n            act();\n        }\n        return 0;\n    }\n---","content":"<h1 id=\"T1-计算几何\"><a href=\"#T1-计算几何\" class=\"headerlink\" title=\"T1 计算几何\"></a>T1 计算几何</h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问<br>题。今天，他想到了一个十分有意思的题目：</p>\n<p>首先，花花会在 x 轴正半轴和 y 轴正半轴分别挑选 n 个点。随后，他将 x 轴的点与 y 轴<br>的点一一连接，形成 n 条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅<br>有一种。最后，花花会给出 m 个询问。对于每个询问，将会给定一个点 P($x_p$ ,$y_p$ )，问线段<br>OP（O 为坐标原点）与 n 条线段会产生多少个交点？</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第 1 行包含一个正整数 n，表示线段的数量；</p>\n<p>第 2 行包含 n 个正整数，表示花花在 x 轴选取的点的横坐标；</p>\n<p>第 3 行包含 n 个正整数，表示花花在 y 轴选取的点的纵坐标；</p>\n<p>第 4 行包含一个正整数 m，表示询问数量；</p>\n<p>随后 m 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>共 m 行，每行包含一个非负整数，表示你对这条询问给出的答案。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\n4 5 3\n3 5 4\n2\n1 1\n3 3\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>0\n3\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 40% 的数据：n,m ≤ $10$；</p>\n<p>另有 20% 的数据：n,m ≤ $100$；</p>\n<p>另有 20% 的数据：n,m ≤ $1000$；</p>\n<p>对于 100% 的数据：n,m ≤ $10^5$,y &lt; $2^{31}$</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $y<em>p$ 与 $y</em>{mid}$ 大小即可。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N =1e5+1;\nint n,m,x[N],y[N];\ndouble a[N];\ntypedef double db;\ninline void get(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint main()\n{\n//    freopen(&quot;geometry.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;geometry.out&quot;,&quot;w&quot;,stdout);\n    get(n);\n    for(int i=1;i&lt;=n;++i)get(x[i]);sort(x+1,x+n+1);\n    for(int i=1;i&lt;=n;++i)get(y[i]);sort(y+1,y+n+1);\n\n    get(m);\n    for(int i=1,xx,yy;i&lt;=m;++i)\n    {\n        get(xx);get(yy);\n        int l=0,r=n,mid;\n        while(l!=r)\n        {\n            mid=l+r+1&gt;&gt;1;\n            if(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid]));\n            double yt=a[mid]*(db)xx+y[mid];\n            if(yt&lt;=(db)yy) l=mid;\n            else          r=mid-1;\n        }\n        printf(&quot;%d\\n&quot;,l);\n    }\n}\n</code></pre><hr>\n<h1 id=\"T2-花花的聚会\"><a href=\"#T2-花花的聚会\" class=\"headerlink\" title=\"T2 花花的聚会\"></a>T2 花花的聚会</h1><hr>\n<h2 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>花花住在 H 国。H 国有 n 个城市，其中 1 号城市为其首都。城市间有 n − 1 条单向道<br>路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市<br>走到首都的路径是唯一的。</p>\n<p>过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 m 种过<br>路券，每张过路券以三个整数表示：v k w：你可以在城市 v 以价格 w 买到一张过路券。这<br>张券可以使用 k 次。这意味着，拿着这张券通过了 k 条道路之后，这张券就不能再使用了。</p>\n<p>请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，<br>并且在所在的城市再买一张。</p>\n<p>花花家在首都。他有 q 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道<br>每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。</p>\n<p>花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮<br>他么？</p>\n<h3 id=\"输入输出格式-1\"><a href=\"#输入输出格式-1\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：-1\"><a href=\"#输入格式：-1\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入的第一行包含两个空格隔开的整数 n 和 m，表示 H 国的城市数量和过路券的种数。</p>\n<p>之后的 n − 1 行各自包含两个数 a i 和 b i ，代表城市 a i 到城市 b i 间有一条单向道路。</p>\n<p>之后的 m 行每行包括三个整数 v i ,k i 和 w i ，表示一种过路券。</p>\n<p>下一行包含一个整数 q，表示花花朋友的数量。</p>\n<p>之后的 q 行各自包含一个整数，表示花花朋友的所在城市。</p>\n<h4 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出共 q 行，每一行代表一位朋友的路费。</p>\n<h3 id=\"输入输出样例-1\"><a href=\"#输入输出样例-1\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>7 7\n3 1\n2 1\n7 6\n6 3\n5 3\n4 3\n7 2 3\n7 1 1\n2 3 5\n3 6 2\n4 2 4\n5 3 10\n6 1 20\n3\n5\n6\n7\n</code></pre><h4 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>10\n22\n5\n</code></pre><h3 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 40% 的数据：n,m,q ≤ 10,w i ≤ 10；</p>\n<p>另有 20% 的数据：n,m,q ≤ 500,w i ≤ 100；</p>\n<p>另有 20% 的数据：n,m,q ≤ 5000,w i ≤ 1000；</p>\n<p>对于 100% 的数据：n,m,q ≤ 10 5 ,w i ≤ 10000,1 ≤ v i ,k i ≤ n。</p>\n<hr>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：<br>$f[y] = min ( f[x] + w[y][i] )( x 为 y 祖先 &amp;&amp; dep[x] - dep[y] &gt; = k[y][i] )$</p>\n<p>先进行拓扑排序，顺序进行操作。对于寻找$min(f[x])$的操作，则可以通过LCA或树链剖分实现。(要开 long long 不然会爆)</p>\n<hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nconst int inf =0x7fffffff;\nconst int N =1e5+1;\nconst int maxlogn =21;\nusing namespace std;\nint deep[N],head[N],head2[N];\nlong long st[N][maxlogn],minn[N][maxlogn],f[N];\nint tot,tot2,n,m,qu;\nstruct edg{int t,ne;}e[N*2];\nstruct edg2{int k,w,ne;}e2[N*2];\nvoid in(int x,int y)\n{\n    e[++tot].t=y;\n    e[tot].ne=head[x];\n    head[x]=tot;\n    return;\n}\n\nvoid in2(int x,int k,int w)\n{\n    e2[++tot2].k=k;\n    e2[tot2].w=w;\n    e2[tot2].ne=head2[x];\n    head2[x]=tot2;\n    return;\n}\n\nvoid getf(int x,int pre)\n{\n    st[x][0]=pre;minn[x][0]=f[pre];\n    for(int i=1;i&lt;maxlogn;i++)\n    {\n        st[x][i]=st[st[x][i-1]][i-1];\n        minn[x][i]=min(minn[x][i-1],minn[st[x][i-1]][i-1]);\n    }\n    f[x]=x==1?0:inf;\n    for(int i=head2[x];i;i=e2[i].ne)\n    {\n        long long tmp=inf,y=x,k=e2[i].k,p=0;\n        while(k)\n        {\n            if(k&amp;1)tmp=min(tmp,minn[y][p]),y=st[y][p];\n            p++;k&gt;&gt;=1;\n        }\n        f[x]=min(f[x],tmp+e2[i].w);\n    }\n    for(int i=head[x];i;i=e[i].ne)\n    {\n        int y=e[i].t;\n        if(y!=pre)getf(y,x);\n    }\n    return;\n}\n\nint main()\n{\n//    freopen(&quot;party.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;party.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1,x,y;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x);\n    for(int i=1,x,k,w;i&lt;=m;i++)scanf(&quot;%d%d%d&quot;,&amp;x,&amp;k,&amp;w),in2(x,k,w);\n    scanf(&quot;%d&quot;,&amp;qu);getf(1,1);\n    for(int i=1,x;i&lt;=qu;i++){scanf(&quot;%d&quot;,&amp;x);printf(&quot;%d\\n&quot;,f[x]);}\n}\n</code></pre><hr>\n<h1 id=\"T3-文本编辑器\"><a href=\"#T3-文本编辑器\" class=\"headerlink\" title=\"T3 文本编辑器\"></a>T3 文本编辑器</h1><hr>\n<h2 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时<br>在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用<br>处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但<br>是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一<br>些功能。</p>\n<p>功能列表如下：</p>\n<pre><code>&lt; w\n\nw 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。\n该命令将选定光标向左移动，如果已经是最左端则不移动。\n命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。\n\n&gt; w\n\nw 同上。\n与&lt; 命令不同的是，该命令将光标向右移动。\n命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。\n\nI w c\n\nw 同上。\nc 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。\n该命令始终输出“T”。\n\nD w\n\nw 同上。\n代表删除该光标右侧的一个字符。\n命令执行成功时输出“T”，若光标右侧没有字符输出“F”。\n\nR\n\n代表翻转左光标和右光标之间的字符。\n该命令只有左光标在右光标左侧时才能执行。\n（两光标重合时也不能执行）\n命令执行成功时输出“T”，否则输“F”。\n\nS\n\n代表显示当前处理的文本。\n该命令只输出文本，不输出“T”和“F”。\n</code></pre><p>开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。</p>\n<p>注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。</p>\n<h3 id=\"输入输出格式-2\"><a href=\"#输入输出格式-2\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：-2\"><a href=\"#输入格式：-2\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行是初始时文本编辑器内容。</p>\n<p>第二行是一个正整数 N，N 表示操作次数。</p>\n<p>接下来有 N 行，每行有一个命令，命令格式如上方表格。</p>\n<h4 id=\"输出格式：-2\"><a href=\"#输出格式：-2\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于每个命令，按上方表格要求执行并输出。</p>\n<h3 id=\"输入输出样例-2\"><a href=\"#输入输出样例-2\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-2\"><a href=\"#输入样例：-2\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>goodykc\n11\nI R u\nI R l\n&gt; L\n&gt; L\n&gt; L\n&gt; L\nR\nD R\n&lt; R\nD R\nS\n</code></pre><h4 id=\"输出样例：-2\"><a href=\"#输出样例：-2\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>T\nT\nT\nT\nT\nT\nT\nF\nT\nT\ngoodluck\n</code></pre><h3 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 40% 的数据：1 ≤ N , 初始文本长度 ≤ 100，数据不包含翻转（Reverse）操作；</p>\n<p>另有 30% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据不包含翻转（Reverse）操作；</p>\n<p>另有 20% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据包含翻转（Reverse）操作；</p>\n<p>对于 100% 的数据：1 ≤ N , 初始文本长度 ≤ 4 × 10 6 ，输出文件大小 ≤ 20MB;</p>\n<hr>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。</p>\n<p>具体的实现代码十分清楚，但还有许多细节要注意，因为l，r的相对位置可能互换，所以只能写左开右开或左闭右闭区间。</p>\n<hr>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int N=1e7+1;\n\nint tot,m,pos[2],cnt[2],pre[N],next[N];\n\nchar opreator,ch[N],str[N];\n\nint move(){getchar();return getchar()==&#39;L&#39;?0:1;}\n\nvoid in(int opreator,char c)\n{\n    ++tot;\n    ch[tot]=c;\n    int u=pos[opreator],v=next[u];\n\n    pre[tot]=u;next[tot]=v;\n    next[u]=tot;pre[v]=tot;\n\n    if (cnt[opreator^1]&gt;=cnt[opreator])cnt[opreator^1]++;\n\n    pos[opreator]=tot;cnt[opreator]++;\n    if (pos[opreator^1]==u)pos[opreator^1]=tot;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid ll(int opreator)\n{\n    if (pos[opreator]==1){printf(&quot;F\\n&quot;);return;}\n    int u=pos[opreator],v=pre[u];\n\n    if (next[v]!=u)swap(next[v],pre[v]);\n\n    pos[opreator]=v; cnt[opreator]--;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid rl(int opreator)\n{\n    if (next[pos[opreator]]==2){printf(&quot;F\\n&quot;);return;}\n    int u=next[pos[opreator]],v=next[u];\n\n    if(pre[v]!=u)swap(next[v],pre[v]);\n\n    pos[opreator]=u;cnt[opreator]++;\n    printf(&quot;T\\n&quot;);    \n}\n\nvoid D(int opreator)\n{\n    if (next[pos[opreator]]== 2){printf(&quot;F\\n&quot;);return;}\n    int u = pos[opreator], v = next[u], w = next[v];\n\n    if (pre[w]!=v) swap(next[w], pre[w]);\n    if (cnt[opreator^1]&gt;cnt[opreator])cnt[opreator^1]--;\n    if (pos[opreator^1]==v)pos[opreator^1]=u;\n\n    next[u]= w;pre[w]=u;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid R()\n{\n    if (cnt[1]-cnt[0]&lt;=0){printf(&quot;F\\n&quot;);return;}\n    if (cnt[1]-cnt[0]==1){printf(&quot;T\\n&quot;);return;}\n    int now=pos[0],ne=next[now],c=pos[1],d=next[c];\n\n    swap(pre[ne], next[ne]);swap(pre[c],next[c]);\n    next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne;\n    pos[1]=ne;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid show()\n{\n    int u=1;\n    while(true)\n    {\n        if(pre[next[u]]!= u)swap(pre[next[u]],next[next[u]]);\n        u=next[u];\n        if (u==2)break;\n        putchar(ch[u]);\n    }\n    printf(&quot;\\n&quot;);\n}\n\nvoid init()\n{\n    tot=2;\n    pre[1]=-1;next[1]= 2;\n    pre[2]=1;next[2]=-1;\n    pos[0]=pos[1]=cnt[0]=cnt[1]=1;\n    int len=strlen(str);\n    for(int i=0;i&lt;len;i++)\n    {\n        ++tot;\n        ch[tot]=str[i];\n        pre[tot]= i==0?1:tot-1;\n        next[tot]= i==len-1?2:tot+1;\n    }\n    if(len&gt;0)\n    {\n        next[1]=3;pre[2]=tot;\n        pos[1]=tot;cnt[1]=len+1;\n    }\n}\n\nint act()\n{\n    if(opreator==&#39;&lt;&#39;)         ll(move());\n    if(opreator==&#39;&gt;&#39;)         rl(move());\n    if(opreator==&#39;I&#39;)\n    {\n        int d=move();\n        char c=getchar();\n        while (c&lt;33||c&gt;126)c=getchar();\n        in(d,c);\n    }\n    if (opreator==&#39;D&#39;)         D(move());\n    if (opreator==&#39;R&#39;)         R();\n    if (opreator==&#39;S&#39;)         show();\n}\nint main()\n{\n//    freopen(&quot;editor.in&quot;,&quot;r&quot;, stdin);\n//    freopen(&quot;editor.out&quot;,&quot;w&quot;, stdout);\n    scanf(&quot;%s&quot;,str);\n    init();\n    scanf(&quot;%d&quot;,&amp;m);\n    for (int i=1;i&lt;=m;i++)\n    {\n        getchar();\n        opreator=getchar();\n        while (opreator!=&#39;&lt;&#39;&amp;&amp; opreator!=&#39;&gt;&#39;&amp;&amp;!(opreator &gt;=&#39;A&#39;&amp;&amp; opreator &lt;=&#39;Z&#39;))opreator=getchar();\n        act();\n    }\n    return 0;\n}\n</code></pre><hr>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/17/NOIP模拟赛 2017 3 17/","excerpt":"","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"https://prostkhala.github.io/categories/NOIP模拟赛/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://prostkhala.github.io/tags/二分答案/"},{"name":"计算几何","slug":"计算几何","permalink":"https://prostkhala.github.io/tags/计算几何/"},{"name":"树形动态规划","slug":"树形动态规划","permalink":"https://prostkhala.github.io/tags/树形动态规划/"},{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"链表","slug":"链表","permalink":"https://prostkhala.github.io/tags/链表/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://prostkhala.github.io/tags/树链剖分/"}]},{"title":"NOIP模拟赛 2017 3 16","date":"2017-03-17T10:42:51.000Z","path":"2017/03/17/NOIP模拟赛 2017 3 16/","text":"T1 题目描述输入输出格式输入格式：输出格式：输入输出样例输入样例：输出样例：数据范围 题解 CODE T2 题目描述输入输出格式输入格式：输出格式：输入输出样例输入样例：输出样例：数据范围 题解 CODE T3 题目描述输入输出格式输入格式：输出格式：输入输出样例输入样例：输出样例：数据范围 题解 CODE","raw":"title: NOIP模拟赛 2017 3 16\ndate: 2017-03-17 18:42:51\ncategories:\n  - NOIP模拟赛\ntags:\n  - no yet\n---\n\n# T1 \n\n---\n## 题目描述\n\n### 输入输出格式\n#### 输入格式：\n\n\n\n#### 输出格式：\n\n\n\n### 输入输出样例\n#### 输入样例：\n\n    \n\n#### 输出样例：\n\n    \n\n### 数据范围\n\n---\n\n## 题解\n\n---\n### CODE\n\n\n---\n# T2 \n\n---\n## 题目描述\n\n### 输入输出格式\n#### 输入格式：\n\n\n\n#### 输出格式：\n\n\n\n### 输入输出样例\n#### 输入样例：\n\n    \n\n#### 输出样例：\n\n    \n\n### 数据范围\n\n---\n\n## 题解\n\n---\n### CODE\n\n\n---\n# T3 \n\n---\n## 题目描述\n\n### 输入输出格式\n#### 输入格式：\n\n\n\n#### 输出格式：\n\n\n\n### 输入输出样例\n#### 输入样例：\n\n    \n\n#### 输出样例：\n\n    \n\n### 数据范围\n\n---\n\n## 题解\n\n---\n### CODE\n\n---","content":"<h1 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a>T1</h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><hr>\n<h1 id=\"T2\"><a href=\"#T2\" class=\"headerlink\" title=\"T2\"></a>T2</h1><hr>\n<h2 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><h3 id=\"输入输出格式-1\"><a href=\"#输入输出格式-1\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：-1\"><a href=\"#输入格式：-1\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><h4 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><h3 id=\"输入输出样例-1\"><a href=\"#输入输出样例-1\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><h4 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><h3 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><hr>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><hr>\n<h1 id=\"T3\"><a href=\"#T3\" class=\"headerlink\" title=\"T3\"></a>T3</h1><hr>\n<h2 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><h3 id=\"输入输出格式-2\"><a href=\"#输入输出格式-2\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：-2\"><a href=\"#输入格式：-2\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><h4 id=\"输出格式：-2\"><a href=\"#输出格式：-2\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><h3 id=\"输入输出样例-2\"><a href=\"#输入输出样例-2\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-2\"><a href=\"#输入样例：-2\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><h4 id=\"输出样例：-2\"><a href=\"#输出样例：-2\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><h3 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><hr>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h2><hr>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><hr>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/17/NOIP模拟赛 2017 3 16/","excerpt":"","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"https://prostkhala.github.io/categories/NOIP模拟赛/"}],"tags":[{"name":"no yet","slug":"no-yet","permalink":"https://prostkhala.github.io/tags/no-yet/"}]},{"title":"病毒侵袭","date":"2017-03-17T02:21:17.000Z","path":"2017/03/17/AC自动机 模板/","text":"病毒侵袭hdu 2896 题目描述当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~ 但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。 万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~ 输入输出格式输入格式：第一行，一个整数N（1&lt;=N&lt;=500），表示病毒特征码的个数。 接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。每个病毒都有一个编号，依此为1—N。 不同编号的病毒特征码不会相同。 在这之后一行，有一个整数M（1&lt;=M&lt;=1000），表示网站数。 接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。 每个网站都有一个编号，依此为1—M。 以上字符串中字符都是ASCII码可见字符（不包括回车）。 输出格式：依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。 web 网站编号: 病毒编号 病毒编号 … 冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。 最后一行输出统计信息，如下格式 total: 带病毒网站数 (冒号后有一个空格) 输入输出样例输入样例#1：3 aaa bbb ccc 2 aaabbbccc bbaacc 输出样例#1：web 1: 1 2 3 total: 1 AC自动机模板题CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N=501*201+5; const int maxf = 128; int ans[1001],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N]; char s[10001]; bool use[N]; void insert(int noww) { int n=strlen(s),now=0; for(int i=0;i&lt;n;++i) { if(tr[now][s[i]]==-1) { tr[now][s[i]]=++tot; for(int j=0;j&lt;maxf;++j)tr[tot][j]=-1; tag[tot]=0; } now=tr[now][s[i]]; } tag[now]=noww; } void getfail() { queue&lt;int&gt;q; fail[0]=0; for(int i=0;i&lt;maxf;++i) if(tr[0][i]!=-1) fail[tr[0][i]]=0,q.push(tr[0][i]); else tr[0][i]=0; while(!q.empty()) { int x=q.front();q.pop(); for(int j=0;j&lt;maxf;++j) if(tr[x][j]!=-1) {q.push(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];} else tr[x][j]=tr[fail[x]][j]; } } void solve(int noww) { int n=strlen(s),now=0; memset(use,0,sizeof(use)); tmp=0; for(int i=0;i&lt;n;++i) { now=tr[now][s[i]]; for(int j=now;j;j=fail[j]) if(tag[j]&amp;&amp;!use[tag[j]]) ans[++tmp]=tag[j],use[tag[j]]=1; } if(tmp) { ans2++; printf(&quot;web %d:&quot;,noww); sort(ans+1,ans+tmp+1); for(int j=1;j&lt;=tmp;++j) printf(&quot; %d&quot;,ans[j]); printf(&quot;\\n&quot;); } } int main() { int n,m; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;maxf;++i)tr[0][i]=-1; for(int i=1;i&lt;=n;++i) scanf(&quot;%s&quot;,s),insert(i); getfail(); scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;++i) scanf(&quot;%s&quot;,s),solve(i); printf(&quot;total: %d\\n&quot;,ans2); }","raw":"title: 病毒侵袭\ndate: 2017-03-17 10:21:17\ncategories:\n  - Hollerith-type\n  - AC自动机\ntags:\n  - AC自动机\n  - 模板\n  - KMP\n  - 字符串问题\n---\n\n# 病毒侵袭\n\n## [hdu 2896]()\n\n---\n## 题目描述\n\n当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~\n\n但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。\n\n万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~\n### 输入输出格式\n#### 输入格式：\n第一行，一个整数N（1<=N<=500），表示病毒特征码的个数。\n\n接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。\n每个病毒都有一个编号，依此为1—N。\n\n不同编号的病毒特征码不会相同。\n\n在这之后一行，有一个整数M（1<=M<=1000），表示网站数。\n\n接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。\n\n每个网站都有一个编号，依此为1—M。\n\n以上字符串中字符都是ASCII码可见字符（不包括回车）。\n#### 输出格式：\n依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。\n\nweb 网站编号: 病毒编号 病毒编号 …\n\n冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。\n\n最后一行输出统计信息，如下格式\n\ntotal: 带病毒网站数\n\n(冒号后有一个空格)\n\n\n### 输入输出样例\n#### 输入样例#1：\n    3\n    aaa\n    bbb\n    ccc\n    2\n    aaabbbccc\n    bbaacc\n\n\n    \n\n#### 输出样例#1：\n\n    web 1: 1 2 3\n\ttotal: 1\n\n---\nAC自动机模板题\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<queue>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N=501*201+5;\n    const int maxf = 128;\n    int ans[1001],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N];\n    char s[10001];\n    bool use[N];\n    void insert(int noww)\n    {\n        int n=strlen(s),now=0;\n        for(int i=0;i<n;++i)\n        {\n            if(tr[now][s[i]]==-1)\n            {\n                tr[now][s[i]]=++tot;\n                for(int j=0;j<maxf;++j)tr[tot][j]=-1;\n                tag[tot]=0;\n            }\n            now=tr[now][s[i]];\n        }\n        tag[now]=noww;\n    }\n    void getfail()\n    {\n        queue<int>q;\n        fail[0]=0;\n        for(int i=0;i<maxf;++i)\n        if(tr[0][i]!=-1)\n        fail[tr[0][i]]=0,q.push(tr[0][i]);\n        else tr[0][i]=0;\n        while(!q.empty())\n        {\n            int x=q.front();q.pop();\n            for(int j=0;j<maxf;++j)\n            if(tr[x][j]!=-1)\n            {q.push(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];}\n            else\n            tr[x][j]=tr[fail[x]][j];\n        }\n    }\n    void solve(int noww)\n    {\n        int n=strlen(s),now=0;\n        memset(use,0,sizeof(use));\n        tmp=0;\n        for(int i=0;i<n;++i)\n        {\n            now=tr[now][s[i]];\n            for(int j=now;j;j=fail[j])\n            if(tag[j]&&!use[tag[j]])\n            ans[++tmp]=tag[j],use[tag[j]]=1;\n        }\n        if(tmp)\n        {\n            ans2++;\n            printf(\"web %d:\",noww);\n            sort(ans+1,ans+tmp+1);\n            for(int j=1;j<=tmp;++j)\n            printf(\" %d\",ans[j]);\n            printf(\"\\n\");\n        }\n    }\n    int main()\n    {\n        int n,m;\n        scanf(\"%d\",&n);\n        for(int i=0;i<maxf;++i)tr[0][i]=-1;\n        for(int i=1;i<=n;++i)\n        scanf(\"%s\",s),insert(i);\n        getfail();\n        scanf(\"%d\",&m);\n        for(int i=1;i<=m;++i)\n        scanf(\"%s\",s),solve(i);\n            printf(\"total: %d\\n\",ans2);\n    }","content":"<h1 id=\"病毒侵袭\"><a href=\"#病毒侵袭\" class=\"headerlink\" title=\"病毒侵袭\"></a>病毒侵袭</h1><h2 id=\"hdu-2896\"><a href=\"#hdu-2896\" class=\"headerlink\" title=\"hdu 2896\"></a><a href=\"\">hdu 2896</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~</p>\n<p>但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。</p>\n<p>万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行，一个整数N（1&lt;=N&lt;=500），表示病毒特征码的个数。</p>\n<p>接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。<br>每个病毒都有一个编号，依此为1—N。</p>\n<p>不同编号的病毒特征码不会相同。</p>\n<p>在这之后一行，有一个整数M（1&lt;=M&lt;=1000），表示网站数。</p>\n<p>接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。</p>\n<p>每个网站都有一个编号，依此为1—M。</p>\n<p>以上字符串中字符都是ASCII码可见字符（不包括回车）。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。</p>\n<p>web 网站编号: 病毒编号 病毒编号 …</p>\n<p>冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。</p>\n<p>最后一行输出统计信息，如下格式</p>\n<p>total: 带病毒网站数</p>\n<p>(冒号后有一个空格)</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>3\naaa\nbbb\nccc\n2\naaabbbccc\nbbaacc\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>web 1: 1 2 3\ntotal: 1\n</code></pre><hr>\n<h2 id=\"AC自动机模板题\"><a href=\"#AC自动机模板题\" class=\"headerlink\" title=\"AC自动机模板题\"></a>AC自动机模板题</h2><h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;queue&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N=501*201+5;\nconst int maxf = 128;\nint ans[1001],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N];\nchar s[10001];\nbool use[N];\nvoid insert(int noww)\n{\n    int n=strlen(s),now=0;\n    for(int i=0;i&lt;n;++i)\n    {\n        if(tr[now][s[i]]==-1)\n        {\n            tr[now][s[i]]=++tot;\n            for(int j=0;j&lt;maxf;++j)tr[tot][j]=-1;\n            tag[tot]=0;\n        }\n        now=tr[now][s[i]];\n    }\n    tag[now]=noww;\n}\nvoid getfail()\n{\n    queue&lt;int&gt;q;\n    fail[0]=0;\n    for(int i=0;i&lt;maxf;++i)\n    if(tr[0][i]!=-1)\n    fail[tr[0][i]]=0,q.push(tr[0][i]);\n    else tr[0][i]=0;\n    while(!q.empty())\n    {\n        int x=q.front();q.pop();\n        for(int j=0;j&lt;maxf;++j)\n        if(tr[x][j]!=-1)\n        {q.push(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];}\n        else\n        tr[x][j]=tr[fail[x]][j];\n    }\n}\nvoid solve(int noww)\n{\n    int n=strlen(s),now=0;\n    memset(use,0,sizeof(use));\n    tmp=0;\n    for(int i=0;i&lt;n;++i)\n    {\n        now=tr[now][s[i]];\n        for(int j=now;j;j=fail[j])\n        if(tag[j]&amp;&amp;!use[tag[j]])\n        ans[++tmp]=tag[j],use[tag[j]]=1;\n    }\n    if(tmp)\n    {\n        ans2++;\n        printf(&quot;web %d:&quot;,noww);\n        sort(ans+1,ans+tmp+1);\n        for(int j=1;j&lt;=tmp;++j)\n        printf(&quot; %d&quot;,ans[j]);\n        printf(&quot;\\n&quot;);\n    }\n}\nint main()\n{\n    int n,m;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;maxf;++i)tr[0][i]=-1;\n    for(int i=1;i&lt;=n;++i)\n    scanf(&quot;%s&quot;,s),insert(i);\n    getfail();\n    scanf(&quot;%d&quot;,&amp;m);\n    for(int i=1;i&lt;=m;++i)\n    scanf(&quot;%s&quot;,s),solve(i);\n        printf(&quot;total: %d\\n&quot;,ans2);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/17/AC自动机 模板/","excerpt":"","categories":[{"name":"Hollerith-type","slug":"Hollerith-type","permalink":"https://prostkhala.github.io/categories/Hollerith-type/"},{"name":"AC自动机","slug":"Hollerith-type/AC自动机","permalink":"https://prostkhala.github.io/categories/Hollerith-type/AC自动机/"}],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://prostkhala.github.io/tags/AC自动机/"},{"name":"模板","slug":"模板","permalink":"https://prostkhala.github.io/tags/模板/"},{"name":"KMP","slug":"KMP","permalink":"https://prostkhala.github.io/tags/KMP/"},{"name":"字符串问题","slug":"字符串问题","permalink":"https://prostkhala.github.io/tags/字符串问题/"}]},{"title":"HAOI2007 理想的正方形","date":"2017-03-14T07:36:17.000Z","path":"2017/03/14/理想的正方形/","text":"[HAOI2007] 理想的正方形BZOJ1047 洛谷2216 题目描述有一个ab的整数组成的矩阵，现请你从中找出一个nn的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 输入输出格式输入格式：第一行为3个整数，分别表示a,b,n的值 第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。 输出格式：仅一个整数，为ab矩阵中所有“nn正方形区域中的最大整数和最小整数的差值”的最小值。 输入输出样例输入样例：5 4 2 1 2 5 6 0 17 16 0 16 17 2 1 2 10 2 1 1 2 2 2 输出样例：1 数据范围矩阵中的所有数都不超过1,000,000,000 20%的数据2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10 100%的数据2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100 题解二维滑动窗口，先对每一行建立双端队列，记录每一个$1n$的长方体中的极值，将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n1$的长方体(在原矩阵中为nn的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的nn正方形的极值信息)，枚举即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int inf = 0x7fffffff; const int N =1e3+1; inline int get(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N]; int y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N]; int mapp[N][N],a,b,n; long long ans=inf; int main() { get(a),get(b),get(n); for(int i=1;i&lt;=a;++i)for(int t=1;t&lt;=b;++t)get(mapp[i][t]); for(int i=1;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1; for(int i=1;i&lt;=a;++i) for(int t=1;t&lt;=b;++t) { while(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--; x1[++tailx1[i]]=t; while(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++; minx[i][t]=mapp[i][x1[headx1[i]]]; } for(int i=1;i&lt;=a;++i) for(int t=1;t&lt;=b;++t) { while(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--; x2[++tailx2[i]]=t; while(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++; maxx[i][t]=mapp[i][x2[headx2[i]]]; } for(int t=n;t&lt;=b;++t) for(int i=1;i&lt;=a;++i) { while(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--; y1[++taily1[t]]=i; while(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++; miny[i][t]=minx[y1[heady1[t]]][t]; } for(int t=n;t&lt;=b;++t) for(int i=1;i&lt;=a;++i) { while(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--; y2[++taily2[t]]=i; while(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++; maxy[i][t]=maxx[y2[heady2[t]]][t]; } for(int t=n;t&lt;=b;++t) for(int i=n;i&lt;=a;++i) if(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t]; printf(&quot;%lld&quot;,ans); }","raw":"\n\ntitle: HAOI2007 理想的正方形\ndate: 2017-03-14 15:36:17\ncategories:\n  - 动态规划\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n---\n\n# [HAOI2007] 理想的正方形\n\n## [BZOJ1047](http://www.lydsy.com/JudgeOnline/problem.php?id=1047) [洛谷2216](https://www.luogu.org/problem/show?pid=2216)\n\n---\n## 题目描述\n\n有一个a*b的整数组成的矩阵，现请你从中找出一个n*n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。\n\n### 输入输出格式\n#### 输入格式：\n第一行为3个整数，分别表示a,b,n的值\n\n第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。\n\n\n#### 输出格式：\n仅一个整数，为a*b矩阵中所有“n*n正方形区域中的最大整数和最小整数的差值”的最小值。\n\n\n### 输入输出样例\n#### 输入样例：\n    5 4 2\n    1 2 5 6\n    0 17 16 0\n    16 17 2 1\n    2 10 2 1\n    1 2 2 2\n    \n\n#### 输出样例：\n\t1\n    \n\n### 数据范围\n矩阵中的所有数都不超过1,000,000,000\n\n20%的数据2<=a,b<=100,n<=a,n<=b,n<=10\n\n100%的数据2<=a,b<=1000,n<=a,n<=b,n<=100\n\n---\n\n## 题解\n二维滑动窗口，先对每一行建立双端队列，记录每一个$1*n$的长方体中的极值，\n将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n*1$的长方体(在原矩阵中为n*n的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的n*n正方形的极值信息)，枚举即可。\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<queue>\n    using namespace std;\n    const int inf = 0x7fffffff;\n    const int N =1e3+1;\n    inline int get(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];\n    int y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];\n    int mapp[N][N],a,b,n;\n    long long ans=inf;\n    int main()\n    {\n\n        get(a),get(b),get(n);\n        for(int i=1;i<=a;++i)for(int t=1;t<=b;++t)get(mapp[i][t]);\n        for(int i=1;i<N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1;\n        for(int i=1;i<=a;++i)\n        for(int t=1;t<=b;++t)\n        {\n            while(headx1[i]<=tailx1[i]&&mapp[i][x1[tailx1[i]]]>=mapp[i][t])tailx1[i]--;\n            x1[++tailx1[i]]=t;\n            while(headx1[i]<=tailx1[i]&&x1[headx1[i]]<=t-n)headx1[i]++;\n            minx[i][t]=mapp[i][x1[headx1[i]]];\n        }\n        for(int i=1;i<=a;++i)\n        for(int t=1;t<=b;++t)\n        {\n            while(headx2[i]<=tailx2[i]&&mapp[i][x2[tailx2[i]]]<=mapp[i][t])tailx2[i]--;\n            x2[++tailx2[i]]=t;\n            while(headx2[i]<=tailx2[i]&&x2[headx2[i]]<=t-n)headx2[i]++;\n            maxx[i][t]=mapp[i][x2[headx2[i]]];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=1;i<=a;++i)\n        {\n            while(heady1[t]<=taily1[t]&&minx[y1[taily1[t]]][t]>=minx[i][t])taily1[t]--;\n            y1[++taily1[t]]=i;\n            while(heady1[t]<=taily1[t]&&y1[heady1[t]]<=i-n)heady1[t]++;\n            miny[i][t]=minx[y1[heady1[t]]][t];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=1;i<=a;++i)\n        {\n            while(heady2[t]<=taily2[t]&&maxx[y2[taily2[t]]][t]<=maxx[i][t])taily2[t]--;\n            y2[++taily2[t]]=i;\n            while(heady2[t]<=taily2[t]&&y2[heady2[t]]<=i-n)heady2[t]++;\n            maxy[i][t]=maxx[y2[heady2[t]]][t];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=n;i<=a;++i)\n        if(maxy[i][t]-miny[i][t]<ans)ans=maxy[i][t]-miny[i][t];\n        printf(\"%lld\",ans);\n    }","content":"<h1 id=\"HAOI2007-理想的正方形\"><a href=\"#HAOI2007-理想的正方形\" class=\"headerlink\" title=\"[HAOI2007] 理想的正方形\"></a>[HAOI2007] 理想的正方形</h1><h2 id=\"BZOJ1047-洛谷2216\"><a href=\"#BZOJ1047-洛谷2216\" class=\"headerlink\" title=\"BZOJ1047 洛谷2216\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1047\" target=\"_blank\" rel=\"external\">BZOJ1047</a> <a href=\"https://www.luogu.org/problem/show?pid=2216\" target=\"_blank\" rel=\"external\">洛谷2216</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有一个a<em>b的整数组成的矩阵，现请你从中找出一个n</em>n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行为3个整数，分别表示a,b,n的值</p>\n<p>第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>仅一个整数，为a<em>b矩阵中所有“n</em>n正方形区域中的最大整数和最小整数的差值”的最小值。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>5 4 2\n1 2 5 6\n0 17 16 0\n16 17 2 1\n2 10 2 1\n1 2 2 2\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>1\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>矩阵中的所有数都不超过1,000,000,000</p>\n<p>20%的数据2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10</p>\n<p>100%的数据2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>二维滑动窗口，先对每一行建立双端队列，记录每一个$1<em>n$的长方体中的极值，<br>将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n</em>1$的长方体(在原矩阵中为n<em>n的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的n</em>n正方形的极值信息)，枚举即可。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int inf = 0x7fffffff;\nconst int N =1e3+1;\ninline int get(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];\nint y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];\nint mapp[N][N],a,b,n;\nlong long ans=inf;\nint main()\n{\n\n    get(a),get(b),get(n);\n    for(int i=1;i&lt;=a;++i)for(int t=1;t&lt;=b;++t)get(mapp[i][t]);\n    for(int i=1;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1;\n    for(int i=1;i&lt;=a;++i)\n    for(int t=1;t&lt;=b;++t)\n    {\n        while(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--;\n        x1[++tailx1[i]]=t;\n        while(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++;\n        minx[i][t]=mapp[i][x1[headx1[i]]];\n    }\n    for(int i=1;i&lt;=a;++i)\n    for(int t=1;t&lt;=b;++t)\n    {\n        while(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--;\n        x2[++tailx2[i]]=t;\n        while(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++;\n        maxx[i][t]=mapp[i][x2[headx2[i]]];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=1;i&lt;=a;++i)\n    {\n        while(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--;\n        y1[++taily1[t]]=i;\n        while(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++;\n        miny[i][t]=minx[y1[heady1[t]]][t];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=1;i&lt;=a;++i)\n    {\n        while(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--;\n        y2[++taily2[t]]=i;\n        while(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++;\n        maxy[i][t]=maxx[y2[heady2[t]]][t];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=n;i&lt;=a;++i)\n    if(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t];\n    printf(&quot;%lld&quot;,ans);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/14/理想的正方形/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"}]},{"title":"NOIP模拟赛 2017 3 12","date":"2017-03-13T10:01:11.000Z","path":"2017/03/13/NOIP模拟赛 2017 3 12/","text":"T1 Blue题目描述Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。 他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。 当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。 输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。 输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。 样例输入5 10 9 16 30 2 4 6 9 11 15 18 19 25 27 10 1 23 30 10 11 13 14 15 16 18 26 27 29 10 7 28 30 2 3 7 9 12 15 20 24 27 28 10 3 18 30 1 6 9 14 18 19 22 27 28 29 10 7 10 30 1 2 4 6 18 19 20 22 23 26 样例输出5 Excited Excited Excited 0 数据范围对于 10%的数据保证 $m=1$. 对于另外 10%的数据保证 $D=L$. 对于另外 10%的数据保证 $n=L-1$. 对于另外 30%的数据保证 $n&lt;=100, L&lt;=10^5$. 对于 100%的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$.数据范围中的 n、m 皆代表题目描述中 n、m 的总和。 题解这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。 具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了…. CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N =1e6+1; inline void read(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int tt,n,m,d,l,a[N],b[N]; bool can(int ans) { for(int i=1;i&lt;=ans;++i)b[i]=0; int anss=0; for(int now=1;now&lt;=n;++now) { if(a[now]-b[++anss]&lt;=d)b[anss]=a[now]; if(anss==ans)anss=0; } for(int i=1;i&lt;=ans;++i) if(l-b[i]&gt;d)return 0; return 1; } int main() { // freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout); read(tt); while(tt--) { read(n),read(m),read(d),read(l); for(int i=1;i&lt;=n;++i)read(a[i]); int ll=0,rr=m,mid; while(ll!=rr) { mid=ll+rr+1&gt;&gt;1; if(can(mid)) ll=mid; else rr=mid-1; } if(rr==m) printf(&quot;Excited\\n&quot;); else printf(&quot;%d\\n&quot;,rr); } return 0; } T2 Weed题目描述duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。 电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上面没有金坷垃了。 duyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最终金坷垃的量有多少。 输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，后面 2 个数描述更改为这样的操作。 输出 q 行代表每次金坷垃的量为多少 样例输入10 5 0 10 1 5 0 13 0 18 0 2 1 1 0 8 0 9 1 3 0 7 9 0 3 10 1 7 6 0 8 10 0 5 8 1 2 样例输出58 0 0 66 41 数据范围对于 30%的数据，m&lt;=1000,q&lt;=1000. 对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。 对于 100%的数据，m&lt;=210^5,q&lt;=210^5,vi&lt;=10^4. 题解由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现… 题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; inline void read(int &amp;x) { x=0;int f=1;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} x*=f; } const int N =2e5+7; struct build{int sum,in,out;}tr[8*N]; int n,q,k,a[N],tot; int find(int x,int pot) { if(pot&gt;=tr[x].in) return 0; if(!pot) return tr[x].sum; if(pot&lt;=tr[x*2+1].in) return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot); return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out); } void update(int x) { tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out); tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in); tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out); } void build(int x,int l,int r) { if(l==r) { if(a[l]&lt;0) tr[x].out=-a[l]; else tr[x].in=1,tr[x].sum=a[l]; } else { int mid=l+r&gt;&gt;1; build(x*2,l,mid); build(x*2+1,mid+1,r); update(x); } } void change(int x,int pot,int w,int l,int r) { if(l==r) { memset(&amp;tr[x],0,sizeof(tr[x])); if(w&lt;0) tr[x].out=-w; else tr[x].in=1,tr[x].sum=w; } else { int mid=l+r&gt;&gt;1; if(pot&gt;mid) change(x*2+1,pot,w,mid+1,r); else change(x*2,pot,w,l,mid); update(x); } } int main() { // freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout); read(n),read(q); for(int i=1;i&lt;=n;++i) { read(k),read(a[i]); if(k)a[i]*=-1; } build(1,1,n); while(q--) { int x,w; read(x);read(k);read(w); if(k)w*=-1; change(1,x,w,1,n); printf(&quot;%d\\n&quot;,tr[1].sum); } } T3 Drink题目描述在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚不到这么多资本），所以决定用特殊的方法赏赐毒液哥。 Link的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财的他想知道最后棋盘内所有的宝物价值以方便他挑选。 作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）和资产阶级代表（Link）之间的贫富差距么。 输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c的正方形。 输出一个 N * M 的矩阵表示最后的棋盘。 样例输入4 4 3 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 1 3 3 3 2 2 2 2 样例输出1 5 1 4 2 7 6 8 3 7 2 3 5 6 8 4 数据范围对于 30%的数据，N, M, Q &lt;= 100. 对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。 对于 100%的数据, N, M, Q &lt;= 1000.所有数取值都为 0~9. 题解以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。 CODE/* * @Author: 閫搁棽 * @Date: 2016-09-25 13:04:44 * @Last Modified by: 閫搁棽 * @Last Modified time: 2016-10-01 10:19:00 */ #include &quot;cstdio&quot; #include &quot;cstdlib&quot; #include &quot;iostream&quot; #include &quot;algorithm&quot; #include &quot;cstring&quot; #include &quot;queue&quot; using namespace std; #define INF 0x3F3F3F3F #define MAX_SIZE 2005 #define Eps #define Mod #define Get(x, a) (x ? x -&gt; a : 0) #define Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it) inline int Get_Int() { int Num = 0, Flag = 1; char ch; do { ch = getchar(); if(ch == &#39;-&#39;) Flag = -Flag; } while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;); do { Num = Num * 10 + ch - &#39;0&#39;; ch = getchar(); } while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return Num * Flag; } int N, M, Q; int A[MAX_SIZE * MAX_SIZE][4], Map[MAX_SIZE][MAX_SIZE]; inline void Move(int &amp;Direction, int &amp;Now, int j) { int Next = A[Now][j - Direction + 4 &amp; 3]; for(Direction = 0; A[Next][j - Direction + 6 &amp; 3] != Now; ++Direction); Now = Next; } int main() { #ifndef ONLINE_JUDGE // freopen(&quot;drink.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;drink.out&quot;, &quot;w&quot;, stdout); #endif cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q; for(int i = 1; i &lt;= N; ++i) for(int j = 1; j &lt;= M; ++j) Map[i][j] = Get_Int(); for(int i = 1; i &lt;= (N + 2) * (M + 2); ++i) { A[i][0] = i - M - 2; A[i][1] = i + 1; A[i][2] = i + M + 2; A[i][3] = i - 1; } while(Q--) { int x = Get_Int(), y = Get_Int(), c = Get_Int(); int Direction = 0, Now = 1; vector&lt; pair&lt;int, int&gt; &gt; Border[4][2]; for(int i = 1; i &lt;= x; ++i) Move(Direction, Now, 2); for(int i = 1; i &lt;= y; ++i) Move(Direction, Now, 1); for(int j = 0; j &lt; 4; ++j) for(int i = 1; i &lt;= c; ++i) { Border[j][0].push_back(make_pair(Direction, Now)); Move(Direction, Now, j); Border[j][1].push_back(make_pair(Direction, Now)); Move(Direction, Now, j + 2 &amp; 3); if(i != c) Move(Direction, Now, j + 1 &amp; 3); } for(int j = 0; j &lt; 4; ++j) for(int i = 0; i &lt; c; ++i) { pair&lt;int, int&gt; Now = Border[j][1][i]; A[Now.second][j + 6 - Now.first &amp; 3] = Border[j + 3 &amp; 3][0][i].second; Now = Border[j][0][i]; A[Now.second][j + 4 - Now.first &amp; 3] = Border[j + 1 &amp; 3][1][i].second; } } int Direction = 0, Now = 1; for(int i = 1; i &lt;= N; ++i) { Move(Direction, Now, 2); int temp = Direction, Next = Now; for(int j = 1; j &lt;= M; ++j) { Move(temp, Next, 1); printf(&quot;%d &quot;, Map[(Next - 1) / (M + 2)][(Next - 1) % (M + 2)]); } printf(&quot;\\n&quot;); } fclose(stdin); fclose(stdout); return 0; }","raw":"title: NOIP模拟赛 2017 3 12\ndate: 2017-03-13 18:01:11\ncategories:\n  - NOIP模拟赛\ntags:\n  - 二分答案\n  - 贪心\n  - 线段树\n  - 二维线段树\n---\n\n## T1 Blue\n### 题目描述\nBlue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。\n\n他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)\n中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。\n\n当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就\n会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。\n\n输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。\n第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。\n\n输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。\n\n\n#### 样例输入\n    5\n    10 9 16 30\n    2 4 6 9 11 15 18 19 25 27 \n    10 1 23 30\n    10 11 13 14 15 16 18 26 27 29 \n    10 7 28 30\n    2 3 7 9 12 15 20 24 27 28 \n    10 3 18 30\n    1 6 9 14 18 19 22 27 28 29 \n    10 7 10 30\n    1 2 4 6 18 19 20 22 23 26 \n#### 样例输出\n    5\n    Excited\n    Excited\n    Excited\n    0\n#### 数据范围\n对于 10%的数据保证 $m=1$.\n\n对于另外 10%的数据保证 $D=L$.\n\n对于另外 10%的数据保证 $n=L-1$.\n\n对于另外 30%的数据保证 $n<=100, L<=10^5$.\n\n对于 100%的数据保证 $m<=n<=10^6,D<=L<=10^9$.\n数据范围中的 n、m 皆代表题目描述中 n、m 的总和。\n\n---\n### 题解\n\n这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D<=L<=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。\n\n具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了....\n\n---\n#### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N =1e6+1;\n    inline void read(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int tt,n,m,d,l,a[N],b[N];\n    bool can(int ans)\n    {\n        for(int i=1;i<=ans;++i)b[i]=0;\n        int anss=0;\n        for(int now=1;now<=n;++now)\n        {\n            if(a[now]-b[++anss]<=d)b[anss]=a[now];\n            if(anss==ans)anss=0;\n        }\n        for(int i=1;i<=ans;++i)\n        if(l-b[i]>d)return 0;\n        return 1;\n    }\n    int main()\n    {\n    //    freopen(\"Blue.in\",\"r\",stdin);\n    //    freopen(\"Blue.out\",\"w\",stdout);\n        read(tt);\n        while(tt--)\n        {\n            read(n),read(m),read(d),read(l);\n            for(int i=1;i<=n;++i)read(a[i]);\n            int ll=0,rr=m,mid;\n            while(ll!=rr)\n            {\n                mid=ll+rr+1>>1;\n                if(can(mid))\tll=mid;\n                else\t\t\trr=mid-1;\n            }\n            if(rr==m)\tprintf(\"Excited\\n\");\n            else \t\tprintf(\"%d\\n\",rr);\n        }\n        return 0;\n    }\n\n\n---\n## T2 Weed\n### 题目描述\nduyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。\n为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。\n\n电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最\n新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上\n面没有金坷垃了。\n\nduyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行\n了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最\n终金坷垃的量有多少。\n\n输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，\n为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，\n后面 2 个数描述更改为这样的操作。\n\n输出 q 行代表每次金坷垃的量为多少\n#### 样例输入\n    10 5\n    0 10\n    1 5\n    0 13\n    0 18\n    0 2\n    1 1\n    0 8\n    0 9\n    1 3\n    0 7\n    9 0 3\n    10 1 7\n    6 0 8\n    10 0 5\n    8 1 2\n\n\n#### 样例输出\n    58\n    0\n    0\n    66\n    41\n\n#### 数据范围\n对于 30%的数据，m<=1000,q<=1000.\n\n对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。\n\n对于 100%的数据，m<=2*10^5,q<=2*10^5,vi<=10^4.\n\n---\n### 题解\n由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现...\n\n题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    inline void read(int &x)\n    {\n        x=0;int f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n        x*=f;\n    }\n    const int N =2e5+7;\n    struct build{int sum,in,out;}tr[8*N];\n    int n,q,k,a[N],tot;\n    int find(int x,int pot)\n    {\n        if(pot>=tr[x].in)\t\t\treturn 0;\n        if(!pot)\t\t\t\t\treturn tr[x].sum;\n        if(pot<=tr[x*2+1].in)\n        return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot);\n        return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out);\n    }\n    void update(int x)\n    {\n        tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out);\n        tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in);\n        tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out);\n    }\n    void build(int x,int l,int r)\n    {\n        if(l==r)\n        {\n            if(a[l]<0)\ttr[x].out=-a[l];\n            else\t\ttr[x].in=1,tr[x].sum=a[l];\n        }\n        else\n        {\n            int mid=l+r>>1;\n            build(x*2,l,mid);\n            build(x*2+1,mid+1,r);\n            update(x);\n        }\n    }\n    void change(int x,int pot,int w,int l,int r)\n    {\n        if(l==r)\n        {\n            memset(&tr[x],0,sizeof(tr[x]));\n            if(w<0)\t\ttr[x].out=-w;\n            else\t\ttr[x].in=1,tr[x].sum=w;\n        }\n        else\n        {\n            int mid=l+r>>1;\n            if(pot>mid)\tchange(x*2+1,pot,w,mid+1,r);\n            else\t\tchange(x*2,pot,w,l,mid);\n            update(x);\n        }\n    }\n    int main()\n    {\n    //    freopen(\"weed.in\", \"r\", stdin);\n    //    freopen(\"weed.out\", \"w\", stdout);\n        read(n),read(q);\n        for(int i=1;i<=n;++i)\n        {\n            read(k),read(a[i]);\n            if(k)a[i]*=-1;\n        }\n        build(1,1,n);\n        while(q--)\n        {\n            int x,w;\n            read(x);read(k);read(w);\n            if(k)w*=-1;\n            change(1,x,w,1,n);\n            printf(\"%d\\n\",tr[1].sum);\n        }\n    }\n---\n## T3 Drink\n### 题目描述\n在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份\n丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚\n不到这么多资本），所以决定用特殊的方法赏赐毒液哥。\n\nLink的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，\n每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。\n毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财\n的他想知道最后棋盘内所有的宝物价值以方便他挑选。\n\n作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）\n和资产阶级代表（Link）之间的贫富差距么。\n\n输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。\n接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。\n接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c\n的正方形。\n\n输出一个 N * M 的矩阵表示最后的棋盘。\n#### 样例输入\n    4 4 3\n    1 2 3 4\n    5 6 7 8\n    1 2 3 4\n    5 6 7 8\n    1 1 3\n    3 3 2\n    2 2 2\n\n\n#### 样例输出\n    1 5 1 4 \n    2 7 6 8 \n    3 7 2 3 \n    5 6 8 4 \n\n#### 数据范围\n对于 30%的数据，N, M, Q <= 100.\n\n对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。\n\n对于 100%的数据, N, M, Q <= 1000.所有数取值都为 0~9.\n\n---\n### 题解\n以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。\n\n### CODE\n\n    /*\n    * @Author: 閫搁棽\n    * @Date:   2016-09-25 13:04:44\n    * @Last Modified by:   閫搁棽\n    * @Last Modified time: 2016-10-01 10:19:00\n    */\n\n    #include \"cstdio\"\n    #include \"cstdlib\"\n    #include \"iostream\"\n    #include \"algorithm\"\n    #include \"cstring\"\n    #include \"queue\"\n\n    using namespace std;\n\n    #define INF 0x3F3F3F3F\n    #define MAX_SIZE 2005\n    #define Eps\n    #define Mod\n    #define Get(x, a) (x ? x -> a : 0)\n    #define Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it)\n\n    inline int Get_Int()\n    {\n        int Num = 0, Flag = 1;\n        char ch;\n        do\n        {\n            ch = getchar();\n            if(ch == '-')\n                Flag = -Flag;\n        }\n        while(ch < '0' || ch > '9');\n        do\n        {\n            Num = Num * 10 + ch - '0';\n            ch = getchar();\n        }\n        while(ch >= '0' && ch <= '9');\n        return Num * Flag;\n    }\n\n    int N, M, Q;\n    int A[MAX_SIZE * MAX_SIZE][4], Map[MAX_SIZE][MAX_SIZE];\n\n    inline void Move(int &Direction, int &Now, int j)\n    {\n        int Next = A[Now][j - Direction + 4 & 3];\n        for(Direction = 0; A[Next][j - Direction + 6 & 3] != Now; ++Direction);\n        Now = Next;\n    }\n\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n    //\tfreopen(\"drink.in\", \"r\", stdin);\n    //\tfreopen(\"drink.out\", \"w\", stdout);\n    #endif\n        cin >> N >> M >> Q;\n        for(int i = 1; i <= N; ++i)\n            for(int j = 1; j <= M; ++j)\n                Map[i][j] = Get_Int();\n        for(int i = 1; i <= (N + 2) * (M + 2); ++i)\n        {\n            A[i][0] = i - M - 2;\n            A[i][1] = i + 1;\n            A[i][2] = i + M + 2;\n            A[i][3] = i - 1;\n        }\n        while(Q--)\n        {\n            int x = Get_Int(), y = Get_Int(), c = Get_Int();\n            int Direction = 0, Now = 1;\n            vector< pair<int, int> > Border[4][2];\n            for(int i = 1; i <= x; ++i)\n                Move(Direction, Now, 2);\n            for(int i = 1; i <= y; ++i)\n                Move(Direction, Now, 1);\n            for(int j = 0; j < 4; ++j)\n                for(int i = 1; i <= c; ++i)\n                {\n                    Border[j][0].push_back(make_pair(Direction, Now));\n                    Move(Direction, Now, j);\n                    Border[j][1].push_back(make_pair(Direction, Now));\n                    Move(Direction, Now, j + 2 & 3);\n                    if(i != c)\n                        Move(Direction, Now, j + 1 & 3);\n                }\n            for(int j = 0; j < 4; ++j)\n                for(int i = 0; i < c; ++i)\n                {\n                    pair<int, int> Now = Border[j][1][i];\n                    A[Now.second][j + 6 - Now.first & 3] = Border[j + 3 & 3][0][i].second;\n                    Now = Border[j][0][i];\n                    A[Now.second][j + 4 - Now.first & 3] = Border[j + 1 & 3][1][i].second;\n                }\n        }\n        int Direction = 0, Now = 1;\n        for(int i = 1; i <= N; ++i)\n        {\n            Move(Direction, Now, 2);\n            int temp = Direction, Next = Now;\n            for(int j = 1; j <= M; ++j)\n            {\n                Move(temp, Next, 1);\n                printf(\"%d \", Map[(Next - 1) / (M + 2)][(Next - 1) % (M + 2)]);\n            }\n            printf(\"\\n\");\n        }\n        fclose(stdin);\n        fclose(stdout);\n        return 0;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h2 id=\"T1-Blue\"><a href=\"#T1-Blue\" class=\"headerlink\" title=\"T1 Blue\"></a>T1 Blue</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。</p>\n<p>他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)<br>中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。</p>\n<p>当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就<br>会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。</p>\n<p>输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。<br>第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。</p>\n<p>输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。</p>\n<h4 id=\"样例输入\"><a href=\"#样例输入\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>5\n10 9 16 30\n2 4 6 9 11 15 18 19 25 27 \n10 1 23 30\n10 11 13 14 15 16 18 26 27 29 \n10 7 28 30\n2 3 7 9 12 15 20 24 27 28 \n10 3 18 30\n1 6 9 14 18 19 22 27 28 29 \n10 7 10 30\n1 2 4 6 18 19 20 22 23 26 \n</code></pre><h4 id=\"样例输出\"><a href=\"#样例输出\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>5\nExcited\nExcited\nExcited\n0\n</code></pre><h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 10%的数据保证 $m=1$.</p>\n<p>对于另外 10%的数据保证 $D=L$.</p>\n<p>对于另外 10%的数据保证 $n=L-1$.</p>\n<p>对于另外 30%的数据保证 $n&lt;=100, L&lt;=10^5$.</p>\n<p>对于 100%的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$.<br>数据范围中的 n、m 皆代表题目描述中 n、m 的总和。</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。</p>\n<p>具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了….</p>\n<hr>\n<h4 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N =1e6+1;\ninline void read(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint tt,n,m,d,l,a[N],b[N];\nbool can(int ans)\n{\n    for(int i=1;i&lt;=ans;++i)b[i]=0;\n    int anss=0;\n    for(int now=1;now&lt;=n;++now)\n    {\n        if(a[now]-b[++anss]&lt;=d)b[anss]=a[now];\n        if(anss==ans)anss=0;\n    }\n    for(int i=1;i&lt;=ans;++i)\n    if(l-b[i]&gt;d)return 0;\n    return 1;\n}\nint main()\n{\n//    freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout);\n    read(tt);\n    while(tt--)\n    {\n        read(n),read(m),read(d),read(l);\n        for(int i=1;i&lt;=n;++i)read(a[i]);\n        int ll=0,rr=m,mid;\n        while(ll!=rr)\n        {\n            mid=ll+rr+1&gt;&gt;1;\n            if(can(mid))    ll=mid;\n            else            rr=mid-1;\n        }\n        if(rr==m)    printf(&quot;Excited\\n&quot;);\n        else         printf(&quot;%d\\n&quot;,rr);\n    }\n    return 0;\n}\n</code></pre><hr>\n<h2 id=\"T2-Weed\"><a href=\"#T2-Weed\" class=\"headerlink\" title=\"T2 Weed\"></a>T2 Weed</h2><h3 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。<br>为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。</p>\n<p>电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最<br>新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上<br>面没有金坷垃了。</p>\n<p>duyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行<br>了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最<br>终金坷垃的量有多少。</p>\n<p>输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，<br>为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，<br>后面 2 个数描述更改为这样的操作。</p>\n<p>输出 q 行代表每次金坷垃的量为多少</p>\n<h4 id=\"样例输入-1\"><a href=\"#样例输入-1\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>10 5\n0 10\n1 5\n0 13\n0 18\n0 2\n1 1\n0 8\n0 9\n1 3\n0 7\n9 0 3\n10 1 7\n6 0 8\n10 0 5\n8 1 2\n</code></pre><h4 id=\"样例输出-1\"><a href=\"#样例输出-1\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>58\n0\n0\n66\n41\n</code></pre><h4 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 30%的数据，m&lt;=1000,q&lt;=1000.</p>\n<p>对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。</p>\n<p>对于 100%的数据，m&lt;=2<em>10^5,q&lt;=2</em>10^5,vi&lt;=10^4.</p>\n<hr>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现…</p>\n<p>题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。</p>\n<hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ninline void read(int &amp;x)\n{\n    x=0;int f=1;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n    x*=f;\n}\nconst int N =2e5+7;\nstruct build{int sum,in,out;}tr[8*N];\nint n,q,k,a[N],tot;\nint find(int x,int pot)\n{\n    if(pot&gt;=tr[x].in)            return 0;\n    if(!pot)                    return tr[x].sum;\n    if(pot&lt;=tr[x*2+1].in)\n    return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot);\n    return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out);\n}\nvoid update(int x)\n{\n    tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out);\n    tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in);\n    tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out);\n}\nvoid build(int x,int l,int r)\n{\n    if(l==r)\n    {\n        if(a[l]&lt;0)    tr[x].out=-a[l];\n        else        tr[x].in=1,tr[x].sum=a[l];\n    }\n    else\n    {\n        int mid=l+r&gt;&gt;1;\n        build(x*2,l,mid);\n        build(x*2+1,mid+1,r);\n        update(x);\n    }\n}\nvoid change(int x,int pot,int w,int l,int r)\n{\n    if(l==r)\n    {\n        memset(&amp;tr[x],0,sizeof(tr[x]));\n        if(w&lt;0)        tr[x].out=-w;\n        else        tr[x].in=1,tr[x].sum=w;\n    }\n    else\n    {\n        int mid=l+r&gt;&gt;1;\n        if(pot&gt;mid)    change(x*2+1,pot,w,mid+1,r);\n        else        change(x*2,pot,w,l,mid);\n        update(x);\n    }\n}\nint main()\n{\n//    freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin);\n//    freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout);\n    read(n),read(q);\n    for(int i=1;i&lt;=n;++i)\n    {\n        read(k),read(a[i]);\n        if(k)a[i]*=-1;\n    }\n    build(1,1,n);\n    while(q--)\n    {\n        int x,w;\n        read(x);read(k);read(w);\n        if(k)w*=-1;\n        change(1,x,w,1,n);\n        printf(&quot;%d\\n&quot;,tr[1].sum);\n    }\n}\n</code></pre><hr>\n<h2 id=\"T3-Drink\"><a href=\"#T3-Drink\" class=\"headerlink\" title=\"T3 Drink\"></a>T3 Drink</h2><h3 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份<br>丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚<br>不到这么多资本），所以决定用特殊的方法赏赐毒液哥。</p>\n<p>Link的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，<br>每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。<br>毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财<br>的他想知道最后棋盘内所有的宝物价值以方便他挑选。</p>\n<p>作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）<br>和资产阶级代表（Link）之间的贫富差距么。</p>\n<p>输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。<br>接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。<br>接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c<br>的正方形。</p>\n<p>输出一个 N * M 的矩阵表示最后的棋盘。</p>\n<h4 id=\"样例输入-2\"><a href=\"#样例输入-2\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>4 4 3\n1 2 3 4\n5 6 7 8\n1 2 3 4\n5 6 7 8\n1 1 3\n3 3 2\n2 2 2\n</code></pre><h4 id=\"样例输出-2\"><a href=\"#样例输出-2\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>1 5 1 4 \n2 7 6 8 \n3 7 2 3 \n5 6 8 4 \n</code></pre><h4 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 30%的数据，N, M, Q &lt;= 100.</p>\n<p>对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。</p>\n<p>对于 100%的数据, N, M, Q &lt;= 1000.所有数取值都为 0~9.</p>\n<hr>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。</p>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>/*\n* @Author: 閫搁棽\n* @Date:   2016-09-25 13:04:44\n* @Last Modified by:   閫搁棽\n* @Last Modified time: 2016-10-01 10:19:00\n*/\n\n#include &quot;cstdio&quot;\n#include &quot;cstdlib&quot;\n#include &quot;iostream&quot;\n#include &quot;algorithm&quot;\n#include &quot;cstring&quot;\n#include &quot;queue&quot;\n\nusing namespace std;\n\n#define INF 0x3F3F3F3F\n#define MAX_SIZE 2005\n#define Eps\n#define Mod\n#define Get(x, a) (x ? x -&gt; a : 0)\n#define Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it)\n\ninline int Get_Int()\n{\n    int Num = 0, Flag = 1;\n    char ch;\n    do\n    {\n        ch = getchar();\n        if(ch == &#39;-&#39;)\n            Flag = -Flag;\n    }\n    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;);\n    do\n    {\n        Num = Num * 10 + ch - &#39;0&#39;;\n        ch = getchar();\n    }\n    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);\n    return Num * Flag;\n}\n\nint N, M, Q;\nint A[MAX_SIZE * MAX_SIZE][4], Map[MAX_SIZE][MAX_SIZE];\n\ninline void Move(int &amp;Direction, int &amp;Now, int j)\n{\n    int Next = A[Now][j - Direction + 4 &amp; 3];\n    for(Direction = 0; A[Next][j - Direction + 6 &amp; 3] != Now; ++Direction);\n    Now = Next;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//    freopen(&quot;drink.in&quot;, &quot;r&quot;, stdin);\n//    freopen(&quot;drink.out&quot;, &quot;w&quot;, stdout);\n#endif\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q;\n    for(int i = 1; i &lt;= N; ++i)\n        for(int j = 1; j &lt;= M; ++j)\n            Map[i][j] = Get_Int();\n    for(int i = 1; i &lt;= (N + 2) * (M + 2); ++i)\n    {\n        A[i][0] = i - M - 2;\n        A[i][1] = i + 1;\n        A[i][2] = i + M + 2;\n        A[i][3] = i - 1;\n    }\n    while(Q--)\n    {\n        int x = Get_Int(), y = Get_Int(), c = Get_Int();\n        int Direction = 0, Now = 1;\n        vector&lt; pair&lt;int, int&gt; &gt; Border[4][2];\n        for(int i = 1; i &lt;= x; ++i)\n            Move(Direction, Now, 2);\n        for(int i = 1; i &lt;= y; ++i)\n            Move(Direction, Now, 1);\n        for(int j = 0; j &lt; 4; ++j)\n            for(int i = 1; i &lt;= c; ++i)\n            {\n                Border[j][0].push_back(make_pair(Direction, Now));\n                Move(Direction, Now, j);\n                Border[j][1].push_back(make_pair(Direction, Now));\n                Move(Direction, Now, j + 2 &amp; 3);\n                if(i != c)\n                    Move(Direction, Now, j + 1 &amp; 3);\n            }\n        for(int j = 0; j &lt; 4; ++j)\n            for(int i = 0; i &lt; c; ++i)\n            {\n                pair&lt;int, int&gt; Now = Border[j][1][i];\n                A[Now.second][j + 6 - Now.first &amp; 3] = Border[j + 3 &amp; 3][0][i].second;\n                Now = Border[j][0][i];\n                A[Now.second][j + 4 - Now.first &amp; 3] = Border[j + 1 &amp; 3][1][i].second;\n            }\n    }\n    int Direction = 0, Now = 1;\n    for(int i = 1; i &lt;= N; ++i)\n    {\n        Move(Direction, Now, 2);\n        int temp = Direction, Next = Now;\n        for(int j = 1; j &lt;= M; ++j)\n        {\n            Move(temp, Next, 1);\n            printf(&quot;%d &quot;, Map[(Next - 1) / (M + 2)][(Next - 1) % (M + 2)]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    fclose(stdin);\n    fclose(stdout);\n    return 0;\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/13/NOIP模拟赛 2017 3 12/","excerpt":"","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"https://prostkhala.github.io/categories/NOIP模拟赛/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://prostkhala.github.io/tags/二分答案/"},{"name":"贪心","slug":"贪心","permalink":"https://prostkhala.github.io/tags/贪心/"},{"name":"线段树","slug":"线段树","permalink":"https://prostkhala.github.io/tags/线段树/"},{"name":"二维线段树","slug":"二维线段树","permalink":"https://prostkhala.github.io/tags/二维线段树/"}]},{"title":"SCOI2010 股票交易","date":"2017-03-11T01:11:51.000Z","path":"2017/03/11/股票交易/","text":"[SCOI2010] 股票交易BZOJ1855 洛谷2569 题目描述最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。 通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi&gt;=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。 另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。 在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？ 输入输出格式输入格式：输入数据第一行包括3个整数，分别是T，MaxP，W。 接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。 输出格式：输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。 输入输出样例输入样例#1：5 2 0 2 1 1 1 2 1 1 1 3 2 1 1 4 3 1 1 5 4 1 1 输出样例#1：3 说明对于30%的数据，0&lt;=W&lt;T&lt;=50,1&lt;=MaxP&lt;=50 对于50%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=50 对于100%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=2000 对于所有的数据，1&lt;=BPi&lt;=APi&lt;=1000,1&lt;=ASi,BSi&lt;=MaxP $o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i]j$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。 $O(t*maxp^2)$算法：#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 2017; int n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w); for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i); memset(dp,-0x3f,sizeof(dp)); for(int i=1;i&lt;=n;++i) { for(int j=0;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。 for(int j=0;j&lt;=maxp;++j) { dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作 if(i-w-1&gt;=0) for(int k=j+1;k&lt;=min(j+bs[i],maxp);++k) dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出 if(i-w-1&gt;=0) for(int k=max(j-as[i],0);k&lt;j;++k) dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入 } } printf(&quot;%d&quot;,dp[n][0]); } 此题单调队列优化思想不难，但是还要注意各种细节。 $O(t*maxp)$算法(单调队列)：#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 2017; int n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w); for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i); memset(dp,-0x3f,sizeof(dp)); for(int i=1;i&lt;=n;++i) { for(int j=0;j&lt;=as[i];++j) dp[i][j]=-ap[i]*j; for(int j=0;j&lt;=maxp;++j) dp[i][j]=max(dp[i][j],dp[i-1][j]); if(i-w-1&gt;=0) { head=1,tail=0; for(int j=0;j&lt;=maxp;++j)//买入 { while(head&lt;=tail&amp;&amp;q[head]&lt;max(0,j-as[i]))head++; if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]); while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*ap[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--; q[++tail]=j; } head=1,tail=0; for(int j=maxp;j&gt;=0;--j)//卖出 { while(head&lt;=tail&amp;&amp;q[head]&gt;min(maxp,j+bs[i]))head++; if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]); while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*bp[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--; q[++tail]=j; } } } printf(&quot;%d&quot;,dp[n][0]); }","raw":"title: SCOI2010 股票交易\ndate: 2017-03-11 9:11:51\ncategories:\n  - 动态规划\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n---\n# [SCOI2010] 股票交易\n## [BZOJ1855](http://www.lydsy.com/JudgeOnline/problem.php?id=1855) [洛谷2569](https://www.luogu.org/problem/show?pid=2569)\n---\n\n## 题目描述\n\n最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。\n\n通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi>=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。\n\n另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。\n\n在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？\n### 输入输出格式\n#### 输入格式：\n\n输入数据第一行包括3个整数，分别是T，MaxP，W。\n\n接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。\n\n#### 输出格式：\n\n输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。\n\n### 输入输出样例\n#### 输入样例#1：\n\n    5 2 0\n    2 1 1 1\n    2 1 1 1\n    3 2 1 1\n    4 3 1 1\n    5 4 1 1\n\n#### 输出样例#1：\n\n    3\n\n### 说明\n\n对于30%的数据，0<=W<T<=50,1<=MaxP<=50\n\n对于50%的数据，0<=W<T<=2000,1<=MaxP<=50\n\n对于100%的数据，0<=W<T<=2000,1<=MaxP<=2000\n\n对于所有的数据，1<=BPi<=APi<=1000,1<=ASi,BSi<=MaxP\n\n---\n\n$o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i][j](j<=t，j<=maxp)$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。\n\n## $O(t*maxp^2)$算法：\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 2017;\n    int n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];\n    int main()\n    {\n      scanf(\"%d%d%d\",&n,&maxp,&w);\n        for(int i=1;i<=n;++i)scanf(\"%d%d%d%d\",ap+i,bp+i,as+i,bs+i);\n      memset(dp,-0x3f,sizeof(dp));\n      for(int i=1;i<=n;++i)\n      {\n          for(int j=0;j<=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。\n          for(int j=0;j<=maxp;++j)\n          {\n              dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作\n              if(i-w-1>=0)\n              for(int k=j+1;k<=min(j+bs[i],maxp);++k)\n              dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出\n              if(i-w-1>=0)\n              for(int k=max(j-as[i],0);k<j;++k)\n              dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入\n          }\n      }\n      printf(\"%d\",dp[n][0]);\n    }\n---\n此题单调队列优化思想不难，但是还要注意各种细节。\n## $O(t*maxp)$算法(单调队列)：\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 2017;\n    int n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N];\n    int main()\n    {\n        scanf(\"%d%d%d\",&n,&maxp,&w);\n        for(int i=1;i<=n;++i)scanf(\"%d%d%d%d\",ap+i,bp+i,as+i,bs+i);\n        memset(dp,-0x3f,sizeof(dp));\n        for(int i=1;i<=n;++i)\n        {\n            for(int j=0;j<=as[i];++j)\tdp[i][j]=-ap[i]*j;\n            for(int j=0;j<=maxp;++j)\tdp[i][j]=max(dp[i][j],dp[i-1][j]);\n            if(i-w-1>=0)\n            {\n                head=1,tail=0;\n                for(int j=0;j<=maxp;++j)//买入 \n                {\n                    while(head<=tail&&q[head]<max(0,j-as[i]))head++;\n                    if(head<=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]);\n                    while(head<=tail&&dp[i-w-1][j]+j*ap[i]>=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--;\n                    q[++tail]=j;\n                }\n                head=1,tail=0;\n                for(int j=maxp;j>=0;--j)//卖出 \n                {\n                    while(head<=tail&&q[head]>min(maxp,j+bs[i]))head++;\n                    if(head<=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]);\n                    while(head<=tail&&dp[i-w-1][j]+j*bp[i]>=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--;\n                    q[++tail]=j;\n                }\n            }\n        }\n        printf(\"%d\",dp[n][0]);\n    }","content":"<h1 id=\"SCOI2010-股票交易\"><a href=\"#SCOI2010-股票交易\" class=\"headerlink\" title=\"[SCOI2010] 股票交易\"></a>[SCOI2010] 股票交易</h1><h2 id=\"BZOJ1855-洛谷2569\"><a href=\"#BZOJ1855-洛谷2569\" class=\"headerlink\" title=\"BZOJ1855 洛谷2569\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1855\" target=\"_blank\" rel=\"external\">BZOJ1855</a> <a href=\"https://www.luogu.org/problem/show?pid=2569\" target=\"_blank\" rel=\"external\">洛谷2569</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。</p>\n<p>通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi&gt;=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。</p>\n<p>另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。</p>\n<p>在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入数据第一行包括3个整数，分别是T，MaxP，W。</p>\n<p>接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>5 2 0\n2 1 1 1\n2 1 1 1\n3 2 1 1\n4 3 1 1\n5 4 1 1\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>3\n</code></pre><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>对于30%的数据，0&lt;=W&lt;T&lt;=50,1&lt;=MaxP&lt;=50</p>\n<p>对于50%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=50</p>\n<p>对于100%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=2000</p>\n<p>对于所有的数据，1&lt;=BPi&lt;=APi&lt;=1000,1&lt;=ASi,BSi&lt;=MaxP</p>\n<hr>\n<p>$o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i]<a href=\"j&lt;=t，j&lt;=maxp\">j</a>$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。</p>\n<h2 id=\"O-t-maxp-2-算法：\"><a href=\"#O-t-maxp-2-算法：\" class=\"headerlink\" title=\"$O(t*maxp^2)$算法：\"></a>$O(t*maxp^2)$算法：</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 2017;\nint n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];\nint main()\n{\n  scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i);\n  memset(dp,-0x3f,sizeof(dp));\n  for(int i=1;i&lt;=n;++i)\n  {\n      for(int j=0;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。\n      for(int j=0;j&lt;=maxp;++j)\n      {\n          dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作\n          if(i-w-1&gt;=0)\n          for(int k=j+1;k&lt;=min(j+bs[i],maxp);++k)\n          dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出\n          if(i-w-1&gt;=0)\n          for(int k=max(j-as[i],0);k&lt;j;++k)\n          dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入\n      }\n  }\n  printf(&quot;%d&quot;,dp[n][0]);\n}\n</code></pre><hr>\n<p>此题单调队列优化思想不难，但是还要注意各种细节。</p>\n<h2 id=\"O-t-maxp-算法-单调队列-：\"><a href=\"#O-t-maxp-算法-单调队列-：\" class=\"headerlink\" title=\"$O(t*maxp)$算法(单调队列)：\"></a>$O(t*maxp)$算法(单调队列)：</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 2017;\nint n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N];\nint main()\n{\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i);\n    memset(dp,-0x3f,sizeof(dp));\n    for(int i=1;i&lt;=n;++i)\n    {\n        for(int j=0;j&lt;=as[i];++j)    dp[i][j]=-ap[i]*j;\n        for(int j=0;j&lt;=maxp;++j)    dp[i][j]=max(dp[i][j],dp[i-1][j]);\n        if(i-w-1&gt;=0)\n        {\n            head=1,tail=0;\n            for(int j=0;j&lt;=maxp;++j)//买入 \n            {\n                while(head&lt;=tail&amp;&amp;q[head]&lt;max(0,j-as[i]))head++;\n                if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]);\n                while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*ap[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--;\n                q[++tail]=j;\n            }\n            head=1,tail=0;\n            for(int j=maxp;j&gt;=0;--j)//卖出 \n            {\n                while(head&lt;=tail&amp;&amp;q[head]&gt;min(maxp,j+bs[i]))head++;\n                if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]);\n                while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*bp[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--;\n                q[++tail]=j;\n            }\n        }\n    }\n    printf(&quot;%d&quot;,dp[n][0]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/11/股票交易/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"}]},{"title":"动态规划优化 题目列表","date":"2017-03-10T14:12:24.000Z","path":"2017/03/10/动态规划 题目列表/","text":"单调队列优化dpBZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047! 单调栈BZOJ 1057!、BZOJ 1683、BZOJ 3956、BZOJ 3611 状压DPBZOJ 1879!、BZOJ 1087!、BZOJ 2669!、BZOJ 3812 斜率优化BZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675 dp+四边形不等式优化POJ1160! HDU2829! HDU3480 HDU3506 HDU3516http://blog.csdn.net/shiwei408/article/details/8791011 斜率优化DP和四边形不等式优化DP整理http://blog.csdn.net/tomorrowtodie/article/details/52279807 http://blog.csdn.net/u014800748/article/details/45750737","raw":"title: 动态规划优化 题目列表\ndate: 2017-03-10 22:12:24\ncategories:\n  - 动态规划\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n  - 斜率优化\n  - 单调栈\n---\n# 单调队列优化dp\nBZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047!\n\n# 单调栈\nBZOJ 1057!、BZOJ 1683、BZOJ 3956、BZOJ 3611\n\n# 状压DP\nBZOJ 1879!、BZOJ 1087!、BZOJ 2669!、BZOJ 3812\n\n# 斜率优化\nBZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675\n\n# dp+四边形不等式优化\nPOJ1160! HDU2829! HDU3480 HDU3506 HDU3516\nhttp://blog.csdn.net/shiwei408/article/details/8791011\n\n# 斜率优化DP和四边形不等式优化DP整理\nhttp://blog.csdn.net/tomorrowtodie/article/details/52279807\n\nhttp://blog.csdn.net/u014800748/article/details/45750737","content":"<h1 id=\"单调队列优化dp\"><a href=\"#单调队列优化dp\" class=\"headerlink\" title=\"单调队列优化dp\"></a>单调队列优化dp</h1><p>BZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047!</p>\n<h1 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h1><p>BZOJ 1057!、BZOJ 1683、BZOJ 3956、BZOJ 3611</p>\n<h1 id=\"状压DP\"><a href=\"#状压DP\" class=\"headerlink\" title=\"状压DP\"></a>状压DP</h1><p>BZOJ 1879!、BZOJ 1087!、BZOJ 2669!、BZOJ 3812</p>\n<h1 id=\"斜率优化\"><a href=\"#斜率优化\" class=\"headerlink\" title=\"斜率优化\"></a>斜率优化</h1><p>BZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675</p>\n<h1 id=\"dp-四边形不等式优化\"><a href=\"#dp-四边形不等式优化\" class=\"headerlink\" title=\"dp+四边形不等式优化\"></a>dp+四边形不等式优化</h1><p>POJ1160! HDU2829! HDU3480 HDU3506 HDU3516<br><a href=\"http://blog.csdn.net/shiwei408/article/details/8791011\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/shiwei408/article/details/8791011</a></p>\n<h1 id=\"斜率优化DP和四边形不等式优化DP整理\"><a href=\"#斜率优化DP和四边形不等式优化DP整理\" class=\"headerlink\" title=\"斜率优化DP和四边形不等式优化DP整理\"></a>斜率优化DP和四边形不等式优化DP整理</h1><p><a href=\"http://blog.csdn.net/tomorrowtodie/article/details/52279807\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/tomorrowtodie/article/details/52279807</a></p>\n<p><a href=\"http://blog.csdn.net/u014800748/article/details/45750737\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u014800748/article/details/45750737</a></p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/10/动态规划 题目列表/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://prostkhala.github.io/tags/斜率优化/"},{"name":"单调栈","slug":"单调栈","permalink":"https://prostkhala.github.io/tags/单调栈/"}]},{"title":"HNOI2008     玩具装箱Toy(详解)","date":"2017-03-10T14:02:35.000Z","path":"2017/03/10/玩具装箱toy/","text":"[HNOI2008] 玩具装箱toyBZOJ1010 COGS1330 题目描述P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小. 输入输出格式输入格式：第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7 输出格式：输出最小费用. 输入输出样例输入样例#1：5 4 3 4 2 1 4 输出样例#1：1 题解设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0&lt;=i&lt;j&lt;=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N=50005; long long n,l,dp[N],a[N]; int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1]; memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l)); printf(&quot;%lld&quot;,dp[n]); } 观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。 斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，在某DP视频中，主讲人向同学们推荐了打出决策表的方法，对于此题来说，数据容易生成，可以尝试一下。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N=50005; long long n,l,dp[N],a[N],best[N]; int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1]; memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j; for(int i=1;i&lt;=n;i++)printf(&quot;%d&quot;,best[i]);//决策表 printf(&quot;%lld&quot;,dp[n]); } 易观察到best[i]单调不降，满足决策单调性。（证明见下文） 则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有 $dp[k]+(i-k-1+a[i]-a[k]-l)^2&lt;dp[j]+(i-j-1+a[i]-a[j]-l)^2$ $dp[k]-dp[j]&lt;(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$ 对于该方程，可设 $b[i]=a[i]+i$; $l=l+1$ 则有 $dp[k]-dp[j]&lt;(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$ 化简得 $((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])&lt;2b[i]-2l$ 此时的形式为点斜式方程： $(yk-yj)/(xk-xj)&lt;ansi$ 已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。 设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]&lt;b[i]-2l$时，由$A1$转移而来优于$A2$。 当$a&lt;b&lt;c$时，且$g[c,b]&lt;g[b,a]$,易证得b必不为最优决策。 证明1.$g[c,b]&lt;ansi$此时c决策优于b，则b一定不为最优决策。 2.$g[c,b]&gt;=ansi$此时b决策优于c，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时b决策不优于a决策。 综上所述，则可将所有满足$g[c,b]&lt;gb,a$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。 以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：1： 用单调队列维护点集信息。2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。AC代码如下： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 50005; long long n,l,a[N],b[N],dp[N],q[N]; double g(long long k,long long j) { return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]); } int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,a+i),a[i]+=a[i-1]; for(int i=1;i&lt;=n;++i)b[i]=a[i]+i; l++; int head=1,tail=1; q[1]=0; for(int i=1;i&lt;=n;++i) { while(head&lt;tail&amp;&amp;g(q[head+1],q[head])&lt;2*b[i]-2*l)head++; int j=q[head]; dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l); while(head&lt;tail&amp;&amp;g(i,q[tail])&lt;g(q[tail],q[tail-1]))tail--; q[++tail]=i; } printf(&quot;%lld&quot;,dp[n]); }","raw":"title: HNOI2008     玩具装箱toy(详解)\ndate: 2017-03-10 22:02:35\ncategories:\n  - 动态规划\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n  - 斜率优化\n---\n# [HNOI2008]  玩具装箱toy\n\n## [BZOJ1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010) [COGS1330](http://cogs.pro/cogs/problem/problem.php?pid=1330)\n\n---\n\n## 题目描述\n\nP教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1...N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i<=K<=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.\n### 输入输出格式\n#### 输入格式：\n\n第一行输入两个整数N，L.接下来N行输入Ci.1<=N<=50000,1<=L,Ci<=10^7\n\n#### 输出格式：\n\n输出最小费用.\n\n### 输入输出样例\n#### 输入样例#1：\n\n    5 4\n    3\n    4\n    2\n    1\n    4\n\n#### 输出样例#1：\n\n    1\n\n\n---\n## 题解\n设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0<=i<j<=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。\n```cpp\n    #include<cstdio>\n    #include<iostream>\n    #include<cstring>\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N];\n\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i<=n;i++)\n        for(int j=0;j<i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l));\n        printf(\"%lld\",dp[n]);\n    } \n```\n观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。\n\n斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，在某DP视频中，主讲人向同学们推荐了打出决策表的方法，对于此题来说，数据容易生成，可以尝试一下。\n\n    #include<cstdio>\n    #include<iostream>\n    #include<cstring>\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N],best[N];\n\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i<=n;i++)\n        for(int j=0;j<i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j;\n        for(int i=1;i<=n;i++)printf(\"%d\",best[i]);//决策表\n        printf(\"%lld\",dp[n]);\n    } \n\n易观察到best[i]单调不降，满足决策单调性。（证明见下文）\n\n\n则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有\n\n$dp[k]+(i-k-1+a[i]-a[k]-l)^2<dp[j]+(i-j-1+a[i]-a[j]-l)^2$\n\n$dp[k]-dp[j]<(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$\n\n对于该方程，可设\n\n$b[i]=a[i]+i$;\n\n$l=l+1$\n\n则有\n\n$dp[k]-dp[j]<(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$\n\n化简得\n\n$((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])<2b[i]-2l$\n\n此时的形式为点斜式方程：\n\n$(yk-yj)/(xk-xj)<ansi$\n\n已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。\n\n设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]<b[i]-2l$时，由$A1$转移而来优于$A2$。\n\n当$a<b<c$时，且$g[c,b]<g[b,a]$,易证得b必不为最优决策。\n## 证明\n### 1.$g[c,b]<ansi$\n此时c决策优于b，则b一定不为最优决策。\n### 2.$g[c,b]>=ansi$\n此时b决策优于c，但又有$g[b,a]>g[c,b]>=ansi$,此时b决策不优于a决策。\n\n综上所述，则可将所有满足$g[c,b]<g[b,a](a<b<c)$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。\n\n## 以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\n### 1： 用单调队列维护点集信息。\n### 2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)<ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。\n### 3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\n\nAC代码如下：\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 50005;\n    long long n,l,a[N],b[N],dp[N],q[N];\n    double g(long long k,long long j)\n    {\n        return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);\n    }\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;++i)scanf(\"%lld\",a+i),a[i]+=a[i-1];\n        for(int i=1;i<=n;++i)b[i]=a[i]+i;\n        l++;\n        int head=1,tail=1;\n        q[1]=0;\n        for(int i=1;i<=n;++i)\n        {\n            while(head<tail&&g(q[head+1],q[head])<2*b[i]-2*l)head++;\n            int j=q[head];\n            dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);\n            while(head<tail&&g(i,q[tail])<g(q[tail],q[tail-1]))tail--;\n            q[++tail]=i;\n        }\n        printf(\"%lld\",dp[n]);\n    }","content":"<h1 id=\"HNOI2008-玩具装箱toy\"><a href=\"#HNOI2008-玩具装箱toy\" class=\"headerlink\" title=\"[HNOI2008]  玩具装箱toy\"></a>[HNOI2008]  玩具装箱toy</h1><h2 id=\"BZOJ1010-COGS1330\"><a href=\"#BZOJ1010-COGS1330\" class=\"headerlink\" title=\"BZOJ1010 COGS1330\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1010\" target=\"_blank\" rel=\"external\">BZOJ1010</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1330\" target=\"_blank\" rel=\"external\">COGS1330</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出最小费用.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>5 4\n3\n4\n2\n1\n4\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>1\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0&lt;=i&lt;j&lt;=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。</p>\n<pre><code class=\"cpp\">    #include&lt;cstdio&gt;\n    #include&lt;iostream&gt;\n    #include&lt;cstring&gt;\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N];\n\n    int main()\n    {\n    //    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n    //    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n        for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i&lt;=n;i++)\n        for(int j=0;j&lt;i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l));\n        printf(&quot;%lld&quot;,dp[n]);\n    }\n</code></pre>\n<p>观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。</p>\n<p>斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性，在某DP视频中，主讲人向同学们推荐了打出决策表的方法，对于此题来说，数据容易生成，可以尝试一下。</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N=50005;\n\nlong long n,l,dp[N],a[N],best[N];\n\nint main()\n{\n//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n    for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1];\n    memset(dp,0x3f,sizeof(dp));\n    dp[0]=0;\n    for(int i=1;i&lt;=n;i++)\n    for(int j=0;j&lt;i;j++)\n    dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j;\n    for(int i=1;i&lt;=n;i++)printf(&quot;%d&quot;,best[i]);//决策表\n    printf(&quot;%lld&quot;,dp[n]);\n} \n</code></pre><p>易观察到best[i]单调不降，满足决策单调性。（证明见下文）</p>\n<p>则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有</p>\n<p>$dp[k]+(i-k-1+a[i]-a[k]-l)^2&lt;dp[j]+(i-j-1+a[i]-a[j]-l)^2$</p>\n<p>$dp[k]-dp[j]&lt;(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$</p>\n<p>对于该方程，可设</p>\n<p>$b[i]=a[i]+i$;</p>\n<p>$l=l+1$</p>\n<p>则有</p>\n<p>$dp[k]-dp[j]&lt;(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$</p>\n<p>化简得</p>\n<p>$((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])&lt;2b[i]-2l$</p>\n<p>此时的形式为点斜式方程：</p>\n<p>$(yk-yj)/(xk-xj)&lt;ansi$</p>\n<p>已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。</p>\n<p>设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]&lt;b[i]-2l$时，由$A1$转移而来优于$A2$。</p>\n<p>当$a&lt;b&lt;c$时，且$g[c,b]&lt;g[b,a]$,易证得b必不为最优决策。</p>\n<h2 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h2><h3 id=\"1-g-c-b-lt-ansi\"><a href=\"#1-g-c-b-lt-ansi\" class=\"headerlink\" title=\"1.$g[c,b]&lt;ansi$\"></a>1.$g[c,b]&lt;ansi$</h3><p>此时c决策优于b，则b一定不为最优决策。</p>\n<h3 id=\"2-g-c-b-gt-ansi\"><a href=\"#2-g-c-b-gt-ansi\" class=\"headerlink\" title=\"2.$g[c,b]&gt;=ansi$\"></a>2.$g[c,b]&gt;=ansi$</h3><p>此时b决策优于c，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时b决策不优于a决策。</p>\n<p>综上所述，则可将所有满足$g[c,b]&lt;g<a href=\"a&lt;b&lt;c\">b,a</a>$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。</p>\n<h2 id=\"以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\"><a href=\"#以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\" class=\"headerlink\" title=\"以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\"></a>以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：</h2><h3 id=\"1：-用单调队列维护点集信息。\"><a href=\"#1：-用单调队列维护点集信息。\" class=\"headerlink\" title=\"1： 用单调队列维护点集信息。\"></a>1： 用单调队列维护点集信息。</h3><h3 id=\"2：-求解dp-i-可以从队首开始扫描，当g-head-1-head-lt-ansi时，可知head-1优于head，故继续扫描，直到不满足条件，此时bext-i-head-即使dp-i-最优的决策为队首。\"><a href=\"#2：-求解dp-i-可以从队首开始扫描，当g-head-1-head-lt-ansi时，可知head-1优于head，故继续扫描，直到不满足条件，此时bext-i-head-即使dp-i-最优的决策为队首。\" class=\"headerlink\" title=\"2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。\"></a>2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。</h3><h3 id=\"3：-当加入点i，我们要维护队列的上凸性质-即从队尾开始扫描，判断g-i-tail-是否小于g-tail，tail-1-，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\"><a href=\"#3：-当加入点i，我们要维护队列的上凸性质-即从队尾开始扫描，判断g-i-tail-是否小于g-tail，tail-1-，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\" class=\"headerlink\" title=\"3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\"></a>3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。</h3><p>AC代码如下：</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 50005;\nlong long n,l,a[N],b[N],dp[N],q[N];\ndouble g(long long k,long long j)\n{\n    return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);\n}\nint main()\n{\n//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,a+i),a[i]+=a[i-1];\n    for(int i=1;i&lt;=n;++i)b[i]=a[i]+i;\n    l++;\n    int head=1,tail=1;\n    q[1]=0;\n    for(int i=1;i&lt;=n;++i)\n    {\n        while(head&lt;tail&amp;&amp;g(q[head+1],q[head])&lt;2*b[i]-2*l)head++;\n        int j=q[head];\n        dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);\n        while(head&lt;tail&amp;&amp;g(i,q[tail])&lt;g(q[tail],q[tail-1]))tail--;\n        q[++tail]=i;\n    }\n    printf(&quot;%lld&quot;,dp[n]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/10/玩具装箱toy/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://prostkhala.github.io/tags/斜率优化/"}]},{"title":"后缀数组十三题","date":"2017-03-08T03:02:35.000Z","path":"2017/03/08/后缀数组13题/","text":"论文后缀数组——处理字符串的有力工具–罗穗骞 题目 例3 (1).cogs902:Musical Theme(poj1743)本题题目描述与论文略有差别。 应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..）） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; const int inf = 0x7fffffff; int wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N]; int s[N]; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(p=1,j=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } bool can(int k,int n) { int tmp=0,maxsa=-1,minsa=inf; for(int i=1;i&lt;=n;++i) { if(h[i]&lt;k)maxsa=-1,minsa=inf; if(sa[i]&lt;minsa)minsa=sa[i]; if(sa[i]&gt;maxsa)maxsa=sa[i]; if(maxsa-minsa&gt;k)return 1; } return 0; } int main() { // freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout); int n,x; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) { memset(h,0,sizeof(h)); memset(sa,0,sizeof(sa)); memset(rank,0,sizeof(rank)); if(!n)break; cin&gt;&gt;x; for(int i=1;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;s[i]); s[0]=s[1]-x; for(int i=1;i&lt;n-1;++i)s[i]=s[i+1]-s[i]; n--; for(int i=0;i&lt;n;++i)s[i]+=150; da(n+1,maxf); getheight(n); int l=0,r=1e6,ans; int mid=0; while(l!=r) { ans=l+r+1&gt;&gt;1; if(can(ans,n)) l=ans; else r=ans-1; } l++; printf(&quot;%d\\n&quot;,(l)&gt;=5?l:0); } } CODE 例4 (1).poj3261：Milk Patterns#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int maxf = 255; const int inf = 0x7fffffff; const int N = 1e5+5; int sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N]; int s[N],k; int cmp(int*r,int a,int b,int l) {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;height[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } bool can(int ans,int n) { int tot=0; for(int i=1;i&lt;=n;++i) { if(height[i]&lt;ans)tot=0; tot++; if(tot==k)return 1; } return 0; } int main() { int n; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,s+i); da(n+1,maxf); getheight(n); int l=1,r=n+1,ans,mid; while(l!=r) { int mid=(l+r&gt;&gt;1)+1; if(can(mid,n))ans=l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,ans); } CODE 例5 (1).spoj694：Distinct Substrings(Vjudge)这题论文中的方法不太好想，可以换一种思路。 易证长度为len的字符串一共有$（len+1）*len / 2$个子串。而其中重复的字串个数则为height数组的总和，减去即可。 以 sa[i-1] abba sa[i] abcd //height[i] = 2 这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。 这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为 bba bcd //height = 1 重复的子串 b 将在此处减掉。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; const int N =1e4+5; using namespace std; char s[N]; int sa[N],wa[N],wb[N],tong[N],wv[N]; int rank[N],height[N]; int cmp(int*r,int a,int b,int l) {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void calheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;i++) rank[sa[i]]=i; for(i=0;i&lt;n;height[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int i; scanf(&quot;%s&quot;,s); int n=strlen(s); da(n+1,128); calheight(n); long long ans=n*(n+1)/2; for(i=1;i&lt;=n;i++) ans-=height[i]; printf(&quot;%lld\\n&quot;,ans); } } CODE (2).cogs1709:不同的子串 （spoj705） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N]; char s[N]; bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } int main() { // freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%s&quot;,s); int n=strlen(s); da(n+1,maxf); getheight(n); for(int i=1;i&lt;=n;++i)sa[i]++; long long ans=0; for(int i=1;i&lt;=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1; printf(&quot;%d&quot;,ans); } CODE 例6 (1).ural1297：Palindrome(Vjudge)这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。 #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; const int N = 1e4+1; int tong[N],wv[N],wa[N],wb[N]; int rank1[N],height[N],sa[N]; char s[N]; int a[N],n; int dp[N][30]; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=a[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void calheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;i++)rank1[sa[i]]=i; for(i=0;i&lt;n;height[rank1[i++]]=k) for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++); return; } void preRMQ() { int i,j; memset(dp,127,sizeof(dp)); for(i=1;i&lt;=n*2+1;i++)dp[i][0]=height[i]; for(j=1;(1&lt;&lt;j)&lt;=2*n+1;j++) for(i=1;i+(1&lt;&lt;j)-1&lt;=2*n+1;i++) dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]); } int lcp(int l,int r) { int a=rank1[l],b=rank1[r]; if(a&gt;b) swap(a,b); a++; int t=(int)(log(double(b-a+1))/log(2.00)); return min(dp[a][t],dp[b-(1&lt;&lt;t)+1][t]); } int main() { int i,res,flag,max; while(scanf(&quot;%s&quot;,s)!=EOF) { max=0; n=strlen(s); for(i=0;i&lt;n;i++)a[i]=(int)s[i]; a[n]=1; for(i=0;i&lt;n;i++)a[i+n+1]=int(s[n-i-1]); a[2*n+1]=0; da(2*n+2,123); calheight(2*n+1); preRMQ(); for(i=0;i&lt;n;i++) { res=lcp(i,2*n-i)*2-1; if(max&lt;res) max=res,flag=i; if(i&gt;0) { res=lcp(i,2*n-i+1)*2; if(max&lt;res) max=res,flag=i; } } if(max%2==1)for(i=flag-max/2;i&lt;=flag+max/2;i++) printf(&quot;%c&quot;,s[i]); else for(i=flag-max/2;i&lt;=flag+max/2-1;i++) printf(&quot;%c&quot;,s[i]); printf(&quot;\\n&quot;); } } CODE 例7 (1).cogs1710:Power Strings （poj2406）本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。 例8 (1).poj3693:Maximum repetition substring #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N]; int k,now,jj,maxr,cnt; int d[N][21],ans[N]; char s[N*2]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } int prermq(int*a,int n) { for(int i=0;i&lt;n;++i)d[i][0]=a[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;++j) for(int i=0;i+(1&lt;&lt;j)-1&lt;n;++i) d[i][j]=min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]); } int askrmq(int l,int r) { l=rank[l],r=rank[r]; if(l&gt;r)swap(l,r); l++; int k=0; while((1&lt;&lt;(k+1))&lt;=r-l+1)k++; return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]); } int main() { int ccase=0; while(1) { memset(h,0,sizeof(h)); memset(d,0,sizeof(d)); memset(tong,0,sizeof(tong)); memset(rank,0,sizeof(rank)); memset(ans,0,sizeof(ans)); ccase++; k=now=jj=maxr=cnt=0; scanf(&quot;%s&quot;,s); if(s[0]==&#39;#&#39;)return 0; int n=strlen(s); da(n+1,maxf); getheight(n); prermq(h,n+1); for(int i=1;i&lt;n;++i) for(int j=0;j+i&lt;n;j+=i) { k=askrmq(j,j+i); now=k/i+1; jj=j-(i-k%i); if (jj&gt;=0&amp;&amp;askrmq(jj,jj+i)&gt;=(i-k%i))++now; if(now&gt;maxr) {cnt=0;maxr=now;ans[cnt++]=i;} else if(now==maxr) ans[cnt++]=i; } for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;cnt;++j) if(askrmq(sa[i],sa[i]+ans[j])&gt;=(maxr-1)*ans[j]) { jj=sa[i],k=ans[j]; goto dd; } dd:; printf(&quot;Case %d: &quot;,ccase); for (int i=0;i&lt;maxr*k;++i)putchar(s[jj++]); printf(&quot;\\n&quot;); } } CODE (2).cogs1711:重复的字符串 （spoj687） 例9 (1).cogs1713:Long Long Message （poj2774）#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 3e5+1; const int maxf = 255; const int inf =0x7fffffff; int sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N]; char s[N],ss[N]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;m=p,j&lt;&lt;=1) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } int main() { freopen(&quot;longlongmessage.in&quot;,&quot;r&quot;,stdin); freopen(&quot;longlongmessage.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%s&quot;,s); scanf(&quot;%s&quot;,ss); int n=strlen(s),m=strlen(ss); s[n]=&#39;*&#39;; for(int i=n+1;i&lt;=n+m;++i)s[i]=ss[i-n-1]; int l=n+m+1; da(l+1,maxf); geth(l); int maxx=0; for(int i=2;i&lt;=l;++i) { if(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i-1]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i-1]&lt;n))) maxx=h[i]; } cout&lt;&lt;maxx; } CODE 例10 (1).cogs1712:Common Substrings （poj3415） 例11 (1).cogs2128:生命形态 （poj3294）例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 2e5+1; const int inf =0x7fffffff; const int maxf = 255; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} int sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N]; char ss[111][10001],s[N]; int nn[111],tt; bool inq[111]; int ll[N]; void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(i=1,p=1,swap(x,y),x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++); } int k; int ansg; bool can(int ans,int n,int flag) { if(!flag) { int tot1=0; memset(inq,0,sizeof(inq)); for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { memset(inq,0,sizeof(inq)); tot1=0; } else { int nowq,nowt; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t; if(!inq[nowq])tot1++,inq[nowq]=true; if(!inq[nowt])tot1++,inq[nowt]=true; if(tot1&gt;=k)return 1; } } return 0; } if(flag) { int lll=inf,rrr=-1; int tot1=0; memset(inq,0,sizeof(inq)); for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { memset(inq,0,sizeof(inq)); tot1=0; lll=inf;rrr=-1; } else { int nowq,nowt; if(sa[i-1]&lt;lll)lll=sa[i-1];if(sa[i-1]&gt;rrr)rrr=sa[i-1]; if(sa[i]&lt;lll)lll=sa[i];if(sa[i]&gt;rrr)rrr=sa[i]; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t; if(!inq[nowq])tot1++,inq[nowq]=true; if(!inq[nowt])tot1++,inq[nowt]=true; if(tot1==k)ll[++ansg]=lll; } } } } int main() { // freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout); while(scanf(&quot;%d&quot;,&amp;tt)!=EOF) { if(!tt)return 0; memset(wa,0,sizeof(wa)); memset(wb,0,sizeof(wb)); memset(wv,0,sizeof(wv)); memset(rank,0,sizeof(rank)); memset(sa,0,sizeof(sa)); memset(h,0,sizeof(h)); memset(nn,0,sizeof(nn)); memset(s,0,sizeof(s)); int tot=0; int tmp=2; ansg=0; for(int i=1;i&lt;=tt;++i) { scanf(&quot;%s&quot;,ss[i]); nn[i]=strlen(ss[i]); nn[0]=-1; for(int t=0;t&lt;nn[i];++t)s[tot++]=ss[i][t]; nn[i]+=nn[i-1]+(i==tt?0:1); if(i!=tt)s[tot++]=tmp++; } nn[tt]++; int n=strlen(s); da(n+1,maxf); geth(n); k=(tt)/2+1; int l=0,r=n+1,mid; while(l!=r) { mid=(l+r+1)&gt;&gt;1; if(can(mid,n,0)) l=mid; else r=mid-1; } if(l==0){printf(&quot;?&quot;);goto dd;} can(l,n,1); for(int i=1;i&lt;=ansg;++i) { if(i!=1) { bool flag=0; for(int t=0;t&lt;l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;} if(!flag)continue; } for(int t=ll[i];t&lt;=ll[i]+l-1;++t)putchar(s[t]); printf(&quot;\\n&quot;); } dd:; } } CODE 例12 (1).cogs2120:破译进攻计划 （spoj220）#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; const int N = 2e5+500; const int maxf = 255; int sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N]; char s[N],ss[13][15031]; int inq[13],maxq[13],minq[13]; int tt,num; bool use[13]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),x[sa[0]]=0,i=1,p=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } bool can(int ans,int n) { int tot=0; for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { tot=0; memset(inq,0,sizeof(inq)); memset(maxq,0,sizeof(maxq)); memset(minq,0x3f,sizeof(minq)); memset(use,0,sizeof(use)); } else { for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t]) { inq[t]++; minq[t]=min(minq[t],sa[i]); maxq[t]=max(maxq[t],sa[i]); if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true; if(tot==num)return 1; } for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t]) { inq[t]++; minq[t]=min(minq[t],sa[i-1]); maxq[t]=max(maxq[t],sa[i-1]); if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true; if(tot==num)return 1; } } } return 0; } int main() { // freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout); nn[0]=-1; scanf(&quot;%d&quot;,&amp;tt); while(tt--) { memset(inq,0,sizeof(inq)); memset(wa,0,sizeof(wa)); memset(wb,0,sizeof(wb)); memset(wv,0,sizeof(wv)); memset(sa,0,sizeof(sa)); memset(rank,0,sizeof(rank)); memset(h,0,sizeof(h)); scanf(&quot;%d&quot;,&amp;num); int tot=0,qiguaizifu=2; for(int i=1;i&lt;=num;++i) { scanf(&quot;%s&quot;,ss[i]); nn[i]=strlen(ss[i]); } for(int i=1;i&lt;=num;++i) { for(int t=0;t&lt;nn[i];++t) s[tot++]=ss[i][t]; s[tot++]=qiguaizifu++; } for(int i=1;i&lt;=num;++i)nn[i]+=(nn[i-1]+1); int n=strlen(s); da(n+1,maxf); geth(n); int l=0,r=(n+1)/2; while(l!=r) { int mid=l+r+1&gt;&gt;1; if(can(mid,n)) l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,l); } } CODE 例13 (1).poj1226:Substrings","raw":"title: 后缀数组十三题\ndate: 2017-03-08 11:02:35\ncategories:\n  - Hollerith-type\n  - 后缀数组\ntags:\n  - 后缀数组\n---\n\n\n# 论文\n[后缀数组——处理字符串的有力工具--罗穗骞](https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/pdfs/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E4%B9%8B%E3%80%8A%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E5%8A%9B%E5%B7%A5%E5%85%B7%E3%80%8B.pdf)\n\n\n <!--more--> \n \n \n# 题目\n\n-----------------------------------------------------------------------------------------------------------\n## 例3         (1).[cogs902:Musical Theme](http://cogs.pro/cogs/problem/problem.php?pid=902)(poj1743)\n\n本题题目描述与论文略有差别。\n\n应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa > k，而不是maxsa - minsa > = k（然而POJ并没有卡我..））\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 1e5+1;\n    const int maxf = 255;\n    const int inf = 0x7fffffff;\n    int wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];\n    int s[N];\n    int cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i<m;i++)tong[i]=0;\n    for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i<m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n    for(p=1,j=1;p<n;j<<=1,m=p)\n    {\n        for(p=0,i=n-j;i<n;++i)y[p++]=i;\n        for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n        for(i=0;i<n;++i)wv[i]=x[y[i]];\n        for(i=0;i<m;i++)tong[i]=0;\n        for(i=0;i<n;++i)tong[wv[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n    }\n    void getheight(int n)\n    {\n    int i,j,k=0;\n    for(i=1;i<=n;++i)rank[sa[i]]=i;\n    for(i=0;i<n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    return;\n    }\n    bool can(int k,int n)\n    {\n    int tmp=0,maxsa=-1,minsa=inf;\n    for(int i=1;i<=n;++i)\n    {\n        if(h[i]<k)maxsa=-1,minsa=inf;\n        if(sa[i]<minsa)minsa=sa[i];\n        if(sa[i]>maxsa)maxsa=sa[i];\n        if(maxsa-minsa>k)return 1;\n    }\n    return 0;\n    }\n    int main()\n    {\n    //  freopen(\"theme.in\",\"r\",stdin);\n    //  freopen(\"theme.out\",\"w\",stdout);\n    int n,x;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        memset(h,0,sizeof(h));\n        memset(sa,0,sizeof(sa));\n        memset(rank,0,sizeof(rank));\n        if(!n)break;\n        cin>>x;\n        for(int i=1;i<n;++i)scanf(\"%d\",&s[i]);\n        s[0]=s[1]-x;\n        for(int i=1;i<n-1;++i)s[i]=s[i+1]-s[i];\n        n--;\n        for(int i=0;i<n;++i)s[i]+=150;\n        da(n+1,maxf);\n        getheight(n);\n        int l=0,r=1e6,ans;\n        int mid=0;\n        while(l!=r)\n        {\n            ans=l+r+1>>1;\n            if(can(ans,n))  l=ans;\n            else      r=ans-1;\n        }\n        l++;\n        printf(\"%d\\n\",(l)>=5?l:0);\n    }\n    }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B3.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例4         (1).[poj3261：Milk Patterns](http://poj.org/problem?id=3261)\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int maxf = 255;\n    const int inf = 0x7fffffff;\n    const int N = 1e5+5;\n    int sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];\n    int s[N],k;\n    int cmp(int*r,int a,int b,int l)\n    {return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;i++)tong[i]=0;\n            for(i=0;i<n;i++)tong[wv[i]]++;\n            for(i=1;i<m;i++)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void getheight(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;height[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n        return;\n    }\n    bool can(int ans,int n)\n    {\n        int tot=0;\n        for(int i=1;i<=n;++i)\n        {\n            if(height[i]<ans)tot=0;\n            tot++;\n            if(tot==k)return 1;\n        }\n        return 0;\n    }\n    int main()\n    {\n        int n;\n        scanf(\"%d%d\",&n,&k);\n        for(int i=0;i<n;++i)scanf(\"%d\",s+i);\n        da(n+1,maxf);\n        getheight(n);\n        int l=1,r=n+1,ans,mid;\n        while(l!=r)\n        {\n            int mid=(l+r>>1)+1;\n            if(can(mid,n))ans=l=mid;\n            else    r=mid-1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B4.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例5         (1).[spoj694：Distinct Substrings](https://vjudge.net/problem/SPOJ-DISUBSTR)(Vjudge)   \n\n这题论文中的方法不太好想，可以换一种思路。\n\n易证长度为len的字符串一共有$（len+1）*len / 2$个子串。\n而其中重复的字串个数则为height数组的总和，减去即可。\n\n以\n\n\tsa[i-1]  abba\n\n\tsa[i]    abcd //height[i] = 2\n\n这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。\n\n这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为\n   \n   \tbba\n       bcd //height = 1\n    \n    \n   重复的子串 b 将在此处减掉。\n   \n\n      #include<iostream> \n      #include<cstring>\n      #include<cstdio>\n      const int N =1e4+5;       \n      using namespace std;       \n      char s[N];   \n      int sa[N],wa[N],wb[N],tong[N],wv[N];      \n      int rank[N],height[N];      \n      int cmp(int*r,int a,int b,int l)\n      {return r[a]==r[b]&&r[a+l]==r[b+l];}\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<m;i++)tong[i]=0;\n              for(i=0;i<n;i++)tong[wv[i]]++;\n              for(i=1;i<m;i++)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n          return;\n      }\n      void calheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;i++) rank[sa[i]]=i;\n          for(i=0;i<n;height[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n          return;\n      }\n      int main()  \n      {  \n          int t;  \n          scanf(\"%d\",&t);  \n          while(t--)  \n          {  \n              int i;  \n              scanf(\"%s\",s);  \n              int n=strlen(s);   \n              da(n+1,128);  \n              calheight(n);  \n              long long ans=n*(n+1)/2;  \n              for(i=1;i<=n;i++)  \n              ans-=height[i];  \n              printf(\"%lld\\n\",ans);  \n          }  \n      }  \n\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.cpp)\n\n\n\n## (2).[cogs1709:不同的子串](http://cogs.pro/cogs/problem/problem.php?pid=1709) （spoj705）\n\n      #include<iostream>\n      #include<cstdio>\n      #include<cstring>\n      using namespace std;\n      const int N = 1e5+1;\n      const int maxf = 255;\n      int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];\n      char s[N];\n      bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;i--)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<m;++i)tong[i]=0;\n              for(i=0;i<n;++i)tong[wv[i]]++;\n              for(i=1;i<m;++i)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,i=1,x[sa[0]]=0;i<n;++i)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n          return;\n      }\n      void getheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;++i)rank[sa[i]]=i;\n          for(i=0;i<n;h[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n          return;\n      }\n      int main()\n      {\n      //  freopen(\"subst1.in\",\"r\",stdin);\n      //  freopen(\"subst1.out\",\"w\",stdout);\n          scanf(\"%s\",s);\n          int n=strlen(s);\n          da(n+1,maxf);\n          getheight(n);\n          for(int i=1;i<=n;++i)sa[i]++;\n          long long ans=0;\n          for(int i=1;i<=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1;\n          printf(\"%d\",ans);\n      }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.2.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例6         (1).[ural1297：Palindrome](https://vjudge.net/problem/URAL-1297)(Vjudge)\n\n这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]>=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。\n\n\n\n    #include<cstring>\n    #include<cstdlib>\n    #include<cstdio>\n    #include<iostream>\n    #include<cmath>\n    using namespace std;\n    const int N = 1e4+1;\n    int tong[N],wv[N],wa[N],wb[N];\n    int rank1[N],height[N],sa[N];\n    char s[N];\n    int a[N],n;\n    int dp[N][30];\n    int cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=a[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;i++)tong[i]=0;\n            for(i=0;i<n;i++)tong[wv[i]]++;\n            for(i=1;i<m;i++)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n      return;\n    }\n\n    void calheight(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;i++)rank1[sa[i]]=i;\n        for(i=0;i<n;height[rank1[i++]]=k)\n        for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++);\n        return;\n    }\n\n    void preRMQ()\n    {\n        int i,j;\n        memset(dp,127,sizeof(dp));\n        for(i=1;i<=n*2+1;i++)dp[i][0]=height[i];\n        for(j=1;(1<<j)<=2*n+1;j++)\n        for(i=1;i+(1<<j)-1<=2*n+1;i++)\n        dp[i][j]=min(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);\n    }\n\n    int lcp(int l,int r)\n    {\n        int a=rank1[l],b=rank1[r];\n        if(a>b)\n            swap(a,b);\n        a++;\n        int t=(int)(log(double(b-a+1))/log(2.00));\n        return min(dp[a][t],dp[b-(1<<t)+1][t]);\n    }\n\n    int main()\n    {\n        int i,res,flag,max;\n        while(scanf(\"%s\",s)!=EOF)\n        {\n            max=0;\n            n=strlen(s);\n            for(i=0;i<n;i++)a[i]=(int)s[i];\n            a[n]=1;\n            for(i=0;i<n;i++)a[i+n+1]=int(s[n-i-1]);\n            a[2*n+1]=0;\n            da(2*n+2,123);\n            calheight(2*n+1);\n            preRMQ();\n            for(i=0;i<n;i++)\n            {\n                res=lcp(i,2*n-i)*2-1;\n                if(max<res)   max=res,flag=i;\n                if(i>0)\n                {\n                    res=lcp(i,2*n-i+1)*2;\n                    if(max<res) max=res,flag=i;\n                }\n            }\n            if(max%2==1)for(i=flag-max/2;i<=flag+max/2;i++)   printf(\"%c\",s[i]);\n            else    for(i=flag-max/2;i<=flag+max/2-1;i++) printf(\"%c\",s[i]);\n            printf(\"\\n\");\n        }\n  }\n\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B6.cpp)\n\n-----------------------------------------------------------------------------------------------------------\n## 例7           (1).[cogs1710:Power Strings](http://cogs.pro/cogs/problem/problem.php?pid=1710)  （poj2406）\n\n本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n ## 例8       (1).[poj3693:Maximum repetition substring](http://poj.org/problem?id=3693)\n\n\n      #include<iostream>\n      #include<cstdio>\n      #include<cstring>\n      using namespace std;\n      const int N = 1e5+1;\n      const int maxf = 255;\n      int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];\n      int k,now,jj,maxr,cnt;\n      int d[N][21],ans[N];\n      char s[N*2];\n      bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<m;++i)tong[i]=0;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<n;++i)tong[wv[i]]++;\n              for(i=1;i<m;++i)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;++i)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n      }\n      void getheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;++i)rank[sa[i]]=i;\n          for(i=0;i<n;h[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      }\n      int prermq(int*a,int n)\n      {\n          for(int i=0;i<n;++i)d[i][0]=a[i];\n          for(int j=1;(1<<j)<=n;++j)\n          for(int i=0;i+(1<<j)-1<n;++i)\n          d[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n      }\n      int askrmq(int l,int r)\n      {\n          l=rank[l],r=rank[r];\n          if(l>r)swap(l,r);\n          l++;\n          int k=0;\n          while((1<<(k+1))<=r-l+1)k++;\n          return min(d[l][k],d[r-(1<<k)+1][k]);\n      }\n      int main()\n      {\n          int ccase=0;\n          while(1)\n          {\n          memset(h,0,sizeof(h));\n          memset(d,0,sizeof(d));\n          memset(tong,0,sizeof(tong));\n          memset(rank,0,sizeof(rank));\n          memset(ans,0,sizeof(ans));\n          ccase++;\n\n          k=now=jj=maxr=cnt=0;\n          scanf(\"%s\",s);\n          if(s[0]=='#')return 0;\n          int n=strlen(s);\n          da(n+1,maxf);\n          getheight(n);\n          prermq(h,n+1);\n          for(int i=1;i<n;++i) \n          for(int j=0;j+i<n;j+=i) \n          {\n              k=askrmq(j,j+i);\n              now=k/i+1;\n              jj=j-(i-k%i);\n              if (jj>=0&&askrmq(jj,jj+i)>=(i-k%i))++now;\n              if(now>maxr)    {cnt=0;maxr=now;ans[cnt++]=i;}\n              else if(now==maxr)  ans[cnt++]=i;\n          }\n              for(int i=1;i<=n;++i) \n              for(int j=0;j<cnt;++j)\n              if(askrmq(sa[i],sa[i]+ans[j])>=(maxr-1)*ans[j])\n              {\n                  jj=sa[i],k=ans[j];\n                  goto dd;\n              }\n              dd:;\n              printf(\"Case %d: \",ccase);\n              for (int i=0;i<maxr*k;++i)putchar(s[jj++]);\n              printf(\"\\n\");\n          }\n      }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B8.cpp)\n\n\n\n\n\n## (2).[cogs1711:重复的字符串](http://cogs.pro/cogs/problem/problem.php?pid=1711) （spoj687）\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例9      (1).[cogs1713:Long Long Message](http://cogs.pro/cogs/problem/problem.php?pid=1713)  （poj2774）\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 3e5+1;\n    const int maxf = 255;\n    const int inf =0x7fffffff;\n    int sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N];\n    char s[N],ss[N];\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;m=p,j<<=1)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,i=1,x[sa[0]]=0;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    }\n    int main()\n    {\n        freopen(\"longlongmessage.in\",\"r\",stdin);\n        freopen(\"longlongmessage.out\",\"w\",stdout);\n        scanf(\"%s\",s);\n        scanf(\"%s\",ss);\n        int n=strlen(s),m=strlen(ss);\n        s[n]='*';\n        for(int i=n+1;i<=n+m;++i)s[i]=ss[i-n-1];\n        int l=n+m+1;\n        da(l+1,maxf);\n        geth(l);\n        int maxx=0;\n        for(int i=2;i<=l;++i)\n        {\n            if(h[i]>maxx&&((sa[i]<n&&sa[i-1]>n)||(sa[i]>n&&sa[i-1]<n)))\n            maxx=h[i];\n        }\n        cout<<maxx;\n    }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B9.tag.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例10    (1).[cogs1712:Common Substrings](http://cogs.pro/cogs/problem/problem.php?pid=1712)  （poj3415）\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例11    (1).[cogs2128:生命形态](http://cogs.pro/cogs/problem/problem.php?pid=2128)   （poj3294）\n\n例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。\n\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N = 2e5+1;\n    const int inf =0x7fffffff;\n    const int maxf = 255;\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    int sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];\n    char ss[111][10001],s[N];\n    int nn[111],tt;\n    bool inq[111];\n    int ll[N];\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]=x[y[i]]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(i=1,p=1,swap(x,y),x[sa[0]]=0;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++);\n    }\n    int k;\n    int ansg;\n    bool can(int ans,int n,int flag)\n    {\n        if(!flag)\n        {\n            int tot1=0;\n            memset(inq,0,sizeof(inq));\n            for(int i=1;i<=n;++i)\n            {\n                if(h[i]<ans)\n                {\n                    memset(inq,0,sizeof(inq));  tot1=0;\n                }\n                else\n                {\n                    int nowq,nowt;\n                    for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])nowt=t;\n                    for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i]&&sa[i]<nn[t])nowq=t;\n                    if(!inq[nowq])tot1++,inq[nowq]=true;\n                    if(!inq[nowt])tot1++,inq[nowt]=true;\n                    if(tot1>=k)return 1;\n                }\n            }\n            return 0;\n        }\n        if(flag)\n        {\n          int lll=inf,rrr=-1;\n          int tot1=0;\n          memset(inq,0,sizeof(inq));\n          for(int i=1;i<=n;++i)\n          {\n              if(h[i]<ans)\n              {\n                  memset(inq,0,sizeof(inq));  tot1=0;\n                  lll=inf;rrr=-1;\n              }\n              else\n              {\n                  int nowq,nowt;\n                  if(sa[i-1]<lll)lll=sa[i-1];if(sa[i-1]>rrr)rrr=sa[i-1];\n                  if(sa[i]<lll)lll=sa[i];if(sa[i]>rrr)rrr=sa[i];\n                  for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])nowt=t;\n                  for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i]&&sa[i]<nn[t])nowq=t;\n                  if(!inq[nowq])tot1++,inq[nowq]=true;\n                  if(!inq[nowt])tot1++,inq[nowt]=true;\n                  if(tot1==k)ll[++ansg]=lll;\n              }\n          }\n      }\n    }\n      int main()\n      {\n      //  freopen(\"Lifeforms.in\",\"r\",stdin);\n      //  freopen(\"Lifeforms.out\",\"w\",stdout);\n          while(scanf(\"%d\",&tt)!=EOF)\n          {\n              if(!tt)return 0;\n              memset(wa,0,sizeof(wa));\n              memset(wb,0,sizeof(wb));\n              memset(wv,0,sizeof(wv));\n              memset(rank,0,sizeof(rank));\n              memset(sa,0,sizeof(sa));\n              memset(h,0,sizeof(h));\n              memset(nn,0,sizeof(nn));\n              memset(s,0,sizeof(s));\n              int tot=0;\n              int tmp=2;\n              ansg=0;\n              for(int i=1;i<=tt;++i)\n              {\n                  scanf(\"%s\",ss[i]);\n                  nn[i]=strlen(ss[i]);\n                  nn[0]=-1;\n                  for(int t=0;t<nn[i];++t)s[tot++]=ss[i][t];\n                  nn[i]+=nn[i-1]+(i==tt?0:1);\n                  if(i!=tt)s[tot++]=tmp++;\n              }\n              nn[tt]++;\n              int n=strlen(s);\n              da(n+1,maxf);\n              geth(n);\n              k=(tt)/2+1;\n              int l=0,r=n+1,mid;\n              while(l!=r)\n              {\n                  mid=(l+r+1)>>1;\n                  if(can(mid,n,0))  l=mid;\n                  else      r=mid-1;\n              }\n              if(l==0){printf(\"?\");goto dd;}\n              can(l,n,1);\n              for(int i=1;i<=ansg;++i)\n              {\n                  if(i!=1)\n                  {\n                  bool flag=0;\n                  for(int t=0;t<l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;}\n                  if(!flag)continue;\n                  }\n                  for(int t=ll[i];t<=ll[i]+l-1;++t)putchar(s[t]);\n                  printf(\"\\n\");\n              }\n              dd:;\n          }\n      }\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B11.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例12    (1).[cogs2120:破译进攻计划](http://cogs.pro/cogs/problem/problem.php?pid=2120)   （spoj220）\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<cmath>\n    using namespace std;\n    const int N = 2e5+500;\n    const int maxf = 255;\n    int sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];\n    char s[N],ss[13][15031];\n    int inq[13],maxq[13],minq[13];\n    int tt,num;\n    bool use[13];\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;i--)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]=x[y[i]]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),x[sa[0]]=0,i=1,p=1;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    }\n    bool can(int ans,int n)\n    {\n        int tot=0;\n        for(int i=1;i<=n;++i)\n        {\n            if(h[i]<ans)\n            {\n                tot=0;\n                memset(inq,0,sizeof(inq));\n                memset(maxq,0,sizeof(maxq));\n                memset(minq,0x3f,sizeof(minq));\n                memset(use,0,sizeof(use));\n            }\n            else\n            {\n                for(int t=1;t<=num;++t)if(nn[t-1]<sa[i]&&sa[i]<=nn[t])\n                {\n                    inq[t]++;\n                    minq[t]=min(minq[t],sa[i]);\n                    maxq[t]=max(maxq[t],sa[i]);\n                    if(maxq[t]-minq[t]>=ans&&!use[t])tot++,use[t]=true;\n                    if(tot==num)return 1;\n                }\n                for(int t=1;t<=num;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])\n                {\n                    inq[t]++;\n                    minq[t]=min(minq[t],sa[i-1]);\n                    maxq[t]=max(maxq[t],sa[i-1]);\n                    if(maxq[t]-minq[t]>=ans&&!use[t])tot++,use[t]=true;\n                    if(tot==num)return 1;\n                }\n            } \n        }\n        return 0;\n    }\n    int main()\n    {\n    //  freopen(\"RelevantPhrasesofAnnihil.in\",\"r\",stdin);\n    //  freopen(\"RelevantPhrasesofAnnihil.out\",\"w\",stdout);\n        nn[0]=-1;\n        scanf(\"%d\",&tt);\n        while(tt--)\n        {\n            memset(inq,0,sizeof(inq));\n            memset(wa,0,sizeof(wa));\n            memset(wb,0,sizeof(wb));\n            memset(wv,0,sizeof(wv));\n            memset(sa,0,sizeof(sa));\n            memset(rank,0,sizeof(rank));\n            memset(h,0,sizeof(h));\n            scanf(\"%d\",&num);\n            int tot=0,qiguaizifu=2;\n            for(int i=1;i<=num;++i)\n            {\n                scanf(\"%s\",ss[i]);\n                nn[i]=strlen(ss[i]);\n            }\n            for(int i=1;i<=num;++i)\n            {\n                for(int t=0;t<nn[i];++t)\n                s[tot++]=ss[i][t];\n                s[tot++]=qiguaizifu++;\n            }\n            for(int i=1;i<=num;++i)nn[i]+=(nn[i-1]+1);\n            int n=strlen(s);\n            da(n+1,maxf);\n            geth(n);\n            int l=0,r=(n+1)/2;\n            while(l!=r)\n            {\n                int mid=l+r+1>>1;\n                if(can(mid,n))  l=mid;\n                else      r=mid-1;\n            }\n            printf(\"%d\\n\",l);\n        }\n    }\n\n\n[CODE](https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B12.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例13    (1).[poj1226:Substrings](http://poj.org/problem?id=1226)\n-------------------------------------------------------------\n\n    \n","content":"<h1 id=\"论文\"><a href=\"#论文\" class=\"headerlink\" title=\"论文\"></a>论文</h1><p><a href=\"https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/pdfs/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E4%B9%8B%E3%80%8A%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E5%8A%9B%E5%B7%A5%E5%85%B7%E3%80%8B.pdf\" target=\"_blank\" rel=\"external\">后缀数组——处理字符串的有力工具–罗穗骞</a></p>\n <a id=\"more\"></a> \n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><hr>\n<h2 id=\"例3-1-cogs902-Musical-Theme-poj1743\"><a href=\"#例3-1-cogs902-Musical-Theme-poj1743\" class=\"headerlink\" title=\"例3         (1).cogs902:Musical Theme(poj1743)\"></a>例3         (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=902\" target=\"_blank\" rel=\"external\">cogs902:Musical Theme</a>(poj1743)</h2><p>本题题目描述与论文略有差别。</p>\n<p>应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..））</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 1e5+1;\nconst int maxf = 255;\nconst int inf = 0x7fffffff;\nint wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];\nint s[N];\nint cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\nint i,j,p,*x=wa,*y=wb;\nfor(i=0;i&lt;m;i++)tong[i]=0;\nfor(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\nfor(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\nfor(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\nfor(p=1,j=1;p&lt;n;j&lt;&lt;=1,m=p)\n{\n    for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n    for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n    for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n    for(i=0;i&lt;m;i++)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[wv[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n    for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i)\n    x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n}\nreturn;\n}\nvoid getheight(int n)\n{\nint i,j,k=0;\nfor(i=1;i&lt;=n;++i)rank[sa[i]]=i;\nfor(i=0;i&lt;n;h[rank[i++]]=k)\nfor(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\nreturn;\n}\nbool can(int k,int n)\n{\nint tmp=0,maxsa=-1,minsa=inf;\nfor(int i=1;i&lt;=n;++i)\n{\n    if(h[i]&lt;k)maxsa=-1,minsa=inf;\n    if(sa[i]&lt;minsa)minsa=sa[i];\n    if(sa[i]&gt;maxsa)maxsa=sa[i];\n    if(maxsa-minsa&gt;k)return 1;\n}\nreturn 0;\n}\nint main()\n{\n//  freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin);\n//  freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout);\nint n,x;\nwhile(scanf(&quot;%d&quot;,&amp;n)!=EOF)\n{\n    memset(h,0,sizeof(h));\n    memset(sa,0,sizeof(sa));\n    memset(rank,0,sizeof(rank));\n    if(!n)break;\n    cin&gt;&gt;x;\n    for(int i=1;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;s[i]);\n    s[0]=s[1]-x;\n    for(int i=1;i&lt;n-1;++i)s[i]=s[i+1]-s[i];\n    n--;\n    for(int i=0;i&lt;n;++i)s[i]+=150;\n    da(n+1,maxf);\n    getheight(n);\n    int l=0,r=1e6,ans;\n    int mid=0;\n    while(l!=r)\n    {\n        ans=l+r+1&gt;&gt;1;\n        if(can(ans,n))  l=ans;\n        else      r=ans-1;\n    }\n    l++;\n    printf(&quot;%d\\n&quot;,(l)&gt;=5?l:0);\n}\n}\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B3.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例4-1-poj3261：Milk-Patterns\"><a href=\"#例4-1-poj3261：Milk-Patterns\" class=\"headerlink\" title=\"例4         (1).poj3261：Milk Patterns\"></a>例4         (1).<a href=\"http://poj.org/problem?id=3261\" target=\"_blank\" rel=\"external\">poj3261：Milk Patterns</a></h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int maxf = 255;\nconst int inf = 0x7fffffff;\nconst int N = 1e5+5;\nint sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];\nint s[N],k;\nint cmp(int*r,int a,int b,int l)\n{return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n        for(i=0;i&lt;m;i++)tong[i]=0;\n        for(i=0;i&lt;n;i++)tong[wv[i]]++;\n        for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n}\nvoid getheight(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;height[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    return;\n}\nbool can(int ans,int n)\n{\n    int tot=0;\n    for(int i=1;i&lt;=n;++i)\n    {\n        if(height[i]&lt;ans)tot=0;\n        tot++;\n        if(tot==k)return 1;\n    }\n    return 0;\n}\nint main()\n{\n    int n;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);\n    for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,s+i);\n    da(n+1,maxf);\n    getheight(n);\n    int l=1,r=n+1,ans,mid;\n    while(l!=r)\n    {\n        int mid=(l+r&gt;&gt;1)+1;\n        if(can(mid,n))ans=l=mid;\n        else    r=mid-1;\n    }\n    printf(&quot;%d\\n&quot;,ans);\n}\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B4.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例5-1-spoj694：Distinct-Substrings-Vjudge\"><a href=\"#例5-1-spoj694：Distinct-Substrings-Vjudge\" class=\"headerlink\" title=\"例5         (1).spoj694：Distinct Substrings(Vjudge)\"></a>例5         (1).<a href=\"https://vjudge.net/problem/SPOJ-DISUBSTR\" target=\"_blank\" rel=\"external\">spoj694：Distinct Substrings</a>(Vjudge)</h2><p>这题论文中的方法不太好想，可以换一种思路。</p>\n<p>易证长度为len的字符串一共有$（len+1）*len / 2$个子串。<br>而其中重复的字串个数则为height数组的总和，减去即可。</p>\n<p>以</p>\n<pre><code>sa[i-1]  abba\n\nsa[i]    abcd //height[i] = 2\n</code></pre><p>这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。</p>\n<p>这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为</p>\n<pre><code>   bba\n   bcd //height = 1\n</code></pre><p>   重复的子串 b 将在此处减掉。</p>\n<pre><code>  #include&lt;iostream&gt; \n  #include&lt;cstring&gt;\n  #include&lt;cstdio&gt;\n  const int N =1e4+5;       \n  using namespace std;       \n  char s[N];   \n  int sa[N],wa[N],wb[N],tong[N],wv[N];      \n  int rank[N],height[N];      \n  int cmp(int*r,int a,int b,int l)\n  {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n  void da(int n,int m)\n  {\n      int i,j,p,*x=wa,*y=wb;\n      for(i=0;i&lt;m;++i)tong[i]=0;\n      for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n      for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n      for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n      for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n      {\n          for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n          for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n          for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n          for(i=0;i&lt;m;i++)tong[i]=0;\n          for(i=0;i&lt;n;i++)tong[wv[i]]++;\n          for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n          for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n          x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n      }\n      return;\n  }\n  void calheight(int n)\n  {\n      int i,j,k=0;\n      for(i=1;i&lt;=n;i++) rank[sa[i]]=i;\n      for(i=0;i&lt;n;height[rank[i++]]=k)\n      for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      return;\n  }\n  int main()  \n  {  \n      int t;  \n      scanf(&quot;%d&quot;,&amp;t);  \n      while(t--)  \n      {  \n          int i;  \n          scanf(&quot;%s&quot;,s);  \n          int n=strlen(s);   \n          da(n+1,128);  \n          calheight(n);  \n          long long ans=n*(n+1)/2;  \n          for(i=1;i&lt;=n;i++)  \n          ans-=height[i];  \n          printf(&quot;%lld\\n&quot;,ans);  \n      }  \n  }  \n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<h2 id=\"2-cogs1709-不同的子串-（spoj705）\"><a href=\"#2-cogs1709-不同的子串-（spoj705）\" class=\"headerlink\" title=\"(2).cogs1709:不同的子串 （spoj705）\"></a>(2).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1709\" target=\"_blank\" rel=\"external\">cogs1709:不同的子串</a> （spoj705）</h2><pre><code>  #include&lt;iostream&gt;\n  #include&lt;cstdio&gt;\n  #include&lt;cstring&gt;\n  using namespace std;\n  const int N = 1e5+1;\n  const int maxf = 255;\n  int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];\n  char s[N];\n  bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n  void da(int n,int m)\n  {\n      int i,j,p,*x=wa,*y=wb;\n      for(i=0;i&lt;m;++i)tong[i]=0;\n      for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n      for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n      for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i;\n      for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n      {\n          for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n          for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n          for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n          for(i=0;i&lt;m;++i)tong[i]=0;\n          for(i=0;i&lt;n;++i)tong[wv[i]]++;\n          for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n          for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i)\n          x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n      }\n      return;\n  }\n  void getheight(int n)\n  {\n      int i,j,k=0;\n      for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n      for(i=0;i&lt;n;h[rank[i++]]=k)\n      for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      return;\n  }\n  int main()\n  {\n  //  freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin);\n  //  freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout);\n      scanf(&quot;%s&quot;,s);\n      int n=strlen(s);\n      da(n+1,maxf);\n      getheight(n);\n      for(int i=1;i&lt;=n;++i)sa[i]++;\n      long long ans=0;\n      for(int i=1;i&lt;=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1;\n      printf(&quot;%d&quot;,ans);\n  }\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.2.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例6-1-ural1297：Palindrome-Vjudge\"><a href=\"#例6-1-ural1297：Palindrome-Vjudge\" class=\"headerlink\" title=\"例6         (1).ural1297：Palindrome(Vjudge)\"></a>例6         (1).<a href=\"https://vjudge.net/problem/URAL-1297\" target=\"_blank\" rel=\"external\">ural1297：Palindrome</a>(Vjudge)</h2><p>这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。</p>\n<pre><code>#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nconst int N = 1e4+1;\nint tong[N],wv[N],wa[N],wb[N];\nint rank1[N],height[N],sa[N];\nchar s[N];\nint a[N],n;\nint dp[N][30];\nint cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=a[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n        for(i=0;i&lt;m;i++)tong[i]=0;\n        for(i=0;i&lt;n;i++)tong[wv[i]]++;\n        for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n  return;\n}\n\nvoid calheight(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;i++)rank1[sa[i]]=i;\n    for(i=0;i&lt;n;height[rank1[i++]]=k)\n    for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++);\n    return;\n}\n\nvoid preRMQ()\n{\n    int i,j;\n    memset(dp,127,sizeof(dp));\n    for(i=1;i&lt;=n*2+1;i++)dp[i][0]=height[i];\n    for(j=1;(1&lt;&lt;j)&lt;=2*n+1;j++)\n    for(i=1;i+(1&lt;&lt;j)-1&lt;=2*n+1;i++)\n    dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);\n}\n\nint lcp(int l,int r)\n{\n    int a=rank1[l],b=rank1[r];\n    if(a&gt;b)\n        swap(a,b);\n    a++;\n    int t=(int)(log(double(b-a+1))/log(2.00));\n    return min(dp[a][t],dp[b-(1&lt;&lt;t)+1][t]);\n}\n\nint main()\n{\n    int i,res,flag,max;\n    while(scanf(&quot;%s&quot;,s)!=EOF)\n    {\n        max=0;\n        n=strlen(s);\n        for(i=0;i&lt;n;i++)a[i]=(int)s[i];\n        a[n]=1;\n        for(i=0;i&lt;n;i++)a[i+n+1]=int(s[n-i-1]);\n        a[2*n+1]=0;\n        da(2*n+2,123);\n        calheight(2*n+1);\n        preRMQ();\n        for(i=0;i&lt;n;i++)\n        {\n            res=lcp(i,2*n-i)*2-1;\n            if(max&lt;res)   max=res,flag=i;\n            if(i&gt;0)\n            {\n                res=lcp(i,2*n-i+1)*2;\n                if(max&lt;res) max=res,flag=i;\n            }\n        }\n        if(max%2==1)for(i=flag-max/2;i&lt;=flag+max/2;i++)   printf(&quot;%c&quot;,s[i]);\n        else    for(i=flag-max/2;i&lt;=flag+max/2-1;i++) printf(&quot;%c&quot;,s[i]);\n        printf(&quot;\\n&quot;);\n    }\n</code></pre><p>  }</p>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B6.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例7-1-cogs1710-Power-Strings-（poj2406）\"><a href=\"#例7-1-cogs1710-Power-Strings-（poj2406）\" class=\"headerlink\" title=\"例7           (1).cogs1710:Power Strings  （poj2406）\"></a>例7           (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1710\" target=\"_blank\" rel=\"external\">cogs1710:Power Strings</a>  （poj2406）</h2><p>本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。</p>\n<hr>\n<h2 id=\"例8-1-poj3693-Maximum-repetition-substring\"><a href=\"#例8-1-poj3693-Maximum-repetition-substring\" class=\"headerlink\" title=\"例8       (1).poj3693:Maximum repetition substring\"></a>例8       (1).<a href=\"http://poj.org/problem?id=3693\" target=\"_blank\" rel=\"external\">poj3693:Maximum repetition substring</a></h2><pre><code>  #include&lt;iostream&gt;\n  #include&lt;cstdio&gt;\n  #include&lt;cstring&gt;\n  using namespace std;\n  const int N = 1e5+1;\n  const int maxf = 255;\n  int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];\n  int k,now,jj,maxr,cnt;\n  int d[N][21],ans[N];\n  char s[N*2];\n  bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n\n  void da(int n,int m)\n  {\n      int i,j,p,*x=wa,*y=wb;\n      for(i=0;i&lt;m;++i)tong[i]=0;\n      for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n      for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n      for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n      for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n      {\n          for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n          for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n          for(i=0;i&lt;m;++i)tong[i]=0;\n          for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n          for(i=0;i&lt;n;++i)tong[wv[i]]++;\n          for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n          for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i)\n          x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n      }\n  }\n  void getheight(int n)\n  {\n      int i,j,k=0;\n      for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n      for(i=0;i&lt;n;h[rank[i++]]=k)\n      for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n  }\n  int prermq(int*a,int n)\n  {\n      for(int i=0;i&lt;n;++i)d[i][0]=a[i];\n      for(int j=1;(1&lt;&lt;j)&lt;=n;++j)\n      for(int i=0;i+(1&lt;&lt;j)-1&lt;n;++i)\n      d[i][j]=min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]);\n  }\n  int askrmq(int l,int r)\n  {\n      l=rank[l],r=rank[r];\n      if(l&gt;r)swap(l,r);\n      l++;\n      int k=0;\n      while((1&lt;&lt;(k+1))&lt;=r-l+1)k++;\n      return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]);\n  }\n  int main()\n  {\n      int ccase=0;\n      while(1)\n      {\n      memset(h,0,sizeof(h));\n      memset(d,0,sizeof(d));\n      memset(tong,0,sizeof(tong));\n      memset(rank,0,sizeof(rank));\n      memset(ans,0,sizeof(ans));\n      ccase++;\n\n      k=now=jj=maxr=cnt=0;\n      scanf(&quot;%s&quot;,s);\n      if(s[0]==&#39;#&#39;)return 0;\n      int n=strlen(s);\n      da(n+1,maxf);\n      getheight(n);\n      prermq(h,n+1);\n      for(int i=1;i&lt;n;++i) \n      for(int j=0;j+i&lt;n;j+=i) \n      {\n          k=askrmq(j,j+i);\n          now=k/i+1;\n          jj=j-(i-k%i);\n          if (jj&gt;=0&amp;&amp;askrmq(jj,jj+i)&gt;=(i-k%i))++now;\n          if(now&gt;maxr)    {cnt=0;maxr=now;ans[cnt++]=i;}\n          else if(now==maxr)  ans[cnt++]=i;\n      }\n          for(int i=1;i&lt;=n;++i) \n          for(int j=0;j&lt;cnt;++j)\n          if(askrmq(sa[i],sa[i]+ans[j])&gt;=(maxr-1)*ans[j])\n          {\n              jj=sa[i],k=ans[j];\n              goto dd;\n          }\n          dd:;\n          printf(&quot;Case %d: &quot;,ccase);\n          for (int i=0;i&lt;maxr*k;++i)putchar(s[jj++]);\n          printf(&quot;\\n&quot;);\n      }\n  }\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B8.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<h2 id=\"2-cogs1711-重复的字符串-（spoj687）\"><a href=\"#2-cogs1711-重复的字符串-（spoj687）\" class=\"headerlink\" title=\"(2).cogs1711:重复的字符串 （spoj687）\"></a>(2).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1711\" target=\"_blank\" rel=\"external\">cogs1711:重复的字符串</a> （spoj687）</h2><hr>\n<h2 id=\"例9-1-cogs1713-Long-Long-Message-（poj2774）\"><a href=\"#例9-1-cogs1713-Long-Long-Message-（poj2774）\" class=\"headerlink\" title=\"例9      (1).cogs1713:Long Long Message  （poj2774）\"></a>例9      (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1713\" target=\"_blank\" rel=\"external\">cogs1713:Long Long Message</a>  （poj2774）</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 3e5+1;\nconst int maxf = 255;\nconst int inf =0x7fffffff;\nint sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N];\nchar s[N],ss[N];\nbool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;m=p,j&lt;&lt;=1)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[wv[i]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n}\nvoid geth(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n}\nint main()\n{\n    freopen(&quot;longlongmessage.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;longlongmessage.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%s&quot;,s);\n    scanf(&quot;%s&quot;,ss);\n    int n=strlen(s),m=strlen(ss);\n    s[n]=&#39;*&#39;;\n    for(int i=n+1;i&lt;=n+m;++i)s[i]=ss[i-n-1];\n    int l=n+m+1;\n    da(l+1,maxf);\n    geth(l);\n    int maxx=0;\n    for(int i=2;i&lt;=l;++i)\n    {\n        if(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i-1]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i-1]&lt;n)))\n        maxx=h[i];\n    }\n    cout&lt;&lt;maxx;\n}\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B9.tag.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例10-1-cogs1712-Common-Substrings-（poj3415）\"><a href=\"#例10-1-cogs1712-Common-Substrings-（poj3415）\" class=\"headerlink\" title=\"例10    (1).cogs1712:Common Substrings  （poj3415）\"></a>例10    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1712\" target=\"_blank\" rel=\"external\">cogs1712:Common Substrings</a>  （poj3415）</h2><hr>\n<h2 id=\"例11-1-cogs2128-生命形态-（poj3294）\"><a href=\"#例11-1-cogs2128-生命形态-（poj3294）\" class=\"headerlink\" title=\"例11    (1).cogs2128:生命形态   （poj3294）\"></a>例11    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=2128\" target=\"_blank\" rel=\"external\">cogs2128:生命形态</a>   （poj3294）</h2><p>例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N = 2e5+1;\nconst int inf =0x7fffffff;\nconst int maxf = 255;\nbool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nint sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];\nchar ss[111][10001],s[N];\nint nn[111],tt;\nbool inq[111];\nint ll[N];\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(i=1,p=1,swap(x,y),x[sa[0]]=0;i&lt;n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n}\nvoid geth(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;h[rank[i++]]=k)\n    for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++);\n}\nint k;\nint ansg;\nbool can(int ans,int n,int flag)\n{\n    if(!flag)\n    {\n        int tot1=0;\n        memset(inq,0,sizeof(inq));\n        for(int i=1;i&lt;=n;++i)\n        {\n            if(h[i]&lt;ans)\n            {\n                memset(inq,0,sizeof(inq));  tot1=0;\n            }\n            else\n            {\n                int nowq,nowt;\n                for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t;\n                for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;\n                if(!inq[nowq])tot1++,inq[nowq]=true;\n                if(!inq[nowt])tot1++,inq[nowt]=true;\n                if(tot1&gt;=k)return 1;\n            }\n        }\n        return 0;\n    }\n    if(flag)\n    {\n      int lll=inf,rrr=-1;\n      int tot1=0;\n      memset(inq,0,sizeof(inq));\n      for(int i=1;i&lt;=n;++i)\n      {\n          if(h[i]&lt;ans)\n          {\n              memset(inq,0,sizeof(inq));  tot1=0;\n              lll=inf;rrr=-1;\n          }\n          else\n          {\n              int nowq,nowt;\n              if(sa[i-1]&lt;lll)lll=sa[i-1];if(sa[i-1]&gt;rrr)rrr=sa[i-1];\n              if(sa[i]&lt;lll)lll=sa[i];if(sa[i]&gt;rrr)rrr=sa[i];\n              for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t;\n              for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;\n              if(!inq[nowq])tot1++,inq[nowq]=true;\n              if(!inq[nowt])tot1++,inq[nowt]=true;\n              if(tot1==k)ll[++ansg]=lll;\n          }\n      }\n  }\n}\n  int main()\n  {\n  //  freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin);\n  //  freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout);\n      while(scanf(&quot;%d&quot;,&amp;tt)!=EOF)\n      {\n          if(!tt)return 0;\n          memset(wa,0,sizeof(wa));\n          memset(wb,0,sizeof(wb));\n          memset(wv,0,sizeof(wv));\n          memset(rank,0,sizeof(rank));\n          memset(sa,0,sizeof(sa));\n          memset(h,0,sizeof(h));\n          memset(nn,0,sizeof(nn));\n          memset(s,0,sizeof(s));\n          int tot=0;\n          int tmp=2;\n          ansg=0;\n          for(int i=1;i&lt;=tt;++i)\n          {\n              scanf(&quot;%s&quot;,ss[i]);\n              nn[i]=strlen(ss[i]);\n              nn[0]=-1;\n              for(int t=0;t&lt;nn[i];++t)s[tot++]=ss[i][t];\n              nn[i]+=nn[i-1]+(i==tt?0:1);\n              if(i!=tt)s[tot++]=tmp++;\n          }\n          nn[tt]++;\n          int n=strlen(s);\n          da(n+1,maxf);\n          geth(n);\n          k=(tt)/2+1;\n          int l=0,r=n+1,mid;\n          while(l!=r)\n          {\n              mid=(l+r+1)&gt;&gt;1;\n              if(can(mid,n,0))  l=mid;\n              else      r=mid-1;\n          }\n          if(l==0){printf(&quot;?&quot;);goto dd;}\n          can(l,n,1);\n          for(int i=1;i&lt;=ansg;++i)\n          {\n              if(i!=1)\n              {\n              bool flag=0;\n              for(int t=0;t&lt;l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;}\n              if(!flag)continue;\n              }\n              for(int t=ll[i];t&lt;=ll[i]+l-1;++t)putchar(s[t]);\n              printf(&quot;\\n&quot;);\n          }\n          dd:;\n      }\n  }\n</code></pre><p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B11.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例12-1-cogs2120-破译进攻计划-（spoj220）\"><a href=\"#例12-1-cogs2120-破译进攻计划-（spoj220）\" class=\"headerlink\" title=\"例12    (1).cogs2120:破译进攻计划   （spoj220）\"></a>例12    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=2120\" target=\"_blank\" rel=\"external\">cogs2120:破译进攻计划</a>   （spoj220）</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nconst int N = 2e5+500;\nconst int maxf = 255;\nint sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];\nchar s[N],ss[13][15031];\nint inq[13],maxq[13],minq[13];\nint tt,num;\nbool use[13];\nbool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\nvoid da(int n,int m)\n{\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;++i)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i;\n    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),x[sa[0]]=0,i=1,p=1;i&lt;n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n}\nvoid geth(int n)\n{\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n}\nbool can(int ans,int n)\n{\n    int tot=0;\n    for(int i=1;i&lt;=n;++i)\n    {\n        if(h[i]&lt;ans)\n        {\n            tot=0;\n            memset(inq,0,sizeof(inq));\n            memset(maxq,0,sizeof(maxq));\n            memset(minq,0x3f,sizeof(minq));\n            memset(use,0,sizeof(use));\n        }\n        else\n        {\n            for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t])\n            {\n                inq[t]++;\n                minq[t]=min(minq[t],sa[i]);\n                maxq[t]=max(maxq[t],sa[i]);\n                if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true;\n                if(tot==num)return 1;\n            }\n            for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])\n            {\n                inq[t]++;\n                minq[t]=min(minq[t],sa[i-1]);\n                maxq[t]=max(maxq[t],sa[i-1]);\n                if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true;\n                if(tot==num)return 1;\n            }\n        } \n    }\n    return 0;\n}\nint main()\n{\n//  freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin);\n//  freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout);\n    nn[0]=-1;\n    scanf(&quot;%d&quot;,&amp;tt);\n    while(tt--)\n    {\n        memset(inq,0,sizeof(inq));\n        memset(wa,0,sizeof(wa));\n        memset(wb,0,sizeof(wb));\n        memset(wv,0,sizeof(wv));\n        memset(sa,0,sizeof(sa));\n        memset(rank,0,sizeof(rank));\n        memset(h,0,sizeof(h));\n        scanf(&quot;%d&quot;,&amp;num);\n        int tot=0,qiguaizifu=2;\n        for(int i=1;i&lt;=num;++i)\n        {\n            scanf(&quot;%s&quot;,ss[i]);\n            nn[i]=strlen(ss[i]);\n        }\n        for(int i=1;i&lt;=num;++i)\n        {\n            for(int t=0;t&lt;nn[i];++t)\n            s[tot++]=ss[i][t];\n            s[tot++]=qiguaizifu++;\n        }\n        for(int i=1;i&lt;=num;++i)nn[i]+=(nn[i-1]+1);\n        int n=strlen(s);\n        da(n+1,maxf);\n        geth(n);\n        int l=0,r=(n+1)/2;\n        while(l!=r)\n        {\n            int mid=l+r+1&gt;&gt;1;\n            if(can(mid,n))  l=mid;\n            else      r=mid-1;\n        }\n        printf(&quot;%d\\n&quot;,l);\n    }\n}\n</code></pre><p><a href=\"https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B12.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例13-1-poj1226-Substrings\"><a href=\"#例13-1-poj1226-Substrings\" class=\"headerlink\" title=\"例13    (1).poj1226:Substrings\"></a>例13    (1).<a href=\"http://poj.org/problem?id=1226\" target=\"_blank\" rel=\"external\">poj1226:Substrings</a></h2><hr>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/08/后缀数组13题/","excerpt":"论文后缀数组——处理字符串的有力工具–罗穗骞","categories":[{"name":"Hollerith-type","slug":"Hollerith-type","permalink":"https://prostkhala.github.io/categories/Hollerith-type/"},{"name":"后缀数组","slug":"Hollerith-type/后缀数组","permalink":"https://prostkhala.github.io/categories/Hollerith-type/后缀数组/"}],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"https://prostkhala.github.io/tags/后缀数组/"}]},{"title":"C/C++代码规范","date":"2017-03-07T09:53:42.000Z","path":"2017/03/07/c++代码规范/","text":"命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C+ 命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C++ 12 静态变量的命名前缀 适用于C 13 自定义类型typedef的命名 适用于C++ 14 宏定义的命名 适用于C++ 15 C 函数的命名 适用于C++ 16 枚举的命名 适用于C++ 排版规则 1 布局和模板 11 类的布局模板 适用于C 12 源文件格式 适用于C 13 保护头文件不被重复包含 适用于C++ 14 方法和函数的布局 适用于C++ 2 缩进制表符以及空格 适用于C++ 3 尽量使一行不要超过78个字母 适用于C++ 4 保证一行只写一条语句 适用于C++ 5 花括号 规则 适用于C++ 51 花括号的位置 52 什么时候应使用花括号 53 在花括号结束的位置加上注释 54 注意屏幕大小 6圆括号 规则 适用于C++ 7if else 语句的格式 适用于C++ 8switch 格式 适用于C++ 9 使用gotocontinuebreak 和 适用于C++ 91 Goto 92 Continue and Break 93 10 运算符号的规则 适用于C++ 11 变量声明语句块 适用于C++ 文档及注释 1 文件或程序库的文档注释 适用于C++ 2 类文档注释 适用于C++ 3 函数文档注释 适用于C++ 4 Include 语句注释 适用于C++ 5语句块注释 适用于C++ 编码要求 1 不要忽略编译器的警告 适用于C++ 2 应使用源代码管理器 适用于C++ 3 固有的类方法成员 适用于C 4 使用命名空间 适用于C 5 初始化所有的变量 适用于C++ 6 保持函数短小精悍 适用于C++ 7对空语句进行注释 适用于C++ 8不要用if语句的默认方法测试非零值 适用于C++ 9布尔类型 适用于C++ 10避免在语句中内含赋值 适用于C++ 11正确的使用Const 适用于C++ 12不要在头文件定义数据适用于C++ 13不要直接使用数字 适用于C++ 14宏 适用于C++ 1. 命名规则1.1. 起个合适的名字1.1.1. 类的名称（适用于C++）² 类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。 ² 类的名字不需要告诉我们，它从哪个类继承而来的。 ² 有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。 1.1.2. 方法和函数的名称（适用于C/C++）² 方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。 ² 函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。 ² 可以加一些必要的后缀： Max – 表示取最大值 Cnt – 表示当前的计数值 Key – 表示键值 例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。 ² 前缀也同样有用： Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。 Get – 用于获取一个值。 Set – 用于设置一个值。 例如：IsHitRetryLimit. 1.1.3. 含有度量单位的名称（适用于C/C++）² 如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。 例如： uint32 mTimeoutMsecs; uint32 mMyWeightLbs; 1.1.4. 缩写名称不要全部大写（适用于C/C++）² 无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。 例如： class FluidOz; // 而不是 FluidOZ class NetworkAbcKey; // 而不是 NetworkABCKey 1.2.类的命名（适用于C++）² 用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。 ² 名字的第一个字母应大写 ² 不含有下划线 (‘_’) 例如： class NameOneTwo; class Name; 1.3.类库（或程序库）命名 （适用于C/C++）² 使用命名空间防止名字冲突。 ² 如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。 例如： John Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样： class JjLinkList { } 1.4.方法和函数的命名（适用于C++）² 使用与类名相同的规则 例如： class NameOneTwo { public: int DoIt(); void HandleError(); } 1.5.类属性的命名（适用于C++）² 属性（通常是非公有数据成员）名字以字母’m’开头。 ² 在 ‘m(m_)’ 后面，使用与类名相同的规则。 ² ‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。 例如： class NameOneTwo { public: int VarAbc(); int ErrorNumber(); private: int mVarAbc; int mErrorNumber; String* mpName; } 1.6.方法和函数参数的命名（适用于C++）² 第一个字母必须小写。 ² 第一个字母后面的单词使用与类名相同的规则。 例如： class NameOneTwo { public: int StartYourEngines( Engine&amp;rSomeEngine, Engine&amp;rAnotherEngine); } 1.7.局部变量的命名（适用于C/C++）² 所有字母都用小写 ² 使用下划线 ‘_’ 作为单词的分隔。 例如： int NameOneTwo::HandleError(int errorNumber) { int error= OsErr(); Time time_of_error; ErrorProcessor error_processor; } 1.8.指针变量的命名前缀（适用于C/C++）² 指针变量多数情况应在前面加 ‘p’。 ² 星号 ‘*’ 应靠近类型，而不是变量名。 例如： String* pName=new String; 特别的：String* pName, name; 应分成两行来写： String* pName; String name; 1.9.引用变量和返回引用函数的命名前缀（适用于C++）² 引用必须用 ‘r’作前缀修饰。 例如： class Test { public: void DoSomething(StatusInfo&amp;rStatus); StatusInfo&amp; rStatus(); constStatusInfo&amp; Status() const; // 这里返回的是常量引用，所以不符合本规则 private: StatusInfo&amp; mrStatus; } 1.10. 全局变量的命名前缀（适用于C/C++）² 全局变量总是以 ‘g(g_)’ 作为前缀。 例如： Logger g_Log; Logger* g_pLog; 1.11. 全局常量的命名（适用于C/C++）² 全局常量全部大写，并以下划线 ‘_’ 分隔单词。 例如： const intA_GLOBAL_CONSTANT = 5; 1.12. 静态变量的命名前缀（适用于C++）² 静态变量以 ‘s’ 作为前缀。 例如： class Test { public: private: staticStatusInfo m_sStatus; } 1.13. 自定义类型（typedef）的命名（适用于C/C++）² 类型定义名称指的是用typedef定义的名称。 ² 类型定义名称使用与类名相同的规则，并使用Type作为后缀。 例如： typedefuint16 ModuleType; typedefuint32 SystemType; 1.14. 宏定义的命名（适用于C/C++）² 所有单词的字母都用大写，并使用下划线 ‘_’ 分隔. 例如： #define MAX(a,b) blah #define IS_ERR(err) blah 1.15. C 函数的命名（适用于C/C++）² C++项目中，应尽量少用C函数。 ² C函数使用GNU规范，所有字母都使用小写，并用下划线 ‘_’ 作为单词的分隔。 例如： int some_bloody_function() { } ² 特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数： extern “C” int some_bloody_function(); ² 或在C/C++中推荐使用下面的格式： #ifdef__cplusplus__ extern “C”{ #endif int some_bloody_function() { } #ifdef__cplusplus__ } #endif 1.16. 枚举的命名（适用于C/C++）² 所有字母都大写，并用下划线 ‘_’ 作为单词分隔。 例如： enumPinStateType { PIN_OFF, PIN_ON }; enum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING}; 2. 排版规则2.1. 布局和模板2.1.1. 类的布局模板 （适用于C++）² 请使用下面的模板来创建一个新的类： /** * 用一行来描述类 * *#include &quot;XX.h&quot; &lt;BR&gt; *-llib * * 类的详细说明 * * @seesomething */ #ifndef SORUTION_PROJECT_CLASSNAME_H #define SORUTION_PROJECT_CLASSNAME_H // 在这里包含系统头文件 // // 在这里包含项目头文件 // // 在这里包含局部头文件 // // 在这里放置前置引用 // class XX { public: // 类的生命周期控制函数，如构造和析构，以及状态机 /** *Default constructor. */ XX(void); /** *Copy constructor. * *@param from The value to copy to this object. */ XX(const XX&amp; from); /** *Destructor. */ virtual ~XX(void); // 在这里放置类的运算操作符 /** *Assignment operator. * *@param from THe value to assign to this object. * *@return A reference to this object. */ XX&amp; operator=(XX&amp;from); // 在这里放置类的操作 // 在这里放置属性存取 // 在这里放置类的状态查询 protected: private: }; // 内联方法定义 // // 外部引用 // #endif // SORUTION_PROJECT_CLASSNAME_H ² 定义的顺序是: public, protected, private ² 要清楚public/protected/private都应该放置哪些东西 2.1.2. 源文件格式（适用于C++） #include &quot;XX.h&quot; // class implemented /////////////// PUBLIC/////////////////////// //================= 构造函数 ==================== XX::XX() { }// XX XX::XX(const XX&amp;) { }// XX XX::~XX() { }// ~XX //=============== 操作符========================= XX&amp; XX::operator=(XX&amp;); { return *this; }// = //==============类的操作 ===================== //==============属性存取 ===================== //==============状态查询 ===================== ///////////// PROTECTED ////////////////// ///////////// PRIVATE ////////////////// 2.1.3. 保护头文件不被重复包含 （适用于C/C++）² 应使用宏定义来保护头文件不被重复包含： #ifndef SORUTION_PROJECT_CLASSNAME_H #define SORUTION_PROJECT_CLASSNAME_H #endif // SORUTION_PROJECT_CLASSNAME_H ² 如果使用命名空间的时候，要把命名空间加到文件名前面： #ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H #define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H #endif 2.1.4. 方法和函数的布局 （适用于C/C++）² 对于有较多参数的函数的写法 如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐： int AnyMethod( int arg1, int arg2, int arg3, int arg4); 或 int AnyMethod( int arg1 , int arg2 , int arg3 , int arg4); 2.2. 缩进、制表符以及空格 （适用于C/C++）² 缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格） ² 不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。 ² 虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。 例如： void func() { if (something bad) { if (another thing bad) { while (more input) { } } } } 2.3. 尽量使一行不要超过78个字母 （适用于C/C++）² 有许多编辑器屏幕只有78个字母宽 2.4. 保证一行只写一条语句 （适用于C/C++）² 一行最多只写一条语句 ² 一行只定义一个变量 例如： 不要象下面这样: char** a, *x; int width, height; //widthand height of image 要象这样: char** a= 0; // 文档说明 char* x= 0; // 文档说明 2.5. 花括号 {} 规则 （适用于C/C++） 2.5.1. 花括号的位置 ² 在关键字的下一行单独放置括号，并且与关键字对齐，如： if (condition) { ... } while (condition) { … } 2.5.2. 什么时候应使用花括号所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。 ² 使用花括号格式： if (1 == somevalue) { somevalue = 2; } ² 单行格式： if (1 == somevalue) somevalue = 2; 或下面这样（对于这种写法，建议使用花括号）： if (1 == somevalue) { somevalue = 2; } 2.5.3. 在花括号结束的位置加上注释² 在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如： while(1) { if (valid) { } // if valid else { } // not valid } // end forever 2.5.4. 注意屏幕大小² 一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。 2.6.圆括号 () 规则 （适用于C/C++）² 圆括号与关键字之间应放一个空格。 ² 圆括号与函数名之间不要有空格。 ² Return 语句不要使用圆括号。 例如： if (condition) { } while(condition) { } strcpy(s, s1); return 1; 2.7.if else 语句的格式 （适用于C/C++）² 布局 if (条件) // 注释 { } else if (条件) // 注释 { } else // 注释 { } ² 条件格式 总是把常量放在等号或不等于号的左边： if ( 6 == errorNum ) ... 一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。 比如： if ( errorNum == 6) ... 错写成： if ( errorNum = 6) ... // 这是一个不容易发现的灾难 2.8.switch 格式 （适用于C/C++）² 直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。 ² 总是要写default语句，不管是否是需要。 ² 在case中需要定义变量的时候，应把所有代码放在语句块中。 例如： switch (...) { case 1: ... // 继续执行case2 case 2: { int v; ... } break; default: } 2.9. 使用goto,continue,break 和 ?: （适用于C/C++）2.9.1. Goto² 尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如： for (...) { while (...) { ... if (disaster) goto error; //跳出循环 } } ... error: clean up the mess ² 跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。 2.9.2. Continue and Break² Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。 2.9.3. ?:² 用括号把条件表达式括起来。 ² 不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。 ² 操作语句应分行写，除非它们能够简洁的放在一行当中。 例如： (condition) ?funct1() : func2(); 或 (condition) ? longstatement : anotherlong statement; 2.10. 运算符号的规则 （适用于C/C++）² 一元操作符如（!、~ 等等）应贴近操作对象。如： if (!IsOk) return ++v; ² 二元操作符如（+、*、%、== 等等）应在前后留空格。如： if ( v1 == v2) return v1 * 3; ² ++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。如： for(int i = 0; i &lt; 10; ++i) 2.11. 变量声明语句块 （适用于C/C++）² 变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。如： for(int i = 0; i &lt; 10; ++i) ² 声明语句块必须要对齐 类型，变量，等号和初始化值要分别对齐。 例如： DWORD mDword; DWORD* mpDword; char* mpChar; char mChar; mDword = 0; mpDword = NULL; mpChar = NULL; mChar = 0; 3. 文档及注释应当使用文档自动生成工具，来生成相关的程序文档。 3.1. 文件或程序库的文档注释（适用于C/C++）可以为整个文件编写文档。 例如： /** @file file.h * Abrief file description. * Amore elaborated file description. */ 3.2. 类文档注释（适用于C/C++）在类定义前面应加上类说明文档。 例如： /** WindowsNT * @brief Windows Nice Try. * @author Bill Gates * @author Several species of small furryanimals gathered together * in a cave and grooving with a pict. * @version 4.0 * @date 1996-1998 * @bug It crashes a lot and requires hugeamounts of memory. * @bug The class introduces the more bugs, thelonger it is used. * @warning This class may explode in your face. * @warning If you inherit anything from thisclass, you&#39;re doomed. */ class WindowsNT {}; 3.3. 函数文档注释（适用于C/C++）² 函数注释 所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如： /** * 赋值操作符 * *@param val 将要赋给本对象的值 * *@return 本对象的引用 */ XX&amp; operator =(XX&amp; val); ² 注释属性 一些自动文档工具定义的属性可以包含在文档中，常用的有： n 前提条件 (pre)定义调用这个函数的前提条件 n 警告说明 (warning)定义一些关于这个函数必须知道的事情。 n 备注说明 (remarks)定义一些关于这个函数的备注信息。 n 将要完成的工作 (todo)说明哪些事情将在不久以后完成 n 使用例子说明 (example)一个图片能表达100句话，一个好的例子能解答1000个问题。 例如： /** * 复制一个字串 * *@pre * - 需要保证(from != 0) * - 需要保证(to != 0) * *@warning * 缓冲区必需足够大，以便容纳的下要拷贝的字串。 * *@example teststrcpy.cpp * *@param from 要拷贝的字串 *@param to 用于容纳字串的缓冲区 *@return void */ void strcpy(constchar* from, char* to); 3.4. Include 语句注释 （适用于C/C++）² 如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。 3.5.语句块注释（适用于C/C++）² 语句块的注释可以用在语句块的开头和结束位置： { // Block1 (meaningful comment about Block1) ... some code { // Block2 (meaningful comment about Block2) ... somecode } // End Block2 } // End Block1 4. 编码要求4.1. 不要忽略编译器的警告（适用于C/C++）² 编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。 4.2. 应使用源代码管理器（适用于C/C++）² 根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。 4.3. 固有的类方法成员（适用于C++）² 默认构造函数(DefaultConstructor) 如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。 ² 虚析构函数(Virtual Destructor) 如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。 ² 拷贝构造函数(Copy Constructor) 如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。 ² 赋值操作(AssignmentOperator) 如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。 4.4. 使用命名空间 （适用于C++）² 命名规则 根名字一般是设计者的名字。比如公司名称等等。 ² 不要在全局空间使用using语句。 4.5. 初始化所有的变量 （适用于C/C++）² 无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。 4.6. 保持函数短小精悍（适用于C/C++）² 一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。 4.7.对空语句进行注释 （适用于C/C++）² For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如： while(*dest++ = *srC++) ; // VOID ² 不允许写成： while (*dest++ = *srC++) ; // 绝对不允许这么写 4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）² If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如： 建议使用： if (FAIL != f()) 不建议使用下面的表达式： if (f()) ² 宏定义的情况也一样： #define STREQ(a,b) (strcmp((a), (b)) == 0) 或者使用内联函数： inline bool StringEqual(char* a, char* b) { (strcmp(a, b)== 0) ? return true : return false; Or more compactly: returnstrcmp(a, b) == 0; } 4.9.布尔类型 （适用于C/C++）² 早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。 早期的布尔类型定义为： typedef int bool; #defineTRUE 1 #defineFALSE 0 或： const intTRUE = 1; const int FALSE= 0; ² 在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如： if (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？ 必须写成： if (FALSE !=func()) { ... 4.10. 避免在语句中内含赋值 （适用于C/C++）² 只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如： while (EOF != (c= getchar())) { process thecharacter } ² ++ 和 – 操作也是一种赋值语句 ² 内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如： a = b + c; d = a + r; 不应该写成： d = (a = b + c)+ r; 4.11. 正确的使用Const （适用于C/C++）² C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。 4.12. 不要在头文件定义数据（适用于C/C++）不要把数据定义放在头文件，如： /* * aheader.h */ int x = 0; 4.13. 不要直接使用数字 （适用于C/C++）² 直接使用数字，会使源代码难以理解和维护。如： if (22 ==foo) { start_thermo_nuclear_war(); } else if (19 == foo) {refund_lotso_money(); } else if (16 == foo) {infinite_loop(); } else { cry_cause_im_lost(); } 当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。 ² 我们可以用#define或者常量来改变这一状况，如： #define PRESIDENT_WENT_CRAZY (22) const int WE_GOOFED= 19; enum { THEY_DIDNT_PAY=16 }; if (PRESIDENT_WENT_CRAZY == foo) { start_thermo_nuclear_war(); } else if (WE_GOOFED == foo) {refund_lotso_money(); } else if (THEY_DIDNT_PAY == foo) { infinite_loop();} else {happy_days_i_know_why_im_here(); } 4.14. 宏（适用于C/C++）² 如果可以，使用内联函数代替宏。 例如： #ifndef MAX #define MAX(x,y) (((x) &gt; (y) ? (x) : (y)) // 取最大数 #endif 使用内联函数可以达到相同的效果，而且更安全： inline int max(int x, inty) { return (x&gt; y ? x : y); } ² 要注意副作用 必须小心副作用，因为在调用表达式时，会发生潜在的错误。 例如： MAX(f(x),z++); ² 表达式总是用括号括起来 在宏展开时，使用括号可以避免宏展开后产生的二义性。 例如： #define ADD(x,y) x + y 必须写成： #define ADD(x,y) ((x) + (y)) ² 保证宏名称的唯一性 和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题： n 在宏名称前加上库的名字避免使用简单而常用的名字，如：MAX 和MIN。","raw":"title: C/C++代码规范\ndate: 2017-03-07 17:53:42\ncategories:\n  - 代码规范\ntags:\n  - 代码规范\n---\n\n        命名规则\n        1 起个合适的名字\n            11    类的名称 适用于C\n            12    方法和函数的名称 适用于C++\n            13   含有度量单位的名称 适用于C++\n            14    缩写名称不要全部大写 适用于C++\n        2类的命名 适用于C\n        3类库或程序库命名 适用于C++\n        4方法和函数的命名 适用于C\n        5类属性的命名 适用于C\n        6方法和函数参数的命名 适用于C\n        7局部变量的命名 适用于C++\n        8指针变量的命名前缀 适用于C++\n        9引用变量和返回引用函数的命名前缀 适用于C\n        10   全局变量的命名前缀 适用于C++\n        11   全局常量的命名 适用于C+\n        命名规则\n        1 起个合适的名字\n            11    类的名称 适用于C\n            12    方法和函数的名称 适用于C++\n            13   含有度量单位的名称 适用于C++\n            14    缩写名称不要全部大写 适用于C++\n        2类的命名 适用于C\n        3类库或程序库命名 适用于C++\n        4方法和函数的命名 适用于C\n        5类属性的命名 适用于C\n        6方法和函数参数的命名 适用于C\n        7局部变量的命名 适用于C++\n        8指针变量的命名前缀 适用于C++\n        9引用变量和返回引用函数的命名前缀 适用于C\n        10   全局变量的命名前缀 适用于C++\n        11   全局常量的命名 适用于C++\n        12   静态变量的命名前缀 适用于C\n        13   自定义类型typedef的命名 适用于C++\n        14   宏定义的命名 适用于C++\n        15   C 函数的命名 适用于C++\n        16   枚举的命名 适用于C++\n        排版规则\n        1 布局和模板\n            11    类的布局模板 适用于C\n            12   源文件格式 适用于C\n            13    保护头文件不被重复包含 适用于C++\n            14    方法和函数的布局 适用于C++\n        2 缩进制表符以及空格 适用于C++\n        3 尽量使一行不要超过78个字母 适用于C++\n        4 保证一行只写一条语句 适用于C++\n        5 花括号 规则 适用于C++\n            51    花括号的位置\n            52    什么时候应使用花括号\n            53    在花括号结束的位置加上注释\n            54    注意屏幕大小 \n        6圆括号 规则 适用于C++\n        7if else 语句的格式 适用于C++\n        8switch 格式 适用于C++\n        9 使用gotocontinuebreak 和 适用于C++\n            91    Goto\n            92    Continue and Break\n            93    \n        10   运算符号的规则 适用于C++\n        11    变量声明语句块 适用于C++\n        文档及注释\n        1 文件或程序库的文档注释 适用于C++\n        2 类文档注释 适用于C++\n        3 函数文档注释 适用于C++\n        4 Include 语句注释 适用于C++\n        5语句块注释 适用于C++\n        编码要求\n        1 不要忽略编译器的警告 适用于C++\n        2 应使用源代码管理器 适用于C++\n        3 固有的类方法成员 适用于C\n        4 使用命名空间 适用于C\n        5 初始化所有的变量 适用于C++\n        6 保持函数短小精悍 适用于C++\n        7对空语句进行注释 适用于C++\n        8不要用if语句的默认方法测试非零值 适用于C++\n        9布尔类型 适用于C++\n        10避免在语句中内含赋值 适用于C++\n        11正确的使用Const 适用于C++\n        12不要在头文件定义数据适用于C++\n        13不要直接使用数字 适用于C++\n        14宏 适用于C++\n        \n <!--more--> \n \n# 1.    命名规则\n## 1.1. 起个合适的名字\n### 1.1.1.    类的名称（适用于C++）\n\n²  类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。\n\n²  类的名字不需要告诉我们，它从哪个类继承而来的。\n\n²  有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。\n### 1.1.2.    方法和函数的名称（适用于C/C++）\n\n²  方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。\n\n²  函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。\n\n²  可以加一些必要的后缀：\n\nMax – 表示取最大值\n\nCnt – 表示当前的计数值\n\nKey – 表示键值\n\n例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。\n\n²  前缀也同样有用：\n\nIs – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。\n\nGet – 用于获取一个值。\n\nSet – 用于设置一个值。\n\n例如：IsHitRetryLimit.\n### 1.1.3.   含有度量单位的名称（适用于C/C++）\n\n²  如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。\n\n例如：\n\n\tuint32 mTimeoutMsecs;\n\n\tuint32 mMyWeightLbs;\n### 1.1.4.    缩写名称不要全部大写（适用于C/C++）\n\n²  无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。\n\n例如：\n\n\tclass FluidOz;            // 而不是 FluidOZ\n\n\tclass NetworkAbcKey;      // 而不是 NetworkABCKey\n## 1.2.类的命名（适用于C++）\n\n²  用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。\n\n²  名字的第一个字母应大写\n\n²  不含有下划线 ('_')\n\n例如：\n\n   \tclass NameOneTwo; \n\n   \tclass Name;\n## 1.3.类库（或程序库）命名 （适用于C/C++）\n\n²  使用命名空间防止名字冲突。\n\n²  如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。\n\n例如：\n\nJohn Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样：\n\n   \tclass JjLinkList\n\n   \t{\n\n   \t}\n## 1.4.方法和函数的命名（适用于C++）\n\n²  使用与类名相同的规则\n\n例如：\n\n   \tclass NameOneTwo\n\n   \t{\n\n   \t\tpublic:\n\n      int     DoIt();\n\n      void    HandleError();\n\n   \t}\n   \n## 1.5.类属性的命名（适用于C++）\n\n²  属性（通常是非公有数据成员）名字以字母'm'开头。\n\n²  在 'm(m_)'  后面，使用与类名相同的规则。\n\n²  'm(m_)' 总是位于其它修饰符（如表示指针的 'p'）的前面。\n\n例如：\n\n       class NameOneTwo\n\n       {\n\n       public:\n\n          int     VarAbc();\n\n          int     ErrorNumber();\n\n       private:\n\n          int          mVarAbc;\n\n          int          mErrorNumber;\n\n          String*      mpName;\n\n       }\n## 1.6.方法和函数参数的命名（适用于C++）\n\n²  第一个字母必须小写。\n\n²  第一个字母后面的单词使用与类名相同的规则。\n\n例如：\n\n       class NameOneTwo\n\n       {\n\n       public:\n\n      int     StartYourEngines(\n\n                               Engine&rSomeEngine,\n\n                              Engine&rAnotherEngine);\n\n   \t}\n## 1.7.局部变量的命名（适用于C/C++）\n\n²  所有字母都用小写\n\n²  使用下划线 '_' 作为单词的分隔。\n\n例如：\n\n       int\n\n      NameOneTwo::HandleError(int errorNumber)\n\n       {\n\n      int            error= OsErr();\n\n      Time           time_of_error;\n\n     ErrorProcessor error_processor;\n\n   }\n## 1.8.指针变量的命名前缀（适用于C/C++）\n\n²  指针变量多数情况应在前面加 'p'。\n\n²  星号 '*' 应靠近类型，而不是变量名。\n\n例如：\n\n  \tString* pName=new String;\n\n \n\n  特别的：String* pName, name; 应分成两行来写：\n\n  \tString* pName;\n\n  \tString  name;\n## 1.9.引用变量和返回引用函数的命名前缀（适用于C++）\n\n²  引用必须用 'r'作前缀修饰。\n\n例如：\n\n   \tclass Test\n\n   \t{\n\n   \tpublic:\n\n      void               DoSomething(StatusInfo&rStatus);\n\n \n\n     StatusInfo&        rStatus();\n\n      constStatusInfo&  Status() const; // 这里返回的是常量引用，所以不符合本规则\n\n \n\n   \tprivate:\n\n     \tStatusInfo&        mrStatus;\n\n   \t}\n## 1.10.   全局变量的命名前缀（适用于C/C++）\n\n²  全局变量总是以 'g(g_)' 作为前缀。\n\n例如：\n\n    Logger g_Log;\n\n    Logger* g_pLog;\n## 1.11.   全局常量的命名（适用于C/C++）\n\n²  全局常量全部大写，并以下划线 '_' 分隔单词。\n\n例如：\n\n    const intA_GLOBAL_CONSTANT = 5;\n## 1.12.   静态变量的命名前缀（适用于C++）\n\n²  静态变量以 's' 作为前缀。\n\n例如：\n\n       class Test\n\n       {\n\n       public:\n\n       private:\n\n          staticStatusInfo m_sStatus;\n\n       }\n## 1.13.   自定义类型（typedef）的命名（适用于C/C++）\n\n²  类型定义名称指的是用typedef定义的名称。\n\n²  类型定义名称使用与类名相同的规则，并使用Type作为后缀。\n\n例如：\n\n       typedefuint16  ModuleType;\n\n       typedefuint32  SystemType;\n## 1.14.   宏定义的命名（适用于C/C++）\n\n²  所有单词的字母都用大写，并使用下划线 '_' 分隔.\n\n例如：\n\n\t#define MAX(a,b) blah\n\n\t#define IS_ERR(err) blah\n## 1.15.   C 函数的命名（适用于C/C++）\n\n²  C++项目中，应尽量少用C函数。\n\n²  C函数使用GNU规范，所有字母都使用小写，并用下划线 '_' 作为单词的分隔。\n\n例如：\n\n   \tint\n\n  \tsome_bloody_function()\n\n   \t{\n\n   \t}\n\n²  特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：\n\n       extern “C” int some_bloody_function();\n\n²  或在C/C++中推荐使用下面的格式：\n\n       #ifdef__cplusplus__\n\n       extern “C”{\n\n       #endif\n\n       int\n\n      some_bloody_function()\n\n       {\n\n       }\n\n       #ifdef__cplusplus__\n\n       }\n\n       #endif\n## 1.16.   枚举的命名（适用于C/C++）\n\n²  所有字母都大写，并用下划线 '_' 作为单词分隔。\n\n例如：\n\n   \tenumPinStateType\n\n   \t{\n\n      \tPIN_OFF,\n\n      \tPIN_ON\n\n   \t};\n\n\tenum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING};\n# 2.    排版规则\n## 2.1. 布局和模板\n### 2.1.1.    类的布局模板 （适用于C++）\n\n²  请使用下面的模板来创建一个新的类：\n\n\t/**     \n\n \t* 用一行来描述类\n\n \t*\n\n \t*#include \"XX.h\" <BR>\n\n \t*-llib\n\n \t*\n\n \t* 类的详细说明\n\n \t* \n\n \t* @seesomething\n\n \t*/\n\n \n\n\t#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n\t#define SORUTION_PROJECT_CLASSNAME_H\n\n \n\n\t// 在这里包含系统头文件\n\n\t//\n\n \n\n\t// 在这里包含项目头文件\n\n\t//\n\n \n\n\t// 在这里包含局部头文件\n\n\t//\n\n \n\n\t// 在这里放置前置引用\n\n\t//\n\n \n\n \n\n\t\tclass XX\n\n\t\t{\n\n\t\tpublic:\n\n    \t// 类的生命周期控制函数，如构造和析构，以及状态机\n\n \n\n    \t\t/**\n\n    \t\t*Default constructor.\n\n    \t\t*/\n\n    \t\tXX(void);\n\n \n\n    \t\t/**\n\n    \t\t*Copy constructor.\n\n    \t\t*\n\n    \t\t*@param from The value to copy to this object.\n\n    \t\t*/\n\n    \t\tXX(const XX& from);\n\n \n\n    \t\t/**\n\n    \t\t*Destructor.\n\n    \t\t*/\n\n\t\t    virtual ~XX(void);\n\n\t\t \n\n\t\t    // 在这里放置类的运算操作符\n\n\t\t \n\n\t\t    /**\n\n\t\t    *Assignment operator.\n\n\t\t    *\n\n\t\t    *@param from THe value to assign to this object.\n\n\t\t    *\n\n\t\t    *@return A reference to this object.\n\n\t\t    */\n\n\t\t    XX&                     operator=(XX&from); \n\n\t\t \n\n\t\t    // 在这里放置类的操作                      \n\n\t\t    // 在这里放置属性存取\n\n\t\t    // 在这里放置类的状态查询\n\n\t\t \n\n\t\t\tprotected:\n\n\t\t\tprivate:\n\n\t\t\t};\n\n \n\n\t\t// 内联方法定义\n\n\t\t//\n\n\t\t \n\n\t\t// 外部引用\n\n\t\t//\n\n\t\t \n\n\t\t#endif  // SORUTION_PROJECT_CLASSNAME_H\n\n \n\n²  定义的顺序是: public, protected, private\n\n²  要清楚public/protected/private都应该放置哪些东西\n### 2.1.2.   源文件格式（适用于C++）\n\n\t\t#include \"XX.h\"                               // class implemented\n\n \n\n \n\n/////////////// PUBLIC///////////////////////\n\n \n\n//================= 构造函数 ====================\n\n \n\n\t\tXX::XX()\n\n\t\t{\n\n\t\t}// XX\n\n\t\t \n\n\t\tXX::XX(const XX&)\n\n\t\t{\n\n\t\t}// XX\n\n\t\t \n\n\t\tXX::~XX()\n\n\t\t{\n\n\t\t}// ~XX\n\n\t\t \n\n \n\n//=============== 操作符=========================\n\n \n\n\t\tXX&\n\n\t\tXX::operator=(XX&);\n\n\t\t{\n\n\t\t   return *this;\n\n\t\t \n\n\t\t}// =\n\n\t\t \n\n//==============类的操作 =====================\n\n//==============属性存取 =====================\n\n//==============状态查询   =====================\n\n///////////// PROTECTED  //////////////////\n\n \n\n///////////// PRIVATE    //////////////////\n### 2.1.3.    保护头文件不被重复包含 （适用于C/C++）\n\n²  应使用宏定义来保护头文件不被重复包含：\n\n\t\t#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n\t\t#define SORUTION_PROJECT_CLASSNAME_H\n\n\t\t \n\n\t\t#endif // SORUTION_PROJECT_CLASSNAME_H\n\n \n\n \n\n²  如果使用命名空间的时候，要把命名空间加到文件名前面：\n\n\t\t#ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n\t\t#define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n \n\n#endif\n### 2.1.4.    方法和函数的布局 （适用于C/C++）\n\n²  对于有较多参数的函数的写法\n\n如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：\n\n\t\t   int AnyMethod(\n\n\t\t                 int  arg1, \n\n\t\t                 int   arg2,\n\n\t\t                 int   arg3,\n\n\t\t                 int   arg4); \n或\n\n\t\tint AnyMethod( int   arg1 \n\n\t\t               , int   arg2\n\n\t\t               , int   arg3\n\n\t\t               , int   arg4);\n\n \n## 2.2. 缩进、制表符以及空格 （适用于C/C++）\n\n²  缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格）\n\n²  不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。\n\n²  虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。\n\n例如：\n\n\t\t   void\n\n\t\t   func()\n\n\t\t   {\n\n\t\t      if (something bad)\n\n\t\t      {\n\n\t\t          if (another thing bad)\n\n\t\t          {\n\n\t\t              while (more input)\n\n\t\t              {\n\n\t\t              }\n\n\t\t          }\n\n\t\t      }\n\n\t\t   }\n## 2.3. 尽量使一行不要超过78个字母 （适用于C/C++）\n\n²  有许多编辑器屏幕只有78个字母宽\n## 2.4. 保证一行只写一条语句 （适用于C/C++）\n\n²  一行最多只写一条语句\n\n²  一行只定义一个变量\n\n例如：\n\n不要象下面这样:\n\n\t\tchar** a, *x;\n\n\t\t \n\n\t\tint width, height; //widthand height of image\n\n \n\n要象这样:\n\n\t\tchar** a= 0;  // 文档说明\n\n\t\tchar*  x= 0;  // 文档说明\n\t\t2.5. 花括号 {} 规则 （适用于C/C++）\n\t\t2.5.1.    花括号的位置\n\n²  在关键字的下一行单独放置括号，并且与关键字对齐，如：\n\n\t\tif (condition)       \n\n\t\t{\n\n\t\t    ...\n\n\t\t}\n\n\t\twhile (condition)\n\n\t\t{\n\n\t\t    …\n\n\t\t}\n### 2.5.2.    什么时候应使用花括号\n\n所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。\n\n²  使用花括号格式：\n\n\t\tif (1 == somevalue)\n\n\t\t{\n\n\t\t   somevalue = 2;\n\n\t\t}\n\n\t\t²  单行格式：\n\n\t\tif (1 == somevalue) somevalue = 2;\n\n\t\t或下面这样（对于这种写法，建议使用花括号）：\n\n\t\tif (1 == somevalue)\n\n\t\t{\n\t\tsomevalue = 2;\n\n\t\t}\n### 2.5.3.    在花括号结束的位置加上注释\n\n²  在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如：\n\n\t\twhile(1)\n\n\t\t{\n\n\t\t   if (valid)\n\n\t\t   {\n\n\t\t \n\n\t\t   } // if valid\n\n\t\t   else\n\n\t\t   {\n\n\t\t   } // not valid\n\n \n\n\t\t} // end forever\n### 2.5.4.    注意屏幕大小\n\n²  一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。\n## 2.6.圆括号 () 规则 （适用于C/C++）\n\n²  圆括号与关键字之间应放一个空格。\n\n²  圆括号与函数名之间不要有空格。\n\n²  Return 语句不要使用圆括号。\n\n例如：\n\n\t    if (condition)\n\n\t    {\n\n\t    }\n\n\t \n\n\t    while(condition)\n\n\t    {\n\n\t    }\n\n\t \n\n\t    strcpy(s, s1);\n\n \n\n    \treturn 1;\n## 2.7.if else 语句的格式 （适用于C/C++）\n\n²  布局\n\n\t\t   if (条件)               // 注释\n\n\t\t   {\n\n\t\t   }\n\n\t\t   else if (条件)           // 注释\n\n\t\t   {\n\n\t\t   }\n\n\t\t   else                   // 注释\n\n\t\t   {\n\n\t\t   }\n\n²  条件格式\n\n总是把常量放在等号或不等于号的左边：\n\n\t\tif ( 6 == errorNum ) ...\n\n一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。\n\n比如：\n\n\t\tif ( errorNum == 6) ...\n\n错写成：\n\n\t\tif ( errorNum = 6) ... // 这是一个不容易发现的灾难\n\n \n## 2.8.switch 格式 （适用于C/C++）\n\n²  直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。\n\n²  总是要写default语句，不管是否是需要。\n\n²  在case中需要定义变量的时候，应把所有代码放在语句块中。\n\n例如：\n\n\t\tswitch (...)\n\n\t\t{\n\n\t\tcase 1:\n\n\t\t    ...\n\n\t\t        // 继续执行case2\n\n\t\t \n\n\t\tcase 2:\n\n\t\t    {       \n\n\t\t        int v;\n\n\t\t        ...\n\n\t\t    }\n\n\t\t    break;\n\n\t\t \n\n\t\tdefault:\n\n\t\t}\n## 2.9. 使用goto,continue,break 和 ?: （适用于C/C++）\n### 2.9.1.    Goto\n\n²  尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如：\n\n\t\tfor (...)\n\n\t\t{\n\n\t\t    while (...)\n\n\t\t    {\n\n\t\t        ...\n\n\t\t            if (disaster)\n\n\t\tgoto error; //跳出循环\n\n\t\t    }\n\n\t\t}\n\n\t\t...\n\n\t\terror:\n\n\t\tclean up the mess\n\n²  跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。\n### 2.9.2.    Continue and Break\n\n²  Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。\n### 2.9.3.    ?:\n\n²  用括号把条件表达式括起来。\n\n²  不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。\n\n²  操作语句应分行写，除非它们能够简洁的放在一行当中。\n\n例如：\n\n   \t\t(condition) ?funct1() : func2();\n\n   或\n\n   \t\t(condition)\n\n     \t\t ? longstatement\n\n      \t\t: anotherlong statement;\n## 2.10.   运算符号的规则 （适用于C/C++）\n\n²  一元操作符如（!、~ 等等）应贴近操作对象。\n如：\n\n\t\tif (!IsOk)\n\n\t\t\treturn ++v;\n\n²  二元操作符如（+、*、%、== 等等）应在前后留空格。\n如：\n\n\t\tif ( v1 == v2)\n\n\t\t     return v1 * 3;\n\n²  ++ 和 -- 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。\n如：\n\t\tfor(int i = 0; i < 10; ++i)\n## 2.11.    变量声明语句块 （适用于C/C++）\n\n²  变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。\n如：\n\t\tfor(int i = 0; i < 10; ++i)\n\n \n\n²  声明语句块必须要对齐\n\n类型，变量，等号和初始化值要分别对齐。\n\n例如：\n\n\t\t   DWORD      mDword;\n\n\t\t   DWORD*     mpDword;\n\n\t\t   char*      mpChar;\n\n\t\t   char       mChar;\n\n\t\t \n\n\t\t   mDword     =    0;\n\n\t\t   mpDword    =    NULL;\n\n\t\t   mpChar      =    NULL;\n\n\t\t   mChar      =    0;\n# 3.    文档及注释\n\n应当使用文档自动生成工具，来生成相关的程序文档。\n## 3.1. 文件或程序库的文档注释（适用于C/C++）\n\n可以为整个文件编写文档。\n\n例如：\n\n\t\t/** @file file.h\n\n\t\t * Abrief file description.\n\n\t\t * Amore elaborated file description.\n\n\t\t */\n\n \n## 3.2. 类文档注释（适用于C/C++）\n\n在类定义前面应加上类说明文档。\n\n例如：\n\n\t\t/** WindowsNT\n\n\t\t *  @brief Windows Nice Try.\n\n\t\t *  @author Bill Gates\n\n\t\t *  @author Several species of small furryanimals gathered together\n\n\t\t *          in a cave and grooving with a pict.\n\n\t\t *  @version 4.0\n\n\t\t *  @date   1996-1998\n\n\t\t *  @bug It crashes a lot and requires hugeamounts of memory.\n\n\t\t *  @bug The class introduces the more bugs, thelonger it is used.\n\n\t\t *  @warning This class may explode in your face.\n\n\t\t *  @warning If you inherit anything from thisclass, you're doomed.\n\n\t\t */\n\n\t\tclass WindowsNT {};\n\n \n## 3.3. 函数文档注释（适用于C/C++）\n\n²  函数注释\n\n所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如：\n\n\t\t  /**\n\n\t\t   * 赋值操作符\n\n\t\t   *\n\n\t\t   *@param val 将要赋给本对象的值\n\n\t\t   *\n\n\t\t   *@return 本对象的引用\n\n\t\t   */\n\n\t\t  XX&  operator =(XX& val);\n\n²  注释属性\n\n一些自动文档工具定义的属性可以包含在文档中，常用的有：\n\nn  前提条件 (pre)\n定义调用这个函数的前提条件\n\nn  警告说明 (warning)\n定义一些关于这个函数必须知道的事情。\n\nn  备注说明 (remarks)\n定义一些关于这个函数的备注信息。\n\nn  将要完成的工作 (todo)\n说明哪些事情将在不久以后完成\n\nn  使用例子说明 (example)\n一个图片能表达100句话，一个好的例子能解答1000个问题。\n\n例如：\n\n\t\t  /**\n\n\t\t   * 复制一个字串\n\n\t\t   *\n\n\t\t   *@pre\n\n\t\t   *     - 需要保证(from != 0)\n\n\t\t   *     - 需要保证(to != 0)\n\n\t\t   *\n\n\t\t   *@warning\n\n\t\t   * 缓冲区必需足够大，以便容纳的下要拷贝的字串。\n\n\t\t   *\n\n\t\t   *@example teststrcpy.cpp\n\n\t\t   *\n\n\t\t   *@param from 要拷贝的字串\n\n\t\t   *@param to 用于容纳字串的缓冲区\n\n\t\t   *@return void\n\n\t\t   */\n\n\t\t  void  strcpy(constchar* from, char* to);\n## 3.4. Include 语句注释 （适用于C/C++）\n\n²  如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。\n## 3.5.语句块注释（适用于C/C++）\n\n²  语句块的注释可以用在语句块的开头和结束位置：\n\n\t\t{ \n\n\t\t    // Block1 (meaningful comment about Block1)\n\n\t\t    ... some code\n\n\t\t \n\n\t\t    { \n\n\t\t        // Block2 (meaningful comment about Block2)\n\n\t\t        ... somecode\n\n\t\t    }  // End Block2\n\n\t\t \n\n\t\t}  // End Block1\n# 4.    编码要求\n## 4.1. 不要忽略编译器的警告（适用于C/C++）\n\n²  编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。\n## 4.2. 应使用源代码管理器（适用于C/C++）\n\n²  根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。\n## 4.3. 固有的类方法成员（适用于C++）\n\n²  默认构造函数(DefaultConstructor)\n\n如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。\n\n²  虚析构函数(Virtual Destructor)\n\n如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。\n\n²  拷贝构造函数(Copy Constructor)\n\n如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。\n\n²  赋值操作(AssignmentOperator)\n\n如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。\n## 4.4. 使用命名空间 （适用于C++）\n\n²  命名规则\n\n根名字一般是设计者的名字。比如公司名称等等。\n\n²  不要在全局空间使用using语句。\n## 4.5. 初始化所有的变量 （适用于C/C++）\n\n²  无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。\n## 4.6. 保持函数短小精悍（适用于C/C++）\n\n²  一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。\n## 4.7.对空语句进行注释 （适用于C/C++）\n\n²  For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如：\n\n\t\t   while(*dest++ = *srC++)\n\n\t\t      ;         // VOID\n\n²  不允许写成：\n\n\t\t   while (*dest++ = *srC++) ;   // 绝对不允许这么写\n\n \n## 4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）\n\n²  If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如：\n\n建议使用：\n\n   \t\tif (FAIL != f())\n\n不建议使用下面的表达式：\n\n   \t\tif (f())\n\n \n\n²  宏定义的情况也一样：\n\n   \t\t#define STREQ(a,b) (strcmp((a), (b)) == 0)\n\n或者使用内联函数：\n\n\t\t   inline bool\n\n\t\t  StringEqual(char* a, char* b)\n\n\t\t   {\n\n\t\t      (strcmp(a, b)== 0) ? return true : return false;\n\n\t\t       Or more compactly:\n\n\t\t      returnstrcmp(a, b) == 0;\n\n\t\t   }\n## 4.9.布尔类型 （适用于C/C++）\n\n²  早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。\n\n \n\n早期的布尔类型定义为：\n\n\t\t   typedef int     bool;\n\n\t\t   #defineTRUE    1\n\n\t\t   #defineFALSE   0\n\n \n\n或：\n\n\t\t   const intTRUE  = 1;\n\n\t\t   const int FALSE= 0;\n\n \n\n²  在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如：\n\n   \t\tif (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？\n\n必须写成：\n\n   \t\tif (FALSE !=func()) { ...\n## 4.10.   避免在语句中内含赋值 （适用于C/C++）\n\n²  只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如：\n\n\t\t   while (EOF != (c= getchar()))\n\n\t\t   {\n\n\t\t      process thecharacter\n\n\t\t   }\n\n²  ++ 和 -- 操作也是一种赋值语句\n\n²  内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如：\n\n\t\t   a = b + c;\n\n\t\t   d = a + r;\n\n不应该写成：\n\n   \t\t\td = (a = b + c)+ r;\n## 4.11.   正确的使用Const （适用于C/C++）\n\n²  C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。\n## 4.12.    不要在头文件定义数据（适用于C/C++）\n\n不要把数据定义放在头文件，如：\n\n\t\t/*\n\n\t\t * aheader.h\n\n\t\t */\n\n\t\tint x = 0;\n## 4.13.   不要直接使用数字 （适用于C/C++）\n\n²  直接使用数字，会使源代码难以理解和维护。如：\n\n\t\tif      (22 ==foo)    { start_thermo_nuclear_war(); }\n\n\t\telse if (19 == foo)    {refund_lotso_money(); }\n\n\t\telse if (16 == foo)    {infinite_loop(); }\n\n\t\telse                   { cry_cause_im_lost(); }\n\n当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。\n\n²  我们可以用#define或者常量来改变这一状况，如：\n\n\t\t#define  PRESIDENT_WENT_CRAZY  (22)\n\n\t\tconst int WE_GOOFED= 19;\n\n\t\tenum\n\n\t\t{\n\n\t\t    THEY_DIDNT_PAY=16\n\n\t\t};\n\n\t\t \n\n\t\tif (PRESIDENT_WENT_CRAZY    == foo) { start_thermo_nuclear_war(); }\n\n\t\telse if (WE_GOOFED          == foo)  {refund_lotso_money(); }\n\n\t\telse if (THEY_DIDNT_PAY     == foo) { infinite_loop();}\n\n\t\telse                                 {happy_days_i_know_why_im_here(); }\n\n \n## 4.14.    宏（适用于C/C++）\n\n²  如果可以，使用内联函数代替宏。\n\n例如：\n\n\t\t#ifndef MAX\n\n\t\t#define  MAX(x,y)  (((x) > (y) ? (x) : (y))    // 取最大数\n\n\t\t#endif\n\n使用内联函数可以达到相同的效果，而且更安全：\n\n\t\t   inline int\n\n\t\t   max(int x, inty)\n\n\t\t   {\n\n\t\t      return (x> y ? x : y);\n\n\t\t   }\n\n²  要注意副作用\n\n必须小心副作用，因为在调用表达式时，会发生潜在的错误。\n\n例如：\n\n  \t\t MAX(f(x),z++);\n\n²  表达式总是用括号括起来\n\n在宏展开时，使用括号可以避免宏展开后产生的二义性。\n\n例如：\n\n\t\t#define ADD(x,y) x + y\n\n必须写成：\n\n\t\t#define ADD(x,y) ((x) + (y))\n\n²  保证宏名称的唯一性\n\n和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题：\n\nn  在宏名称前加上库的名字\n避免使用简单而常用的名字，如：MAX 和MIN。","content":"<pre><code>    命名规则\n    1 起个合适的名字\n        11    类的名称 适用于C\n        12    方法和函数的名称 适用于C++\n        13   含有度量单位的名称 适用于C++\n        14    缩写名称不要全部大写 适用于C++\n    2类的命名 适用于C\n    3类库或程序库命名 适用于C++\n    4方法和函数的命名 适用于C\n    5类属性的命名 适用于C\n    6方法和函数参数的命名 适用于C\n    7局部变量的命名 适用于C++\n    8指针变量的命名前缀 适用于C++\n    9引用变量和返回引用函数的命名前缀 适用于C\n    10   全局变量的命名前缀 适用于C++\n    11   全局常量的命名 适用于C+\n    命名规则\n    1 起个合适的名字\n        11    类的名称 适用于C\n        12    方法和函数的名称 适用于C++\n        13   含有度量单位的名称 适用于C++\n        14    缩写名称不要全部大写 适用于C++\n    2类的命名 适用于C\n    3类库或程序库命名 适用于C++\n    4方法和函数的命名 适用于C\n    5类属性的命名 适用于C\n    6方法和函数参数的命名 适用于C\n    7局部变量的命名 适用于C++\n    8指针变量的命名前缀 适用于C++\n    9引用变量和返回引用函数的命名前缀 适用于C\n    10   全局变量的命名前缀 适用于C++\n    11   全局常量的命名 适用于C++\n    12   静态变量的命名前缀 适用于C\n    13   自定义类型typedef的命名 适用于C++\n    14   宏定义的命名 适用于C++\n    15   C 函数的命名 适用于C++\n    16   枚举的命名 适用于C++\n    排版规则\n    1 布局和模板\n        11    类的布局模板 适用于C\n        12   源文件格式 适用于C\n        13    保护头文件不被重复包含 适用于C++\n        14    方法和函数的布局 适用于C++\n    2 缩进制表符以及空格 适用于C++\n    3 尽量使一行不要超过78个字母 适用于C++\n    4 保证一行只写一条语句 适用于C++\n    5 花括号 规则 适用于C++\n        51    花括号的位置\n        52    什么时候应使用花括号\n        53    在花括号结束的位置加上注释\n        54    注意屏幕大小 \n    6圆括号 规则 适用于C++\n    7if else 语句的格式 适用于C++\n    8switch 格式 适用于C++\n    9 使用gotocontinuebreak 和 适用于C++\n        91    Goto\n        92    Continue and Break\n        93    \n    10   运算符号的规则 适用于C++\n    11    变量声明语句块 适用于C++\n    文档及注释\n    1 文件或程序库的文档注释 适用于C++\n    2 类文档注释 适用于C++\n    3 函数文档注释 适用于C++\n    4 Include 语句注释 适用于C++\n    5语句块注释 适用于C++\n    编码要求\n    1 不要忽略编译器的警告 适用于C++\n    2 应使用源代码管理器 适用于C++\n    3 固有的类方法成员 适用于C\n    4 使用命名空间 适用于C\n    5 初始化所有的变量 适用于C++\n    6 保持函数短小精悍 适用于C++\n    7对空语句进行注释 适用于C++\n    8不要用if语句的默认方法测试非零值 适用于C++\n    9布尔类型 适用于C++\n    10避免在语句中内含赋值 适用于C++\n    11正确的使用Const 适用于C++\n    12不要在头文件定义数据适用于C++\n    13不要直接使用数字 适用于C++\n    14宏 适用于C++\n</code></pre> <a id=\"more\"></a> \n<h1 id=\"1-命名规则\"><a href=\"#1-命名规则\" class=\"headerlink\" title=\"1.    命名规则\"></a>1.    命名规则</h1><h2 id=\"1-1-起个合适的名字\"><a href=\"#1-1-起个合适的名字\" class=\"headerlink\" title=\"1.1. 起个合适的名字\"></a>1.1. 起个合适的名字</h2><h3 id=\"1-1-1-类的名称（适用于C-）\"><a href=\"#1-1-1-类的名称（适用于C-）\" class=\"headerlink\" title=\"1.1.1.    类的名称（适用于C++）\"></a>1.1.1.    类的名称（适用于C++）</h3><p>²  类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。</p>\n<p>²  类的名字不需要告诉我们，它从哪个类继承而来的。</p>\n<p>²  有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。</p>\n<h3 id=\"1-1-2-方法和函数的名称（适用于C-C-）\"><a href=\"#1-1-2-方法和函数的名称（适用于C-C-）\" class=\"headerlink\" title=\"1.1.2.    方法和函数的名称（适用于C/C++）\"></a>1.1.2.    方法和函数的名称（适用于C/C++）</h3><p>²  方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。</p>\n<p>²  函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。</p>\n<p>²  可以加一些必要的后缀：</p>\n<p>Max – 表示取最大值</p>\n<p>Cnt – 表示当前的计数值</p>\n<p>Key – 表示键值</p>\n<p>例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。</p>\n<p>²  前缀也同样有用：</p>\n<p>Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。</p>\n<p>Get – 用于获取一个值。</p>\n<p>Set – 用于设置一个值。</p>\n<p>例如：IsHitRetryLimit.</p>\n<h3 id=\"1-1-3-含有度量单位的名称（适用于C-C-）\"><a href=\"#1-1-3-含有度量单位的名称（适用于C-C-）\" class=\"headerlink\" title=\"1.1.3.   含有度量单位的名称（适用于C/C++）\"></a>1.1.3.   含有度量单位的名称（适用于C/C++）</h3><p>²  如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。</p>\n<p>例如：</p>\n<pre><code>uint32 mTimeoutMsecs;\n\nuint32 mMyWeightLbs;\n</code></pre><h3 id=\"1-1-4-缩写名称不要全部大写（适用于C-C-）\"><a href=\"#1-1-4-缩写名称不要全部大写（适用于C-C-）\" class=\"headerlink\" title=\"1.1.4.    缩写名称不要全部大写（适用于C/C++）\"></a>1.1.4.    缩写名称不要全部大写（适用于C/C++）</h3><p>²  无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。</p>\n<p>例如：</p>\n<pre><code>class FluidOz;            // 而不是 FluidOZ\n\nclass NetworkAbcKey;      // 而不是 NetworkABCKey\n</code></pre><h2 id=\"1-2-类的命名（适用于C-）\"><a href=\"#1-2-类的命名（适用于C-）\" class=\"headerlink\" title=\"1.2.类的命名（适用于C++）\"></a>1.2.类的命名（适用于C++）</h2><p>²  用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。</p>\n<p>²  名字的第一个字母应大写</p>\n<p>²  不含有下划线 (‘_’)</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo; \n\n   class Name;\n</code></pre><h2 id=\"1-3-类库（或程序库）命名-（适用于C-C-）\"><a href=\"#1-3-类库（或程序库）命名-（适用于C-C-）\" class=\"headerlink\" title=\"1.3.类库（或程序库）命名 （适用于C/C++）\"></a>1.3.类库（或程序库）命名 （适用于C/C++）</h2><p>²  使用命名空间防止名字冲突。</p>\n<p>²  如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。</p>\n<p>例如：</p>\n<p>John Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样：</p>\n<pre><code>   class JjLinkList\n\n   {\n\n   }\n</code></pre><h2 id=\"1-4-方法和函数的命名（适用于C-）\"><a href=\"#1-4-方法和函数的命名（适用于C-）\" class=\"headerlink\" title=\"1.4.方法和函数的命名（适用于C++）\"></a>1.4.方法和函数的命名（适用于C++）</h2><p>²  使用与类名相同的规则</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n       public:\n\n  int     DoIt();\n\n  void    HandleError();\n\n   }\n</code></pre><h2 id=\"1-5-类属性的命名（适用于C-）\"><a href=\"#1-5-类属性的命名（适用于C-）\" class=\"headerlink\" title=\"1.5.类属性的命名（适用于C++）\"></a>1.5.类属性的命名（适用于C++）</h2><p>²  属性（通常是非公有数据成员）名字以字母’m’开头。</p>\n<p>²  在 ‘m(m_)’  后面，使用与类名相同的规则。</p>\n<p>²  ‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n   public:\n\n      int     VarAbc();\n\n      int     ErrorNumber();\n\n   private:\n\n      int          mVarAbc;\n\n      int          mErrorNumber;\n\n      String*      mpName;\n\n   }\n</code></pre><h2 id=\"1-6-方法和函数参数的命名（适用于C-）\"><a href=\"#1-6-方法和函数参数的命名（适用于C-）\" class=\"headerlink\" title=\"1.6.方法和函数参数的命名（适用于C++）\"></a>1.6.方法和函数参数的命名（适用于C++）</h2><p>²  第一个字母必须小写。</p>\n<p>²  第一个字母后面的单词使用与类名相同的规则。</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n   public:\n\n  int     StartYourEngines(\n\n                           Engine&amp;rSomeEngine,\n\n                          Engine&amp;rAnotherEngine);\n\n   }\n</code></pre><h2 id=\"1-7-局部变量的命名（适用于C-C-）\"><a href=\"#1-7-局部变量的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.7.局部变量的命名（适用于C/C++）\"></a>1.7.局部变量的命名（适用于C/C++）</h2><p>²  所有字母都用小写</p>\n<p>²  使用下划线 ‘_’ 作为单词的分隔。</p>\n<p>例如：</p>\n<pre><code>   int\n\n  NameOneTwo::HandleError(int errorNumber)\n\n   {\n\n  int            error= OsErr();\n\n  Time           time_of_error;\n\n ErrorProcessor error_processor;\n</code></pre><p>   }</p>\n<h2 id=\"1-8-指针变量的命名前缀（适用于C-C-）\"><a href=\"#1-8-指针变量的命名前缀（适用于C-C-）\" class=\"headerlink\" title=\"1.8.指针变量的命名前缀（适用于C/C++）\"></a>1.8.指针变量的命名前缀（适用于C/C++）</h2><p>²  指针变量多数情况应在前面加 ‘p’。</p>\n<p>²  星号 ‘*’ 应靠近类型，而不是变量名。</p>\n<p>例如：</p>\n<pre><code>  String* pName=new String;\n</code></pre><p>  特别的：String* pName, name; 应分成两行来写：</p>\n<pre><code>  String* pName;\n\n  String  name;\n</code></pre><h2 id=\"1-9-引用变量和返回引用函数的命名前缀（适用于C-）\"><a href=\"#1-9-引用变量和返回引用函数的命名前缀（适用于C-）\" class=\"headerlink\" title=\"1.9.引用变量和返回引用函数的命名前缀（适用于C++）\"></a>1.9.引用变量和返回引用函数的命名前缀（适用于C++）</h2><p>²  引用必须用 ‘r’作前缀修饰。</p>\n<p>例如：</p>\n<pre><code>   class Test\n\n   {\n\n   public:\n\n  void               DoSomething(StatusInfo&amp;rStatus);\n\n\n\n StatusInfo&amp;        rStatus();\n\n  constStatusInfo&amp;  Status() const; // 这里返回的是常量引用，所以不符合本规则\n\n\n\n   private:\n\n     StatusInfo&amp;        mrStatus;\n\n   }\n</code></pre><h2 id=\"1-10-全局变量的命名前缀（适用于C-C-）\"><a href=\"#1-10-全局变量的命名前缀（适用于C-C-）\" class=\"headerlink\" title=\"1.10.   全局变量的命名前缀（适用于C/C++）\"></a>1.10.   全局变量的命名前缀（适用于C/C++）</h2><p>²  全局变量总是以 ‘g(g_)’ 作为前缀。</p>\n<p>例如：</p>\n<pre><code>Logger g_Log;\n\nLogger* g_pLog;\n</code></pre><h2 id=\"1-11-全局常量的命名（适用于C-C-）\"><a href=\"#1-11-全局常量的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.11.   全局常量的命名（适用于C/C++）\"></a>1.11.   全局常量的命名（适用于C/C++）</h2><p>²  全局常量全部大写，并以下划线 ‘_’ 分隔单词。</p>\n<p>例如：</p>\n<pre><code>const intA_GLOBAL_CONSTANT = 5;\n</code></pre><h2 id=\"1-12-静态变量的命名前缀（适用于C-）\"><a href=\"#1-12-静态变量的命名前缀（适用于C-）\" class=\"headerlink\" title=\"1.12.   静态变量的命名前缀（适用于C++）\"></a>1.12.   静态变量的命名前缀（适用于C++）</h2><p>²  静态变量以 ‘s’ 作为前缀。</p>\n<p>例如：</p>\n<pre><code>   class Test\n\n   {\n\n   public:\n\n   private:\n\n      staticStatusInfo m_sStatus;\n\n   }\n</code></pre><h2 id=\"1-13-自定义类型（typedef）的命名（适用于C-C-）\"><a href=\"#1-13-自定义类型（typedef）的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.13.   自定义类型（typedef）的命名（适用于C/C++）\"></a>1.13.   自定义类型（typedef）的命名（适用于C/C++）</h2><p>²  类型定义名称指的是用typedef定义的名称。</p>\n<p>²  类型定义名称使用与类名相同的规则，并使用Type作为后缀。</p>\n<p>例如：</p>\n<pre><code>   typedefuint16  ModuleType;\n\n   typedefuint32  SystemType;\n</code></pre><h2 id=\"1-14-宏定义的命名（适用于C-C-）\"><a href=\"#1-14-宏定义的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.14.   宏定义的命名（适用于C/C++）\"></a>1.14.   宏定义的命名（适用于C/C++）</h2><p>²  所有单词的字母都用大写，并使用下划线 ‘_’ 分隔.</p>\n<p>例如：</p>\n<pre><code>#define MAX(a,b) blah\n\n#define IS_ERR(err) blah\n</code></pre><h2 id=\"1-15-C-函数的命名（适用于C-C-）\"><a href=\"#1-15-C-函数的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.15.   C 函数的命名（适用于C/C++）\"></a>1.15.   C 函数的命名（适用于C/C++）</h2><p>²  C++项目中，应尽量少用C函数。</p>\n<p>²  C函数使用GNU规范，所有字母都使用小写，并用下划线 ‘_’ 作为单词的分隔。</p>\n<p>例如：</p>\n<pre><code>   int\n\n  some_bloody_function()\n\n   {\n\n   }\n</code></pre><p>²  特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：</p>\n<pre><code>   extern “C” int some_bloody_function();\n</code></pre><p>²  或在C/C++中推荐使用下面的格式：</p>\n<pre><code>   #ifdef__cplusplus__\n\n   extern “C”{\n\n   #endif\n\n   int\n\n  some_bloody_function()\n\n   {\n\n   }\n\n   #ifdef__cplusplus__\n\n   }\n\n   #endif\n</code></pre><h2 id=\"1-16-枚举的命名（适用于C-C-）\"><a href=\"#1-16-枚举的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.16.   枚举的命名（适用于C/C++）\"></a>1.16.   枚举的命名（适用于C/C++）</h2><p>²  所有字母都大写，并用下划线 ‘_’ 作为单词分隔。</p>\n<p>例如：</p>\n<pre><code>   enumPinStateType\n\n   {\n\n      PIN_OFF,\n\n      PIN_ON\n\n   };\n\nenum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING};\n</code></pre><h1 id=\"2-排版规则\"><a href=\"#2-排版规则\" class=\"headerlink\" title=\"2.    排版规则\"></a>2.    排版规则</h1><h2 id=\"2-1-布局和模板\"><a href=\"#2-1-布局和模板\" class=\"headerlink\" title=\"2.1. 布局和模板\"></a>2.1. 布局和模板</h2><h3 id=\"2-1-1-类的布局模板-（适用于C-）\"><a href=\"#2-1-1-类的布局模板-（适用于C-）\" class=\"headerlink\" title=\"2.1.1.    类的布局模板 （适用于C++）\"></a>2.1.1.    类的布局模板 （适用于C++）</h3><p>²  请使用下面的模板来创建一个新的类：</p>\n<pre><code>/**     \n\n * 用一行来描述类\n\n *\n\n *#include &quot;XX.h&quot; &lt;BR&gt;\n\n *-llib\n\n *\n\n * 类的详细说明\n\n * \n\n * @seesomething\n\n */\n\n\n\n#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n#define SORUTION_PROJECT_CLASSNAME_H\n\n\n\n// 在这里包含系统头文件\n\n//\n\n\n\n// 在这里包含项目头文件\n\n//\n\n\n\n// 在这里包含局部头文件\n\n//\n\n\n\n// 在这里放置前置引用\n\n//\n\n\n\n\n\n    class XX\n\n    {\n\n    public:\n\n    // 类的生命周期控制函数，如构造和析构，以及状态机\n\n\n\n        /**\n\n        *Default constructor.\n\n        */\n\n        XX(void);\n\n\n\n        /**\n\n        *Copy constructor.\n\n        *\n\n        *@param from The value to copy to this object.\n\n        */\n\n        XX(const XX&amp; from);\n\n\n\n        /**\n\n        *Destructor.\n\n        */\n\n        virtual ~XX(void);\n\n\n\n        // 在这里放置类的运算操作符\n\n\n\n        /**\n\n        *Assignment operator.\n\n        *\n\n        *@param from THe value to assign to this object.\n\n        *\n\n        *@return A reference to this object.\n\n        */\n\n        XX&amp;                     operator=(XX&amp;from); \n\n\n\n        // 在这里放置类的操作                      \n\n        // 在这里放置属性存取\n\n        // 在这里放置类的状态查询\n\n\n\n        protected:\n\n        private:\n\n        };\n\n\n\n    // 内联方法定义\n\n    //\n\n\n\n    // 外部引用\n\n    //\n\n\n\n    #endif  // SORUTION_PROJECT_CLASSNAME_H\n</code></pre><p>²  定义的顺序是: public, protected, private</p>\n<p>²  要清楚public/protected/private都应该放置哪些东西</p>\n<h3 id=\"2-1-2-源文件格式（适用于C-）\"><a href=\"#2-1-2-源文件格式（适用于C-）\" class=\"headerlink\" title=\"2.1.2.   源文件格式（适用于C++）\"></a>2.1.2.   源文件格式（适用于C++）</h3><pre><code>    #include &quot;XX.h&quot;                               // class implemented\n</code></pre><p>/////////////// PUBLIC///////////////////////</p>\n<p>//================= 构造函数 ====================</p>\n<pre><code>    XX::XX()\n\n    {\n\n    }// XX\n\n\n\n    XX::XX(const XX&amp;)\n\n    {\n\n    }// XX\n\n\n\n    XX::~XX()\n\n    {\n\n    }// ~XX\n</code></pre><p>//=============== 操作符=========================</p>\n<pre><code>    XX&amp;\n\n    XX::operator=(XX&amp;);\n\n    {\n\n       return *this;\n\n\n\n    }// =\n</code></pre><p>//==============类的操作 =====================</p>\n<p>//==============属性存取 =====================</p>\n<p>//==============状态查询   =====================</p>\n<p>///////////// PROTECTED  //////////////////</p>\n<p>///////////// PRIVATE    //////////////////</p>\n<h3 id=\"2-1-3-保护头文件不被重复包含-（适用于C-C-）\"><a href=\"#2-1-3-保护头文件不被重复包含-（适用于C-C-）\" class=\"headerlink\" title=\"2.1.3.    保护头文件不被重复包含 （适用于C/C++）\"></a>2.1.3.    保护头文件不被重复包含 （适用于C/C++）</h3><p>²  应使用宏定义来保护头文件不被重复包含：</p>\n<pre><code>    #ifndef SORUTION_PROJECT_CLASSNAME_H\n\n    #define SORUTION_PROJECT_CLASSNAME_H\n\n\n\n    #endif // SORUTION_PROJECT_CLASSNAME_H\n</code></pre><p>²  如果使用命名空间的时候，要把命名空间加到文件名前面：</p>\n<pre><code>    #ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n    #define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n</code></pre><p>#endif</p>\n<h3 id=\"2-1-4-方法和函数的布局-（适用于C-C-）\"><a href=\"#2-1-4-方法和函数的布局-（适用于C-C-）\" class=\"headerlink\" title=\"2.1.4.    方法和函数的布局 （适用于C/C++）\"></a>2.1.4.    方法和函数的布局 （适用于C/C++）</h3><p>²  对于有较多参数的函数的写法</p>\n<p>如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：</p>\n<pre><code>       int AnyMethod(\n\n                     int  arg1, \n\n                     int   arg2,\n\n                     int   arg3,\n\n                     int   arg4); \n</code></pre><p>或</p>\n<pre><code>    int AnyMethod( int   arg1 \n\n                   , int   arg2\n\n                   , int   arg3\n\n                   , int   arg4);\n</code></pre><h2 id=\"2-2-缩进、制表符以及空格-（适用于C-C-）\"><a href=\"#2-2-缩进、制表符以及空格-（适用于C-C-）\" class=\"headerlink\" title=\"2.2. 缩进、制表符以及空格 （适用于C/C++）\"></a>2.2. 缩进、制表符以及空格 （适用于C/C++）</h2><p>²  缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格）</p>\n<p>²  不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。</p>\n<p>²  虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。</p>\n<p>例如：</p>\n<pre><code>       void\n\n       func()\n\n       {\n\n          if (something bad)\n\n          {\n\n              if (another thing bad)\n\n              {\n\n                  while (more input)\n\n                  {\n\n                  }\n\n              }\n\n          }\n\n       }\n</code></pre><h2 id=\"2-3-尽量使一行不要超过78个字母-（适用于C-C-）\"><a href=\"#2-3-尽量使一行不要超过78个字母-（适用于C-C-）\" class=\"headerlink\" title=\"2.3. 尽量使一行不要超过78个字母 （适用于C/C++）\"></a>2.3. 尽量使一行不要超过78个字母 （适用于C/C++）</h2><p>²  有许多编辑器屏幕只有78个字母宽</p>\n<h2 id=\"2-4-保证一行只写一条语句-（适用于C-C-）\"><a href=\"#2-4-保证一行只写一条语句-（适用于C-C-）\" class=\"headerlink\" title=\"2.4. 保证一行只写一条语句 （适用于C/C++）\"></a>2.4. 保证一行只写一条语句 （适用于C/C++）</h2><p>²  一行最多只写一条语句</p>\n<p>²  一行只定义一个变量</p>\n<p>例如：</p>\n<p>不要象下面这样:</p>\n<pre><code>    char** a, *x;\n\n\n\n    int width, height; //widthand height of image\n</code></pre><p>要象这样:</p>\n<pre><code>    char** a= 0;  // 文档说明\n\n    char*  x= 0;  // 文档说明\n    2.5. 花括号 {} 规则 （适用于C/C++）\n    2.5.1.    花括号的位置\n</code></pre><p>²  在关键字的下一行单独放置括号，并且与关键字对齐，如：</p>\n<pre><code>    if (condition)       \n\n    {\n\n        ...\n\n    }\n\n    while (condition)\n\n    {\n\n        …\n\n    }\n</code></pre><h3 id=\"2-5-2-什么时候应使用花括号\"><a href=\"#2-5-2-什么时候应使用花括号\" class=\"headerlink\" title=\"2.5.2.    什么时候应使用花括号\"></a>2.5.2.    什么时候应使用花括号</h3><p>所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。</p>\n<p>²  使用花括号格式：</p>\n<pre><code>    if (1 == somevalue)\n\n    {\n\n       somevalue = 2;\n\n    }\n\n    ²  单行格式：\n\n    if (1 == somevalue) somevalue = 2;\n\n    或下面这样（对于这种写法，建议使用花括号）：\n\n    if (1 == somevalue)\n\n    {\n    somevalue = 2;\n\n    }\n</code></pre><h3 id=\"2-5-3-在花括号结束的位置加上注释\"><a href=\"#2-5-3-在花括号结束的位置加上注释\" class=\"headerlink\" title=\"2.5.3.    在花括号结束的位置加上注释\"></a>2.5.3.    在花括号结束的位置加上注释</h3><p>²  在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如：</p>\n<pre><code>    while(1)\n\n    {\n\n       if (valid)\n\n       {\n\n\n\n       } // if valid\n\n       else\n\n       {\n\n       } // not valid\n\n\n\n    } // end forever\n</code></pre><h3 id=\"2-5-4-注意屏幕大小\"><a href=\"#2-5-4-注意屏幕大小\" class=\"headerlink\" title=\"2.5.4.    注意屏幕大小\"></a>2.5.4.    注意屏幕大小</h3><p>²  一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。</p>\n<h2 id=\"2-6-圆括号-规则-（适用于C-C-）\"><a href=\"#2-6-圆括号-规则-（适用于C-C-）\" class=\"headerlink\" title=\"2.6.圆括号 () 规则 （适用于C/C++）\"></a>2.6.圆括号 () 规则 （适用于C/C++）</h2><p>²  圆括号与关键字之间应放一个空格。</p>\n<p>²  圆括号与函数名之间不要有空格。</p>\n<p>²  Return 语句不要使用圆括号。</p>\n<p>例如：</p>\n<pre><code>    if (condition)\n\n    {\n\n    }\n\n\n\n    while(condition)\n\n    {\n\n    }\n\n\n\n    strcpy(s, s1);\n\n\n\n    return 1;\n</code></pre><h2 id=\"2-7-if-else-语句的格式-（适用于C-C-）\"><a href=\"#2-7-if-else-语句的格式-（适用于C-C-）\" class=\"headerlink\" title=\"2.7.if else 语句的格式 （适用于C/C++）\"></a>2.7.if else 语句的格式 （适用于C/C++）</h2><p>²  布局</p>\n<pre><code>       if (条件)               // 注释\n\n       {\n\n       }\n\n       else if (条件)           // 注释\n\n       {\n\n       }\n\n       else                   // 注释\n\n       {\n\n       }\n</code></pre><p>²  条件格式</p>\n<p>总是把常量放在等号或不等于号的左边：</p>\n<pre><code>    if ( 6 == errorNum ) ...\n</code></pre><p>一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。</p>\n<p>比如：</p>\n<pre><code>    if ( errorNum == 6) ...\n</code></pre><p>错写成：</p>\n<pre><code>    if ( errorNum = 6) ... // 这是一个不容易发现的灾难\n</code></pre><h2 id=\"2-8-switch-格式-（适用于C-C-）\"><a href=\"#2-8-switch-格式-（适用于C-C-）\" class=\"headerlink\" title=\"2.8.switch 格式 （适用于C/C++）\"></a>2.8.switch 格式 （适用于C/C++）</h2><p>²  直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。</p>\n<p>²  总是要写default语句，不管是否是需要。</p>\n<p>²  在case中需要定义变量的时候，应把所有代码放在语句块中。</p>\n<p>例如：</p>\n<pre><code>    switch (...)\n\n    {\n\n    case 1:\n\n        ...\n\n            // 继续执行case2\n\n\n\n    case 2:\n\n        {       \n\n            int v;\n\n            ...\n\n        }\n\n        break;\n\n\n\n    default:\n\n    }\n</code></pre><h2 id=\"2-9-使用goto-continue-break-和-（适用于C-C-）\"><a href=\"#2-9-使用goto-continue-break-和-（适用于C-C-）\" class=\"headerlink\" title=\"2.9. 使用goto,continue,break 和 ?: （适用于C/C++）\"></a>2.9. 使用goto,continue,break 和 ?: （适用于C/C++）</h2><h3 id=\"2-9-1-Goto\"><a href=\"#2-9-1-Goto\" class=\"headerlink\" title=\"2.9.1.    Goto\"></a>2.9.1.    Goto</h3><p>²  尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如：</p>\n<pre><code>    for (...)\n\n    {\n\n        while (...)\n\n        {\n\n            ...\n\n                if (disaster)\n\n    goto error; //跳出循环\n\n        }\n\n    }\n\n    ...\n\n    error:\n\n    clean up the mess\n</code></pre><p>²  跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。</p>\n<h3 id=\"2-9-2-Continue-and-Break\"><a href=\"#2-9-2-Continue-and-Break\" class=\"headerlink\" title=\"2.9.2.    Continue and Break\"></a>2.9.2.    Continue and Break</h3><p>²  Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。</p>\n<h3 id=\"2-9-3\"><a href=\"#2-9-3\" class=\"headerlink\" title=\"2.9.3.    ?:\"></a>2.9.3.    ?:</h3><p>²  用括号把条件表达式括起来。</p>\n<p>²  不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。</p>\n<p>²  操作语句应分行写，除非它们能够简洁的放在一行当中。</p>\n<p>例如：</p>\n<pre><code>       (condition) ?funct1() : func2();\n</code></pre><p>   或</p>\n<pre><code>       (condition)\n\n          ? longstatement\n\n          : anotherlong statement;\n</code></pre><h2 id=\"2-10-运算符号的规则-（适用于C-C-）\"><a href=\"#2-10-运算符号的规则-（适用于C-C-）\" class=\"headerlink\" title=\"2.10.   运算符号的规则 （适用于C/C++）\"></a>2.10.   运算符号的规则 （适用于C/C++）</h2><p>²  一元操作符如（!、~ 等等）应贴近操作对象。<br>如：</p>\n<pre><code>    if (!IsOk)\n\n        return ++v;\n</code></pre><p>²  二元操作符如（+、*、%、== 等等）应在前后留空格。<br>如：</p>\n<pre><code>    if ( v1 == v2)\n\n         return v1 * 3;\n</code></pre><p>²  ++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。<br>如：<br>        for(int i = 0; i &lt; 10; ++i)</p>\n<h2 id=\"2-11-变量声明语句块-（适用于C-C-）\"><a href=\"#2-11-变量声明语句块-（适用于C-C-）\" class=\"headerlink\" title=\"2.11.    变量声明语句块 （适用于C/C++）\"></a>2.11.    变量声明语句块 （适用于C/C++）</h2><p>²  变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。<br>如：<br>        for(int i = 0; i &lt; 10; ++i)</p>\n<p>²  声明语句块必须要对齐</p>\n<p>类型，变量，等号和初始化值要分别对齐。</p>\n<p>例如：</p>\n<pre><code>       DWORD      mDword;\n\n       DWORD*     mpDword;\n\n       char*      mpChar;\n\n       char       mChar;\n\n\n\n       mDword     =    0;\n\n       mpDword    =    NULL;\n\n       mpChar      =    NULL;\n\n       mChar      =    0;\n</code></pre><h1 id=\"3-文档及注释\"><a href=\"#3-文档及注释\" class=\"headerlink\" title=\"3.    文档及注释\"></a>3.    文档及注释</h1><p>应当使用文档自动生成工具，来生成相关的程序文档。</p>\n<h2 id=\"3-1-文件或程序库的文档注释（适用于C-C-）\"><a href=\"#3-1-文件或程序库的文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.1. 文件或程序库的文档注释（适用于C/C++）\"></a>3.1. 文件或程序库的文档注释（适用于C/C++）</h2><p>可以为整个文件编写文档。</p>\n<p>例如：</p>\n<pre><code>    /** @file file.h\n\n     * Abrief file description.\n\n     * Amore elaborated file description.\n\n     */\n</code></pre><h2 id=\"3-2-类文档注释（适用于C-C-）\"><a href=\"#3-2-类文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.2. 类文档注释（适用于C/C++）\"></a>3.2. 类文档注释（适用于C/C++）</h2><p>在类定义前面应加上类说明文档。</p>\n<p>例如：</p>\n<pre><code>    /** WindowsNT\n\n     *  @brief Windows Nice Try.\n\n     *  @author Bill Gates\n\n     *  @author Several species of small furryanimals gathered together\n\n     *          in a cave and grooving with a pict.\n\n     *  @version 4.0\n\n     *  @date   1996-1998\n\n     *  @bug It crashes a lot and requires hugeamounts of memory.\n\n     *  @bug The class introduces the more bugs, thelonger it is used.\n\n     *  @warning This class may explode in your face.\n\n     *  @warning If you inherit anything from thisclass, you&#39;re doomed.\n\n     */\n\n    class WindowsNT {};\n</code></pre><h2 id=\"3-3-函数文档注释（适用于C-C-）\"><a href=\"#3-3-函数文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.3. 函数文档注释（适用于C/C++）\"></a>3.3. 函数文档注释（适用于C/C++）</h2><p>²  函数注释</p>\n<p>所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如：</p>\n<pre><code>      /**\n\n       * 赋值操作符\n\n       *\n\n       *@param val 将要赋给本对象的值\n\n       *\n\n       *@return 本对象的引用\n\n       */\n\n      XX&amp;  operator =(XX&amp; val);\n</code></pre><p>²  注释属性</p>\n<p>一些自动文档工具定义的属性可以包含在文档中，常用的有：</p>\n<p>n  前提条件 (pre)<br>定义调用这个函数的前提条件</p>\n<p>n  警告说明 (warning)<br>定义一些关于这个函数必须知道的事情。</p>\n<p>n  备注说明 (remarks)<br>定义一些关于这个函数的备注信息。</p>\n<p>n  将要完成的工作 (todo)<br>说明哪些事情将在不久以后完成</p>\n<p>n  使用例子说明 (example)<br>一个图片能表达100句话，一个好的例子能解答1000个问题。</p>\n<p>例如：</p>\n<pre><code>      /**\n\n       * 复制一个字串\n\n       *\n\n       *@pre\n\n       *     - 需要保证(from != 0)\n\n       *     - 需要保证(to != 0)\n\n       *\n\n       *@warning\n\n       * 缓冲区必需足够大，以便容纳的下要拷贝的字串。\n\n       *\n\n       *@example teststrcpy.cpp\n\n       *\n\n       *@param from 要拷贝的字串\n\n       *@param to 用于容纳字串的缓冲区\n\n       *@return void\n\n       */\n\n      void  strcpy(constchar* from, char* to);\n</code></pre><h2 id=\"3-4-Include-语句注释-（适用于C-C-）\"><a href=\"#3-4-Include-语句注释-（适用于C-C-）\" class=\"headerlink\" title=\"3.4. Include 语句注释 （适用于C/C++）\"></a>3.4. Include 语句注释 （适用于C/C++）</h2><p>²  如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。</p>\n<h2 id=\"3-5-语句块注释（适用于C-C-）\"><a href=\"#3-5-语句块注释（适用于C-C-）\" class=\"headerlink\" title=\"3.5.语句块注释（适用于C/C++）\"></a>3.5.语句块注释（适用于C/C++）</h2><p>²  语句块的注释可以用在语句块的开头和结束位置：</p>\n<pre><code>    { \n\n        // Block1 (meaningful comment about Block1)\n\n        ... some code\n\n\n\n        { \n\n            // Block2 (meaningful comment about Block2)\n\n            ... somecode\n\n        }  // End Block2\n\n\n\n    }  // End Block1\n</code></pre><h1 id=\"4-编码要求\"><a href=\"#4-编码要求\" class=\"headerlink\" title=\"4.    编码要求\"></a>4.    编码要求</h1><h2 id=\"4-1-不要忽略编译器的警告（适用于C-C-）\"><a href=\"#4-1-不要忽略编译器的警告（适用于C-C-）\" class=\"headerlink\" title=\"4.1. 不要忽略编译器的警告（适用于C/C++）\"></a>4.1. 不要忽略编译器的警告（适用于C/C++）</h2><p>²  编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。</p>\n<h2 id=\"4-2-应使用源代码管理器（适用于C-C-）\"><a href=\"#4-2-应使用源代码管理器（适用于C-C-）\" class=\"headerlink\" title=\"4.2. 应使用源代码管理器（适用于C/C++）\"></a>4.2. 应使用源代码管理器（适用于C/C++）</h2><p>²  根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。</p>\n<h2 id=\"4-3-固有的类方法成员（适用于C-）\"><a href=\"#4-3-固有的类方法成员（适用于C-）\" class=\"headerlink\" title=\"4.3. 固有的类方法成员（适用于C++）\"></a>4.3. 固有的类方法成员（适用于C++）</h2><p>²  默认构造函数(DefaultConstructor)</p>\n<p>如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。</p>\n<p>²  虚析构函数(Virtual Destructor)</p>\n<p>如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。</p>\n<p>²  拷贝构造函数(Copy Constructor)</p>\n<p>如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。</p>\n<p>²  赋值操作(AssignmentOperator)</p>\n<p>如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。</p>\n<h2 id=\"4-4-使用命名空间-（适用于C-）\"><a href=\"#4-4-使用命名空间-（适用于C-）\" class=\"headerlink\" title=\"4.4. 使用命名空间 （适用于C++）\"></a>4.4. 使用命名空间 （适用于C++）</h2><p>²  命名规则</p>\n<p>根名字一般是设计者的名字。比如公司名称等等。</p>\n<p>²  不要在全局空间使用using语句。</p>\n<h2 id=\"4-5-初始化所有的变量-（适用于C-C-）\"><a href=\"#4-5-初始化所有的变量-（适用于C-C-）\" class=\"headerlink\" title=\"4.5. 初始化所有的变量 （适用于C/C++）\"></a>4.5. 初始化所有的变量 （适用于C/C++）</h2><p>²  无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。</p>\n<h2 id=\"4-6-保持函数短小精悍（适用于C-C-）\"><a href=\"#4-6-保持函数短小精悍（适用于C-C-）\" class=\"headerlink\" title=\"4.6. 保持函数短小精悍（适用于C/C++）\"></a>4.6. 保持函数短小精悍（适用于C/C++）</h2><p>²  一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。</p>\n<h2 id=\"4-7-对空语句进行注释-（适用于C-C-）\"><a href=\"#4-7-对空语句进行注释-（适用于C-C-）\" class=\"headerlink\" title=\"4.7.对空语句进行注释 （适用于C/C++）\"></a>4.7.对空语句进行注释 （适用于C/C++）</h2><p>²  For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如：</p>\n<pre><code>       while(*dest++ = *srC++)\n\n          ;         // VOID\n</code></pre><p>²  不允许写成：</p>\n<pre><code>       while (*dest++ = *srC++) ;   // 绝对不允许这么写\n</code></pre><h2 id=\"4-8-不要用if语句的默认方法测试非零值（适用于C-C-）\"><a href=\"#4-8-不要用if语句的默认方法测试非零值（适用于C-C-）\" class=\"headerlink\" title=\"4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）\"></a>4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）</h2><p>²  If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如：</p>\n<p>建议使用：</p>\n<pre><code>       if (FAIL != f())\n</code></pre><p>不建议使用下面的表达式：</p>\n<pre><code>       if (f())\n</code></pre><p>²  宏定义的情况也一样：</p>\n<pre><code>       #define STREQ(a,b) (strcmp((a), (b)) == 0)\n</code></pre><p>或者使用内联函数：</p>\n<pre><code>       inline bool\n\n      StringEqual(char* a, char* b)\n\n       {\n\n          (strcmp(a, b)== 0) ? return true : return false;\n\n           Or more compactly:\n\n          returnstrcmp(a, b) == 0;\n\n       }\n</code></pre><h2 id=\"4-9-布尔类型-（适用于C-C-）\"><a href=\"#4-9-布尔类型-（适用于C-C-）\" class=\"headerlink\" title=\"4.9.布尔类型 （适用于C/C++）\"></a>4.9.布尔类型 （适用于C/C++）</h2><p>²  早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。</p>\n<p>早期的布尔类型定义为：</p>\n<pre><code>       typedef int     bool;\n\n       #defineTRUE    1\n\n       #defineFALSE   0\n</code></pre><p>或：</p>\n<pre><code>       const intTRUE  = 1;\n\n       const int FALSE= 0;\n</code></pre><p>²  在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如：</p>\n<pre><code>       if (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？\n</code></pre><p>必须写成：</p>\n<pre><code>       if (FALSE !=func()) { ...\n</code></pre><h2 id=\"4-10-避免在语句中内含赋值-（适用于C-C-）\"><a href=\"#4-10-避免在语句中内含赋值-（适用于C-C-）\" class=\"headerlink\" title=\"4.10.   避免在语句中内含赋值 （适用于C/C++）\"></a>4.10.   避免在语句中内含赋值 （适用于C/C++）</h2><p>²  只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如：</p>\n<pre><code>       while (EOF != (c= getchar()))\n\n       {\n\n          process thecharacter\n\n       }\n</code></pre><p>²  ++ 和 – 操作也是一种赋值语句</p>\n<p>²  内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如：</p>\n<pre><code>       a = b + c;\n\n       d = a + r;\n</code></pre><p>不应该写成：</p>\n<pre><code>           d = (a = b + c)+ r;\n</code></pre><h2 id=\"4-11-正确的使用Const-（适用于C-C-）\"><a href=\"#4-11-正确的使用Const-（适用于C-C-）\" class=\"headerlink\" title=\"4.11.   正确的使用Const （适用于C/C++）\"></a>4.11.   正确的使用Const （适用于C/C++）</h2><p>²  C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。</p>\n<h2 id=\"4-12-不要在头文件定义数据（适用于C-C-）\"><a href=\"#4-12-不要在头文件定义数据（适用于C-C-）\" class=\"headerlink\" title=\"4.12.    不要在头文件定义数据（适用于C/C++）\"></a>4.12.    不要在头文件定义数据（适用于C/C++）</h2><p>不要把数据定义放在头文件，如：</p>\n<pre><code>    /*\n\n     * aheader.h\n\n     */\n\n    int x = 0;\n</code></pre><h2 id=\"4-13-不要直接使用数字-（适用于C-C-）\"><a href=\"#4-13-不要直接使用数字-（适用于C-C-）\" class=\"headerlink\" title=\"4.13.   不要直接使用数字 （适用于C/C++）\"></a>4.13.   不要直接使用数字 （适用于C/C++）</h2><p>²  直接使用数字，会使源代码难以理解和维护。如：</p>\n<pre><code>    if      (22 ==foo)    { start_thermo_nuclear_war(); }\n\n    else if (19 == foo)    {refund_lotso_money(); }\n\n    else if (16 == foo)    {infinite_loop(); }\n\n    else                   { cry_cause_im_lost(); }\n</code></pre><p>当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。</p>\n<p>²  我们可以用#define或者常量来改变这一状况，如：</p>\n<pre><code>    #define  PRESIDENT_WENT_CRAZY  (22)\n\n    const int WE_GOOFED= 19;\n\n    enum\n\n    {\n\n        THEY_DIDNT_PAY=16\n\n    };\n\n\n\n    if (PRESIDENT_WENT_CRAZY    == foo) { start_thermo_nuclear_war(); }\n\n    else if (WE_GOOFED          == foo)  {refund_lotso_money(); }\n\n    else if (THEY_DIDNT_PAY     == foo) { infinite_loop();}\n\n    else                                 {happy_days_i_know_why_im_here(); }\n</code></pre><h2 id=\"4-14-宏（适用于C-C-）\"><a href=\"#4-14-宏（适用于C-C-）\" class=\"headerlink\" title=\"4.14.    宏（适用于C/C++）\"></a>4.14.    宏（适用于C/C++）</h2><p>²  如果可以，使用内联函数代替宏。</p>\n<p>例如：</p>\n<pre><code>    #ifndef MAX\n\n    #define  MAX(x,y)  (((x) &gt; (y) ? (x) : (y))    // 取最大数\n\n    #endif\n</code></pre><p>使用内联函数可以达到相同的效果，而且更安全：</p>\n<pre><code>       inline int\n\n       max(int x, inty)\n\n       {\n\n          return (x&gt; y ? x : y);\n\n       }\n</code></pre><p>²  要注意副作用</p>\n<p>必须小心副作用，因为在调用表达式时，会发生潜在的错误。</p>\n<p>例如：</p>\n<pre><code>       MAX(f(x),z++);\n</code></pre><p>²  表达式总是用括号括起来</p>\n<p>在宏展开时，使用括号可以避免宏展开后产生的二义性。</p>\n<p>例如：</p>\n<pre><code>    #define ADD(x,y) x + y\n</code></pre><p>必须写成：</p>\n<pre><code>    #define ADD(x,y) ((x) + (y))\n</code></pre><p>²  保证宏名称的唯一性</p>\n<p>和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题：</p>\n<p>n  在宏名称前加上库的名字<br>避免使用简单而常用的名字，如：MAX 和MIN。</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/07/c++代码规范/","excerpt":"命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C+ 命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C++ 12 静态变量的命名前缀 适用于C 13 自定义类型typedef的命名 适用于C++ 14 宏定义的命名 适用于C++ 15 C 函数的命名 适用于C++ 16 枚举的命名 适用于C++ 排版规则 1 布局和模板 11 类的布局模板 适用于C 12 源文件格式 适用于C 13 保护头文件不被重复包含 适用于C++ 14 方法和函数的布局 适用于C++ 2 缩进制表符以及空格 适用于C++ 3 尽量使一行不要超过78个字母 适用于C++ 4 保证一行只写一条语句 适用于C++ 5 花括号 规则 适用于C++ 51 花括号的位置 52 什么时候应使用花括号 53 在花括号结束的位置加上注释 54 注意屏幕大小 6圆括号 规则 适用于C++ 7if else 语句的格式 适用于C++ 8switch 格式 适用于C++ 9 使用gotocontinuebreak 和 适用于C++ 91 Goto 92 Continue and Break 93 10 运算符号的规则 适用于C++ 11 变量声明语句块 适用于C++ 文档及注释 1 文件或程序库的文档注释 适用于C++ 2 类文档注释 适用于C++ 3 函数文档注释 适用于C++ 4 Include 语句注释 适用于C++ 5语句块注释 适用于C++ 编码要求 1 不要忽略编译器的警告 适用于C++ 2 应使用源代码管理器 适用于C++ 3 固有的类方法成员 适用于C 4 使用命名空间 适用于C 5 初始化所有的变量 适用于C++ 6 保持函数短小精悍 适用于C++ 7对空语句进行注释 适用于C++ 8不要用if语句的默认方法测试非零值 适用于C++ 9布尔类型 适用于C++ 10避免在语句中内含赋值 适用于C++ 11正确的使用Const 适用于C++ 12不要在头文件定义数据适用于C++ 13不要直接使用数字 适用于C++ 14宏 适用于C++","categories":[{"name":"代码规范","slug":"代码规范","permalink":"https://prostkhala.github.io/categories/代码规范/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://prostkhala.github.io/tags/代码规范/"}]}]}