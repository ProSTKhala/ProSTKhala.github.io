{"meta":{"title":"ST","subtitle":"A HAOIER","description":"每一个不曾起舞的日子，都是对于生命的辜负。","author":"ST","url":"https://prostkhala.github.io"},"pages":[{},{},{}],"posts":[{"title":"AC自动机总结","date":"2017-12-01T03:11:11.000Z","path":"2017/12/01/AC自动机总结/","text":"AC自动机（简单版） 题目描述给定n个模式串和1个文本串，求有多少个模式串在文本串里出现过。 输入输出格式输入格式:第一行一个n，表示模式串个数； 下面n行每行一个模式串； 下面一行一个文本串。 输出格式：一个数表示答案。 输入输出样例输入样例：2 a aa aa 输出样例：2 题解AC自动机裸题，如果不加last优化会TLE。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e6+1; int ch[N][26],f[N],cnt; int l[N]; int tag[N]; void add(char *s){ int n=strlen(s); int x=0; for(int i=0;i&lt;n;++i){ int c=s[i]-&#39;a&#39;; if(ch[x][c]==-1){ ch[x][c]=++cnt; for(int j=0;j&lt;26;++j)ch[cnt][j]=-1; } x=ch[x][c]; } tag[x]++; } void getfail(){ queue&lt;int&gt;q; for(int i=0;i&lt;26;++i) if(~ch[0][i])l[ch[0][i]]=f[ch[0][i]]=0,q.push(ch[0][i]); else ch[0][i]=0; // static int g[N]; while(!q.empty()){ int x=q.front();q.pop(); for(int i=0;i&lt;26;++i){ if(tag[ch[f[x]][i]])l[ch[x][i]]=ch[f[x]][i]; else l[ch[x][i]]=l[ch[f[x]][i]]; if(~ch[x][i])f[ch[x][i]]=ch[f[x]][i],q.push(ch[x][i]); else ch[x][i]=ch[f[x]][i]; } } } bool vis[N]; int get(char *s){ int n=strlen(s); int x=0,ret=0; for(int i=0;i&lt;n;++i){ x=ch[x][s[i]-&#39;a&#39;]; for(int j=x;j;j=l[j]) if(!vis[j])vis[j]=1,ret+=tag[j]; } return ret; } int n; char s[N]; int main(){ // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n; for(int i=0;i&lt;26;++i)ch[0][i]=-1; for(int i=0;i&lt;n;++i)scanf(&quot;%s&quot;,s),add(s); getfail(); scanf(&quot;%s&quot;,s); cout&lt;&lt;get(s)&lt;&lt;endl; } AC自动机（加强版） 题目描述有N个由小写字母组成的模式串以及一个文本串T。每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串T中出现的次数最多。 输入输出格式输入格式:输入含多组数据。 每组数据的第一行为一个正整数N，表示共有N个模式串，$1≤N≤150$。 接下去N行，每行一个长度小于等于$70$的模式串。下一行是一个长度小于等于$10^6$的文本串T。 输入结束标志为$N=0$。 输出格式：对于每组数据，第一行输出模式串最多出现的次数，接下去若干行每行输出一个出现次数最多的模式串，按输入顺序排列。 输入输出样例输入样例：2 aba bab ababababac 6 beta alpha haha delta dede tata dedeltalphahahahototatalpha 0 输出样例：4 aba 2 alpha haha 题解AC自动机裸题。不加last优化也能过，多组数据注意清零。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e6+1; int tr[N][26],f[N],cnt,ans[N]; int l[N]; int tag[N]; void add(char *s,int fa){ int n=strlen(s); int x=0; for(int i=0;i&lt;n;++i){ int c=s[i]-&#39;a&#39;; if(tr[x][c]==-1){ tr[x][c]=++cnt; for(int j=0;j&lt;26;++j)tr[cnt][j]=-1; } x=tr[x][c]; } tag[x]=fa; } void getfail(){ queue&lt;int&gt;q; for(int i=0;i&lt;26;++i) if(~tr[0][i])l[tr[0][i]]=f[tr[0][i]]=0,q.push(tr[0][i]); else tr[0][i]=0; while(!q.empty()){ int x=q.front();q.pop(); for(int i=0;i&lt;26;++i){ if(tr[x][i]==-1){tr[x][i]=tr[f[x]][i];continue;} int y=tr[x][i]; q.push(y); f[y]=tr[f[x]][i]; // l[y]=tag[f[y]]?f[y]:l[f[y]]; } } } bool vis[N]; void get(char *s){ int n=strlen(s); int x=0,ret=0; for(int i=0;i&lt;n;++i){ x=tr[x][s[i]-&#39;a&#39;]; for(int j=x;j;j=f[j]) if(tag[j])ans[tag[j]]++; } } int n; char s[256][256]; char s1[N]; void put(char *s){ int n=strlen(s); for(int i=0;i&lt;n;++i)putchar(s[i]); printf(&quot;\\n&quot;); } int main(){ while(scanf(&quot;%d&quot;,&amp;n)!=EOF){ if(!n)return 0; cnt=0; for(int i=0;i&lt;26;++i)tr[0][i]=-1; for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s[i]),add(s[i],i); getfail(); scanf(&quot;%s&quot;,s1);get(s1); int res=*max_element(ans+1,ans+n+1); printf(&quot;%d\\n&quot;,res); for(int i=1;i&lt;=n;++i)if(ans[i]==res)put(s[i]); for(int i=1;i&lt;=n;++i)ans[i]=0; for(int i=1;i&lt;=cnt;++i)tag[i]=f[i]=l[i]=0; } } HNOI2006 最短母串 题目描述给定n个字符串（S1,S2,„,Sn），要求找到一个最短的字符串T，使得这n个字符串（S1,S2,„,Sn）都是T的子串。 输入输出格式输入格式:第一行是一个正整数n（n&lt;=12），表示给定的字符串的个数。以下的n行，每行有一个全由大写字母组成的字符串。每个字符串的长度不超过50。 输出格式：只有一行，为找到的最短的字符串T。在保证最短的前提下，如果有多个字符串都满足要求，那么必须输出按字典序排列的第一个。 输入输出样例输入样例：2 ABCD BCDABC 输出样例：ABCDABC 题解考虑$n$很小的性质，第一眼以为是状态压缩DP暴力转移（实际也能做，但是很难写），正解应该是将在AC自动机上DP。根据AC自动机的性质，易知一条路径即代表一个字符串。设$f[i][S]$表示当前走到第$i$号节点，已经覆盖串的集合为$S$的最小步数状态数为$n502^n$，直接用BFS更新即可。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 6e2+5; int read(){ int x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=x*10+ch-&#39;0&#39;,ch=getchar(); return x; } char s[13][51]; int n; struct kd{ int x,y; }X,Y; struct AC{ int cnt,tr[N][26],f[N],tag[N],pos[N]; int d[N][1&lt;&lt;12]; int prex[N][1&lt;&lt;12],prey[N][1&lt;&lt;12]; void init(){ cnt=0; memset(tr[0],-1,sizeof(tr[0])); } void add(char *s,int k){ int n=strlen(s); int x=0; for(int i=0;i&lt;n;++i){ int c=s[i]-&#39;A&#39;; if(tr[x][c]==-1){ tr[x][c]=++cnt; pos[cnt]=c; memset(tr[cnt],-1,sizeof(tr[cnt])); tag[cnt]=0; } x=tr[x][c]; } tag[x]|=1&lt;&lt;k; } void getf(){ queue&lt;int&gt;q; f[0]=0; for(int i=0;i&lt;26;++i) if(~tr[0][i])f[tr[0][i]]=0,q.push(tr[0][i]); else tr[0][i]=0; while(!q.empty()){ int x=q.front();q.pop(); tag[x]|=tag[f[x]]; for(int i=0;i&lt;26;++i){ if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]); else tr[x][i]=tr[f[x]][i]; } } } void output(int x,int y){ static int q[N]; while(x){ q[++q[0]]=pos[x]+&#39;A&#39;; int x1=x,y1=y; x=prex[x1][y1]; y=prey[x1][y1]; } reverse(q+1,q+q[0]+1); for(int i=1;i&lt;=q[0];++i)printf(&quot;%c&quot;,(char)q[i]); } void solve(){ getf(); int S=(1&lt;&lt;n)-1; memset(d,-1,sizeof(d)); queue&lt;kd&gt;q; X.x=0;X.y=0; q.push(X);d[0][0]=0; prex[0][0]=0;prey[0][0]=0; while(!q.empty()){ X=q.front();q.pop(); for(int i=0;i&lt;26;++i) if(tr[X.x][i]){ int to=tr[X.x][i]; Y.x=to;Y.y=X.y|tag[to]; if(d[Y.x][Y.y]==-1){ prex[Y.x][Y.y]=X.x;prey[Y.x][Y.y]=X.y; d[Y.x][Y.y]=d[X.x][X.y]+1; if(Y.y==S){ // printf(&quot;%d\\n&quot;,d[Y.x][Y.y]); output(Y.x,Y.y); printf(&quot;\\n&quot;); exit(0); } q.push(Y); } } } } }T; int main(){ scanf(&quot;%d&quot;,&amp;n); T.init(); for(int i=0;i&lt;n;++i){ scanf(&quot;%s&quot;,s[i]); T.add(s[i],i); } T.solve(); } Beijing2017 魔法咒语 题目描述Chandra 是一个魔法天才。 从一岁时接受火之教会洗礼之后， Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。直到十四岁，开始学习威力强大的禁咒法术时， Chandra 才遇到了障碍。根据火之魔法规则，禁咒的构成单位是 N 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 L 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时， Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。很多年过去了，在一次远古遗迹探险中， Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。 Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 M 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。例如，若 ”banana” 是唯一的忌讳词语， “an”、 ”ban”、 ”analysis” 是基本词汇，禁咒长度须是 11， 则“bananalysis” 是无效法术， ”analysisban”、 ”anbanbanban”是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、 一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。谜题破解， Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。由于答案可能很大，你需要输出答案模 1,000,000,007的结果。 输入输出格式输入格式:第一行，三个正整数 N, M, L。接下来 N 行，每行一个只含小写英文字母的字符串，表示一个基本词汇。接下来 M 行，每行一个只含小写英文字母的字符串，表示一个忌讳词语。对于60%的数据1&lt;=N,M&lt;=50,L&lt;=100对于另40%数据基本词汇长度不超过2,L&lt;=10^8 输出格式：仅一行，一个整数，表示答案（模 10^9+7）。 输入输出样例输入样例：4 2 10 boom oo ooh bang ob mo 输出样例：14 样例解释有效的禁咒法术共有 14 种：boom/bang/oo，oo/oo/oo/oo/oo，oo/oo/ooh/ooh，oo/ooh/oo/ooh， oo/ooh/ooh/oo， ooh/oo/oo/ooh， ooh/oo/ooh/oo，ooh/ooh/boom， ooh/ooh/oo/oo， ooh/ooh/bang，ooh/bang/ooh，bang/oo/oo/oo， bang/ooh/ooh， bang/bang/oo。 题解设$f[i][L]$为走到第$i$号节点，此时字符串长度（即路径长度）为$L$的方案数，那么由于字符集在此题中被限制为了一个个的字符串，所以需要预处理$go[i][j]$表示从$i$号节点出发后经过第$j$个基本词汇后所到达的节点，如果其中经过禁忌词语，则初始化为-1表示不可到达。那么DP方程如下：（$len[j]$表示基本词汇$j$的长度） $$f[go [i] [j] ][ L + len[j] ] += f[i][L] (go[i][j]!=-1)$$ 观察数据范围，朴素的DP只能通过$60%$的数据，剩余$L&lt;=10^8$且$len[j]&lt;=2$的部分分，可以通过矩阵乘法优化，同先前的DNA Sequence一样，用$f[i][j]$表示从$i$号节点一步到达$j$号节点的方案数，可以处理$len[j]=1$的情况。对于$len[j]=2$的情况，对于每个节点$i$设一个虚拟节点$b[i]$，然后$f[i][b[j]]$表示从$i$一步到$b[j]$的方案数，再从$b[j]$向$j$连一条边即可（即$f[b[j]][j]=1$）。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 5e3+1; const ll mod = 1e9+7; int n,m,L,cnt,len[51]; char a[51][401],b[51][401]; void mul(int &amp;a,int b){ a+=b; if(a&gt;=mod)a-=mod; } int t1k; struct Matrix{ ll a[401][401]; friend Matrix operator * (Matrix a,Matrix b){ Matrix c; memset(c.a,0,sizeof(c.a)); for(int i=0;i&lt;=t1k;++i) for(int j=0;j&lt;=t1k;++j){ for(int k=0;k&lt;=t1k;++k) (c.a[i][j]+=a.a[i][k]*b.a[k][j])%=mod; } return c; } }res,c; struct AC{ int tr[N][26],f[N],tag[N],val[N],to[N][51]; void init(){ cnt=0; memset(tr[0],-1,sizeof(tr[0])); } void add(char *s,int h){ int x=0; int n=strlen(s); for(int i=0;i&lt;n;++i){ int c=s[i]-&#39;a&#39;; if(tr[x][c]==-1){ tr[x][c]=++cnt; val[cnt]=i; memset(tr[cnt],-1,sizeof(tr[cnt])); } x=tr[x][c]; } tag[x]=h; } void getf(){ queue&lt;int&gt;q; for(int i=0;i&lt;26;++i) if(~tr[0][i])f[tr[0][i]]=0,q.push(tr[0][i]); else tr[0][i]=0; while(!q.empty()){ int x=q.front();q.pop(); tag[x]|=tag[f[x]]; for(int i=0;i&lt;26;++i) if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]); else tr[x][i]=tr[f[x]][i]; } } int go(int i,char *s){ int n=strlen(s); int x=i; if(tag[x])return -1; for(int j=0;j&lt;n;++j){ x=tr[x][s[j]-&#39;a&#39;]; if(tag[x])return -1; } return x; } void A(){ static int dp[N][101]; dp[0][0]=1; for(int l=0;l&lt;=L;++l) for(int i=0;i&lt;=cnt;++i) for(int j=0;j&lt;n;++j) if(len[j]+l&lt;=L){ int y=to[i][j]; if(y==-1)continue; mul(dp[y][len[j]+l],dp[i][l]); } int ans=0; for(int i=0;i&lt;=cnt;++i)mul(ans,dp[i][L]); printf(&quot;%d\\n&quot;,ans); } void B(){ t1k=2*cnt+1; int tp=cnt+1; for(int i=0;i&lt;=cnt;++i)res.a[i+tp][i]=1; for(int i=0;i&lt;=2*cnt+1;++i)c.a[i][i]=1; for(int i=0;i&lt;=cnt;++i) for(int j=0;j&lt;n;++j){ int y=to[i][j]; if(y==-1)continue; if(len[j]==1)res.a[i][y]++; else res.a[i][y+tp]++; } while(L){ if(L&amp;1)c=c*res; L&gt;&gt;=1; res=res*res; } ll ans=0; for(int i=0;i&lt;=cnt;++i)(ans+=c.a[0][i])%=mod; printf(&quot;%lld\\n&quot;,ans); } void solve(){ init(); for(int i=0;i&lt;m;++i)add(b[i],1); getf(); for(int i=0;i&lt;=cnt;++i) for(int j=0;j&lt;n;++j) to[i][j]=go(i,a[j]); if(L&lt;=100)A(); else B(); } }T; int main(){ // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;L); for(int i=0;i&lt;n;++i)scanf(&quot;%s&quot;,a[i]),len[i]=strlen(a[i]); for(int i=0;i&lt;m;++i)scanf(&quot;%s&quot;,b[i]); T.solve(); } /* 4 2 98 bo oo hm ba ob mho */ BeiJing2011 禁忌 题目描述Magic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力…… 如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。 这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。 为了说明什么是禁忌魔法及其伤害，引入以下概念： 字母集A上的每个非空字符串对应了一个魔法。其中A是包含了前alphabet个小写字母的集合。 有一个集合T，包含了N个字母集A上的字符串.T中的每一串称为一个禁忌串（Taboo string） 一个魔法，或等价地，其对应的串s因为包含禁忌而对使用者造成的伤害按以下方式确定：把s分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。 由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集A上所有长度为len的串。 但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。 你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。 输入输出格式输入格式:第一行包含三个正整数N、len、alphabet。接下来N行，每行包含一个串Ti，表示禁忌串。 输出格式：一个非负实数，表示所受到禁忌伤害的期望值。 输入输出样例输入样例：2 4 2 aa abb 输出样例：0.75 数据范围100%的数据中N ≤ 5，len ≤109，1 ≤ alphabet ≤ 26。 在所有数据中，有不少于40%的数据中：N = 1。 数据保证每个串Ti的长度不超过15，并且不是空串。 数据保证每个Ti均仅含有前alphabet个小写字母。 数据保证集合T中没有相同的元素，即对任意不同的i和j，有Ti≠Tj。 题解首先考虑对于一个给定的串，如何求其禁忌伤害，这是一个经典的贪心问题，即线段覆盖问题，正确的姿势是按右端点排序，能取的尽量取即可，如果去除存在覆盖的禁忌串（一定没有只取被覆盖的子串优越），那么姿势等价于按左端点排序，且尽可能的取。 考虑在AC自动机上的贪心，即为从根节点出发每次走到一个禁忌串后，直接返回根节点（因为禁忌串之间不能相互覆盖），重复过程直到路径长度为$L$并将答案加上返回次数除以 $2^{len}$ ，考虑如何用DP优化此过程，仍然设$f[i][L]$表示走到$i$号节点，路径长度为$L$的概率，那么显然有（0表示根节点,$tag$表示是否为禁忌串。） $$f[0][L+1]+=f[i][L]+1/alphabet （tag[tr[x][i]]=1）$$ $$f[tr[x][i]][L+1]+=f[i][L]+1/alphabet （tag[tr[x][i]]=0）$$ 考虑如何将统计答案。在贪心的过程中，每次访问到禁忌串时不仅要返回根节点，还要将答案加上到当前节点的概率，即新建一个节点$g$表示答案节点，那么同样有$$f[g][L+1]+=f[i][L]+1/alphabet （tag[tr[x][i]]=1）$$ 即可以用矩阵乘法优化此过程，并且需要设定$matrix[g][g]=1$，矩阵$L$次方代表$1-L$前缀和的贡献，即为答案。 CODE#include&lt;bits/stdc++.h&gt; #define mp make_pair #define fr first #define sd second #define pii pair&lt;int,int&gt; using namespace std; typedef long long ll; typedef long double db; const int N = 1e2+1; int cnt,n,L,ml,len[6],tr[N][26],f[N],tag[N]; char s[6][N]; struct matrix{ db a[N][N]; friend matrix operator * (matrix a,matrix b){ matrix c; for(int i=0;i&lt;=cnt+1;++i) for(int j=0;j&lt;=cnt+1;++j) c.a[i][j]=0; for(int i=0;i&lt;=cnt+1;++i) for(int j=0;j&lt;=cnt+1;++j) for(int k=0;k&lt;=cnt+1;++k) c.a[i][j]+=a.a[i][k]*b.a[k][j]; return c; } }res; matrix qpow(ll b){ matrix c; for(int i=0;i&lt;=cnt+1;++i) for(int j=0;j&lt;=cnt+1;++j) c.a[i][j]=(i==j); while(b){ if(b&amp;1)c=c*res; b&gt;&gt;=1; res=res*res; } return c; } void solve(){ db k=1.00/(db)ml; for(int i=0;i&lt;=cnt;++i) for(int j=0;j&lt;ml;++j){ int y=tr[i][j]; if(tag[y])res.a[i][0]+=k,res.a[i][cnt+1]+=k; else res.a[i][y]+=k; } res.a[cnt+1][cnt+1]=1; printf(&quot;%.8lf&quot;,(double)qpow(L).a[0][cnt+1]); } int add(char *s){ int n=strlen(s),x=0; for(int i=0;i&lt;n;++i){ int c=s[i]-&#39;a&#39;; if(tr[x][c]==-1){ tr[x][c]=++cnt; memset(tr[cnt],-1,sizeof(tr[cnt])); } x=tr[x][c]; } tag[x]=1; return n; } void getf(){ queue&lt;int&gt;q; for(int i=0;i&lt;ml;++i) if(~tr[0][i])f[tr[0][i]]=0,q.push(tr[0][i]); else tr[0][i]=0; while(!q.empty()){ int x=q.front();q.pop(); tag[x]|=tag[f[x]]; for(int i=0;i&lt;ml;++i){ if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]); else tr[x][i]=tr[f[x]][i]; } } } int main(){ // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); memset(tr[0],-1,sizeof(tr[0])); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;ml); for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s[i]),len[i]=add(s[i]); getf(); solve(); } SCOI2012 喵星球上的点名 题目描述a180285幸运地被选做了地球到喵星球的留学生。他发现喵星人在上课前的点名现象非常有趣。 假设课堂上有N个喵星人，每个喵星人的名字由姓和名构成。喵星球上的老师会选择M个串来点名，每次读出一个串的时候，如果这个串是一个喵星人的姓或名的子串，那么这个喵星人就必须答到。 然而，由于喵星人的字码过于古怪，以至于不能用ASCII码来表示。为了方便描述，a180285决定用数串来表示喵星人的名字。现在你能帮助a180285统计每次点名的时候有多少喵星人答到，以及M次点名结束后每个喵星人答到多少次吗？ 输入输出格式输入格式:现在定义喵星球上的字符串给定方法： 先给出一个正整数L，表示字符串的长度，接下来L个整数表示字符串的每个字符。 输入的第一行是两个整数N和M。 接下来有N行，每行包含第i 个喵星人的姓和名两个串。姓和名都是标准的喵星球上的字符串。 接下来有M行，每行包含一个喵星球上的字符串，表示老师点名的串。 输出格式：对于每个老师点名的串输出有多少个喵星人应该答到。 然后在最后一行输出每个喵星人被点到多少次。 输入输出样例输入样例：2 3 6 8 25 0 24 14 8 6 18 0 10 20 24 0 7 14 17 8 7 0 17 0 5 8 25 0 24 0 4 8 25 0 24 4 7 0 17 0 4 17 0 8 25 输出样例：2 1 0 1 2 数据范围 对于30%的数据，保证： 1&lt;=N,M&lt;=1000，喵星人的名字总长不超过4000，点名串的总长不超过2000。 对于100%的数据，保证： 1&lt;=N&lt;=20000，1&lt;=M&lt;=50000，喵星人的名字总长和点名串的总长分别不超过100000，保证喵星人的字符串中作为字符存在的数不超过10000。 题解由于本题中字符集过大，肯定不能将数组开满，需要用$map$来存储儿子，且不能在每次新建节点时将儿子都表示成$-1$，那么就要默认为$0$。同理需要将根节点设为$1$，并赋值$tr[0][i]=1$，在$getfail$的时候，也应该直接暴力跳$fail$。由于数据较水，这样即可通过此题。（正解为后缀数组+主席树） CODE#include&lt;bits/stdc++.h&gt; #define pb push_back using namespace std; typedef long long ll; const int N = 1e5+5; map&lt;int,int&gt;tr[N]; map&lt;int,int&gt;::iterator it; int n,m,L,cnt,f[N],g[N],ans[N],res[N],id[N]; int vis[N],vis1[N],T; vector&lt;int&gt;a[N],b[N],tag[N]; int read(){ int x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;,ch=getchar(); return x; } void add(int *s,int n,int fa){ int x=1; for(int i=1;i&lt;=n;++i){ int c=s[i]; if(!tr[x][c])tr[x][c]=++cnt; x=tr[x][c]; } tag[x].pb(fa); } void getf(){ queue&lt;int&gt;q; q.push(1); while(!q.empty()){ int x=q.front();q.pop(); for(it=tr[x].begin();it!=tr[x].end();++it){ int t=it-&gt;first,k=f[x]; while(!tr[k][t])k=f[k]; f[it-&gt;second]=tr[k][t]; q.push(it-&gt;second); } // for(int i=0;i&lt;L;++i){ // if(tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]); // else tr[x][i]=tr[f[x]][i]; // } } } int cala(int g){ int x=1,ret=0; for(int i=0;i&lt;a[g].size();++i){ int to=a[g][i]; while(!tr[x][to])x=f[x];x=tr[x][to]; for(int j=x;j;j=f[j]){ if(vis1[j]==T)break;vis1[j]=T; for(int k=0;k&lt;tag[j].size();++k){ int y=tag[j][k]; if(vis[y]!=T)vis[y]=T,++ret,ans[y]++; } } } return ret; } int calb(int g){ int x=1,ret=0; for(int i=0;i&lt;b[g].size();++i){ int to=b[g][i]; while(!tr[x][to])x=f[x];x=tr[x][to]; for(int j=x;j;j=f[j]){ if(vis1[j]==T)break;vis1[j]=T; for(int k=0;k&lt;tag[j].size();++k){ int y=tag[j][k]; if(vis[y]!=T)vis[y]=T,++ret,ans[y]++; } } } return ret; } int main(){ // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); L=10001;cnt=1;f[1]=0; for(int i=0;i&lt;L;++i)tr[0][i]=1; n=read();m=read(); for(int i=1,k;i&lt;=n;++i){ k=read();for(int j=1;j&lt;=k;++j)a[i].pb(read()); k=read();for(int j=1;j&lt;=k;++j)b[i].pb(read()); } for(int i=1,k;i&lt;=m;++i){ k=read();for(int j=1;j&lt;=k;++j)g[j]=read(); add(g,k,i); } getf(); for(int i=1;i&lt;=n;++i){ ++T; res[i]= cala(i)+ calb(i); } for(int i=1;i&lt;=m;++i)printf(&quot;%d\\n&quot;,ans[i]); for(int i=1;i&lt;=n;++i){ printf(&quot;%d&quot;,res[i]); if(i!=n)printf(&quot; &quot;); } return 0; } HAOI2017 字符串 题目描述 输入输出格式输入格式: 输出格式： 输入输出样例输入样例：1 xyz 3 xz y xzy 输出样例：2 3 0 数据范围 题解对于每个询问串和初始串，将问题转化为其前后缀的匹配（初始串的表示为$x,y$询问串的表示为为$a,b$）。先将所有询问串建到AC自动机上，然后建出$fail$树。 同$NOI2011$阿狸的打字机一样，对于一个初始串的子串能匹配到询问串当且仅当在$fail$树中，$x[j]$在$a[j]$的子树中，且$y[j+k+1]$在$b[j+k+1]$的子树中，该算法可以通过子树差分来实现。但是如果直接统计所有前后缀的话，明显会存在重复的情况： 初始串：$aaab$ 询问串：$abab$ $k=2$ 此时显然询问串与初始串匹配了两回（即$x[0]-&gt;y[3]$与$a[0]-&gt;b[3]$和$x[1]-&gt;y[4]$与$a[1]-&gt;b[4]$）。 一般性的，以上算法实际上求的是$k1 \\in [1,k]$中所有可以匹配的$k1$的个数，那么$k$匹配个数即为$[1,k]$匹配个数与$[1,k-1]$匹配个数的差。（需要注意在求解$[1,k-1]$的时候，$a,b,x,y$的边界条件需要与求解$[1,k]$时对齐。） CODE#include&lt;bits/stdc++.h&gt; #define mp make_pair #define pii pair&lt;int,int&gt; #define fr first #define pb push_back #define sd second using namespace std; typedef long long ll; const int N = 4e5+5; int k; char s[N],p[N]; int n,ans[N]; vector&lt;pii&gt;sum1[N],sum2[N]; vector&lt;int&gt;g[N],ch1[N],ch2[N]; int st[N],ed[N],totw; struct lb{ int a[N]; lb(){ memset(a,0,sizeof(a)); } void add(int x){ for(;x&lt;=totw;x+=x&amp;-x)a[x]++; } int sum(int x){ int ret=0; for(;x;x-=x&amp;-x)ret+=a[x]; return ret; } int get(int x){ return sum(ed[x])-sum(st[x]-1); } }T[2]; void _debug(int *a){ for(int i=0;a[i];++i)printf(&quot;%d &quot;,a[i]); cout&lt;&lt;endl; } struct __AC{ int tr[N][95],f[N],cnt,x[N],y[N]; void add(char *s,int n,int *q,bool flag){ int x=0; q[0]=q[n+1]=0; for(int i=flag?n:1;flag?i&gt;=1:i&lt;=n;flag?--i:++i){ int c=s[i]-33; if(tr[x][c]==-1){ tr[x][c]=++cnt; memset(tr[cnt],-1,sizeof(tr[cnt])); } q[i]=x=tr[x][c]; } } void getf(){ queue&lt;int&gt;q; for(int i=0;i&lt;95;++i) if(~tr[0][i])q.push(tr[0][i]); else tr[0][i]=0; while(!q.empty()){ int x=q.front();q.pop(); g[f[x]].pb(x); for(int i=0;i&lt;95;++i) if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]); else tr[x][i]=tr[f[x]][i]; } } void dfs(int x){ st[x]=++totw; for(int i=0;i&lt;g[x].size();++i)dfs(g[x][i]); ed[x]=totw; } void getans(int x){ for(int i=0;i&lt;sum1[x].size();++i){pii t=sum1[x][i];ans[t.sd]-=T[0].get(t.fr);} for(int i=0;i&lt;sum2[x].size();++i){pii t=sum2[x][i];ans[t.sd]+=T[1].get(t.fr);} for(int i=0;i&lt;ch1[x].size();++i){int t=ch1[x][i];T[0].add(st[t]);} for(int i=0;i&lt;ch2[x].size();++i){int t=ch2[x][i];T[1].add(st[t]);} for(int i=0;i&lt;g[x].size();++i)getans(g[x][i]); for(int i=0;i&lt;sum1[x].size();++i){pii t=sum1[x][i];ans[t.sd]+=T[0].get(t.fr);} for(int i=0;i&lt;sum2[x].size();++i){pii t=sum2[x][i];ans[t.sd]-=T[1].get(t.fr);} } void solve(){ memset(tr[0],-1,sizeof(tr[0])); int len=strlen(s+1); for(int i=1;i&lt;=n;++i){ scanf(&quot;%s&quot;,p+1); int m=strlen(p+1); if(m&lt;=k)ans[i]=len-m+1; else{ add(p,m,x,0);add(p,m,y,1); // _debug(x);_debug(y); for(int j=k+1;j&lt;=m+1;++j)sum1[x[j-k-1]].pb(mp(y[j],i)); for(int j=k+1;j&lt;=m;++j)sum2[x[j-k]].pb(mp(y[j],i)); } } getf(); int pt; x[0]=x[len+1]=y[0]=y[len+1]=0; pt=0;for(int i=1;i&lt;=len;++i)x[i]=pt=tr[pt][s[i]-33]; pt=0;for(int i=len;i&gt;=1;--i)y[i]=pt=tr[pt][s[i]-33]; // _debug(x);_debug(y); // cout&lt;&lt;endl; for(int j=k+1;j&lt;=len+1;++j)ch1[x[j-k-1]].pb(y[j]); for(int j=k+1;j&lt;=len;++j)ch2[x[j-k]].pb(y[j]); dfs(0); // _debug(st); getans(0); } }AC; int main(){ // freopen(&quot;problemb.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;problemb.out&quot;,&quot;w&quot;,stdout); // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%s%d&quot;,&amp;k,s+1,&amp;n); AC.solve(); for(int i=1;i&lt;=n;++i)printf(&quot;%d\\n&quot;,ans[i]); // cout&lt;&lt;AC.cnt&lt;&lt;endl; } Tjoi2013 单词 Coci2015 Divljak","raw":"title:  AC自动机总结\ndate: 2017-12-01 11:11:11\ncategories:\n  - 数据结构\n  - Hollerith-type\n  - AC自动机\ntags:\n  - AC自动机\n  - 子树差分\n  - BFS\n  - 动态规划\n---\n# [AC自动机（简单版）](https://www.luogu.org/problemnew/show/3808)\n---\n## 题目描述\n给定n个模式串和1个文本串，求有多少个模式串在文本串里出现过。\n\n### 输入输出格式\n#### 输入格式:\n第一行一个n，表示模式串个数；\n\n下面n行每行一个模式串；\n\n下面一行一个文本串。\n#### 输出格式：\n一个数表示答案。\n### 输入输出样例\n#### 输入样例：\n    2\n    a\n    aa\n    aa\n#### 输出样例：\n    2\n---\n\n## 题解\nAC自动机裸题，如果不加last优化会TLE。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e6+1;\n\n    int ch[N][26],f[N],cnt;\n    int l[N];\n    int tag[N];\n\n    void add(char *s){\n        int n=strlen(s);\n        int x=0;\n        for(int i=0;i<n;++i){\n            int c=s[i]-'a';\n            if(ch[x][c]==-1){\n                ch[x][c]=++cnt;\n                for(int j=0;j<26;++j)ch[cnt][j]=-1;\n            }\n            x=ch[x][c];\n        }\n        tag[x]++;\n    }\n\n    void getfail(){\n        queue<int>q;\n        for(int i=0;i<26;++i)\n        if(~ch[0][i])l[ch[0][i]]=f[ch[0][i]]=0,q.push(ch[0][i]);\n        else\tch[0][i]=0;\n    //\tstatic int g[N];\n        while(!q.empty()){\n            int x=q.front();q.pop();\n            for(int i=0;i<26;++i){\n                if(tag[ch[f[x]][i]])l[ch[x][i]]=ch[f[x]][i];\n                else    l[ch[x][i]]=l[ch[f[x]][i]];\n                if(~ch[x][i])f[ch[x][i]]=ch[f[x]][i],q.push(ch[x][i]);\n                else\tch[x][i]=ch[f[x]][i];\n            }\n        }\n    }\n    bool vis[N];\n    int get(char *s){\n\n        int n=strlen(s);\n        int x=0,ret=0;\n        for(int i=0;i<n;++i){\n            x=ch[x][s[i]-'a'];\n            for(int j=x;j;j=l[j])\n            if(!vis[j])vis[j]=1,ret+=tag[j];\n        }\n        return ret;\n    }\n\n    int n;\n    char s[N];\n    int main(){\n    //\tfreopen(\"c.in\",\"r\",stdin);\n        cin>>n;\n        for(int i=0;i<26;++i)ch[0][i]=-1;\n        for(int i=0;i<n;++i)scanf(\"%s\",s),add(s);\n        getfail();\n        scanf(\"%s\",s);\n        cout<<get(s)<<endl;\n    }\n\n\n---\n\n# [AC自动机（加强版）](https://www.luogu.org/problemnew/show/3796)\n---\n## 题目描述\n有N个由小写字母组成的模式串以及一个文本串T。每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串T中出现的次数最多。\n### 输入输出格式\n#### 输入格式:\n输入含多组数据。\n\n每组数据的第一行为一个正整数N，表示共有N个模式串，$1≤N≤150$。\n\n接下去N行，每行一个长度小于等于$70$的模式串。下一行是一个长度小于等于$10^6$的文本串T。\n\n输入结束标志为$N=0$。\n#### 输出格式：\n对于每组数据，第一行输出模式串最多出现的次数，接下去若干行每行输出一个出现次数最多的模式串，按输入顺序排列。\n### 输入输出样例\n#### 输入样例：\n    2\n    aba\n    bab\n    ababababac\n    6\n    beta\n    alpha\n    haha\n    delta\n    dede\n    tata\n    dedeltalphahahahototatalpha\n    0\n#### 输出样例：\n    4\n    aba\n    2\n    alpha\n    haha\n\n---\n\n## 题解\nAC自动机裸题。不加last优化也能过，多组数据注意清零。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e6+1;\n\n    int tr[N][26],f[N],cnt,ans[N];\n    int l[N];\n    int tag[N];\n\n    void add(char *s,int fa){\n        int n=strlen(s);\n        int x=0;\n        for(int i=0;i<n;++i){\n            int c=s[i]-'a';\n            if(tr[x][c]==-1){\n                tr[x][c]=++cnt;\n                for(int j=0;j<26;++j)tr[cnt][j]=-1;\n            }\n            x=tr[x][c];\n        }\n        tag[x]=fa;\n    }\n\n    void getfail(){\n        queue<int>q;\n        for(int i=0;i<26;++i)\n        if(~tr[0][i])l[tr[0][i]]=f[tr[0][i]]=0,q.push(tr[0][i]);\n        else\ttr[0][i]=0;\t\n        while(!q.empty()){\n            int x=q.front();q.pop();\n            for(int i=0;i<26;++i){\n                if(tr[x][i]==-1){tr[x][i]=tr[f[x]][i];continue;}\n                int y=tr[x][i];\n                q.push(y);\n                f[y]=tr[f[x]][i];\n    //            l[y]=tag[f[y]]?f[y]:l[f[y]];\n            }\n        }\n    }\n    bool vis[N];\n\n    void get(char *s){\n\n        int n=strlen(s);\n        int x=0,ret=0;\n        for(int i=0;i<n;++i){\n            x=tr[x][s[i]-'a'];\n            for(int j=x;j;j=f[j])\n            if(tag[j])ans[tag[j]]++;\n        }\n    }\n\n    int n;\n    char s[256][256];\n    char s1[N];\n\n    void put(char *s){\n        int n=strlen(s);\n        for(int i=0;i<n;++i)putchar(s[i]);\n        printf(\"\\n\");\n    }\n\n    int main(){\n        while(scanf(\"%d\",&n)!=EOF){\n            if(!n)return 0;\n            cnt=0;\n            for(int i=0;i<26;++i)tr[0][i]=-1;\n            for(int i=1;i<=n;++i)scanf(\"%s\",s[i]),add(s[i],i);\n            getfail();\n            scanf(\"%s\",s1);get(s1);\n            int res=*max_element(ans+1,ans+n+1);\n            printf(\"%d\\n\",res);\n            for(int i=1;i<=n;++i)if(ans[i]==res)put(s[i]);\n            for(int i=1;i<=n;++i)ans[i]=0;\n            for(int i=1;i<=cnt;++i)tag[i]=f[i]=l[i]=0;\n        }\n    }\n---\n\n\n# [HNOI2006 最短母串](http://www.lydsy.com/JudgeOnline/problem.php?id=1195)\n---\n## 题目描述\n给定n个字符串（S1,S2,„,Sn），要求找到一个最短的字符串T，使得这n个字符串（S1,S2,„,Sn）都是T的子串。\n### 输入输出格式\n#### 输入格式:\n第一行是一个正整数n（n<=12），表示给定的字符串的个数。以下的n行，每行有一个全由大写字母组成的字符串。每个字符串的长度不超过50。\n#### 输出格式：\n只有一行，为找到的最短的字符串T。在保证最短的前提下，如果有多个字符串都满足要求，那么必须输出按字典序排列的第一个。\n### 输入输出样例\n#### 输入样例：\n\t2 \n\tABCD\n\tBCDABC\n#### 输出样例：\n\tABCDABC\n---\n\n## 题解\n考虑$n$很小的性质，第一眼以为是状态压缩DP暴力转移（实际也能做，但是很难写），正解应该是将在AC自动机上DP。根据AC自动机的性质，易知一条路径即代表一个字符串。设$f[i][S]$表示当前走到第$i$号节点，已经覆盖串的集合为$S$的最小步数状态数为$n*50*2^n$，直接用BFS更新即可。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 6e2+5;\n\n    int read(){\n        int x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n        return x;\n    }\n\n    char s[13][51];\n    int n;\n    struct kd{\n        int x,y;\n    }X,Y;\n\n    struct AC{\n        int cnt,tr[N][26],f[N],tag[N],pos[N];\n        int d[N][1<<12];\n        int prex[N][1<<12],prey[N][1<<12];\n\n        void init(){\n            cnt=0;\n            memset(tr[0],-1,sizeof(tr[0]));\n        }\n\n        void add(char *s,int k){\n            int n=strlen(s);\n            int x=0;\n            for(int i=0;i<n;++i){\n                int c=s[i]-'A';\n                if(tr[x][c]==-1){\n                    tr[x][c]=++cnt;\n                    pos[cnt]=c;\n                    memset(tr[cnt],-1,sizeof(tr[cnt]));\n                    tag[cnt]=0;\n                }\n                x=tr[x][c];\n            }\n            tag[x]|=1<<k;\n        }\n\n        void getf(){\n            queue<int>q;\n            f[0]=0;\n            for(int i=0;i<26;++i)\n            if(~tr[0][i])f[tr[0][i]]=0,q.push(tr[0][i]);\n            else\ttr[0][i]=0;\n            while(!q.empty()){\n                int x=q.front();q.pop();\n                tag[x]|=tag[f[x]];\n                for(int i=0;i<26;++i){\n                    if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);\n                    else\ttr[x][i]=tr[f[x]][i];\n                }\n            }\n        }\n\n        void output(int x,int y){\n            static int q[N];\n            while(x){\n                q[++q[0]]=pos[x]+'A';\t\n                int x1=x,y1=y;\t\n                x=prex[x1][y1];\n                y=prey[x1][y1];\n            }\n            reverse(q+1,q+q[0]+1);\n            for(int i=1;i<=q[0];++i)printf(\"%c\",(char)q[i]);\n        }\n\n        void solve(){\n            getf();\n            int S=(1<<n)-1;\n            memset(d,-1,sizeof(d));\n            queue<kd>q;\n            X.x=0;X.y=0;\n            q.push(X);d[0][0]=0;\n            prex[0][0]=0;prey[0][0]=0;\n            while(!q.empty()){\n                X=q.front();q.pop();\n                for(int i=0;i<26;++i)\n                if(tr[X.x][i]){\n                    int to=tr[X.x][i];\n                    Y.x=to;Y.y=X.y|tag[to];\n                    if(d[Y.x][Y.y]==-1){\n                        prex[Y.x][Y.y]=X.x;prey[Y.x][Y.y]=X.y;\n                        \n                        d[Y.x][Y.y]=d[X.x][X.y]+1;\n                        if(Y.y==S){\n    //\t\t\t\t\t\tprintf(\"%d\\n\",d[Y.x][Y.y]);\n                            output(Y.x,Y.y);\n                            printf(\"\\n\");\n                            exit(0);\n                        }\n                        q.push(Y);\n                    }\n                }\n            }\n        }\n    }T;\n\n    int main(){\n        scanf(\"%d\",&n);\n        T.init();\n        for(int i=0;i<n;++i){\n            scanf(\"%s\",s[i]);\n            T.add(s[i],i);\n        }\n        T.solve();\n    }\n---\n\n# [Beijing2017 魔法咒语](http://www.lydsy.com/JudgeOnline/problem.php?id=4861)\n---\n## 题目描述\nChandra 是一个魔法天才。\n\n从一岁时接受火之教会洗礼之后， Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。直到十四岁，开始学习威力强大的禁咒法术时， Chandra 才遇到了障碍。根据火之魔法规则，禁咒的构成单位是 N 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 L 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时， Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。很多年过去了，在一次远古遗迹探险中， Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。 Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 M 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。例如，若 ”banana” 是唯一的忌讳词语， “an”、 ”ban”、 ”analysis” 是基本词汇，禁咒长度须是 11， 则“bananalysis” 是无效法术， ”analysisban”、 ”anbanbanban”是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、 一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。谜题破解， Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。由于答案可能很大，你需要输出答案模 1,000,000,007的结果。\n### 输入输出格式\n#### 输入格式:\n第一行，三个正整数 N, M, L。\n接下来 N 行，每行一个只含小写英文字母的字符串，表示一个基本词汇。\n接下来 M 行，每行一个只含小写英文字母的字符串，表示一个忌讳词语。\n对于60%的数据1<=N,M<=50,L<=100\n对于另40%数据基本词汇长度不超过2,L<=10^8\n#### 输出格式：\n仅一行，一个整数，表示答案（模 10^9+7）。\n### 输入输出样例\n#### 输入样例：\n    4 2 10\n    boom\n    oo\n    ooh\n    bang\n    ob\n    mo\n#### 输出样例：\n\t14\n### 样例解释\n\n有效的禁咒法术共有 14 种：boom/bang/oo，oo/oo/oo/oo/oo，oo/oo/ooh/ooh，oo/ooh/oo/ooh， oo/ooh/ooh/oo， ooh/oo/oo/ooh， ooh/oo/ooh/oo，ooh/ooh/boom， ooh/ooh/oo/oo， ooh/ooh/bang，ooh/bang/ooh，bang/oo/oo/oo， bang/ooh/ooh， bang/bang/oo。\n\n---\n\n## 题解\n设$f[i][L]$为走到第$i$号节点，此时字符串长度（即路径长度）为$L$的方案数，那么由于字符集在此题中被限制为了一个个的字符串，所以需要预处理$go[i][j]$表示从$i$号节点出发后经过第$j$个基本词汇后所到达的节点，如果其中经过禁忌词语，则初始化为-1表示不可到达。那么DP方程如下：（$len[j]$表示基本词汇$j$的长度）\n\n$$f[go [i] [j] ][ L + len[j] ] += f[i][L] \\ (go[i][j]!=-1)$$\n\n观察数据范围，朴素的DP只能通过$60%$的数据，剩余$L<=10^8$且$len[j]<=2$的部分分，可以通过矩阵乘法优化，同先前的[DNA Sequence](https://prostkhala.github.io/2017/03/18/DNA%20Sequence/)一样，用$f[i][j]$表示从$i$号节点一步到达$j$号节点的方案数，可以处理$len[j]=1$的情况。对于$len[j]=2$的情况，对于每个节点$i$设一个虚拟节点$b[i]$，然后$f[i][b[j]]$表示从$i$一步到$b[j]$的方案数，再从$b[j]$向$j$连一条边即可（即$f[b[j]][j]=1$）。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 5e3+1;\n    const ll mod = 1e9+7;\n    int n,m,L,cnt,len[51];\n    char a[51][401],b[51][401];\n\n    void mul(int &a,int b){\n        a+=b;\n        if(a>=mod)a-=mod;\n    }\n    int t1k;\n    struct Matrix{\n        ll a[401][401];\n        friend Matrix operator * (Matrix a,Matrix b){\n            Matrix c;\n            memset(c.a,0,sizeof(c.a));\n            for(int i=0;i<=t1k;++i)\n            for(int j=0;j<=t1k;++j){\n                for(int k=0;k<=t1k;++k)\n                (c.a[i][j]+=a.a[i][k]*b.a[k][j])%=mod;\n            }\n            return c;\n        }\n    }res,c;\n\n\n\n    struct AC{\n        int tr[N][26],f[N],tag[N],val[N],to[N][51];\n\n        void init(){\n            cnt=0;\n            memset(tr[0],-1,sizeof(tr[0]));\n        }\n\n        void add(char *s,int h){\n            int x=0;\n            int n=strlen(s);\n            for(int i=0;i<n;++i){\n                int c=s[i]-'a';\n                if(tr[x][c]==-1){\n                    tr[x][c]=++cnt;\n                    val[cnt]=i;\n                    memset(tr[cnt],-1,sizeof(tr[cnt]));\n                }\n                x=tr[x][c];\n            }\n            tag[x]=h;\n        }\n\n        void getf(){\n            queue<int>q;\n            for(int i=0;i<26;++i)\n            if(~tr[0][i])f[tr[0][i]]=0,q.push(tr[0][i]);\n            else\ttr[0][i]=0;\n            while(!q.empty()){\n                int x=q.front();q.pop();\n                tag[x]|=tag[f[x]];\n                for(int i=0;i<26;++i)\n                if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);\n                else\ttr[x][i]=tr[f[x]][i]; \n            }\n        }\n\n        int go(int i,char *s){\n            int n=strlen(s);\n                int x=i;\n                if(tag[x])return -1;\n                for(int j=0;j<n;++j){\n                    x=tr[x][s[j]-'a'];\n                    if(tag[x])return -1;\n                }\n                return x;\n        }\n\n        void A(){\n            static int dp[N][101];\n            dp[0][0]=1;\n            for(int l=0;l<=L;++l)\n            for(int i=0;i<=cnt;++i)\n            for(int j=0;j<n;++j)\n            if(len[j]+l<=L){\n                int y=to[i][j];\n                if(y==-1)continue;\n                mul(dp[y][len[j]+l],dp[i][l]);\n            }\n            int ans=0;\n            for(int i=0;i<=cnt;++i)mul(ans,dp[i][L]);\n            printf(\"%d\\n\",ans);\n        }\n\n        void B(){\n            t1k=2*cnt+1;\n            int tp=cnt+1;\n            for(int i=0;i<=cnt;++i)res.a[i+tp][i]=1;\n            for(int i=0;i<=2*cnt+1;++i)c.a[i][i]=1;\n            for(int i=0;i<=cnt;++i)\n            for(int j=0;j<n;++j){\n                int y=to[i][j];\n                if(y==-1)continue;\n                if(len[j]==1)res.a[i][y]++;\n                else    res.a[i][y+tp]++;\n            }\n            while(L){\n                if(L&1)c=c*res;\n                L>>=1;\n                res=res*res;\n            }\n            ll ans=0;\n            for(int i=0;i<=cnt;++i)(ans+=c.a[0][i])%=mod;\n            printf(\"%lld\\n\",ans);\n        }\n\n        void solve(){\n            init();\n            for(int i=0;i<m;++i)add(b[i],1);\n            getf();\n            for(int i=0;i<=cnt;++i)\n            for(int j=0;j<n;++j)\n            to[i][j]=go(i,a[j]);\n            if(L<=100)A();\n            else     B();\n        }\n    }T;\n\n    int main(){\n    //\tfreopen(\"c.in\",\"r\",stdin);\n        scanf(\"%d%d%d\",&n,&m,&L);\n        for(int i=0;i<n;++i)scanf(\"%s\",a[i]),len[i]=strlen(a[i]);\n        for(int i=0;i<m;++i)scanf(\"%s\",b[i]);\n        T.solve();\n    }\n    /*\n    4 2 98\n    bo\n    oo\n    hm\n    ba\n    ob\n    mho\n    */\n---\n\n# [BeiJing2011 禁忌](http://www.lydsy.com/JudgeOnline/problem.php?id=2553)\n---\n## 题目描述\nMagic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力……\n\n      \n\n如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。\n\n这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。\n\n为了说明什么是禁忌魔法及其伤害，引入以下概念：\n\n1. 字母集A上的每个非空字符串对应了一个魔法。其中A是包含了前alphabet个小写字母的集合。\n\n2. 有一个集合T，包含了N个字母集A上的字符串.T中的每一串称为一个禁忌串（Taboo string）\n\n3. 一个魔法，或等价地，其对应的串s因为包含禁忌而对使用者造成的伤害按以下方式确定：把s分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。\n\n      \n\n由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集A上所有长度为len的串。\n\n但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。\n\n \n你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。\n### 输入输出格式\n#### 输入格式:\n第一行包含三个正整数N、len、alphabet。\n接下来N行，每行包含一个串Ti，表示禁忌串。\n#### 输出格式：\n一个非负实数，表示所受到禁忌伤害的期望值。\n### 输入输出样例\n#### 输入样例：\n    2 4 2\n    aa\n    abb\n\n#### 输出样例：\n\t0.75\n### 数据范围\n100%的数据中N ≤ 5，len ≤109，1 ≤ alphabet ≤ 26。\n\n在所有数据中，有不少于40%的数据中：N = 1。\n\n数据保证每个串Ti的长度不超过15，并且不是空串。\n\n数据保证每个Ti均仅含有前alphabet个小写字母。\n\n数据保证集合T中没有相同的元素，即对任意不同的i和j，有Ti≠Tj。\n\n---\n\n## 题解\n首先考虑对于一个给定的串，如何求其禁忌伤害，这是一个经典的贪心问题，即线段覆盖问题，正确的姿势是按右端点排序，能取的尽量取即可，如果去除存在覆盖的禁忌串（一定没有只取被覆盖的子串优越），那么姿势等价于按左端点排序，且尽可能的取。\n\n考虑在AC自动机上的贪心，即为从根节点出发每次走到一个禁忌串后，直接返回根节点（因为禁忌串之间不能相互覆盖），重复过程直到路径长度为$L$并将答案加上返回次数除以 $2^{len}$ ，考虑如何用DP优化此过程，仍然设$f[i][L]$表示走到$i$号节点，路径长度为$L$的概率，那么显然有（0表示根节点,$tag$表示是否为禁忌串。）\n\n$$f[0][L+1]+=f[i][L]+1/alphabet\t（tag[tr[x][i]]=1）$$\n\n$$f[tr[x][i]][L+1]+=f[i][L]+1/alphabet\t（tag[tr[x][i]]=0）$$\n\n考虑如何将统计答案。在贪心的过程中，每次访问到禁忌串时不仅要返回根节点，还要将答案加上到当前节点的概率，即新建一个节点$g$表示答案节点，那么同样有\n$$f[g][L+1]+=f[i][L]+1/alphabet\t（tag[tr[x][i]]=1）$$\n\n即可以用矩阵乘法优化此过程，并且需要设定$matrix[g][g]=1$，矩阵$L$次方代表$1-L$前缀和的贡献，即为答案。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    #define mp make_pair\n    #define fr first\n    #define sd second\n    #define pii pair<int,int>\n    using namespace std;\n    typedef long long ll;\n    typedef long double db;\n    const int N = 1e2+1;\n\n    int cnt,n,L,ml,len[6],tr[N][26],f[N],tag[N];\n    char s[6][N];\n\n    struct matrix{\n\n        db a[N][N];\n\n        friend matrix operator * (matrix a,matrix b){\n            matrix c;\n            for(int i=0;i<=cnt+1;++i)\n            for(int j=0;j<=cnt+1;++j)\n            c.a[i][j]=0;\n\n            for(int i=0;i<=cnt+1;++i)\n            for(int j=0;j<=cnt+1;++j)\n            for(int k=0;k<=cnt+1;++k)\n            c.a[i][j]+=a.a[i][k]*b.a[k][j];\n            return c;\n        }\n\n    }res;\n\n    matrix qpow(ll b){\n        matrix c;\n        for(int i=0;i<=cnt+1;++i)\n        for(int j=0;j<=cnt+1;++j)\n        c.a[i][j]=(i==j);\n\n        while(b){\n            if(b&1)c=c*res;\n            b>>=1;\n            res=res*res;\n        }\n        return c;\n    }\n\n    void solve(){\n        db k=1.00/(db)ml;\n        for(int i=0;i<=cnt;++i)\n        for(int j=0;j<ml;++j){\n            int y=tr[i][j];\n            if(tag[y])res.a[i][0]+=k,res.a[i][cnt+1]+=k;\n            else    res.a[i][y]+=k;\n        }\n        res.a[cnt+1][cnt+1]=1;\n        printf(\"%.8lf\",(double)qpow(L).a[0][cnt+1]);\n    }\n\n    int add(char *s){\n        int n=strlen(s),x=0;\n        for(int i=0;i<n;++i){\n            int c=s[i]-'a';\n            if(tr[x][c]==-1){\n                tr[x][c]=++cnt;\n                memset(tr[cnt],-1,sizeof(tr[cnt]));\n            }\n            x=tr[x][c];\n        }\n        tag[x]=1;\n        return n;\n    }\n\n    void getf(){\n        queue<int>q;\n        for(int i=0;i<ml;++i)\n        if(~tr[0][i])f[tr[0][i]]=0,q.push(tr[0][i]);\n        else    tr[0][i]=0;\n        while(!q.empty()){\n            int x=q.front();q.pop();\n            tag[x]|=tag[f[x]];\n            for(int i=0;i<ml;++i){\n                if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);\n                else    tr[x][i]=tr[f[x]][i];\n            }\n        }\n    }\n\n    int main(){\n    //\tfreopen(\"c.in\",\"r\",stdin);\n        memset(tr[0],-1,sizeof(tr[0]));\n        scanf(\"%d%d%d\",&n,&L,&ml);\n        for(int i=1;i<=n;++i)scanf(\"%s\",s[i]),len[i]=add(s[i]);\n        getf();\n        solve();\n    }\n---\n\n# [SCOI2012 喵星球上的点名](http://www.lydsy.com/JudgeOnline/problem.php?id=2754)\n---\n## 题目描述\na180285幸运地被选做了地球到喵星球的留学生。他发现喵星人在上课前的点名现象非常有趣。   假设课堂上有N个喵星人，每个喵星人的名字由姓和名构成。喵星球上的老师会选择M个串来点名，每次读出一个串的时候，如果这个串是一个喵星人的姓或名的子串，那么这个喵星人就必须答到。 然而，由于喵星人的字码过于古怪，以至于不能用ASCII码来表示。为了方便描述，a180285决定用数串来表示喵星人的名字。\n现在你能帮助a180285统计每次点名的时候有多少喵星人答到，以及M次点名结束后每个喵星人答到多少次吗？   \n### 输入输出格式\n#### 输入格式:\n现在定义喵星球上的字符串给定方法：\n\n先给出一个正整数L，表示字符串的长度，接下来L个整数表示字符串的每个字符。\n\n输入的第一行是两个整数N和M。\n\n接下来有N行，每行包含第i 个喵星人的姓和名两个串。姓和名都是标准的喵星球上的字符串。\n\n接下来有M行，每行包含一个喵星球上的字符串，表示老师点名的串。 \n\n#### 输出格式：\n\n对于每个老师点名的串输出有多少个喵星人应该答到。\n\n然后在最后一行输出每个喵星人被点到多少次。 \n### 输入输出样例\n#### 输入样例：\n    2 3 \n    6 8 25 0 24 14 8 6 18 0 10 20 24 0 \n    7 14 17 8 7 0 17 0 5 8 25 0 24 0 \n    4 8 25 0 24 \n    4 7 0 17 0 \n    4 17 0 8 25 \n#### 输出样例：\n    2 \n    1 \n    0 \n    1 2 \n### 数据范围\n 对于30%的数据，保证：\n\n1<=N,M<=1000，喵星人的名字总长不超过4000，点名串的总长不超过2000。\n\n对于100%的数据，保证：\n\n1<=N<=20000，1<=M<=50000，喵星人的名字总长和点名串的总长分别不超过100000，保证喵星人的字符串中作为字符存在的数不超过10000。\n\n---\n\n## 题解\n由于本题中字符集过大，肯定不能将数组开满，需要用$map$来存储儿子，且不能在每次新建节点时将儿子都表示成$-1$，那么就要默认为$0$。同理需要将根节点设为$1$，并赋值$tr[0][i]=1$，在$getfail$的时候，也应该直接暴力跳$fail$。由于数据较水，这样即可通过此题。（正解为后缀数组+主席树）\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    #define pb push_back\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e5+5;\n\n    map<int,int>tr[N];\n    map<int,int>::iterator it;\n    int n,m,L,cnt,f[N],g[N],ans[N],res[N],id[N];\n    int vis[N],vis1[N],T;\n    vector<int>a[N],b[N],tag[N];\n\n    int read(){\n        int x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n        return x;\n    }\n\n    void add(int *s,int n,int fa){\n        int x=1;\n        for(int i=1;i<=n;++i){\n            int c=s[i];\n            if(!tr[x][c])tr[x][c]=++cnt;\n            x=tr[x][c];\n        }\n        tag[x].pb(fa);\n    }\n\n    void getf(){\n        queue<int>q;\n        q.push(1);\n        while(!q.empty()){\n            int x=q.front();q.pop();\n            for(it=tr[x].begin();it!=tr[x].end();++it){\n                int t=it->first,k=f[x];\n                while(!tr[k][t])k=f[k];\n                f[it->second]=tr[k][t];\n                q.push(it->second);\n            }\n    //\t\tfor(int i=0;i<L;++i){\n    //\t\t\tif(tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);\n    //\t\t\telse\ttr[x][i]=tr[f[x]][i];\n    //\t\t}\n        }\n    }\n\n    int cala(int g){\n        int x=1,ret=0;\n        for(int i=0;i<a[g].size();++i){\n            int to=a[g][i];\n            while(!tr[x][to])x=f[x];x=tr[x][to];\n            for(int j=x;j;j=f[j]){\n                if(vis1[j]==T)break;vis1[j]=T;\n                for(int k=0;k<tag[j].size();++k){\n                    int y=tag[j][k];\n                    if(vis[y]!=T)vis[y]=T,++ret,ans[y]++;\n                }\n            }\n        }\n        return ret;\n    }\n\n    int calb(int g){\n        int x=1,ret=0;\n        for(int i=0;i<b[g].size();++i){\n            int to=b[g][i];\n            while(!tr[x][to])x=f[x];x=tr[x][to];\n            for(int j=x;j;j=f[j]){\n                if(vis1[j]==T)break;vis1[j]=T;\n                for(int k=0;k<tag[j].size();++k){\n                    int y=tag[j][k];\n                    if(vis[y]!=T)vis[y]=T,++ret,ans[y]++;\n                }\n            }\n        }\n        return ret;\n    }\n\n    int main(){\n    //\tfreopen(\"c.in\",\"r\",stdin);\n        L=10001;cnt=1;f[1]=0;\n        for(int i=0;i<L;++i)tr[0][i]=1;\n        n=read();m=read();\n        for(int i=1,k;i<=n;++i){\n            k=read();for(int j=1;j<=k;++j)a[i].pb(read());\n            k=read();for(int j=1;j<=k;++j)b[i].pb(read());\n        }\n        for(int i=1,k;i<=m;++i){\n            k=read();for(int j=1;j<=k;++j)g[j]=read();\n            add(g,k,i);\n        }\n        getf();\n        for(int i=1;i<=n;++i){\n            ++T;\n            res[i]=\n            cala(i)+\n            calb(i);\n        }\n        for(int i=1;i<=m;++i)printf(\"%d\\n\",ans[i]);\n        for(int i=1;i<=n;++i){\n            printf(\"%d\",res[i]);\n            if(i!=n)printf(\" \");\n        }\n        return 0;\n    }\n---\n\n# [HAOI2017 字符串](http://218.28.19.228:8080/cogs/problem/problem.php?pid=2673)\n---\n## 题目描述\n![](http://218.28.19.228:8080/upload/image/20170425/20170425154024_30785.png)\n### 输入输出格式\n#### 输入格式:\n![](http://218.28.19.228:8080/upload/image/20170425/20170425154034_33570.png)\n#### 输出格式：\n![](http://218.28.19.228:8080/upload/image/20170425/20170425154044_87420.png)\n### 输入输出样例\n#### 输入样例：\n    1\n    xyz\n    3\n    xz\n    y\n    xzy\n#### 输出样例：\n    2\n    3\n    0\n### 数据范围\n![](http://218.28.19.228:8080/upload/image/20170425/20170425154144_60477.png)\n\n---\n## 题解\n对于每个询问串和初始串，将问题转化为其前后缀的匹配（初始串的表示为$x,y$询问串的表示为为$a,b$）。先将所有询问串建到AC自动机上，然后建出$fail$树。\n\n同$NOI2011$阿狸的打字机一样，对于一个初始串的子串能匹配到询问串当且仅当在$fail$树中，$x[j]$在$a[j]$的子树中，且$y[j+k+1]$在$b[j+k+1]$的子树中，该算法可以通过子树差分来实现。但是如果直接统计所有前后缀的话，明显会存在重复的情况：\n\n初始串：$aaab$\n\n询问串：$abab$\n\n$k=2$\n\n此时显然询问串与初始串匹配了两回（即$x[0]->y[3]$与$a[0]->b[3]$和$x[1]->y[4]$与$a[1]->b[4]$）。\n\n一般性的，以上算法实际上求的是$k1 \\in [1,k]$中所有可以匹配的$k1$的个数，那么$k$匹配个数即为$[1,k]$匹配个数与$[1,k-1]$匹配个数的差。（需要注意在求解$[1,k-1]$的时候，$a,b,x,y$的边界条件需要与求解$[1,k]$时对齐。）                                                                                                                                                                                 \n\n---\n### CODE\n    #include<bits/stdc++.h>\n    #define mp make_pair\n    #define pii pair<int,int>\n    #define fr first\n    #define pb push_back\n    #define sd second\n    using namespace std;\n    typedef long long ll;\n    const int N = 4e5+5;\n\n    int k;\n    char s[N],p[N];\n    int n,ans[N];\n    vector<pii>sum1[N],sum2[N];\n    vector<int>g[N],ch1[N],ch2[N];\n    int st[N],ed[N],totw;\n\n    struct lb{\n        int a[N];\n        lb(){\n            memset(a,0,sizeof(a));\n        }\n        void add(int x){\n            for(;x<=totw;x+=x&-x)a[x]++;\n        }\n        int sum(int x){\n            int ret=0;\n            for(;x;x-=x&-x)ret+=a[x];\n            return ret;\n        }\n        int get(int x){\n            return sum(ed[x])-sum(st[x]-1);\n        }\n    }T[2];\n\n    void _debug(int *a){\n        for(int i=0;a[i];++i)printf(\"%d \",a[i]);\n        cout<<endl;\n    }\n\n    struct __AC{\n        int tr[N][95],f[N],cnt,x[N],y[N];\n        void add(char *s,int n,int *q,bool flag){\n            int x=0;\n            q[0]=q[n+1]=0;\n            for(int i=flag?n:1;flag?i>=1:i<=n;flag?--i:++i){\n                int c=s[i]-33;\n                if(tr[x][c]==-1){\n                    tr[x][c]=++cnt;\n                    memset(tr[cnt],-1,sizeof(tr[cnt]));\n                }\n                q[i]=x=tr[x][c];\n            }\n        }\n        void getf(){\n            queue<int>q;\n            for(int i=0;i<95;++i)\n            if(~tr[0][i])q.push(tr[0][i]);\n            else    tr[0][i]=0;\n            while(!q.empty()){\n                int x=q.front();q.pop();\n                g[f[x]].pb(x);\n                for(int i=0;i<95;++i)\n                if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);\n                else    tr[x][i]=tr[f[x]][i];\n            }\n        }\n        void dfs(int x){\n            st[x]=++totw;\n            for(int i=0;i<g[x].size();++i)dfs(g[x][i]);\n            ed[x]=totw;\n        }\n        void getans(int x){\n            for(int i=0;i<sum1[x].size();++i){pii t=sum1[x][i];ans[t.sd]-=T[0].get(t.fr);}\n            for(int i=0;i<sum2[x].size();++i){pii t=sum2[x][i];ans[t.sd]+=T[1].get(t.fr);}\n            for(int i=0;i<ch1[x].size();++i){int t=ch1[x][i];T[0].add(st[t]);}\n            for(int i=0;i<ch2[x].size();++i){int t=ch2[x][i];T[1].add(st[t]);}\n            for(int i=0;i<g[x].size();++i)getans(g[x][i]);\n            for(int i=0;i<sum1[x].size();++i){pii t=sum1[x][i];ans[t.sd]+=T[0].get(t.fr);}\n            for(int i=0;i<sum2[x].size();++i){pii t=sum2[x][i];ans[t.sd]-=T[1].get(t.fr);}\n        }\n        void solve(){\n            memset(tr[0],-1,sizeof(tr[0]));\n            int len=strlen(s+1);\n            for(int i=1;i<=n;++i){\n                scanf(\"%s\",p+1);\n                int m=strlen(p+1);\n                if(m<=k)ans[i]=len-m+1;\n                else{\n                    add(p,m,x,0);add(p,m,y,1);\n    //\t\t\t\t_debug(x);_debug(y);\n                    for(int j=k+1;j<=m+1;++j)sum1[x[j-k-1]].pb(mp(y[j],i));\n                    for(int j=k+1;j<=m;++j)sum2[x[j-k]].pb(mp(y[j],i));\n                }\n            }\n            getf();\n            int pt;\n            x[0]=x[len+1]=y[0]=y[len+1]=0;\n            pt=0;for(int i=1;i<=len;++i)x[i]=pt=tr[pt][s[i]-33];\n            pt=0;for(int i=len;i>=1;--i)y[i]=pt=tr[pt][s[i]-33];\n    //\t\t_debug(x);_debug(y);\n    //\t\tcout<<endl;\n            for(int j=k+1;j<=len+1;++j)ch1[x[j-k-1]].pb(y[j]);\n            for(int j=k+1;j<=len;++j)ch2[x[j-k]].pb(y[j]);\n            dfs(0);\n    //\t\t_debug(st);\n            getans(0);\n        }\n    }AC;\n\n    int main(){\n    //\tfreopen(\"problemb.in\",\"r\",stdin);\n    //\tfreopen(\"problemb.out\",\"w\",stdout);\n    //\tfreopen(\"c.in\",\"r\",stdin);\n        scanf(\"%d%s%d\",&k,s+1,&n);\n        AC.solve();\n        for(int i=1;i<=n;++i)printf(\"%d\\n\",ans[i]);\n    //\tcout<<AC.cnt<<endl;\n    }\n---\n\n# [Tjoi2013 单词](http://www.lydsy.com/JudgeOnline/problem.php?id=3172)\n\n---\n\n# [Coci2015 Divljak](http://www.lydsy.com/JudgeOnline/problem.php?id=3881)","content":"<h1 id=\"AC自动机（简单版）\"><a href=\"#AC自动机（简单版）\" class=\"headerlink\" title=\"AC自动机（简单版）\"></a><a href=\"https://www.luogu.org/problemnew/show/3808\" target=\"_blank\" rel=\"external\">AC自动机（简单版）</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定n个模式串和1个文本串，求有多少个模式串在文本串里出现过。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>第一行一个n，表示模式串个数；</p>\n<p>下面n行每行一个模式串；</p>\n<p>下面一行一个文本串。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>一个数表示答案。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>2\na\naa\naa\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>2\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>AC自动机裸题，如果不加last优化会TLE。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6+1;\n\nint ch[N][26],f[N],cnt;\nint l[N];\nint tag[N];\n\nvoid add(char *s){\n    int n=strlen(s);\n    int x=0;\n    for(int i=0;i&lt;n;++i){\n        int c=s[i]-&#39;a&#39;;\n        if(ch[x][c]==-1){\n            ch[x][c]=++cnt;\n            for(int j=0;j&lt;26;++j)ch[cnt][j]=-1;\n        }\n        x=ch[x][c];\n    }\n    tag[x]++;\n}\n\nvoid getfail(){\n    queue&lt;int&gt;q;\n    for(int i=0;i&lt;26;++i)\n    if(~ch[0][i])l[ch[0][i]]=f[ch[0][i]]=0,q.push(ch[0][i]);\n    else    ch[0][i]=0;\n//    static int g[N];\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(int i=0;i&lt;26;++i){\n            if(tag[ch[f[x]][i]])l[ch[x][i]]=ch[f[x]][i];\n            else    l[ch[x][i]]=l[ch[f[x]][i]];\n            if(~ch[x][i])f[ch[x][i]]=ch[f[x]][i],q.push(ch[x][i]);\n            else    ch[x][i]=ch[f[x]][i];\n        }\n    }\n}\nbool vis[N];\nint get(char *s){\n\n    int n=strlen(s);\n    int x=0,ret=0;\n    for(int i=0;i&lt;n;++i){\n        x=ch[x][s[i]-&#39;a&#39;];\n        for(int j=x;j;j=l[j])\n        if(!vis[j])vis[j]=1,ret+=tag[j];\n    }\n    return ret;\n}\n\nint n;\nchar s[N];\nint main(){\n//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n    cin&gt;&gt;n;\n    for(int i=0;i&lt;26;++i)ch[0][i]=-1;\n    for(int i=0;i&lt;n;++i)scanf(&quot;%s&quot;,s),add(s);\n    getfail();\n    scanf(&quot;%s&quot;,s);\n    cout&lt;&lt;get(s)&lt;&lt;endl;\n}\n</code></pre><hr>\n<h1 id=\"AC自动机（加强版）\"><a href=\"#AC自动机（加强版）\" class=\"headerlink\" title=\"AC自动机（加强版）\"></a><a href=\"https://www.luogu.org/problemnew/show/3796\" target=\"_blank\" rel=\"external\">AC自动机（加强版）</a></h1><hr>\n<h2 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有N个由小写字母组成的模式串以及一个文本串T。每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串T中出现的次数最多。</p>\n<h3 id=\"输入输出格式-1\"><a href=\"#输入输出格式-1\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>输入含多组数据。</p>\n<p>每组数据的第一行为一个正整数N，表示共有N个模式串，$1≤N≤150$。</p>\n<p>接下去N行，每行一个长度小于等于$70$的模式串。下一行是一个长度小于等于$10^6$的文本串T。</p>\n<p>输入结束标志为$N=0$。</p>\n<h4 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于每组数据，第一行输出模式串最多出现的次数，接下去若干行每行输出一个出现次数最多的模式串，按输入顺序排列。</p>\n<h3 id=\"输入输出样例-1\"><a href=\"#输入输出样例-1\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>2\naba\nbab\nababababac\n6\nbeta\nalpha\nhaha\ndelta\ndede\ntata\ndedeltalphahahahototatalpha\n0\n</code></pre><h4 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>4\naba\n2\nalpha\nhaha\n</code></pre><hr>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>AC自动机裸题。不加last优化也能过，多组数据注意清零。</p>\n<hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6+1;\n\nint tr[N][26],f[N],cnt,ans[N];\nint l[N];\nint tag[N];\n\nvoid add(char *s,int fa){\n    int n=strlen(s);\n    int x=0;\n    for(int i=0;i&lt;n;++i){\n        int c=s[i]-&#39;a&#39;;\n        if(tr[x][c]==-1){\n            tr[x][c]=++cnt;\n            for(int j=0;j&lt;26;++j)tr[cnt][j]=-1;\n        }\n        x=tr[x][c];\n    }\n    tag[x]=fa;\n}\n\nvoid getfail(){\n    queue&lt;int&gt;q;\n    for(int i=0;i&lt;26;++i)\n    if(~tr[0][i])l[tr[0][i]]=f[tr[0][i]]=0,q.push(tr[0][i]);\n    else    tr[0][i]=0;    \n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(int i=0;i&lt;26;++i){\n            if(tr[x][i]==-1){tr[x][i]=tr[f[x]][i];continue;}\n            int y=tr[x][i];\n            q.push(y);\n            f[y]=tr[f[x]][i];\n//            l[y]=tag[f[y]]?f[y]:l[f[y]];\n        }\n    }\n}\nbool vis[N];\n\nvoid get(char *s){\n\n    int n=strlen(s);\n    int x=0,ret=0;\n    for(int i=0;i&lt;n;++i){\n        x=tr[x][s[i]-&#39;a&#39;];\n        for(int j=x;j;j=f[j])\n        if(tag[j])ans[tag[j]]++;\n    }\n}\n\nint n;\nchar s[256][256];\nchar s1[N];\n\nvoid put(char *s){\n    int n=strlen(s);\n    for(int i=0;i&lt;n;++i)putchar(s[i]);\n    printf(&quot;\\n&quot;);\n}\n\nint main(){\n    while(scanf(&quot;%d&quot;,&amp;n)!=EOF){\n        if(!n)return 0;\n        cnt=0;\n        for(int i=0;i&lt;26;++i)tr[0][i]=-1;\n        for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s[i]),add(s[i],i);\n        getfail();\n        scanf(&quot;%s&quot;,s1);get(s1);\n        int res=*max_element(ans+1,ans+n+1);\n        printf(&quot;%d\\n&quot;,res);\n        for(int i=1;i&lt;=n;++i)if(ans[i]==res)put(s[i]);\n        for(int i=1;i&lt;=n;++i)ans[i]=0;\n        for(int i=1;i&lt;=cnt;++i)tag[i]=f[i]=l[i]=0;\n    }\n}\n</code></pre><hr>\n<h1 id=\"HNOI2006-最短母串\"><a href=\"#HNOI2006-最短母串\" class=\"headerlink\" title=\"HNOI2006 最短母串\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1195\" target=\"_blank\" rel=\"external\">HNOI2006 最短母串</a></h1><hr>\n<h2 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定n个字符串（S1,S2,„,Sn），要求找到一个最短的字符串T，使得这n个字符串（S1,S2,„,Sn）都是T的子串。</p>\n<h3 id=\"输入输出格式-2\"><a href=\"#输入输出格式-2\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式-2\"><a href=\"#输入格式-2\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>第一行是一个正整数n（n&lt;=12），表示给定的字符串的个数。以下的n行，每行有一个全由大写字母组成的字符串。每个字符串的长度不超过50。</p>\n<h4 id=\"输出格式：-2\"><a href=\"#输出格式：-2\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>只有一行，为找到的最短的字符串T。在保证最短的前提下，如果有多个字符串都满足要求，那么必须输出按字典序排列的第一个。</p>\n<h3 id=\"输入输出样例-2\"><a href=\"#输入输出样例-2\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-2\"><a href=\"#输入样例：-2\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>2 \nABCD\nBCDABC\n</code></pre><h4 id=\"输出样例：-2\"><a href=\"#输出样例：-2\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>ABCDABC\n</code></pre><hr>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>考虑$n$很小的性质，第一眼以为是状态压缩DP暴力转移（实际也能做，但是很难写），正解应该是将在AC自动机上DP。根据AC自动机的性质，易知一条路径即代表一个字符串。设$f[i][S]$表示当前走到第$i$号节点，已经覆盖串的集合为$S$的最小步数状态数为$n<em>50</em>2^n$，直接用BFS更新即可。</p>\n<hr>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 6e2+5;\n\nint read(){\n    int x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=x*10+ch-&#39;0&#39;,ch=getchar();\n    return x;\n}\n\nchar s[13][51];\nint n;\nstruct kd{\n    int x,y;\n}X,Y;\n\nstruct AC{\n    int cnt,tr[N][26],f[N],tag[N],pos[N];\n    int d[N][1&lt;&lt;12];\n    int prex[N][1&lt;&lt;12],prey[N][1&lt;&lt;12];\n\n    void init(){\n        cnt=0;\n        memset(tr[0],-1,sizeof(tr[0]));\n    }\n\n    void add(char *s,int k){\n        int n=strlen(s);\n        int x=0;\n        for(int i=0;i&lt;n;++i){\n            int c=s[i]-&#39;A&#39;;\n            if(tr[x][c]==-1){\n                tr[x][c]=++cnt;\n                pos[cnt]=c;\n                memset(tr[cnt],-1,sizeof(tr[cnt]));\n                tag[cnt]=0;\n            }\n            x=tr[x][c];\n        }\n        tag[x]|=1&lt;&lt;k;\n    }\n\n    void getf(){\n        queue&lt;int&gt;q;\n        f[0]=0;\n        for(int i=0;i&lt;26;++i)\n        if(~tr[0][i])f[tr[0][i]]=0,q.push(tr[0][i]);\n        else    tr[0][i]=0;\n        while(!q.empty()){\n            int x=q.front();q.pop();\n            tag[x]|=tag[f[x]];\n            for(int i=0;i&lt;26;++i){\n                if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);\n                else    tr[x][i]=tr[f[x]][i];\n            }\n        }\n    }\n\n    void output(int x,int y){\n        static int q[N];\n        while(x){\n            q[++q[0]]=pos[x]+&#39;A&#39;;    \n            int x1=x,y1=y;    \n            x=prex[x1][y1];\n            y=prey[x1][y1];\n        }\n        reverse(q+1,q+q[0]+1);\n        for(int i=1;i&lt;=q[0];++i)printf(&quot;%c&quot;,(char)q[i]);\n    }\n\n    void solve(){\n        getf();\n        int S=(1&lt;&lt;n)-1;\n        memset(d,-1,sizeof(d));\n        queue&lt;kd&gt;q;\n        X.x=0;X.y=0;\n        q.push(X);d[0][0]=0;\n        prex[0][0]=0;prey[0][0]=0;\n        while(!q.empty()){\n            X=q.front();q.pop();\n            for(int i=0;i&lt;26;++i)\n            if(tr[X.x][i]){\n                int to=tr[X.x][i];\n                Y.x=to;Y.y=X.y|tag[to];\n                if(d[Y.x][Y.y]==-1){\n                    prex[Y.x][Y.y]=X.x;prey[Y.x][Y.y]=X.y;\n\n                    d[Y.x][Y.y]=d[X.x][X.y]+1;\n                    if(Y.y==S){\n//                        printf(&quot;%d\\n&quot;,d[Y.x][Y.y]);\n                        output(Y.x,Y.y);\n                        printf(&quot;\\n&quot;);\n                        exit(0);\n                    }\n                    q.push(Y);\n                }\n            }\n        }\n    }\n}T;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;n);\n    T.init();\n    for(int i=0;i&lt;n;++i){\n        scanf(&quot;%s&quot;,s[i]);\n        T.add(s[i],i);\n    }\n    T.solve();\n}\n</code></pre><hr>\n<h1 id=\"Beijing2017-魔法咒语\"><a href=\"#Beijing2017-魔法咒语\" class=\"headerlink\" title=\"Beijing2017 魔法咒语\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=4861\" target=\"_blank\" rel=\"external\">Beijing2017 魔法咒语</a></h1><hr>\n<h2 id=\"题目描述-3\"><a href=\"#题目描述-3\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Chandra 是一个魔法天才。</p>\n<p>从一岁时接受火之教会洗礼之后， Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。直到十四岁，开始学习威力强大的禁咒法术时， Chandra 才遇到了障碍。根据火之魔法规则，禁咒的构成单位是 N 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 L 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时， Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。很多年过去了，在一次远古遗迹探险中， Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。 Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 M 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。例如，若 ”banana” 是唯一的忌讳词语， “an”、 ”ban”、 ”analysis” 是基本词汇，禁咒长度须是 11， 则“bananalysis” 是无效法术， ”analysisban”、 ”anbanbanban”是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、 一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。谜题破解， Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。由于答案可能很大，你需要输出答案模 1,000,000,007的结果。</p>\n<h3 id=\"输入输出格式-3\"><a href=\"#输入输出格式-3\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式-3\"><a href=\"#输入格式-3\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>第一行，三个正整数 N, M, L。<br>接下来 N 行，每行一个只含小写英文字母的字符串，表示一个基本词汇。<br>接下来 M 行，每行一个只含小写英文字母的字符串，表示一个忌讳词语。<br>对于60%的数据1&lt;=N,M&lt;=50,L&lt;=100<br>对于另40%数据基本词汇长度不超过2,L&lt;=10^8</p>\n<h4 id=\"输出格式：-3\"><a href=\"#输出格式：-3\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>仅一行，一个整数，表示答案（模 10^9+7）。</p>\n<h3 id=\"输入输出样例-3\"><a href=\"#输入输出样例-3\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-3\"><a href=\"#输入样例：-3\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>4 2 10\nboom\noo\nooh\nbang\nob\nmo\n</code></pre><h4 id=\"输出样例：-3\"><a href=\"#输出样例：-3\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>14\n</code></pre><h3 id=\"样例解释\"><a href=\"#样例解释\" class=\"headerlink\" title=\"样例解释\"></a>样例解释</h3><p>有效的禁咒法术共有 14 种：boom/bang/oo，oo/oo/oo/oo/oo，oo/oo/ooh/ooh，oo/ooh/oo/ooh， oo/ooh/ooh/oo， ooh/oo/oo/ooh， ooh/oo/ooh/oo，ooh/ooh/boom， ooh/ooh/oo/oo， ooh/ooh/bang，ooh/bang/ooh，bang/oo/oo/oo， bang/ooh/ooh， bang/bang/oo。</p>\n<hr>\n<h2 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>设$f[i][L]$为走到第$i$号节点，此时字符串长度（即路径长度）为$L$的方案数，那么由于字符集在此题中被限制为了一个个的字符串，所以需要预处理$go[i][j]$表示从$i$号节点出发后经过第$j$个基本词汇后所到达的节点，如果其中经过禁忌词语，则初始化为-1表示不可到达。那么DP方程如下：（$len[j]$表示基本词汇$j$的长度）</p>\n<p>$$f[go [i] [j] ][ L + len[j] ] += f[i][L]  (go[i][j]!=-1)$$</p>\n<p>观察数据范围，朴素的DP只能通过$60%$的数据，剩余$L&lt;=10^8$且$len[j]&lt;=2$的部分分，可以通过矩阵乘法优化，同先前的<a href=\"https://prostkhala.github.io/2017/03/18/DNA%20Sequence/\">DNA Sequence</a>一样，用$f[i][j]$表示从$i$号节点一步到达$j$号节点的方案数，可以处理$len[j]=1$的情况。对于$len[j]=2$的情况，对于每个节点$i$设一个虚拟节点$b[i]$，然后$f[i][b[j]]$表示从$i$一步到$b[j]$的方案数，再从$b[j]$向$j$连一条边即可（即$f[b[j]][j]=1$）。</p>\n<hr>\n<h3 id=\"CODE-3\"><a href=\"#CODE-3\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 5e3+1;\nconst ll mod = 1e9+7;\nint n,m,L,cnt,len[51];\nchar a[51][401],b[51][401];\n\nvoid mul(int &amp;a,int b){\n    a+=b;\n    if(a&gt;=mod)a-=mod;\n}\nint t1k;\nstruct Matrix{\n    ll a[401][401];\n    friend Matrix operator * (Matrix a,Matrix b){\n        Matrix c;\n        memset(c.a,0,sizeof(c.a));\n        for(int i=0;i&lt;=t1k;++i)\n        for(int j=0;j&lt;=t1k;++j){\n            for(int k=0;k&lt;=t1k;++k)\n            (c.a[i][j]+=a.a[i][k]*b.a[k][j])%=mod;\n        }\n        return c;\n    }\n}res,c;\n\n\n\nstruct AC{\n    int tr[N][26],f[N],tag[N],val[N],to[N][51];\n\n    void init(){\n        cnt=0;\n        memset(tr[0],-1,sizeof(tr[0]));\n    }\n\n    void add(char *s,int h){\n        int x=0;\n        int n=strlen(s);\n        for(int i=0;i&lt;n;++i){\n            int c=s[i]-&#39;a&#39;;\n            if(tr[x][c]==-1){\n                tr[x][c]=++cnt;\n                val[cnt]=i;\n                memset(tr[cnt],-1,sizeof(tr[cnt]));\n            }\n            x=tr[x][c];\n        }\n        tag[x]=h;\n    }\n\n    void getf(){\n        queue&lt;int&gt;q;\n        for(int i=0;i&lt;26;++i)\n        if(~tr[0][i])f[tr[0][i]]=0,q.push(tr[0][i]);\n        else    tr[0][i]=0;\n        while(!q.empty()){\n            int x=q.front();q.pop();\n            tag[x]|=tag[f[x]];\n            for(int i=0;i&lt;26;++i)\n            if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);\n            else    tr[x][i]=tr[f[x]][i]; \n        }\n    }\n\n    int go(int i,char *s){\n        int n=strlen(s);\n            int x=i;\n            if(tag[x])return -1;\n            for(int j=0;j&lt;n;++j){\n                x=tr[x][s[j]-&#39;a&#39;];\n                if(tag[x])return -1;\n            }\n            return x;\n    }\n\n    void A(){\n        static int dp[N][101];\n        dp[0][0]=1;\n        for(int l=0;l&lt;=L;++l)\n        for(int i=0;i&lt;=cnt;++i)\n        for(int j=0;j&lt;n;++j)\n        if(len[j]+l&lt;=L){\n            int y=to[i][j];\n            if(y==-1)continue;\n            mul(dp[y][len[j]+l],dp[i][l]);\n        }\n        int ans=0;\n        for(int i=0;i&lt;=cnt;++i)mul(ans,dp[i][L]);\n        printf(&quot;%d\\n&quot;,ans);\n    }\n\n    void B(){\n        t1k=2*cnt+1;\n        int tp=cnt+1;\n        for(int i=0;i&lt;=cnt;++i)res.a[i+tp][i]=1;\n        for(int i=0;i&lt;=2*cnt+1;++i)c.a[i][i]=1;\n        for(int i=0;i&lt;=cnt;++i)\n        for(int j=0;j&lt;n;++j){\n            int y=to[i][j];\n            if(y==-1)continue;\n            if(len[j]==1)res.a[i][y]++;\n            else    res.a[i][y+tp]++;\n        }\n        while(L){\n            if(L&amp;1)c=c*res;\n            L&gt;&gt;=1;\n            res=res*res;\n        }\n        ll ans=0;\n        for(int i=0;i&lt;=cnt;++i)(ans+=c.a[0][i])%=mod;\n        printf(&quot;%lld\\n&quot;,ans);\n    }\n\n    void solve(){\n        init();\n        for(int i=0;i&lt;m;++i)add(b[i],1);\n        getf();\n        for(int i=0;i&lt;=cnt;++i)\n        for(int j=0;j&lt;n;++j)\n        to[i][j]=go(i,a[j]);\n        if(L&lt;=100)A();\n        else     B();\n    }\n}T;\n\nint main(){\n//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;L);\n    for(int i=0;i&lt;n;++i)scanf(&quot;%s&quot;,a[i]),len[i]=strlen(a[i]);\n    for(int i=0;i&lt;m;++i)scanf(&quot;%s&quot;,b[i]);\n    T.solve();\n}\n/*\n4 2 98\nbo\noo\nhm\nba\nob\nmho\n*/\n</code></pre><hr>\n<h1 id=\"BeiJing2011-禁忌\"><a href=\"#BeiJing2011-禁忌\" class=\"headerlink\" title=\"BeiJing2011 禁忌\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=2553\" target=\"_blank\" rel=\"external\">BeiJing2011 禁忌</a></h1><hr>\n<h2 id=\"题目描述-4\"><a href=\"#题目描述-4\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Magic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力……</p>\n<p>如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。</p>\n<p>这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。</p>\n<p>为了说明什么是禁忌魔法及其伤害，引入以下概念：</p>\n<ol>\n<li><p>字母集A上的每个非空字符串对应了一个魔法。其中A是包含了前alphabet个小写字母的集合。</p>\n</li>\n<li><p>有一个集合T，包含了N个字母集A上的字符串.T中的每一串称为一个禁忌串（Taboo string）</p>\n</li>\n<li><p>一个魔法，或等价地，其对应的串s因为包含禁忌而对使用者造成的伤害按以下方式确定：把s分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。</p>\n</li>\n</ol>\n<p>由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集A上所有长度为len的串。</p>\n<p>但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。</p>\n<p>你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。</p>\n<h3 id=\"输入输出格式-4\"><a href=\"#输入输出格式-4\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式-4\"><a href=\"#输入格式-4\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>第一行包含三个正整数N、len、alphabet。<br>接下来N行，每行包含一个串Ti，表示禁忌串。</p>\n<h4 id=\"输出格式：-4\"><a href=\"#输出格式：-4\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>一个非负实数，表示所受到禁忌伤害的期望值。</p>\n<h3 id=\"输入输出样例-4\"><a href=\"#输入输出样例-4\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-4\"><a href=\"#输入样例：-4\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>2 4 2\naa\nabb\n</code></pre><h4 id=\"输出样例：-4\"><a href=\"#输出样例：-4\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>0.75\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>100%的数据中N ≤ 5，len ≤109，1 ≤ alphabet ≤ 26。</p>\n<p>在所有数据中，有不少于40%的数据中：N = 1。</p>\n<p>数据保证每个串Ti的长度不超过15，并且不是空串。</p>\n<p>数据保证每个Ti均仅含有前alphabet个小写字母。</p>\n<p>数据保证集合T中没有相同的元素，即对任意不同的i和j，有Ti≠Tj。</p>\n<hr>\n<h2 id=\"题解-4\"><a href=\"#题解-4\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>首先考虑对于一个给定的串，如何求其禁忌伤害，这是一个经典的贪心问题，即线段覆盖问题，正确的姿势是按右端点排序，能取的尽量取即可，如果去除存在覆盖的禁忌串（一定没有只取被覆盖的子串优越），那么姿势等价于按左端点排序，且尽可能的取。</p>\n<p>考虑在AC自动机上的贪心，即为从根节点出发每次走到一个禁忌串后，直接返回根节点（因为禁忌串之间不能相互覆盖），重复过程直到路径长度为$L$并将答案加上返回次数除以 $2^{len}$ ，考虑如何用DP优化此过程，仍然设$f[i][L]$表示走到$i$号节点，路径长度为$L$的概率，那么显然有（0表示根节点,$tag$表示是否为禁忌串。）</p>\n<p>$$f[0][L+1]+=f[i][L]+1/alphabet    （tag[tr[x][i]]=1）$$</p>\n<p>$$f[tr[x][i]][L+1]+=f[i][L]+1/alphabet    （tag[tr[x][i]]=0）$$</p>\n<p>考虑如何将统计答案。在贪心的过程中，每次访问到禁忌串时不仅要返回根节点，还要将答案加上到当前节点的概率，即新建一个节点$g$表示答案节点，那么同样有<br>$$f[g][L+1]+=f[i][L]+1/alphabet    （tag[tr[x][i]]=1）$$</p>\n<p>即可以用矩阵乘法优化此过程，并且需要设定$matrix[g][g]=1$，矩阵$L$次方代表$1-L$前缀和的贡献，即为答案。</p>\n<hr>\n<h3 id=\"CODE-4\"><a href=\"#CODE-4\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\n#define mp make_pair\n#define fr first\n#define sd second\n#define pii pair&lt;int,int&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\nconst int N = 1e2+1;\n\nint cnt,n,L,ml,len[6],tr[N][26],f[N],tag[N];\nchar s[6][N];\n\nstruct matrix{\n\n    db a[N][N];\n\n    friend matrix operator * (matrix a,matrix b){\n        matrix c;\n        for(int i=0;i&lt;=cnt+1;++i)\n        for(int j=0;j&lt;=cnt+1;++j)\n        c.a[i][j]=0;\n\n        for(int i=0;i&lt;=cnt+1;++i)\n        for(int j=0;j&lt;=cnt+1;++j)\n        for(int k=0;k&lt;=cnt+1;++k)\n        c.a[i][j]+=a.a[i][k]*b.a[k][j];\n        return c;\n    }\n\n}res;\n\nmatrix qpow(ll b){\n    matrix c;\n    for(int i=0;i&lt;=cnt+1;++i)\n    for(int j=0;j&lt;=cnt+1;++j)\n    c.a[i][j]=(i==j);\n\n    while(b){\n        if(b&amp;1)c=c*res;\n        b&gt;&gt;=1;\n        res=res*res;\n    }\n    return c;\n}\n\nvoid solve(){\n    db k=1.00/(db)ml;\n    for(int i=0;i&lt;=cnt;++i)\n    for(int j=0;j&lt;ml;++j){\n        int y=tr[i][j];\n        if(tag[y])res.a[i][0]+=k,res.a[i][cnt+1]+=k;\n        else    res.a[i][y]+=k;\n    }\n    res.a[cnt+1][cnt+1]=1;\n    printf(&quot;%.8lf&quot;,(double)qpow(L).a[0][cnt+1]);\n}\n\nint add(char *s){\n    int n=strlen(s),x=0;\n    for(int i=0;i&lt;n;++i){\n        int c=s[i]-&#39;a&#39;;\n        if(tr[x][c]==-1){\n            tr[x][c]=++cnt;\n            memset(tr[cnt],-1,sizeof(tr[cnt]));\n        }\n        x=tr[x][c];\n    }\n    tag[x]=1;\n    return n;\n}\n\nvoid getf(){\n    queue&lt;int&gt;q;\n    for(int i=0;i&lt;ml;++i)\n    if(~tr[0][i])f[tr[0][i]]=0,q.push(tr[0][i]);\n    else    tr[0][i]=0;\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        tag[x]|=tag[f[x]];\n        for(int i=0;i&lt;ml;++i){\n            if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);\n            else    tr[x][i]=tr[f[x]][i];\n        }\n    }\n}\n\nint main(){\n//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n    memset(tr[0],-1,sizeof(tr[0]));\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;ml);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s[i]),len[i]=add(s[i]);\n    getf();\n    solve();\n}\n</code></pre><hr>\n<h1 id=\"SCOI2012-喵星球上的点名\"><a href=\"#SCOI2012-喵星球上的点名\" class=\"headerlink\" title=\"SCOI2012 喵星球上的点名\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=2754\" target=\"_blank\" rel=\"external\">SCOI2012 喵星球上的点名</a></h1><hr>\n<h2 id=\"题目描述-5\"><a href=\"#题目描述-5\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>a180285幸运地被选做了地球到喵星球的留学生。他发现喵星人在上课前的点名现象非常有趣。   假设课堂上有N个喵星人，每个喵星人的名字由姓和名构成。喵星球上的老师会选择M个串来点名，每次读出一个串的时候，如果这个串是一个喵星人的姓或名的子串，那么这个喵星人就必须答到。 然而，由于喵星人的字码过于古怪，以至于不能用ASCII码来表示。为了方便描述，a180285决定用数串来表示喵星人的名字。<br>现在你能帮助a180285统计每次点名的时候有多少喵星人答到，以及M次点名结束后每个喵星人答到多少次吗？   </p>\n<h3 id=\"输入输出格式-5\"><a href=\"#输入输出格式-5\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式-5\"><a href=\"#输入格式-5\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>现在定义喵星球上的字符串给定方法：</p>\n<p>先给出一个正整数L，表示字符串的长度，接下来L个整数表示字符串的每个字符。</p>\n<p>输入的第一行是两个整数N和M。</p>\n<p>接下来有N行，每行包含第i 个喵星人的姓和名两个串。姓和名都是标准的喵星球上的字符串。</p>\n<p>接下来有M行，每行包含一个喵星球上的字符串，表示老师点名的串。 </p>\n<h4 id=\"输出格式：-5\"><a href=\"#输出格式：-5\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于每个老师点名的串输出有多少个喵星人应该答到。</p>\n<p>然后在最后一行输出每个喵星人被点到多少次。 </p>\n<h3 id=\"输入输出样例-5\"><a href=\"#输入输出样例-5\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-5\"><a href=\"#输入样例：-5\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>2 3 \n6 8 25 0 24 14 8 6 18 0 10 20 24 0 \n7 14 17 8 7 0 17 0 5 8 25 0 24 0 \n4 8 25 0 24 \n4 7 0 17 0 \n4 17 0 8 25 \n</code></pre><h4 id=\"输出样例：-5\"><a href=\"#输出样例：-5\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>2 \n1 \n0 \n1 2 \n</code></pre><h3 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p> 对于30%的数据，保证：</p>\n<p>1&lt;=N,M&lt;=1000，喵星人的名字总长不超过4000，点名串的总长不超过2000。</p>\n<p>对于100%的数据，保证：</p>\n<p>1&lt;=N&lt;=20000，1&lt;=M&lt;=50000，喵星人的名字总长和点名串的总长分别不超过100000，保证喵星人的字符串中作为字符存在的数不超过10000。</p>\n<hr>\n<h2 id=\"题解-5\"><a href=\"#题解-5\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>由于本题中字符集过大，肯定不能将数组开满，需要用$map$来存储儿子，且不能在每次新建节点时将儿子都表示成$-1$，那么就要默认为$0$。同理需要将根节点设为$1$，并赋值$tr[0][i]=1$，在$getfail$的时候，也应该直接暴力跳$fail$。由于数据较水，这样即可通过此题。（正解为后缀数组+主席树）</p>\n<hr>\n<h3 id=\"CODE-5\"><a href=\"#CODE-5\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\n\nmap&lt;int,int&gt;tr[N];\nmap&lt;int,int&gt;::iterator it;\nint n,m,L,cnt,f[N],g[N],ans[N],res[N],id[N];\nint vis[N],vis1[N],T;\nvector&lt;int&gt;a[N],b[N],tag[N];\n\nint read(){\n    int x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;,ch=getchar();\n    return x;\n}\n\nvoid add(int *s,int n,int fa){\n    int x=1;\n    for(int i=1;i&lt;=n;++i){\n        int c=s[i];\n        if(!tr[x][c])tr[x][c]=++cnt;\n        x=tr[x][c];\n    }\n    tag[x].pb(fa);\n}\n\nvoid getf(){\n    queue&lt;int&gt;q;\n    q.push(1);\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(it=tr[x].begin();it!=tr[x].end();++it){\n            int t=it-&gt;first,k=f[x];\n            while(!tr[k][t])k=f[k];\n            f[it-&gt;second]=tr[k][t];\n            q.push(it-&gt;second);\n        }\n//        for(int i=0;i&lt;L;++i){\n//            if(tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);\n//            else    tr[x][i]=tr[f[x]][i];\n//        }\n    }\n}\n\nint cala(int g){\n    int x=1,ret=0;\n    for(int i=0;i&lt;a[g].size();++i){\n        int to=a[g][i];\n        while(!tr[x][to])x=f[x];x=tr[x][to];\n        for(int j=x;j;j=f[j]){\n            if(vis1[j]==T)break;vis1[j]=T;\n            for(int k=0;k&lt;tag[j].size();++k){\n                int y=tag[j][k];\n                if(vis[y]!=T)vis[y]=T,++ret,ans[y]++;\n            }\n        }\n    }\n    return ret;\n}\n\nint calb(int g){\n    int x=1,ret=0;\n    for(int i=0;i&lt;b[g].size();++i){\n        int to=b[g][i];\n        while(!tr[x][to])x=f[x];x=tr[x][to];\n        for(int j=x;j;j=f[j]){\n            if(vis1[j]==T)break;vis1[j]=T;\n            for(int k=0;k&lt;tag[j].size();++k){\n                int y=tag[j][k];\n                if(vis[y]!=T)vis[y]=T,++ret,ans[y]++;\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n    L=10001;cnt=1;f[1]=0;\n    for(int i=0;i&lt;L;++i)tr[0][i]=1;\n    n=read();m=read();\n    for(int i=1,k;i&lt;=n;++i){\n        k=read();for(int j=1;j&lt;=k;++j)a[i].pb(read());\n        k=read();for(int j=1;j&lt;=k;++j)b[i].pb(read());\n    }\n    for(int i=1,k;i&lt;=m;++i){\n        k=read();for(int j=1;j&lt;=k;++j)g[j]=read();\n        add(g,k,i);\n    }\n    getf();\n    for(int i=1;i&lt;=n;++i){\n        ++T;\n        res[i]=\n        cala(i)+\n        calb(i);\n    }\n    for(int i=1;i&lt;=m;++i)printf(&quot;%d\\n&quot;,ans[i]);\n    for(int i=1;i&lt;=n;++i){\n        printf(&quot;%d&quot;,res[i]);\n        if(i!=n)printf(&quot; &quot;);\n    }\n    return 0;\n}\n</code></pre><hr>\n<h1 id=\"HAOI2017-字符串\"><a href=\"#HAOI2017-字符串\" class=\"headerlink\" title=\"HAOI2017 字符串\"></a><a href=\"http://218.28.19.228:8080/cogs/problem/problem.php?pid=2673\" target=\"_blank\" rel=\"external\">HAOI2017 字符串</a></h1><hr>\n<h2 id=\"题目描述-6\"><a href=\"#题目描述-6\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><img src=\"http://218.28.19.228:8080/upload/image/20170425/20170425154024_30785.png\" alt=\"\"></p>\n<h3 id=\"输入输出格式-6\"><a href=\"#输入输出格式-6\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式-6\"><a href=\"#输入格式-6\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p><img src=\"http://218.28.19.228:8080/upload/image/20170425/20170425154034_33570.png\" alt=\"\"></p>\n<h4 id=\"输出格式：-6\"><a href=\"#输出格式：-6\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p><img src=\"http://218.28.19.228:8080/upload/image/20170425/20170425154044_87420.png\" alt=\"\"></p>\n<h3 id=\"输入输出样例-6\"><a href=\"#输入输出样例-6\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-6\"><a href=\"#输入样例：-6\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>1\nxyz\n3\nxz\ny\nxzy\n</code></pre><h4 id=\"输出样例：-6\"><a href=\"#输出样例：-6\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>2\n3\n0\n</code></pre><h3 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p><img src=\"http://218.28.19.228:8080/upload/image/20170425/20170425154144_60477.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"题解-6\"><a href=\"#题解-6\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>对于每个询问串和初始串，将问题转化为其前后缀的匹配（初始串的表示为$x,y$询问串的表示为为$a,b$）。先将所有询问串建到AC自动机上，然后建出$fail$树。</p>\n<p>同$NOI2011$阿狸的打字机一样，对于一个初始串的子串能匹配到询问串当且仅当在$fail$树中，$x[j]$在$a[j]$的子树中，且$y[j+k+1]$在$b[j+k+1]$的子树中，该算法可以通过子树差分来实现。但是如果直接统计所有前后缀的话，明显会存在重复的情况：</p>\n<p>初始串：$aaab$</p>\n<p>询问串：$abab$</p>\n<p>$k=2$</p>\n<p>此时显然询问串与初始串匹配了两回（即$x[0]-&gt;y[3]$与$a[0]-&gt;b[3]$和$x[1]-&gt;y[4]$与$a[1]-&gt;b[4]$）。</p>\n<p>一般性的，以上算法实际上求的是$k1 \\in [1,k]$中所有可以匹配的$k1$的个数，那么$k$匹配个数即为$[1,k]$匹配个数与$[1,k-1]$匹配个数的差。（需要注意在求解$[1,k-1]$的时候，$a,b,x,y$的边界条件需要与求解$[1,k]$时对齐。）                                                                                                                                                                                 </p>\n<hr>\n<h3 id=\"CODE-6\"><a href=\"#CODE-6\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define fr first\n#define pb push_back\n#define sd second\nusing namespace std;\ntypedef long long ll;\nconst int N = 4e5+5;\n\nint k;\nchar s[N],p[N];\nint n,ans[N];\nvector&lt;pii&gt;sum1[N],sum2[N];\nvector&lt;int&gt;g[N],ch1[N],ch2[N];\nint st[N],ed[N],totw;\n\nstruct lb{\n    int a[N];\n    lb(){\n        memset(a,0,sizeof(a));\n    }\n    void add(int x){\n        for(;x&lt;=totw;x+=x&amp;-x)a[x]++;\n    }\n    int sum(int x){\n        int ret=0;\n        for(;x;x-=x&amp;-x)ret+=a[x];\n        return ret;\n    }\n    int get(int x){\n        return sum(ed[x])-sum(st[x]-1);\n    }\n}T[2];\n\nvoid _debug(int *a){\n    for(int i=0;a[i];++i)printf(&quot;%d &quot;,a[i]);\n    cout&lt;&lt;endl;\n}\n\nstruct __AC{\n    int tr[N][95],f[N],cnt,x[N],y[N];\n    void add(char *s,int n,int *q,bool flag){\n        int x=0;\n        q[0]=q[n+1]=0;\n        for(int i=flag?n:1;flag?i&gt;=1:i&lt;=n;flag?--i:++i){\n            int c=s[i]-33;\n            if(tr[x][c]==-1){\n                tr[x][c]=++cnt;\n                memset(tr[cnt],-1,sizeof(tr[cnt]));\n            }\n            q[i]=x=tr[x][c];\n        }\n    }\n    void getf(){\n        queue&lt;int&gt;q;\n        for(int i=0;i&lt;95;++i)\n        if(~tr[0][i])q.push(tr[0][i]);\n        else    tr[0][i]=0;\n        while(!q.empty()){\n            int x=q.front();q.pop();\n            g[f[x]].pb(x);\n            for(int i=0;i&lt;95;++i)\n            if(~tr[x][i])f[tr[x][i]]=tr[f[x]][i],q.push(tr[x][i]);\n            else    tr[x][i]=tr[f[x]][i];\n        }\n    }\n    void dfs(int x){\n        st[x]=++totw;\n        for(int i=0;i&lt;g[x].size();++i)dfs(g[x][i]);\n        ed[x]=totw;\n    }\n    void getans(int x){\n        for(int i=0;i&lt;sum1[x].size();++i){pii t=sum1[x][i];ans[t.sd]-=T[0].get(t.fr);}\n        for(int i=0;i&lt;sum2[x].size();++i){pii t=sum2[x][i];ans[t.sd]+=T[1].get(t.fr);}\n        for(int i=0;i&lt;ch1[x].size();++i){int t=ch1[x][i];T[0].add(st[t]);}\n        for(int i=0;i&lt;ch2[x].size();++i){int t=ch2[x][i];T[1].add(st[t]);}\n        for(int i=0;i&lt;g[x].size();++i)getans(g[x][i]);\n        for(int i=0;i&lt;sum1[x].size();++i){pii t=sum1[x][i];ans[t.sd]+=T[0].get(t.fr);}\n        for(int i=0;i&lt;sum2[x].size();++i){pii t=sum2[x][i];ans[t.sd]-=T[1].get(t.fr);}\n    }\n    void solve(){\n        memset(tr[0],-1,sizeof(tr[0]));\n        int len=strlen(s+1);\n        for(int i=1;i&lt;=n;++i){\n            scanf(&quot;%s&quot;,p+1);\n            int m=strlen(p+1);\n            if(m&lt;=k)ans[i]=len-m+1;\n            else{\n                add(p,m,x,0);add(p,m,y,1);\n//                _debug(x);_debug(y);\n                for(int j=k+1;j&lt;=m+1;++j)sum1[x[j-k-1]].pb(mp(y[j],i));\n                for(int j=k+1;j&lt;=m;++j)sum2[x[j-k]].pb(mp(y[j],i));\n            }\n        }\n        getf();\n        int pt;\n        x[0]=x[len+1]=y[0]=y[len+1]=0;\n        pt=0;for(int i=1;i&lt;=len;++i)x[i]=pt=tr[pt][s[i]-33];\n        pt=0;for(int i=len;i&gt;=1;--i)y[i]=pt=tr[pt][s[i]-33];\n//        _debug(x);_debug(y);\n//        cout&lt;&lt;endl;\n        for(int j=k+1;j&lt;=len+1;++j)ch1[x[j-k-1]].pb(y[j]);\n        for(int j=k+1;j&lt;=len;++j)ch2[x[j-k]].pb(y[j]);\n        dfs(0);\n//        _debug(st);\n        getans(0);\n    }\n}AC;\n\nint main(){\n//    freopen(&quot;problemb.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;problemb.out&quot;,&quot;w&quot;,stdout);\n//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n    scanf(&quot;%d%s%d&quot;,&amp;k,s+1,&amp;n);\n    AC.solve();\n    for(int i=1;i&lt;=n;++i)printf(&quot;%d\\n&quot;,ans[i]);\n//    cout&lt;&lt;AC.cnt&lt;&lt;endl;\n}\n</code></pre><hr>\n<h1 id=\"Tjoi2013-单词\"><a href=\"#Tjoi2013-单词\" class=\"headerlink\" title=\"Tjoi2013 单词\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=3172\" target=\"_blank\" rel=\"external\">Tjoi2013 单词</a></h1><hr>\n<h1 id=\"Coci2015-Divljak\"><a href=\"#Coci2015-Divljak\" class=\"headerlink\" title=\"Coci2015 Divljak\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=3881\" target=\"_blank\" rel=\"external\">Coci2015 Divljak</a></h1>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/12/01/AC自动机总结/","excerpt":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"Hollerith-type","slug":"数据结构/Hollerith-type","permalink":"https://prostkhala.github.io/categories/数据结构/Hollerith-type/"},{"name":"AC自动机","slug":"数据结构/Hollerith-type/AC自动机","permalink":"https://prostkhala.github.io/categories/数据结构/Hollerith-type/AC自动机/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://prostkhala.github.io/tags/AC自动机/"},{"name":"BFS","slug":"BFS","permalink":"https://prostkhala.github.io/tags/BFS/"},{"name":"子树差分","slug":"子树差分","permalink":"https://prostkhala.github.io/tags/子树差分/"}]},{"title":"回文树总结","date":"2017-11-28T09:51:14.000Z","path":"2017/11/28/回文树总结/","text":"概念与构造概念回文树能够以$O(n)$的时间求出字符串中本质不同的回文串个数（最多为$n$个，证明考虑每次插入一个新的后缀，如果形成的新的最长回文串不是整个串，则一定在前面插入时出现过。）和其长度与出现次数。 回文树中每个节点表示的是一个回文串，第一种边以$son[x][ch]$存储，指向的是$x$所代表的回文串前后各插入一个$ch$所形成的字符串，第二种边为后缀链接边(suffix link)，指向的是$x$所代表的回文串其最长的回文子串（与$x$不相等），以$f[x]$表示。初始化为一个长度为$0$的节点（标号应为$0$）和长度为$-1$的节点，其中前者的$f$指向后者，具体原因见下文代码注释。 构造从左到右一个字符一个字符地处理，始终维护着当前已处理前缀的最长后缀回文串(初始时为空串)。每次扫描一个新的字符$x$时，我们就沿着最长后缀回文串的$f$找到一个回文串$A$，它的两边可以同时添加字符$x$，得到一个合法的后缀回文串。$xAx$是新节点的唯一候选，为了得到它的$f$，我们需要继续沿着链接走，直到找到另一个回文串$B$，它的两边添加字符x可以得到$xAx$的合法后缀回文串，于是添加一条从$xAx$到$xBx$的$f$边（当然，如果这条边已经存在就不用了）。 实现如下： struct PalindromesTree{ int tot,last,l[N],son[N][26],c[N],f[N]; int newnode(int x){ l[++tot]=x;return tot; } void init(){ tot=-1;last=0; f[newnode(0)]=1;f[newnode(-1)]=0; } int get(int x,int n){ while(s[n]!=s[n-l[x]-1])x=f[x]; return x; //沿着最长后缀回文串的$f$找到一个回文串A，它的两边可以同时添加字符x //如果找不到的话，那么会先遍历到长度为$0$的节点，判断能否形成s[n-1],s[n]这样一个回文串，否则来到长度为$-1$的节点，一定能形成一个s[n]单个字符的回文串。 } int add(int x,int i){ int y=get(last,i);//last即为维护的最长后缀回文串 if(!son[y][x]){ int now=newnode(l[y]+2);//now代表的回文串为y代表的回文串在两边加入xx形成。 f[now]=son[get(f[y],i)][x];//更新f，理由get函数注释 son[y][x]=now; } c[last=son[y][x]]++;//表示出现次数，最后要更新c[f[x]]+=c[x]，因为如果产生了一个新的回文串的话，那么其所有子串是没有计算c的变化的。 } ll solve(){ for(int i=1;i&lt;=n;++i)add(s[i]-&#39;a&#39;,i); for(int i=tot;i&gt;=1;--i)c[f[i]]+=c[i]; return ret; } }T; 习题 APIO2014 Palindromes 题目描述给你一个由小写拉丁字母组成的字符串 ss。我们定义 ss 的一个子串的存在值为这个子串在 ss 中出现的次数乘以这个子串的长度。 对于给你的这个字符串 ss，求所有回文子串中的最大存在值。 输入输出格式输入格式:一行，一个由小写拉丁字母（a~z）组成的非空字符串 ss。 输出格式：输出一个整数，表示所有回文子串中的最大存在值。 输入输出样例输入样例：abacaba 输出样例：7 数据范围 第一个子任务共 8 分，满足 1≤∣s∣≤1001≤∣s∣≤100。 第二个子任务共 15 分，满足 1≤∣s∣≤10001≤∣s∣≤1000。 第三个子任务共 24 分，满足 1≤∣s∣≤100001≤∣s∣≤10000。 第四个子任务共 26 分，满足 1≤∣s∣≤1000001≤∣s∣≤100000。 第五个子任务共 27 分，满足 1≤∣s∣≤3000001≤∣s∣≤300000。 时间限制：1s1s 空间限制：256MB 题解虚树裸题。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 3e5+2; char s[N]; int n; struct PalindromesTree{ int tot,last,l[N],son[N][26],c[N],f[N]; int newnode(int x){ l[++tot]=x;return tot; } void init(){ tot=-1;last=0; f[newnode(0)]=1;f[newnode(-1)]=0; } int get(int x,int n){ while(s[n]!=s[n-l[x]-1])x=f[x]; return x; } int add(int x,int i){ int y=get(last,i); if(!son[y][x]){ int now=newnode(l[y]+2),ne=get(f[y],i); f[now]=son[ne][x]; son[y][x]=now; } c[last=son[y][x]]++; } ll solve(){ for(int i=1;i&lt;=n;++i)add(s[i]-&#39;a&#39;,i); for(int i=tot;i&gt;=1;--i)c[f[i]]+=c[i]; ll ret=0; for(int i=1;i&lt;=tot;++i)ret=max(ret,(ll)l[i]*c[i]); return ret; } }T; int main(){ scanf(&quot;%s&quot;,s+1); T.init(); n=strlen(s+1); printf(&quot;%lld\\n&quot;,T.solve()); } Codechef Palindromeness 题目描述非回文串的回文指数为0，单个字符的回文指数为1，否则一个长度为$|S|$的回文串的回文指数为$1+$前$|S/2|$个字符组成的回文串的回文指数。多组询问，求给定回文串所有子串的回文指数之和。 Let us define the palindromeness of a string in the following way: If the string is not a palindrome, its’ palindromeness is zero. The palindromeness of an one-letter string is 1. The palindromness of a string S of the length greater than one is 1 + “palindromeness of the string that is formed by the first [|S|/2] symbols of S”. Let us consider some examples for better understanding: The palindromeness of the string zxqfd is 0, since the string is not a palindrome. The palindromeness of the string a is 1, by definition. The palindromeness of the string aa is 2, beucase for “aa” we get 1 + palindromeness of “a”, that is one, so we get 2. The palindromeness of the string abacaba is 3. You are given a string S. Find the sum of the palindromenesses of all the non empty substrings of S (i.e. S[i..j], where i &lt;= j). In other words, you have to calculate the sum of palindromenesses of N * (N + 1) / 2 substrings of S, where N is the length of S. 输入输出格式输入格式:The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. The first and only line of every test case contains a single string S for the corresponding test case. 输出格式：For each test case, output a single line containing an integer corresponding to the answer to the problem. 输入输出样例输入样例：2 zxqfd aba 输出样例：5 5 数据范围 1 ≤ T ≤ 3 S consists only of lower-case Latin letters. Subtask 1 (15 points): 1 ≤ |S| ≤ 100 Subtask 2 (23 points): 1 ≤ |S| ≤ 1000 Subtask 3 (62 points): 1 ≤ |S| ≤ 100000 题解判断第一个满足条件的后缀回文是否正好为其一半长度，每次递归$f$数组查询显然会TLE，用$hf_x$表示满足小于等于其一半长度的$f_x$记忆化处理即可。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e5+10; int n; char s[N]; struct PalindromicTree{ int tot,last,l[N],son[N][26],hf[N],f[N]; ll c[N],g[N]; int newnode(int x){ l[++tot]=x; f[tot]=hf[tot]=c[tot]=0; memset(son[tot],0,sizeof(son[tot])); return tot; } void init(){ last=0;tot=-1; if(g[0]!=0||g[1]!=0)while(1); newnode(0);f[0]=hf[0]=1; newnode(-1);f[1]=0; } int get(int x,int i){ while(s[i]!=s[i-l[x]-1])x=f[x]; return x; } int add(int x,int i){ int y=get(last,i); if(!son[y][x]){ int now=newnode(l[y]+2); f[now]=son[get(f[y],i)][x]; hf[now]=son[get(hf[y],i)][x]; while(l[hf[now]]&gt;l[now]/2)hf[now]=f[hf[now]]; int fr=hf[now]; g[now]=1+(l[fr]==l[now]/2)*g[fr]; son[y][x]=now; } c[last=son[y][x]]++; } ll solve(){ ll ret=0; init(); for(int i=1;i&lt;=n;++i)add(s[i]-&#39;a&#39;,i); for(int i=tot;i&gt;=1;--i){ ret+=c[i]*g[i]; c[f[i]]+=c[i]; } return ret; } }T; int main(){ // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); int Case; scanf(&quot;%d&quot;,&amp;Case); while(Case--){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); printf(&quot;%lld\\n&quot;,T.solve()); } }","raw":"title: 回文树总结\ndate: 2017-11-28 17:51:14\ncategories:\n  - 数据结构\n  - 回文树\ntags:\n  - 回文树\n---\n\n# 概念与构造\n\n## 概念\n回文树能够以$O(n)$的时间求出字符串中本质不同的回文串个数（最多为$n$个，证明考虑每次插入一个新的后缀，如果形成的新的最长回文串不是整个串，则一定在前面插入时出现过。）和其长度与出现次数。\n\n回文树中每个节点表示的是一个回文串，第一种边以$son[x][ch]$存储，指向的是$x$所代表的回文串前后各插入一个$ch$所形成的字符串，第二种边为后缀链接边(suffix link)，指向的是$x$所代表的回文串其最长的回文子串（与$x$不相等），以$f[x]$表示。初始化为一个长度为$0$的节点（标号应为$0$）和长度为$-1$的节点，其中前者的$f$指向后者，具体原因见下文代码注释。\n\n\n## 构造\n从左到右一个字符一个字符地处理，始终维护着当前已处理前缀的最长后缀回文串(初始时为空串)。每次扫描一个新的字符$x$时，我们就沿着最长后缀回文串的$f$找到一个回文串$A$，它的两边可以同时添加字符$x$，得到一个合法的后缀回文串。$xAx$是新节点的唯一候选，为了得到它的$f$，我们需要继续沿着链接走，直到找到另一个回文串$B$，它的两边添加字符x可以得到$xAx$的合法后缀回文串，于是添加一条从$xAx$到$xBx$的$f$边（当然，如果这条边已经存在就不用了）。\n\n\n实现如下：\n\n    struct PalindromesTree{\n        int tot,last,l[N],son[N][26],c[N],f[N];\n\n        int newnode(int x){\n            l[++tot]=x;return tot;\n        }\n\n        void init(){\n            tot=-1;last=0;\n            f[newnode(0)]=1;f[newnode(-1)]=0;\n        }\n\n        int get(int x,int n){\n            while(s[n]!=s[n-l[x]-1])x=f[x];\n            return x;\n            //沿着最长后缀回文串的$f$找到一个回文串A，它的两边可以同时添加字符x\n            //如果找不到的话，那么会先遍历到长度为$0$的节点，判断能否形成s[n-1],s[n]这样一个回文串，否则来到长度为$-1$的节点，一定能形成一个s[n]单个字符的回文串。\n        }\n\n        int add(int x,int i){\n            int y=get(last,i);//last即为维护的最长后缀回文串\n            if(!son[y][x]){\n                int now=newnode(l[y]+2);//now代表的回文串为y代表的回文串在两边加入xx形成。\n                f[now]=son[get(f[y],i)][x];//更新f，理由get函数注释\n                son[y][x]=now;\n            }\n            c[last=son[y][x]]++;//表示出现次数，最后要更新c[f[x]]+=c[x]，因为如果产生了一个新的回文串的话，那么其所有子串是没有计算c的变化的。\n        }\n\n        ll solve(){\n            for(int i=1;i<=n;++i)add(s[i]-'a',i);\n            for(int i=tot;i>=1;--i)c[f[i]]+=c[i];\n            return ret;\n        }\n    }T;\n    \n---\n\n# 习题\n---\n## [APIO2014 Palindromes](http://uoj.ac/problem/103)\n---\n### 题目描述\n给你一个由小写拉丁字母组成的字符串 ss。我们定义 ss 的一个子串的存在值为这个子串在 ss 中出现的次数乘以这个子串的长度。\n\n对于给你的这个字符串 ss，求所有回文子串中的最大存在值。\n\n#### 输入输出格式\n##### 输入格式:\n一行，一个由小写拉丁字母（a~z）组成的非空字符串 ss。\n\n##### 输出格式：\n输出一个整数，表示所有回文子串中的最大存在值。\n\n#### 输入输出样例\n##### 输入样例：\n    abacaba\n    \n##### 输出样例：\n\t7\n#### 数据范围\n 第一个子任务共 8 分，满足 1≤∣s∣≤1001≤∣s∣≤100。\n\n第二个子任务共 15 分，满足 1≤∣s∣≤10001≤∣s∣≤1000。\n\n第三个子任务共 24 分，满足 1≤∣s∣≤100001≤∣s∣≤10000。\n\n第四个子任务共 26 分，满足 1≤∣s∣≤1000001≤∣s∣≤100000。\n\n第五个子任务共 27 分，满足 1≤∣s∣≤3000001≤∣s∣≤300000。\n\n时间限制：1s1s\n\n空间限制：256MB\n \n---\n\n### 题解\n虚树裸题。\n\n---\n#### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 3e5+2;\n\n    char s[N];\n    int n;\n\n    struct PalindromesTree{\n        int tot,last,l[N],son[N][26],c[N],f[N];\n\n        int newnode(int x){\n            l[++tot]=x;return tot;\n        }\n\n        void init(){\n            tot=-1;last=0;\n            f[newnode(0)]=1;f[newnode(-1)]=0;\n        }\n\n        int get(int x,int n){\n            while(s[n]!=s[n-l[x]-1])x=f[x];\n            return x;\n        }\n\n        int add(int x,int i){\n            int y=get(last,i);\n            if(!son[y][x]){\n                int now=newnode(l[y]+2),ne=get(f[y],i);\n                f[now]=son[ne][x];\n                son[y][x]=now;\n            }\n            c[last=son[y][x]]++;\n        }\n\n        ll solve(){\n            for(int i=1;i<=n;++i)add(s[i]-'a',i);\n            for(int i=tot;i>=1;--i)c[f[i]]+=c[i];\n            ll ret=0;\n            for(int i=1;i<=tot;++i)ret=max(ret,(ll)l[i]*c[i]);\n            return ret;\n        }\n    }T;\n\n    int main(){\n        scanf(\"%s\",s+1);\n        T.init();\n        n=strlen(s+1);\n        printf(\"%lld\\n\",T.solve());\n    }\n\n\n---\n\n## [Codechef Palindromeness](http://www.lydsy.com/JudgeOnline/problem.php?id=3572)\n---\n### 题目描述\n\n非回文串的回文指数为0，单个字符的回文指数为1，否则一个长度为$|S|$的回文串的回文指数为$1+$前$|S/2|$个字符组成的回文串的回文指数。多组询问，求给定回文串所有子串的回文指数之和。\n\nLet us define the palindromeness of a string in the following way:\n\n- If the string is not a palindrome, its' palindromeness is zero.\n\n- The palindromeness of an one-letter string is 1.\n\n- The palindromness of a string S of the length greater than one is 1 + \"palindromeness of the string that is formed by the first [|S|/2] symbols of S\".\n\nLet us consider some examples for better understanding:\n\n- The palindromeness of the string zxqfd is 0, since the string is not a palindrome.\n- The palindromeness of the string a is 1, by definition.\n- The palindromeness of the string aa is 2, beucase for \"aa\" we get 1 + palindromeness of \"a\", that is one, so we get 2.\n- The palindromeness of the string abacaba is 3.\n\nYou are given a string S. Find the sum of the palindromenesses of all the non empty substrings of S (i.e. S[i..j], where i <= j). In other words, you have to calculate the sum of palindromenesses of N * (N + 1) / 2 substrings of S, where N is the length of S.\n\n\n#### 输入输出格式\n##### 输入格式:\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n\nThe first and only line of every test case contains a single string S for the corresponding test case.\n\n##### 输出格式：\nFor each test case, output a single line containing an integer corresponding to the answer to the problem.\n#### 输入输出样例\n##### 输入样例：\n    2\n    zxqfd\n    aba\n\n##### 输出样例：\n\t5\n    5\n    \n#### 数据范围\n- 1 ≤ T ≤ 3\n- S consists only of lower-case Latin letters.\n\n- Subtask 1 (15 points):\n\n\t- 1 ≤ |S| ≤ 100\n\n- Subtask 2 (23 points):\n\n\t- 1 ≤ |S| ≤ 1000\n\n- Subtask 3 (62 points):\n\n\t- 1 ≤ |S| ≤ 100000\n\n---\n\n### 题解\n判断第一个满足条件的后缀回文是否正好为其一半长度，每次递归$f$数组查询显然会TLE，用$hf_x$表示满足小于等于其一半长度的$f_x$记忆化处理即可。\n\n---\n#### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e5+10;\n\n    int n;\n    char s[N];\n\n    struct PalindromicTree{\n        int tot,last,l[N],son[N][26],hf[N],f[N];\n        ll c[N],g[N];\n        int newnode(int x){\n            l[++tot]=x;\n            f[tot]=hf[tot]=c[tot]=0;\n            memset(son[tot],0,sizeof(son[tot]));\n            return tot;\n        }\n\n        void init(){\n            last=0;tot=-1;\n            if(g[0]!=0||g[1]!=0)while(1);\n            newnode(0);f[0]=hf[0]=1;\n            newnode(-1);f[1]=0;\n        }\n\n        int get(int x,int i){\n            while(s[i]!=s[i-l[x]-1])x=f[x];\n            return x;\n        }\n\n        int add(int x,int i){\n            int y=get(last,i);\n            if(!son[y][x]){\n                int now=newnode(l[y]+2);\n                f[now]=son[get(f[y],i)][x];\n                hf[now]=son[get(hf[y],i)][x];\n                while(l[hf[now]]>l[now]/2)hf[now]=f[hf[now]];\n                int fr=hf[now];\n                g[now]=1+(l[fr]==l[now]/2)*g[fr];\n                son[y][x]=now;\n            }\n            c[last=son[y][x]]++;\n        }\n\n        ll solve(){\n            ll ret=0;\n            init();\n            for(int i=1;i<=n;++i)add(s[i]-'a',i);\n            for(int i=tot;i>=1;--i){\n                ret+=c[i]*g[i];\n                c[f[i]]+=c[i];\n            }\n            return ret;\n        }\n    }T;\n\n    int main(){\n    //\tfreopen(\"c.in\",\"r\",stdin);\n        int Case;\n        scanf(\"%d\",&Case);\n        while(Case--){\n            scanf(\"%s\",s+1);\n            n=strlen(s+1);\n            printf(\"%lld\\n\",T.solve());\n        }\n    }","content":"<h1 id=\"概念与构造\"><a href=\"#概念与构造\" class=\"headerlink\" title=\"概念与构造\"></a>概念与构造</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>回文树能够以$O(n)$的时间求出字符串中本质不同的回文串个数（最多为$n$个，证明考虑每次插入一个新的后缀，如果形成的新的最长回文串不是整个串，则一定在前面插入时出现过。）和其长度与出现次数。</p>\n<p>回文树中每个节点表示的是一个回文串，第一种边以$son[x][ch]$存储，指向的是$x$所代表的回文串前后各插入一个$ch$所形成的字符串，第二种边为后缀链接边(suffix link)，指向的是$x$所代表的回文串其最长的回文子串（与$x$不相等），以$f[x]$表示。初始化为一个长度为$0$的节点（标号应为$0$）和长度为$-1$的节点，其中前者的$f$指向后者，具体原因见下文代码注释。</p>\n<h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p>从左到右一个字符一个字符地处理，始终维护着当前已处理前缀的最长后缀回文串(初始时为空串)。每次扫描一个新的字符$x$时，我们就沿着最长后缀回文串的$f$找到一个回文串$A$，它的两边可以同时添加字符$x$，得到一个合法的后缀回文串。$xAx$是新节点的唯一候选，为了得到它的$f$，我们需要继续沿着链接走，直到找到另一个回文串$B$，它的两边添加字符x可以得到$xAx$的合法后缀回文串，于是添加一条从$xAx$到$xBx$的$f$边（当然，如果这条边已经存在就不用了）。</p>\n<p>实现如下：</p>\n<pre><code>struct PalindromesTree{\n    int tot,last,l[N],son[N][26],c[N],f[N];\n\n    int newnode(int x){\n        l[++tot]=x;return tot;\n    }\n\n    void init(){\n        tot=-1;last=0;\n        f[newnode(0)]=1;f[newnode(-1)]=0;\n    }\n\n    int get(int x,int n){\n        while(s[n]!=s[n-l[x]-1])x=f[x];\n        return x;\n        //沿着最长后缀回文串的$f$找到一个回文串A，它的两边可以同时添加字符x\n        //如果找不到的话，那么会先遍历到长度为$0$的节点，判断能否形成s[n-1],s[n]这样一个回文串，否则来到长度为$-1$的节点，一定能形成一个s[n]单个字符的回文串。\n    }\n\n    int add(int x,int i){\n        int y=get(last,i);//last即为维护的最长后缀回文串\n        if(!son[y][x]){\n            int now=newnode(l[y]+2);//now代表的回文串为y代表的回文串在两边加入xx形成。\n            f[now]=son[get(f[y],i)][x];//更新f，理由get函数注释\n            son[y][x]=now;\n        }\n        c[last=son[y][x]]++;//表示出现次数，最后要更新c[f[x]]+=c[x]，因为如果产生了一个新的回文串的话，那么其所有子串是没有计算c的变化的。\n    }\n\n    ll solve(){\n        for(int i=1;i&lt;=n;++i)add(s[i]-&#39;a&#39;,i);\n        for(int i=tot;i&gt;=1;--i)c[f[i]]+=c[i];\n        return ret;\n    }\n}T;\n</code></pre><hr>\n<h1 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h1><hr>\n<h2 id=\"APIO2014-Palindromes\"><a href=\"#APIO2014-Palindromes\" class=\"headerlink\" title=\"APIO2014 Palindromes\"></a><a href=\"http://uoj.ac/problem/103\" target=\"_blank\" rel=\"external\">APIO2014 Palindromes</a></h2><hr>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给你一个由小写拉丁字母组成的字符串 ss。我们定义 ss 的一个子串的存在值为这个子串在 ss 中出现的次数乘以这个子串的长度。</p>\n<p>对于给你的这个字符串 ss，求所有回文子串中的最大存在值。</p>\n<h4 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><h5 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h5><p>一行，一个由小写拉丁字母（a~z）组成的非空字符串 ss。</p>\n<h5 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h5><p>输出一个整数，表示所有回文子串中的最大存在值。</p>\n<h4 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><h5 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h5><pre><code>abacaba\n</code></pre><h5 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h5><pre><code>7\n</code></pre><h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p> 第一个子任务共 8 分，满足 1≤∣s∣≤1001≤∣s∣≤100。</p>\n<p>第二个子任务共 15 分，满足 1≤∣s∣≤10001≤∣s∣≤1000。</p>\n<p>第三个子任务共 24 分，满足 1≤∣s∣≤100001≤∣s∣≤10000。</p>\n<p>第四个子任务共 26 分，满足 1≤∣s∣≤1000001≤∣s∣≤100000。</p>\n<p>第五个子任务共 27 分，满足 1≤∣s∣≤3000001≤∣s∣≤300000。</p>\n<p>时间限制：1s1s</p>\n<p>空间限制：256MB</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>虚树裸题。</p>\n<hr>\n<h4 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 3e5+2;\n\nchar s[N];\nint n;\n\nstruct PalindromesTree{\n    int tot,last,l[N],son[N][26],c[N],f[N];\n\n    int newnode(int x){\n        l[++tot]=x;return tot;\n    }\n\n    void init(){\n        tot=-1;last=0;\n        f[newnode(0)]=1;f[newnode(-1)]=0;\n    }\n\n    int get(int x,int n){\n        while(s[n]!=s[n-l[x]-1])x=f[x];\n        return x;\n    }\n\n    int add(int x,int i){\n        int y=get(last,i);\n        if(!son[y][x]){\n            int now=newnode(l[y]+2),ne=get(f[y],i);\n            f[now]=son[ne][x];\n            son[y][x]=now;\n        }\n        c[last=son[y][x]]++;\n    }\n\n    ll solve(){\n        for(int i=1;i&lt;=n;++i)add(s[i]-&#39;a&#39;,i);\n        for(int i=tot;i&gt;=1;--i)c[f[i]]+=c[i];\n        ll ret=0;\n        for(int i=1;i&lt;=tot;++i)ret=max(ret,(ll)l[i]*c[i]);\n        return ret;\n    }\n}T;\n\nint main(){\n    scanf(&quot;%s&quot;,s+1);\n    T.init();\n    n=strlen(s+1);\n    printf(&quot;%lld\\n&quot;,T.solve());\n}\n</code></pre><hr>\n<h2 id=\"Codechef-Palindromeness\"><a href=\"#Codechef-Palindromeness\" class=\"headerlink\" title=\"Codechef Palindromeness\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=3572\" target=\"_blank\" rel=\"external\">Codechef Palindromeness</a></h2><hr>\n<h3 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>非回文串的回文指数为0，单个字符的回文指数为1，否则一个长度为$|S|$的回文串的回文指数为$1+$前$|S/2|$个字符组成的回文串的回文指数。多组询问，求给定回文串所有子串的回文指数之和。</p>\n<p>Let us define the palindromeness of a string in the following way:</p>\n<ul>\n<li><p>If the string is not a palindrome, its’ palindromeness is zero.</p>\n</li>\n<li><p>The palindromeness of an one-letter string is 1.</p>\n</li>\n<li><p>The palindromness of a string S of the length greater than one is 1 + “palindromeness of the string that is formed by the first [|S|/2] symbols of S”.</p>\n</li>\n</ul>\n<p>Let us consider some examples for better understanding:</p>\n<ul>\n<li>The palindromeness of the string zxqfd is 0, since the string is not a palindrome.</li>\n<li>The palindromeness of the string a is 1, by definition.</li>\n<li>The palindromeness of the string aa is 2, beucase for “aa” we get 1 + palindromeness of “a”, that is one, so we get 2.</li>\n<li>The palindromeness of the string abacaba is 3.</li>\n</ul>\n<p>You are given a string S. Find the sum of the palindromenesses of all the non empty substrings of S (i.e. S[i..j], where i &lt;= j). In other words, you have to calculate the sum of palindromenesses of N * (N + 1) / 2 substrings of S, where N is the length of S.</p>\n<h4 id=\"输入输出格式-1\"><a href=\"#输入输出格式-1\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><h5 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h5><p>The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.</p>\n<p>The first and only line of every test case contains a single string S for the corresponding test case.</p>\n<h5 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h5><p>For each test case, output a single line containing an integer corresponding to the answer to the problem.</p>\n<h4 id=\"输入输出样例-1\"><a href=\"#输入输出样例-1\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><h5 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h5><pre><code>2\nzxqfd\naba\n</code></pre><h5 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h5><pre><code>5\n5\n</code></pre><h4 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><ul>\n<li>1 ≤ T ≤ 3</li>\n<li><p>S consists only of lower-case Latin letters.</p>\n</li>\n<li><p>Subtask 1 (15 points):</p>\n<ul>\n<li>1 ≤ |S| ≤ 100</li>\n</ul>\n</li>\n<li><p>Subtask 2 (23 points):</p>\n<ul>\n<li>1 ≤ |S| ≤ 1000</li>\n</ul>\n</li>\n<li><p>Subtask 3 (62 points):</p>\n<ul>\n<li>1 ≤ |S| ≤ 100000</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>判断第一个满足条件的后缀回文是否正好为其一半长度，每次递归$f$数组查询显然会TLE，用$hf_x$表示满足小于等于其一半长度的$f_x$记忆化处理即可。</p>\n<hr>\n<h4 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+10;\n\nint n;\nchar s[N];\n\nstruct PalindromicTree{\n    int tot,last,l[N],son[N][26],hf[N],f[N];\n    ll c[N],g[N];\n    int newnode(int x){\n        l[++tot]=x;\n        f[tot]=hf[tot]=c[tot]=0;\n        memset(son[tot],0,sizeof(son[tot]));\n        return tot;\n    }\n\n    void init(){\n        last=0;tot=-1;\n        if(g[0]!=0||g[1]!=0)while(1);\n        newnode(0);f[0]=hf[0]=1;\n        newnode(-1);f[1]=0;\n    }\n\n    int get(int x,int i){\n        while(s[i]!=s[i-l[x]-1])x=f[x];\n        return x;\n    }\n\n    int add(int x,int i){\n        int y=get(last,i);\n        if(!son[y][x]){\n            int now=newnode(l[y]+2);\n            f[now]=son[get(f[y],i)][x];\n            hf[now]=son[get(hf[y],i)][x];\n            while(l[hf[now]]&gt;l[now]/2)hf[now]=f[hf[now]];\n            int fr=hf[now];\n            g[now]=1+(l[fr]==l[now]/2)*g[fr];\n            son[y][x]=now;\n        }\n        c[last=son[y][x]]++;\n    }\n\n    ll solve(){\n        ll ret=0;\n        init();\n        for(int i=1;i&lt;=n;++i)add(s[i]-&#39;a&#39;,i);\n        for(int i=tot;i&gt;=1;--i){\n            ret+=c[i]*g[i];\n            c[f[i]]+=c[i];\n        }\n        return ret;\n    }\n}T;\n\nint main(){\n//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n    int Case;\n    scanf(&quot;%d&quot;,&amp;Case);\n    while(Case--){\n        scanf(&quot;%s&quot;,s+1);\n        n=strlen(s+1);\n        printf(&quot;%lld\\n&quot;,T.solve());\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/11/28/回文树总结/","excerpt":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"回文树","slug":"数据结构/回文树","permalink":"https://prostkhala.github.io/categories/数据结构/回文树/"}],"tags":[{"name":"回文树","slug":"回文树","permalink":"https://prostkhala.github.io/tags/回文树/"}]},{"title":"虚树总结","date":"2017-11-27T09:42:01.000Z","path":"2017/11/27/虚树总结/","text":"概念与构造概念虚树可以用来解决在树上的多次询问，约束总询问点数的动态规划问题，相较直接BFS的高复杂度，虚树可以将开销降到与单次询问点数相关的时间复杂度之内。 建树考虑动态规划合并多个询问节点，只有在遍历到关键的$LCA$时才会计算贡献，且可以直接以$LCA$代替以下节点，所以可以设计出以下算法流程： $1.$ 维护一个以$dfn$序为关键字的单调栈，栈顶元素$p$为所有已经处理过的节点中$dfn$最大的节点，一般以根为初始节点，将所有询问节点按$dfn$排序进行插入。 $2.$ 根据以上算法，一定有$dfn_x &gt; dfn_p$。设栈顶第二个元素为$q$，根据$LCA$与$q$的关系进行分类讨论： 当$LCA = p$时，将$x$入栈。 否则$p$与$q$分别在$lca$的两个子树中，则需要重复以下操作，直到$p$到$lca$中所有节点处理完毕，然后再将$x$入栈。 当$dfn_q &gt; dfn_{lca}$时，连边$(q,p)$,并将$p$退栈。 当$dfn_q = dfn_{lca}$时，连边$(lca,p)$。此时$p$到$lca$已经处理完毕，即可跳出循环。 当$dfn_q &lt; dfn_{lca}$时，此时$lca$在$q-&gt;p$上，建边$(lca,p)$，以$lca$代替$p$在栈中的位置。此时$p$到$lca$已经处理完毕，即可跳出循环。 习题 SDOI2011 消耗战 题目描述在一场战争中，战场由n个岛屿和n-1个桥梁组成，保证每两个岛屿间有且仅有一条路径可达。现在，我军已经侦查到敌军的总部在编号为1的岛屿，而且他们已经没有足够多的能源维系战斗，我军胜利在望。已知在其他k个岛屿上有丰富能源，为了防止敌军获取能源，我军的任务是炸毁一些桥梁，使得敌军不能到达任何能源丰富的岛屿。由于不同桥梁的材质和结构不同，所以炸毁不同的桥梁有不同的代价，我军希望在满足目标的同时使得总代价最小。 侦查部门还发现，敌军有一台神秘机器。即使我军切断所有能源之后，他们也可以用那台机器。机器产生的效果不仅仅会修复所有我军炸毁的桥梁，而且会重新随机资源分布（但可以保证的是，资源不会分布到1号岛屿上）。不过侦查部门还发现了这台机器只能够使用m次，所以我们只需要把每次任务完成即可。 输入输出格式输入格式:第一行一个整数$n$，代表岛屿数量。 接下来$n-1$行，每行三个整数$u,v,w$，代表$u$号岛屿和$v$号岛屿由一条代价为c的桥梁直接相连，保证$1&lt;=u,v&lt;=n$且$1&lt;=c&lt;=100000$。 第$n+1$行，一个整数$m$，代表敌方机器能使用的次数。 接下来$m$行，每行一个整数$k_i$，代表第$i$次后，有$k_i$个岛屿资源丰富，接下来$k$个整数$h_1,h_2,…h_k$，表示资源丰富岛屿的编号。 输出格式：输出有$m$行，分别代表每次任务的最小代价。 输入输出样例输入样例：10 1 5 13 1 9 6 2 1 19 2 4 8 2 3 91 5 6 8 7 5 4 7 8 31 10 7 9 3 2 10 6 4 5 7 8 3 3 9 4 6 输出样例：12 32 22 数据范围 $2&lt;=n&lt;=250000$ $m&gt;=1$ $\\sum k_i&lt;=500000$ $1&lt;=k_i&lt;=n-1$ 题解设$f_x$为覆盖以$x$为跟子树的最小代价，则有$f_x=min(\\sum f_{sonx},g_x)$，其中$g_x$代表根到$x$路径上的最小权值边，用虚树优化即可。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e6+1; const ll inf = 1e15; int read(){ int x=0,f=1;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=x*10+ch-&#39;0&#39;,ch=getchar(); return x*f; } int n,m,k,head[N],d[N],cnt,f[N][19],q[N],dfn[N],totw,st[N],vis[N]; ll dp[N],g[N]; struct nd{ int ne,to;ll w; }e[N*2]; void in(int x,int y,ll w){ if(x==y)return; e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w; } void dfs(int x,int fa=-1){ dfn[x]=++totw; for(int i=head[x];i;i=e[i].ne) if(e[i].to!=fa){ int y=e[i].to; f[y][0]=x; g[y]=min(g[x],e[i].w); d[y]=d[x]+1; dfs(y,x); } } int lca(int x,int y){ if(d[x]&lt;d[y])swap(x,y); for(int i=18;i&gt;=0;--i) if(d[f[x][i]]&gt;=d[y])x=f[x][i]; if(x==y)return x; for(int i=18;i&gt;=0;--i) if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i]; return f[x][0]; } bool cmp(int a,int b){ return dfn[a]&lt;dfn[b]; } int T=0; ll get(int x){ ll k=0; for(int i=head[x];i;i=e[i].ne)k+=get(e[i].to); head[x]=0; return dp[x]=(vis[x]!=T?min(g[x],k):g[x]); } ll solve(){ cnt=0;++T; sort(q+1,q+k+1,cmp); for(int i=1;i&lt;=k;++i)vis[q[i]]=T; int L=0; st[++L]=1; for(int i=1;i&lt;=k;++i){ int x=q[i],l=lca(x,st[L]); if(l==st[L])st[++L]=x; else{ while(1){ if(dfn[l]&gt;=dfn[st[L-1]]){ in(l,st[L--],0); if(st[L]!=l)st[++L]=l; break; } in(st[L-1],st[L],0),L--; } if(x!=st[L])st[++L]=x; } } while(--L)in(st[L],st[L+1],0); return get(1); } int main(){ // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); n=read(); for(int i=1,x,y,w;i&lt;n;++i){ x=read(),y=read(),w=read(); in(x,y,w);in(y,x,w); } d[1]=1;g[1]=inf;dfs(1); for(int j=1;j&lt;19;++j) for(int i=1;i&lt;=n;++i) f[i][j]=f[f[i][j-1]][j-1]; m=read(); memset(head,0,sizeof(head));cnt=0; while(m--){ k=read(); for(int j=1;j&lt;=k;++j)q[j]=read(); printf(&quot;%lld\\n&quot;,solve()); } } HNOI2014 世界树 题目描述世界树是一棵无比巨大的树，它伸出的枝干构成了整个世界。在这里，生存着各种各样的种族和生灵，他们共同信奉着绝对公正公平的女神艾莉森，在他们的信条里，公平是使世界树能够生生不息、持续运转的根本基石。 世界树的形态可以用一个数学模型来描述：世界树中有n个种族，种族的编号分别从1到n，分别生活在编号为1到n的聚居地上，种族的编号与其聚居地的编号相同。有的聚居地之间有双向的道路相连，道路的长度为1。保证连接的方式会形成一棵树结构，即所有的聚居地之间可以互相到达，并且不会出现环。定义两个聚居地之间的距离为连接他们的道路的长度；例如，若聚居地a和b之间有道路，b和c之间有道路，因为每条道路长度为1而且又不可能出现环，所卧a与c之间的距离为2。 出于对公平的考虑，第i年，世界树的国王需要授权m[i]个种族的聚居地为临时议事处。对于某个种族x（x为种族的编号），如果距离该种族最近的临时议事处为y（y为议事处所在聚居地的编号），则种族x将接受y议事处的管辖（如果有多个临时议事处到该聚居地的距离一样，则y为其中编号最小的临时议事处）。现在国王想知道，在q年的时间里，每一年完成授权后，当年每个临时议事处将会管理多少个种族（议事处所在的聚居地也将接受该议事处管理）。 现在这个任务交给了以智慧著称的灵长类的你：程序猿。请帮国王完成这个任务吧。 输入输出格式输入格式:第一行为一个正整数n，表示世界树中种族的个数。 接下来n-l行，每行两个正整数x，y，表示x聚居地与y聚居地之间有一条长度为1的双向道路。接下来一行为一个正整数q，表示国王询问的年数。 接下来q块，每块两行： 第i块的第一行为1个正整数m[i]，表示第i年授权的临时议事处的个数。 第i块的第二行为m[i]个正整数h[l]、h[2]、…、h[m[i]]，表示被授权为临时议事处的聚居地编号（保证互不相同）。 输出格式：输出包含q行，第i行为m[i]个整数，该行的第j(j=1，2…，，m[i])个数表示第i年被授权的聚居地h[j]的临时议事处管理的种族个数。 输入输出样例输入样例：10 2 1 3 2 4 3 5 4 6 1 7 3 8 3 9 4 10 1 5 2 6 1 5 2 7 3 6 9 1 8 4 8 7 10 3 5 2 9 3 5 8 输出样例：1 9 3 1 4 1 1 10 1 1 3 5 4 1 3 1 1 数据范围 N&lt;=300000, q&lt;=300000,m[1]+m[2]+…+m[q]&lt;=300000 题解先建立虚树，两遍DP找出每个点的控制点，然后在考虑虚树上每一条边的贡献，如果两个顶点属于同一个控制点，直接计算即可，否则二分出控制点不同的位置在计算贡献，注意这一步不应计算端点，否则会导致重复计算，对于没有考虑到的点，其控制点一定在第一个在虚树上的父亲节点上，也要计算在内，最后应注意清空数组。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 3e5+1; int read(){ int x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;,ch=getchar(); return x; } int n,k,q[N],bel[N],a[N],c[N],d[N],dfn[N],f[N][19],ans[N],g1[N],head[N],cnt,st[N],sz[N]; struct nd{ int ne,to; }e[N*2]; void in(int x,int y){ if(x==y||!x||!y)return; e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt; } int dfs(int x,int fa=-1){ static int totw=0; dfn[x]=++totw;sz[x]=1; for(int i=head[x];i;i=e[i].ne) if(e[i].to!=fa){ int y=e[i].to; d[y]=d[x]+1;f[y][0]=x; dfs(y,x); sz[x]+=sz[y]; } } int lca(int x,int y){ // cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;; if(d[x]&lt;d[y])swap(x,y); for(int i=18;i&gt;=0;--i) if(d[f[x][i]]&gt;=d[y])x=f[x][i]; if(x==y){ // cout&lt;&lt;x&lt;&lt;endl; return x; } for(int i=18;i&gt;=0;--i) if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i]; // cout&lt;&lt;f[x][0]&lt;&lt;endl; return f[x][0]; } int dis(int x,int y){ return d[x]+d[y]-2*d[lca(x,y)]; } bool cmp(int a,int b){ return dfn[a]&lt;dfn[b]; } void dfs1(int x,int fa=-1){ // cout&lt;&lt;x&lt;&lt;&quot; &quot;; c[++c[0]]=x;g1[x]=sz[x]; for(int i=head[x];i;i=e[i].ne) if(e[i].to!=fa){ int y=e[i].to; dfs1(y,x); if(!bel[y])continue; if(!bel[x])bel[x]=bel[y]; else{ int d1=dis(bel[x],x); int d2=dis(bel[y],x); if(d2&lt;d1||(d2==d1&amp;&amp;bel[y]&lt;bel[x]))bel[x]=bel[y]; } } } void dfs2(int x,int fa=-1){ for(int i=head[x];i;i=e[i].ne) if(e[i].to!=fa){ int y=e[i].to; if(!bel[y])bel[y]=bel[x]; else{ int d1=dis(bel[x],y); int d2=dis(bel[y],y); if(d1&lt;d2||(d1==d2&amp;&amp;bel[x]&lt;bel[y]))bel[y]=bel[x]; } dfs2(y,x); } } void solve(int x,int y){ // cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; int son=y,mid=y,now,d1,d2; for(int i=18;i&gt;=0;--i) if(d[f[son][i]]&gt;d[x])son=f[son][i]; g1[x]-=sz[son]; if(bel[x]==bel[y])return void(ans[bel[x]]+=sz[son]-sz[y]); for(int i=18;i&gt;=0;--i){ now=f[mid][i]; if(d[now]&lt;=d[x])continue; d1=dis(bel[x],now);d2=dis(bel[y],now); if(d2&lt;d1||(d2==d1&amp;&amp;bel[y]&lt;bel[x]))mid=now; } ans[bel[x]]+=sz[son]-sz[mid]; ans[bel[y]]+=sz[mid]-sz[y]; return; } void solve(){ sort(q+1,q+k+1,cmp);cnt=0;c[0]=0; for(int i=1;i&lt;=k;++i)bel[q[i]]=q[i]; int L=0; st[++L]=1; for(int i=1;i&lt;=k;++i){ int x=q[i],l=lca(x,st[L]); while(1){ if(dfn[l]&gt;=dfn[st[L-1]]){ in(l,st[L--]); if(st[L]!=l)st[++L]=l; break; } in(st[L-1],st[L]);L--; } if(x!=st[L])st[++L]=x; } while(--L)in(st[L],st[L+1]); dfs1(1);dfs2(1); // for(int i=1;i&lt;=c[0];++i)cout&lt;&lt;bel[c[i]]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; for(int i=1;i&lt;=c[0];++i){ int x=c[i]; for(int j=head[x];j;j=e[j].ne) solve(x,e[j].to); } for(int i=1;i&lt;=c[0];++i)ans[bel[c[i]]]+=g1[c[i]]; for(int i=1;i&lt;=k;++i)printf(&quot;%d &quot;,ans[a[i]]);printf(&quot;\\n&quot;); for(int i=1;i&lt;=c[0];++i){ int x=c[i]; head[x]=ans[x]=g1[x]=bel[x]=0; } return; } int main(){ // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); n=read(); for(int i=1,x,y;i&lt;n;++i) x=read(),y=read(),in(x,y),in(y,x); int Q=read(); d[1]=1;dfs(1); for(int j=1;j&lt;19;++j) for(int i=1;i&lt;=n;++i) f[i][j]=f[f[i][j-1]][j-1]; memset(head,0,sizeof(head));cnt=0; while(Q--){ k=read(); for(int i=1;i&lt;=k;++i)a[i]=q[i]=read(); solve(); } } HEOI2014 大工程 题目描述国家有一个大工程，要给一个非常大的交通网络里建一些新的通道。 我们这个国家位置非常特殊，可以看成是一个单位边权的树，城市位于顶点上。 在 2 个国家 a,b 之间建一条新通道需要的代价为树上 a,b 的最短路径。 现在国家有很多个计划，每个计划都是这样，我们选中了 k 个点，然后在它们两两之间 新建 C(k,2)条 新通道。 现在对于每个计划，我们想知道： 这些新通道的代价和 这些新通道中代价最小的是多少 这些新通道中代价最大的是多少 输入输出格式输入格式:第一行 n 表示点数。 接下来 n-1 行，每行两个数 a,b 表示 a 和 b 之间有一条边。 点从 1 开始标号。 接下来一行 q 表示计划数。 对每个计划有 2 行，第一行 k 表示这个计划选中了几个点。 第二行用空格隔开的 k 个互不相同的数表示选了哪 k 个点。 输出格式：输出 q 行，每行三个数分别表示代价和，最小代价，最大代价。 输入输出样例输入样例：10 2 1 3 2 4 1 5 2 6 4 7 5 8 6 9 7 10 9 5 2 5 4 2 10 4 2 5 2 2 6 1 2 6 1 输出样例：3 3 3 6 6 6 1 1 1 2 2 2 2 2 2 题解虚树裸题，逻辑清晰的实现会让代码难度降低一个等级。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e6+1; const int inf = 1e8; int read(){ int x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;,ch=getchar(); return x; } int n,m,f[N][21],st[N],dfn[N],q[N],head[N],d[N],cnt,k,vis[N],T,sz[N]; struct nd{ int ne,to; }e[N*2]; void in(int x,int y){ if(x==y||!x||!y)return; e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt; } int dfs(int x,int fa=-1){ static int totw=0; dfn[x]=++totw; for(int i=head[x];i;i=e[i].ne) if(e[i].to!=fa){ int y=e[i].to; f[y][0]=x; d[y]=d[x]+1; dfs(y,x); } } bool cmp(int a,int b){ return dfn[a]&lt;dfn[b]; } int lca(int x,int y){ if(d[x]&lt;d[y])swap(x,y); for(int i=20;i&gt;=0;--i) if(d[f[x][i]]&gt;=d[y])x=f[x][i]; if(x==y)return x; for(int i=20;i&gt;=0;--i) if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i]; return f[x][0]; } ll s[N]; ll ans=0; int mx=0,mn=inf,mnn[N],mxx[N]; void get(int x){ s[x]=0; sz[x]=(vis[x]==T); mnn[x]=(vis[x]==T?0:inf); mxx[x]=(vis[x]==T?0:-inf); for(int i=head[x];i;i=e[i].ne){ int y=e[i].to; get(y); ans+=(s[x]+sz[x]*(d[y]-d[x]))*sz[y]+s[y]*sz[x]; sz[x]+=sz[y]; s[x]+=s[y]+(d[y]-d[x])*sz[y]; mx=max(mx,mxx[x]+mxx[y]+d[y]-d[x]); mn=min(mn,mnn[x]+mnn[y]+d[y]-d[x]); mxx[x]=max(mxx[x],mxx[y]+d[y]-d[x]); mnn[x]=min(mnn[x],mnn[y]+d[y]-d[x]); } head[x]=0; } void solve(){ sort(q+1,q+k+1,cmp);cnt=0;++T; for(int i=1;i&lt;=k;++i)vis[q[i]]=T; ans=0;mx=0;mn=inf; int L=0; st[++L]=1; for(int i=1;i&lt;=k;++i){ int x=q[i],l=lca(x,st[L]); while(1){ if(d[l]&gt;=d[st[L-1]]){ in(l,st[L--]); if(l!=st[L])st[++L]=l; break; } in(st[L-1],st[L]);L--; } if(x!=st[L])st[++L]=x; } while(--L)in(st[L],st[L+1]); get(1); printf(&quot;%lld %d %d\\n&quot;,ans,mn,mx); } int main(){ // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); n=read(); for(int i=1,x,y;i&lt;n;++i) x=read(),y=read(),in(x,y),in(y,x); d[1]=1;dfn[0]=inf;dfs(1); for(int j=1;j&lt;21;++j) for(int i=1;i&lt;=n;++i) f[i][j]=f[f[i][j-1]][j-1]; memset(head,0,sizeof(head)); int Q=read(); while(Q--){ k=read(); for(int i=1;i&lt;=k;++i)q[i]=read(); solve(); } }","raw":"title: 虚树总结\ndate: 2017-11-27 17:42:01\ncategories:\n  - 数据结构\n  - 虚树\ntags:\n  - 虚树\n  - 动态规划\n---\n\n# 概念与构造\n\n## 概念\n虚树可以用来解决在树上的多次询问，约束总询问点数的动态规划问题，相较直接BFS的高复杂度，虚树可以将开销降到与单次询问点数相关的时间复杂度之内。\n\n## 建树\n考虑动态规划合并多个询问节点，只有在遍历到关键的$LCA$时才会计算贡献，且可以直接以$LCA$代替以下节点，所以可以设计出以下算法流程：\n\n$1.$ 维护一个以$dfn$序为关键字的单调栈，栈顶元素$p$为所有已经处理过的节点中$dfn$最大的节点，一般以根为初始节点，将所有询问节点按$dfn$排序进行插入。\n\n$2.$ 根据以上算法，一定有$dfn_x > dfn_p$。设栈顶第二个元素为$q$，根据$LCA$与$q$的关系进行分类讨论：\n\t\n- 当$LCA = p$时，将$x$入栈。\n\n- 否则$p$与$q$分别在$lca$的两个子树中，则需要重复以下操作，直到$p$到$lca$中所有节点处理完毕，然后再将$x$入栈。\n\t- 当$dfn_q > dfn_{lca}$时，连边$(q,p)$,并将$p$退栈。\n\t- 当$dfn_q = dfn_{lca}$时，连边$(lca,p)$。此时$p$到$lca$已经处理完毕，即可跳出循环。\n\t- 当$dfn_q < dfn_{lca}$时，此时$lca$在$q->p$上，建边$(lca,p)$，以$lca$代替$p$在栈中的位置。此时$p$到$lca$已经处理完毕，即可跳出循环。\n---\n\n# 习题\n---\n## [SDOI2011 消耗战](http://www.lydsy.com/JudgeOnline/problem.php?id=2286)\n---\n### 题目描述\n在一场战争中，战场由n个岛屿和n-1个桥梁组成，保证每两个岛屿间有且仅有一条路径可达。现在，我军已经侦查到敌军的总部在编号为1的岛屿，而且他们已经没有足够多的能源维系战斗，我军胜利在望。已知在其他k个岛屿上有丰富能源，为了防止敌军获取能源，我军的任务是炸毁一些桥梁，使得敌军不能到达任何能源丰富的岛屿。由于不同桥梁的材质和结构不同，所以炸毁不同的桥梁有不同的代价，我军希望在满足目标的同时使得总代价最小。\n\n侦查部门还发现，敌军有一台神秘机器。即使我军切断所有能源之后，他们也可以用那台机器。机器产生的效果不仅仅会修复所有我军炸毁的桥梁，而且会重新随机资源分布（但可以保证的是，资源不会分布到1号岛屿上）。不过侦查部门还发现了这台机器只能够使用m次，所以我们只需要把每次任务完成即可。\n\n#### 输入输出格式\n##### 输入格式:\n第一行一个整数$n$，代表岛屿数量。\n\n接下来$n-1$行，每行三个整数$u,v,w$，代表$u$号岛屿和$v$号岛屿由一条代价为c的桥梁直接相连，保证$1<=u,v<=n$且$1<=c<=100000$。\n\n第$n+1$行，一个整数$m$，代表敌方机器能使用的次数。\n\n接下来$m$行，每行一个整数$k_i$，代表第$i$次后，有$k_i$个岛屿资源丰富，接下来$k$个整数$h_1,h_2,…h_k$，表示资源丰富岛屿的编号。\n\n##### 输出格式：\n输出有$m$行，分别代表每次任务的最小代价。\n\n#### 输入输出样例\n##### 输入样例：\n    10\n    1 5 13\n    1 9 6\n    2 1 19\n    2 4 8\n    2 3 91\n    5 6 8\n    7 5 4\n    7 8 31\n    10 7 9\n    3\n    2 10 6\n    4 5 7 8 3\n    3 9 4 6\n    \n##### 输出样例：\n\t12\n    32\n    22\n\n#### 数据范围\n $2<=n<=250000$\n \n $m>=1$\n \n $\\sum k_i<=500000$\n \n $1<=k_i<=n-1$\n \n---\n\n### 题解\n设$f_x$为覆盖以$x$为跟子树的最小代价，则有$f_x=min(\\sum f_{sonx},g_x)$，其中$g_x$代表根到$x$路径上的最小权值边，用虚树优化即可。\n\n---\n#### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e6+1;\n    const ll inf = 1e15;\n\n    int read(){\n        int x=0,f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n        return x*f;\n    }\n\n    int n,m,k,head[N],d[N],cnt,f[N][19],q[N],dfn[N],totw,st[N],vis[N];\n    ll dp[N],g[N];\n    struct nd{\n        int ne,to;ll w;\n    }e[N*2];\n\n    void in(int x,int y,ll w){\n        if(x==y)return;\n        e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;\n    }\n\n    void dfs(int x,int fa=-1){\n        dfn[x]=++totw;\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=fa){\n            int y=e[i].to;\n            f[y][0]=x;\n            g[y]=min(g[x],e[i].w);\n            d[y]=d[x]+1;\n            dfs(y,x);\n        }\n    }\n\n    int lca(int x,int y){\n        if(d[x]<d[y])swap(x,y);\n        for(int i=18;i>=0;--i)\n        if(d[f[x][i]]>=d[y])x=f[x][i];\n        if(x==y)return x;\n        for(int i=18;i>=0;--i)\n        if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n        return f[x][0];\n    }\n\n    bool cmp(int a,int b){\n        return dfn[a]<dfn[b];\n    }\n    int T=0;\n    ll get(int x){\n        ll k=0;\n        for(int i=head[x];i;i=e[i].ne)k+=get(e[i].to);\n        head[x]=0;\n        return dp[x]=(vis[x]!=T?min(g[x],k):g[x]);\n    }\n\n    ll solve(){\n        cnt=0;++T;\n        sort(q+1,q+k+1,cmp);\n        for(int i=1;i<=k;++i)vis[q[i]]=T;\n        int L=0;\n        st[++L]=1;\n        for(int i=1;i<=k;++i){\n            int x=q[i],l=lca(x,st[L]);\n            if(l==st[L])st[++L]=x;\n            else{\n                while(1){\n                    if(dfn[l]>=dfn[st[L-1]]){\n                        in(l,st[L--],0);\n                        if(st[L]!=l)st[++L]=l;\n                        break;\n                    }\n                    in(st[L-1],st[L],0),L--;\n                }\n                if(x!=st[L])st[++L]=x;\n            }\n        }\n        while(--L)in(st[L],st[L+1],0);\n        return get(1);\n    }\n\n\n    int main(){\n    //  freopen(\"c.in\",\"r\",stdin);\n        n=read();\n        for(int i=1,x,y,w;i<n;++i){\n            x=read(),y=read(),w=read();\n            in(x,y,w);in(y,x,w);\n        }\n        d[1]=1;g[1]=inf;dfs(1);\n        for(int j=1;j<19;++j)\n        for(int i=1;i<=n;++i)\n        f[i][j]=f[f[i][j-1]][j-1];\n        m=read();\n        memset(head,0,sizeof(head));cnt=0;\n        while(m--){\n            k=read();\n            for(int j=1;j<=k;++j)q[j]=read();\n            printf(\"%lld\\n\",solve());\n        }\n    }\n\n---\n\n## [HNOI2014 世界树](http://www.lydsy.com/JudgeOnline/problem.php?id=3572)\n---\n### 题目描述\n世界树是一棵无比巨大的树，它伸出的枝干构成了整个世界。在这里，生存着各种各样的种族和生灵，他们共同信奉着绝对公正公平的女神艾莉森，在他们的信条里，公平是使世界树能够生生不息、持续运转的根本基石。\n\n世界树的形态可以用一个数学模型来描述：世界树中有n个种族，种族的编号分别从1到n，分别生活在编号为1到n的聚居地上，种族的编号与其聚居地的编号相同。有的聚居地之间有双向的道路相连，道路的长度为1。保证连接的方式会形成一棵树结构，即所有的聚居地之间可以互相到达，并且不会出现环。定义两个聚居地之间的距离为连接他们的道路的长度；例如，若聚居地a和b之间有道路，b和c之间有道路，因为每条道路长度为1而且又不可能出现环，所卧a与c之间的距离为2。\n\n出于对公平的考虑，第i年，世界树的国王需要授权m[i]个种族的聚居地为临时议事处。对于某个种族x（x为种族的编号），如果距离该种族最近的临时议事处为y（y为议事处所在聚居地的编号），则种族x将接受y议事处的管辖（如果有多个临时议事处到该聚居地的距离一样，则y为其中编号最小的临时议事处）。\n现在国王想知道，在q年的时间里，每一年完成授权后，当年每个临时议事处将会管理多少个种族（议事处所在的聚居地也将接受该议事处管理）。 现在这个任务交给了以智慧著称的灵长类的你：程序猿。请帮国王完成这个任务吧。 \n\n#### 输入输出格式\n##### 输入格式:\n第一行为一个正整数n，表示世界树中种族的个数。\n\n接下来n-l行，每行两个正整数x，y，表示x聚居地与y聚居地之间有一条长度为1的双向道路。接下来一行为一个正整数q，表示国王询问的年数。\n\n接下来q块，每块两行：\n\n第i块的第一行为1个正整数m[i]，表示第i年授权的临时议事处的个数。\n\n第i块的第二行为m[i]个正整数h[l]、h[2]、…、h[m[i]]，表示被授权为临时议事处的聚居地编号（保证互不相同）。 \n\n##### 输出格式：\n输出包含q行，第i行为m[i]个整数，该行的第j(j=1，2…，，m[i])个数表示第i年被授权的聚居地h[j]的临时议事处管理的种族个数。\n\n#### 输入输出样例\n##### 输入样例：\n    10 \n    2 1 \n    3 2 \n    4 3 \n    5 4 \n    6 1\n    7 3 \n    8 3 \n    9 4 \n    10 1 \n\n    5 \n    2 \n    6 1   \n    5 \n    2 7 3 6 9   \n    1 \n    8  \n    4 \n    8 7 10 3   \n    5 \n    2 9 3 5 8 \n##### 输出样例：\n    1 9   \n    3 1 4 1 1   \n    10  \n    1 1 3 5   \n    4 1 3 1 1 \n#### 数据范围\n N<=300000, q<=300000,m[1]+m[2]+…+m[q]<=300000\n \n---\n\n### 题解\n先建立虚树，两遍DP找出每个点的控制点，然后在考虑虚树上每一条边的贡献，如果两个顶点属于同一个控制点，直接计算即可，否则二分出控制点不同的位置在计算贡献，注意这一步不应计算端点，否则会导致重复计算，对于没有考虑到的点，其控制点一定在第一个在虚树上的父亲节点上，也要计算在内，最后应注意清空数组。\n\n\n---\n#### CODE\n\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 3e5+1;\n\n    int read(){\n        int x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n        return x;\n    }\n\n    int n,k,q[N],bel[N],a[N],c[N],d[N],dfn[N],f[N][19],ans[N],g1[N],head[N],cnt,st[N],sz[N];\n    struct nd{\n        int ne,to;\n    }e[N*2];\n\n    void in(int x,int y){\n        if(x==y||!x||!y)return;\n        e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;\n    }\n\n    int dfs(int x,int fa=-1){\n        static int totw=0;\n        dfn[x]=++totw;sz[x]=1;\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=fa){\n            int y=e[i].to;\n            d[y]=d[x]+1;f[y][0]=x;\n            dfs(y,x);\n            sz[x]+=sz[y];\n        }\n    }\n\n    int lca(int x,int y){\n    //\tcout<<x<<\" \"<<y<<\" \";\n        if(d[x]<d[y])swap(x,y);\n        for(int i=18;i>=0;--i)\n        if(d[f[x][i]]>=d[y])x=f[x][i];\n        if(x==y){\n    //\t\tcout<<x<<endl;\n            return x;\n        }\n        for(int i=18;i>=0;--i)\n        if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n    //\tcout<<f[x][0]<<endl;\n        return f[x][0];\n    }\n\n    int dis(int x,int y){\n        return d[x]+d[y]-2*d[lca(x,y)];\n    }\n\n    bool cmp(int a,int b){\n        return dfn[a]<dfn[b];\n    }\n\n    void dfs1(int x,int fa=-1){\n    //\tcout<<x<<\" \";\n        c[++c[0]]=x;g1[x]=sz[x];\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=fa){\n            int y=e[i].to;\n            dfs1(y,x);\n            if(!bel[y])continue;\n            if(!bel[x])bel[x]=bel[y];\n            else{\n                int d1=dis(bel[x],x);\n                int d2=dis(bel[y],x);\n                if(d2<d1||(d2==d1&&bel[y]<bel[x]))bel[x]=bel[y];\n            }\n        }\n    }\n\n    void dfs2(int x,int fa=-1){\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=fa){\n            int y=e[i].to;\n            if(!bel[y])bel[y]=bel[x];\n            else{\n                int d1=dis(bel[x],y);\n                int d2=dis(bel[y],y);\n                if(d1<d2||(d1==d2&&bel[x]<bel[y]))bel[y]=bel[x];\n            }\n            dfs2(y,x);\n        }\n    }\n\n    void solve(int x,int y){\n    //\tcout<<x<<\" \"<<y<<endl;\n        int son=y,mid=y,now,d1,d2;\n        for(int i=18;i>=0;--i)\n        if(d[f[son][i]]>d[x])son=f[son][i];\n        g1[x]-=sz[son];\n        if(bel[x]==bel[y])return void(ans[bel[x]]+=sz[son]-sz[y]);\n        for(int i=18;i>=0;--i){\n            now=f[mid][i];\n            if(d[now]<=d[x])continue;\n            d1=dis(bel[x],now);d2=dis(bel[y],now);\n            if(d2<d1||(d2==d1&&bel[y]<bel[x]))mid=now;\n        }\n        ans[bel[x]]+=sz[son]-sz[mid];\n        ans[bel[y]]+=sz[mid]-sz[y];\n        return;\n    }\n\n    void solve(){\n        sort(q+1,q+k+1,cmp);cnt=0;c[0]=0;\n        for(int i=1;i<=k;++i)bel[q[i]]=q[i];\n        int L=0;\n        st[++L]=1;\n        for(int i=1;i<=k;++i){\n            int x=q[i],l=lca(x,st[L]);\n            while(1){\n                if(dfn[l]>=dfn[st[L-1]]){\n                    in(l,st[L--]);\n                    if(st[L]!=l)st[++L]=l;\n                    break;\n                }\n                in(st[L-1],st[L]);L--;\n            }\n            if(x!=st[L])st[++L]=x;\n        }\n        while(--L)in(st[L],st[L+1]);\n\n        dfs1(1);dfs2(1);\n    //\tfor(int i=1;i<=c[0];++i)cout<<bel[c[i]]<<\" \";cout<<endl;\n        for(int i=1;i<=c[0];++i){\n            int x=c[i];\n            for(int j=head[x];j;j=e[j].ne)\n            solve(x,e[j].to);\n        }\n        for(int i=1;i<=c[0];++i)ans[bel[c[i]]]+=g1[c[i]];\n        for(int i=1;i<=k;++i)printf(\"%d \",ans[a[i]]);printf(\"\\n\");\n        for(int i=1;i<=c[0];++i){\n            int x=c[i];\n            head[x]=ans[x]=g1[x]=bel[x]=0;\n        }\n        return;\n    }\n\n    int main(){\n    //\tfreopen(\"c.in\",\"r\",stdin);\n        n=read();\n        for(int i=1,x,y;i<n;++i)\n        x=read(),y=read(),in(x,y),in(y,x);\n        int Q=read();\n        d[1]=1;dfs(1);\n        for(int j=1;j<19;++j)\n        for(int i=1;i<=n;++i)\n        f[i][j]=f[f[i][j-1]][j-1];\n        memset(head,0,sizeof(head));cnt=0;\n        while(Q--){\n            k=read();\n            for(int i=1;i<=k;++i)a[i]=q[i]=read();\n            solve();\n        }\n    }\n---\n\n## [HEOI2014 大工程](http://www.lydsy.com/JudgeOnline/problem.php?id=3611)\n---\n### 题目描述\n国家有一个大工程，要给一个非常大的交通网络里建一些新的通道。 \n\n我们这个国家位置非常特殊，可以看成是一个单位边权的树，城市位于顶点上。 \n\n在 2 个国家 a,b 之间建一条新通道需要的代价为树上 a,b 的最短路径。\n\n 现在国家有很多个计划，每个计划都是这样，我们选中了 k 个点，然后在它们两两之间 新建 C(k,2)条 新通道。\n \n现在对于每个计划，我们想知道：\n\n 1. 这些新通道的代价和\n\n 2. 这些新通道中代价最小的是多少 \n\n3. 这些新通道中代价最大的是多少\n\n#### 输入输出格式\n##### 输入格式:\n第一行 n 表示点数。\n\n 接下来 n-1 行，每行两个数 a,b 表示 a 和 b 之间有一条边。\n \n点从 1 开始标号。 接下来一行 q 表示计划数。\n\n对每个计划有 2 行，第一行 k 表示这个计划选中了几个点。\n\n 第二行用空格隔开的 k 个互不相同的数表示选了哪 k 个点。\n\n##### 输出格式：\n输出 q 行，每行三个数分别表示代价和，最小代价，最大代价。 \n\n#### 输入输出样例\n##### 输入样例：\n\t10 \n    2 1 \n    3 2 \n    4 1 \n    5 2 \n    6 4 \n    7 5\n    8 6 \n    9 7\n    10 9 \n    5 \n    2\n    5 4 \n    2 \n    10 4 \n    2 \n    5 2 \n    2 \n    6 1 \n    2 \n    6 1 \n##### 输出样例：\n    3 3 3 \n\n    6 6 6 \n\n    1 1 1 \n\n    2 2 2 \n\n    2 2 2 \n \n---\n\n### 题解\n虚树裸题，逻辑清晰的实现会让代码难度降低一个等级。\n\n---\n#### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e6+1;\n    const int inf = 1e8;\n\n\n    int read(){\n        int x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n        return x;\n    }\n\n    int n,m,f[N][21],st[N],dfn[N],q[N],head[N],d[N],cnt,k,vis[N],T,sz[N];\n    struct nd{\n        int ne,to;\n    }e[N*2];\n\n    void in(int x,int y){\n        if(x==y||!x||!y)return;\n        e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;\n    }\n\n    int dfs(int x,int fa=-1){\n        static int totw=0;\n        dfn[x]=++totw;\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=fa){\n            int y=e[i].to;\n            f[y][0]=x;\n            d[y]=d[x]+1;\n            dfs(y,x);\n        }\n    }\n\n    bool cmp(int a,int b){\n        return dfn[a]<dfn[b];\n    }\n\n    int lca(int x,int y){\n        if(d[x]<d[y])swap(x,y);\n        for(int i=20;i>=0;--i)\n        if(d[f[x][i]]>=d[y])x=f[x][i];\n        if(x==y)return x;\n        for(int i=20;i>=0;--i)\n        if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n        return f[x][0];\n    }\n\n\n    ll s[N];\n    ll ans=0;\n    int mx=0,mn=inf,mnn[N],mxx[N];\n\n    void get(int x){\n        s[x]=0;\n        sz[x]=(vis[x]==T);\n        mnn[x]=(vis[x]==T?0:inf);\n        mxx[x]=(vis[x]==T?0:-inf);\n        for(int i=head[x];i;i=e[i].ne){\n            int y=e[i].to;\n            get(y);\n            ans+=(s[x]+sz[x]*(d[y]-d[x]))*sz[y]+s[y]*sz[x];\n            sz[x]+=sz[y];\n            s[x]+=s[y]+(d[y]-d[x])*sz[y];\n            mx=max(mx,mxx[x]+mxx[y]+d[y]-d[x]);\n            mn=min(mn,mnn[x]+mnn[y]+d[y]-d[x]);\n            mxx[x]=max(mxx[x],mxx[y]+d[y]-d[x]);\n            mnn[x]=min(mnn[x],mnn[y]+d[y]-d[x]);\n        }\n        head[x]=0;\n    }\n\n    void solve(){\n        sort(q+1,q+k+1,cmp);cnt=0;++T;\n        for(int i=1;i<=k;++i)vis[q[i]]=T;\n        ans=0;mx=0;mn=inf;\n        int L=0;\n        st[++L]=1;\n        for(int i=1;i<=k;++i){\n            int x=q[i],l=lca(x,st[L]);\n            while(1){\n                if(d[l]>=d[st[L-1]]){\n                    in(l,st[L--]);\n                    if(l!=st[L])st[++L]=l;\n                    break;\n                }\n                in(st[L-1],st[L]);L--;\n            }\n            if(x!=st[L])st[++L]=x;\n        }\n        while(--L)in(st[L],st[L+1]);\n        get(1);\n        printf(\"%lld %d %d\\n\",ans,mn,mx);\n    }\n\n    int main(){\n    //\tfreopen(\"c.in\",\"r\",stdin);\n        n=read();\n        for(int i=1,x,y;i<n;++i)\n        x=read(),y=read(),in(x,y),in(y,x);\n        d[1]=1;dfn[0]=inf;dfs(1);\n        for(int j=1;j<21;++j)\n        for(int i=1;i<=n;++i)\n        f[i][j]=f[f[i][j-1]][j-1];\n        memset(head,0,sizeof(head));\n        int Q=read();\n        while(Q--){\n            k=read();\n            for(int i=1;i<=k;++i)q[i]=read();\n            solve();\n        }\n    }","content":"<h1 id=\"概念与构造\"><a href=\"#概念与构造\" class=\"headerlink\" title=\"概念与构造\"></a>概念与构造</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>虚树可以用来解决在树上的多次询问，约束总询问点数的动态规划问题，相较直接BFS的高复杂度，虚树可以将开销降到与单次询问点数相关的时间复杂度之内。</p>\n<h2 id=\"建树\"><a href=\"#建树\" class=\"headerlink\" title=\"建树\"></a>建树</h2><p>考虑动态规划合并多个询问节点，只有在遍历到关键的$LCA$时才会计算贡献，且可以直接以$LCA$代替以下节点，所以可以设计出以下算法流程：</p>\n<p>$1.$ 维护一个以$dfn$序为关键字的单调栈，栈顶元素$p$为所有已经处理过的节点中$dfn$最大的节点，一般以根为初始节点，将所有询问节点按$dfn$排序进行插入。</p>\n<p>$2.$ 根据以上算法，一定有$dfn_x &gt; dfn_p$。设栈顶第二个元素为$q$，根据$LCA$与$q$的关系进行分类讨论：</p>\n<ul>\n<li><p>当$LCA = p$时，将$x$入栈。</p>\n</li>\n<li><p>否则$p$与$q$分别在$lca$的两个子树中，则需要重复以下操作，直到$p$到$lca$中所有节点处理完毕，然后再将$x$入栈。</p>\n<ul>\n<li>当$dfn_q &gt; dfn_{lca}$时，连边$(q,p)$,并将$p$退栈。</li>\n<li>当$dfn_q = dfn_{lca}$时，连边$(lca,p)$。此时$p$到$lca$已经处理完毕，即可跳出循环。</li>\n<li>当$dfn_q &lt; dfn_{lca}$时，此时$lca$在$q-&gt;p$上，建边$(lca,p)$，以$lca$代替$p$在栈中的位置。此时$p$到$lca$已经处理完毕，即可跳出循环。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h1><hr>\n<h2 id=\"SDOI2011-消耗战\"><a href=\"#SDOI2011-消耗战\" class=\"headerlink\" title=\"SDOI2011 消耗战\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=2286\" target=\"_blank\" rel=\"external\">SDOI2011 消耗战</a></h2><hr>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>在一场战争中，战场由n个岛屿和n-1个桥梁组成，保证每两个岛屿间有且仅有一条路径可达。现在，我军已经侦查到敌军的总部在编号为1的岛屿，而且他们已经没有足够多的能源维系战斗，我军胜利在望。已知在其他k个岛屿上有丰富能源，为了防止敌军获取能源，我军的任务是炸毁一些桥梁，使得敌军不能到达任何能源丰富的岛屿。由于不同桥梁的材质和结构不同，所以炸毁不同的桥梁有不同的代价，我军希望在满足目标的同时使得总代价最小。</p>\n<p>侦查部门还发现，敌军有一台神秘机器。即使我军切断所有能源之后，他们也可以用那台机器。机器产生的效果不仅仅会修复所有我军炸毁的桥梁，而且会重新随机资源分布（但可以保证的是，资源不会分布到1号岛屿上）。不过侦查部门还发现了这台机器只能够使用m次，所以我们只需要把每次任务完成即可。</p>\n<h4 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><h5 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h5><p>第一行一个整数$n$，代表岛屿数量。</p>\n<p>接下来$n-1$行，每行三个整数$u,v,w$，代表$u$号岛屿和$v$号岛屿由一条代价为c的桥梁直接相连，保证$1&lt;=u,v&lt;=n$且$1&lt;=c&lt;=100000$。</p>\n<p>第$n+1$行，一个整数$m$，代表敌方机器能使用的次数。</p>\n<p>接下来$m$行，每行一个整数$k_i$，代表第$i$次后，有$k_i$个岛屿资源丰富，接下来$k$个整数$h_1,h_2,…h_k$，表示资源丰富岛屿的编号。</p>\n<h5 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h5><p>输出有$m$行，分别代表每次任务的最小代价。</p>\n<h4 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><h5 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h5><pre><code>10\n1 5 13\n1 9 6\n2 1 19\n2 4 8\n2 3 91\n5 6 8\n7 5 4\n7 8 31\n10 7 9\n3\n2 10 6\n4 5 7 8 3\n3 9 4 6\n</code></pre><h5 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h5><pre><code>12\n32\n22\n</code></pre><h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p> $2&lt;=n&lt;=250000$</p>\n<p> $m&gt;=1$</p>\n<p> $\\sum k_i&lt;=500000$</p>\n<p> $1&lt;=k_i&lt;=n-1$</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>设$f_x$为覆盖以$x$为跟子树的最小代价，则有$f_x=min(\\sum f_{sonx},g_x)$，其中$g_x$代表根到$x$路径上的最小权值边，用虚树优化即可。</p>\n<hr>\n<h4 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6+1;\nconst ll inf = 1e15;\n\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=x*10+ch-&#39;0&#39;,ch=getchar();\n    return x*f;\n}\n\nint n,m,k,head[N],d[N],cnt,f[N][19],q[N],dfn[N],totw,st[N],vis[N];\nll dp[N],g[N];\nstruct nd{\n    int ne,to;ll w;\n}e[N*2];\n\nvoid in(int x,int y,ll w){\n    if(x==y)return;\n    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;\n}\n\nvoid dfs(int x,int fa=-1){\n    dfn[x]=++totw;\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=fa){\n        int y=e[i].to;\n        f[y][0]=x;\n        g[y]=min(g[x],e[i].w);\n        d[y]=d[x]+1;\n        dfs(y,x);\n    }\n}\n\nint lca(int x,int y){\n    if(d[x]&lt;d[y])swap(x,y);\n    for(int i=18;i&gt;=0;--i)\n    if(d[f[x][i]]&gt;=d[y])x=f[x][i];\n    if(x==y)return x;\n    for(int i=18;i&gt;=0;--i)\n    if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n    return f[x][0];\n}\n\nbool cmp(int a,int b){\n    return dfn[a]&lt;dfn[b];\n}\nint T=0;\nll get(int x){\n    ll k=0;\n    for(int i=head[x];i;i=e[i].ne)k+=get(e[i].to);\n    head[x]=0;\n    return dp[x]=(vis[x]!=T?min(g[x],k):g[x]);\n}\n\nll solve(){\n    cnt=0;++T;\n    sort(q+1,q+k+1,cmp);\n    for(int i=1;i&lt;=k;++i)vis[q[i]]=T;\n    int L=0;\n    st[++L]=1;\n    for(int i=1;i&lt;=k;++i){\n        int x=q[i],l=lca(x,st[L]);\n        if(l==st[L])st[++L]=x;\n        else{\n            while(1){\n                if(dfn[l]&gt;=dfn[st[L-1]]){\n                    in(l,st[L--],0);\n                    if(st[L]!=l)st[++L]=l;\n                    break;\n                }\n                in(st[L-1],st[L],0),L--;\n            }\n            if(x!=st[L])st[++L]=x;\n        }\n    }\n    while(--L)in(st[L],st[L+1],0);\n    return get(1);\n}\n\n\nint main(){\n//  freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n    n=read();\n    for(int i=1,x,y,w;i&lt;n;++i){\n        x=read(),y=read(),w=read();\n        in(x,y,w);in(y,x,w);\n    }\n    d[1]=1;g[1]=inf;dfs(1);\n    for(int j=1;j&lt;19;++j)\n    for(int i=1;i&lt;=n;++i)\n    f[i][j]=f[f[i][j-1]][j-1];\n    m=read();\n    memset(head,0,sizeof(head));cnt=0;\n    while(m--){\n        k=read();\n        for(int j=1;j&lt;=k;++j)q[j]=read();\n        printf(&quot;%lld\\n&quot;,solve());\n    }\n}\n</code></pre><hr>\n<h2 id=\"HNOI2014-世界树\"><a href=\"#HNOI2014-世界树\" class=\"headerlink\" title=\"HNOI2014 世界树\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=3572\" target=\"_blank\" rel=\"external\">HNOI2014 世界树</a></h2><hr>\n<h3 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>世界树是一棵无比巨大的树，它伸出的枝干构成了整个世界。在这里，生存着各种各样的种族和生灵，他们共同信奉着绝对公正公平的女神艾莉森，在他们的信条里，公平是使世界树能够生生不息、持续运转的根本基石。</p>\n<p>世界树的形态可以用一个数学模型来描述：世界树中有n个种族，种族的编号分别从1到n，分别生活在编号为1到n的聚居地上，种族的编号与其聚居地的编号相同。有的聚居地之间有双向的道路相连，道路的长度为1。保证连接的方式会形成一棵树结构，即所有的聚居地之间可以互相到达，并且不会出现环。定义两个聚居地之间的距离为连接他们的道路的长度；例如，若聚居地a和b之间有道路，b和c之间有道路，因为每条道路长度为1而且又不可能出现环，所卧a与c之间的距离为2。</p>\n<p>出于对公平的考虑，第i年，世界树的国王需要授权m[i]个种族的聚居地为临时议事处。对于某个种族x（x为种族的编号），如果距离该种族最近的临时议事处为y（y为议事处所在聚居地的编号），则种族x将接受y议事处的管辖（如果有多个临时议事处到该聚居地的距离一样，则y为其中编号最小的临时议事处）。<br>现在国王想知道，在q年的时间里，每一年完成授权后，当年每个临时议事处将会管理多少个种族（议事处所在的聚居地也将接受该议事处管理）。 现在这个任务交给了以智慧著称的灵长类的你：程序猿。请帮国王完成这个任务吧。 </p>\n<h4 id=\"输入输出格式-1\"><a href=\"#输入输出格式-1\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><h5 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h5><p>第一行为一个正整数n，表示世界树中种族的个数。</p>\n<p>接下来n-l行，每行两个正整数x，y，表示x聚居地与y聚居地之间有一条长度为1的双向道路。接下来一行为一个正整数q，表示国王询问的年数。</p>\n<p>接下来q块，每块两行：</p>\n<p>第i块的第一行为1个正整数m[i]，表示第i年授权的临时议事处的个数。</p>\n<p>第i块的第二行为m[i]个正整数h[l]、h[2]、…、h[m[i]]，表示被授权为临时议事处的聚居地编号（保证互不相同）。 </p>\n<h5 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h5><p>输出包含q行，第i行为m[i]个整数，该行的第j(j=1，2…，，m[i])个数表示第i年被授权的聚居地h[j]的临时议事处管理的种族个数。</p>\n<h4 id=\"输入输出样例-1\"><a href=\"#输入输出样例-1\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><h5 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h5><pre><code>10 \n2 1 \n3 2 \n4 3 \n5 4 \n6 1\n7 3 \n8 3 \n9 4 \n10 1 \n\n5 \n2 \n6 1   \n5 \n2 7 3 6 9   \n1 \n8  \n4 \n8 7 10 3   \n5 \n2 9 3 5 8 \n</code></pre><h5 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h5><pre><code>1 9   \n3 1 4 1 1   \n10  \n1 1 3 5   \n4 1 3 1 1 \n</code></pre><h4 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p> N&lt;=300000, q&lt;=300000,m[1]+m[2]+…+m[q]&lt;=300000</p>\n<hr>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>先建立虚树，两遍DP找出每个点的控制点，然后在考虑虚树上每一条边的贡献，如果两个顶点属于同一个控制点，直接计算即可，否则二分出控制点不同的位置在计算贡献，注意这一步不应计算端点，否则会导致重复计算，对于没有考虑到的点，其控制点一定在第一个在虚树上的父亲节点上，也要计算在内，最后应注意清空数组。</p>\n<hr>\n<h4 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 3e5+1;\n\nint read(){\n    int x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;,ch=getchar();\n    return x;\n}\n\nint n,k,q[N],bel[N],a[N],c[N],d[N],dfn[N],f[N][19],ans[N],g1[N],head[N],cnt,st[N],sz[N];\nstruct nd{\n    int ne,to;\n}e[N*2];\n\nvoid in(int x,int y){\n    if(x==y||!x||!y)return;\n    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;\n}\n\nint dfs(int x,int fa=-1){\n    static int totw=0;\n    dfn[x]=++totw;sz[x]=1;\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=fa){\n        int y=e[i].to;\n        d[y]=d[x]+1;f[y][0]=x;\n        dfs(y,x);\n        sz[x]+=sz[y];\n    }\n}\n\nint lca(int x,int y){\n//    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;;\n    if(d[x]&lt;d[y])swap(x,y);\n    for(int i=18;i&gt;=0;--i)\n    if(d[f[x][i]]&gt;=d[y])x=f[x][i];\n    if(x==y){\n//        cout&lt;&lt;x&lt;&lt;endl;\n        return x;\n    }\n    for(int i=18;i&gt;=0;--i)\n    if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n//    cout&lt;&lt;f[x][0]&lt;&lt;endl;\n    return f[x][0];\n}\n\nint dis(int x,int y){\n    return d[x]+d[y]-2*d[lca(x,y)];\n}\n\nbool cmp(int a,int b){\n    return dfn[a]&lt;dfn[b];\n}\n\nvoid dfs1(int x,int fa=-1){\n//    cout&lt;&lt;x&lt;&lt;&quot; &quot;;\n    c[++c[0]]=x;g1[x]=sz[x];\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=fa){\n        int y=e[i].to;\n        dfs1(y,x);\n        if(!bel[y])continue;\n        if(!bel[x])bel[x]=bel[y];\n        else{\n            int d1=dis(bel[x],x);\n            int d2=dis(bel[y],x);\n            if(d2&lt;d1||(d2==d1&amp;&amp;bel[y]&lt;bel[x]))bel[x]=bel[y];\n        }\n    }\n}\n\nvoid dfs2(int x,int fa=-1){\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=fa){\n        int y=e[i].to;\n        if(!bel[y])bel[y]=bel[x];\n        else{\n            int d1=dis(bel[x],y);\n            int d2=dis(bel[y],y);\n            if(d1&lt;d2||(d1==d2&amp;&amp;bel[x]&lt;bel[y]))bel[y]=bel[x];\n        }\n        dfs2(y,x);\n    }\n}\n\nvoid solve(int x,int y){\n//    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;\n    int son=y,mid=y,now,d1,d2;\n    for(int i=18;i&gt;=0;--i)\n    if(d[f[son][i]]&gt;d[x])son=f[son][i];\n    g1[x]-=sz[son];\n    if(bel[x]==bel[y])return void(ans[bel[x]]+=sz[son]-sz[y]);\n    for(int i=18;i&gt;=0;--i){\n        now=f[mid][i];\n        if(d[now]&lt;=d[x])continue;\n        d1=dis(bel[x],now);d2=dis(bel[y],now);\n        if(d2&lt;d1||(d2==d1&amp;&amp;bel[y]&lt;bel[x]))mid=now;\n    }\n    ans[bel[x]]+=sz[son]-sz[mid];\n    ans[bel[y]]+=sz[mid]-sz[y];\n    return;\n}\n\nvoid solve(){\n    sort(q+1,q+k+1,cmp);cnt=0;c[0]=0;\n    for(int i=1;i&lt;=k;++i)bel[q[i]]=q[i];\n    int L=0;\n    st[++L]=1;\n    for(int i=1;i&lt;=k;++i){\n        int x=q[i],l=lca(x,st[L]);\n        while(1){\n            if(dfn[l]&gt;=dfn[st[L-1]]){\n                in(l,st[L--]);\n                if(st[L]!=l)st[++L]=l;\n                break;\n            }\n            in(st[L-1],st[L]);L--;\n        }\n        if(x!=st[L])st[++L]=x;\n    }\n    while(--L)in(st[L],st[L+1]);\n\n    dfs1(1);dfs2(1);\n//    for(int i=1;i&lt;=c[0];++i)cout&lt;&lt;bel[c[i]]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;\n    for(int i=1;i&lt;=c[0];++i){\n        int x=c[i];\n        for(int j=head[x];j;j=e[j].ne)\n        solve(x,e[j].to);\n    }\n    for(int i=1;i&lt;=c[0];++i)ans[bel[c[i]]]+=g1[c[i]];\n    for(int i=1;i&lt;=k;++i)printf(&quot;%d &quot;,ans[a[i]]);printf(&quot;\\n&quot;);\n    for(int i=1;i&lt;=c[0];++i){\n        int x=c[i];\n        head[x]=ans[x]=g1[x]=bel[x]=0;\n    }\n    return;\n}\n\nint main(){\n//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n    n=read();\n    for(int i=1,x,y;i&lt;n;++i)\n    x=read(),y=read(),in(x,y),in(y,x);\n    int Q=read();\n    d[1]=1;dfs(1);\n    for(int j=1;j&lt;19;++j)\n    for(int i=1;i&lt;=n;++i)\n    f[i][j]=f[f[i][j-1]][j-1];\n    memset(head,0,sizeof(head));cnt=0;\n    while(Q--){\n        k=read();\n        for(int i=1;i&lt;=k;++i)a[i]=q[i]=read();\n        solve();\n    }\n}\n</code></pre><hr>\n<h2 id=\"HEOI2014-大工程\"><a href=\"#HEOI2014-大工程\" class=\"headerlink\" title=\"HEOI2014 大工程\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=3611\" target=\"_blank\" rel=\"external\">HEOI2014 大工程</a></h2><hr>\n<h3 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>国家有一个大工程，要给一个非常大的交通网络里建一些新的通道。 </p>\n<p>我们这个国家位置非常特殊，可以看成是一个单位边权的树，城市位于顶点上。 </p>\n<p>在 2 个国家 a,b 之间建一条新通道需要的代价为树上 a,b 的最短路径。</p>\n<p> 现在国家有很多个计划，每个计划都是这样，我们选中了 k 个点，然后在它们两两之间 新建 C(k,2)条 新通道。</p>\n<p>现在对于每个计划，我们想知道：</p>\n<ol>\n<li><p>这些新通道的代价和</p>\n</li>\n<li><p>这些新通道中代价最小的是多少 </p>\n</li>\n</ol>\n<ol>\n<li>这些新通道中代价最大的是多少</li>\n</ol>\n<h4 id=\"输入输出格式-2\"><a href=\"#输入输出格式-2\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><h5 id=\"输入格式-2\"><a href=\"#输入格式-2\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h5><p>第一行 n 表示点数。</p>\n<p> 接下来 n-1 行，每行两个数 a,b 表示 a 和 b 之间有一条边。</p>\n<p>点从 1 开始标号。 接下来一行 q 表示计划数。</p>\n<p>对每个计划有 2 行，第一行 k 表示这个计划选中了几个点。</p>\n<p> 第二行用空格隔开的 k 个互不相同的数表示选了哪 k 个点。</p>\n<h5 id=\"输出格式：-2\"><a href=\"#输出格式：-2\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h5><p>输出 q 行，每行三个数分别表示代价和，最小代价，最大代价。 </p>\n<h4 id=\"输入输出样例-2\"><a href=\"#输入输出样例-2\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><h5 id=\"输入样例：-2\"><a href=\"#输入样例：-2\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h5><pre><code>10 \n2 1 \n3 2 \n4 1 \n5 2 \n6 4 \n7 5\n8 6 \n9 7\n10 9 \n5 \n2\n5 4 \n2 \n10 4 \n2 \n5 2 \n2 \n6 1 \n2 \n6 1 \n</code></pre><h5 id=\"输出样例：-2\"><a href=\"#输出样例：-2\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h5><pre><code>3 3 3 \n\n6 6 6 \n\n1 1 1 \n\n2 2 2 \n\n2 2 2 \n</code></pre><hr>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>虚树裸题，逻辑清晰的实现会让代码难度降低一个等级。</p>\n<hr>\n<h4 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6+1;\nconst int inf = 1e8;\n\n\nint read(){\n    int x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;,ch=getchar();\n    return x;\n}\n\nint n,m,f[N][21],st[N],dfn[N],q[N],head[N],d[N],cnt,k,vis[N],T,sz[N];\nstruct nd{\n    int ne,to;\n}e[N*2];\n\nvoid in(int x,int y){\n    if(x==y||!x||!y)return;\n    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;\n}\n\nint dfs(int x,int fa=-1){\n    static int totw=0;\n    dfn[x]=++totw;\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=fa){\n        int y=e[i].to;\n        f[y][0]=x;\n        d[y]=d[x]+1;\n        dfs(y,x);\n    }\n}\n\nbool cmp(int a,int b){\n    return dfn[a]&lt;dfn[b];\n}\n\nint lca(int x,int y){\n    if(d[x]&lt;d[y])swap(x,y);\n    for(int i=20;i&gt;=0;--i)\n    if(d[f[x][i]]&gt;=d[y])x=f[x][i];\n    if(x==y)return x;\n    for(int i=20;i&gt;=0;--i)\n    if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n    return f[x][0];\n}\n\n\nll s[N];\nll ans=0;\nint mx=0,mn=inf,mnn[N],mxx[N];\n\nvoid get(int x){\n    s[x]=0;\n    sz[x]=(vis[x]==T);\n    mnn[x]=(vis[x]==T?0:inf);\n    mxx[x]=(vis[x]==T?0:-inf);\n    for(int i=head[x];i;i=e[i].ne){\n        int y=e[i].to;\n        get(y);\n        ans+=(s[x]+sz[x]*(d[y]-d[x]))*sz[y]+s[y]*sz[x];\n        sz[x]+=sz[y];\n        s[x]+=s[y]+(d[y]-d[x])*sz[y];\n        mx=max(mx,mxx[x]+mxx[y]+d[y]-d[x]);\n        mn=min(mn,mnn[x]+mnn[y]+d[y]-d[x]);\n        mxx[x]=max(mxx[x],mxx[y]+d[y]-d[x]);\n        mnn[x]=min(mnn[x],mnn[y]+d[y]-d[x]);\n    }\n    head[x]=0;\n}\n\nvoid solve(){\n    sort(q+1,q+k+1,cmp);cnt=0;++T;\n    for(int i=1;i&lt;=k;++i)vis[q[i]]=T;\n    ans=0;mx=0;mn=inf;\n    int L=0;\n    st[++L]=1;\n    for(int i=1;i&lt;=k;++i){\n        int x=q[i],l=lca(x,st[L]);\n        while(1){\n            if(d[l]&gt;=d[st[L-1]]){\n                in(l,st[L--]);\n                if(l!=st[L])st[++L]=l;\n                break;\n            }\n            in(st[L-1],st[L]);L--;\n        }\n        if(x!=st[L])st[++L]=x;\n    }\n    while(--L)in(st[L],st[L+1]);\n    get(1);\n    printf(&quot;%lld %d %d\\n&quot;,ans,mn,mx);\n}\n\nint main(){\n//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n    n=read();\n    for(int i=1,x,y;i&lt;n;++i)\n    x=read(),y=read(),in(x,y),in(y,x);\n    d[1]=1;dfn[0]=inf;dfs(1);\n    for(int j=1;j&lt;21;++j)\n    for(int i=1;i&lt;=n;++i)\n    f[i][j]=f[f[i][j-1]][j-1];\n    memset(head,0,sizeof(head));\n    int Q=read();\n    while(Q--){\n        k=read();\n        for(int i=1;i&lt;=k;++i)q[i]=read();\n        solve();\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/11/27/虚树总结/","excerpt":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"虚树","slug":"数据结构/虚树","permalink":"https://prostkhala.github.io/categories/数据结构/虚树/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"虚树","slug":"虚树","permalink":"https://prostkhala.github.io/tags/虚树/"}]},{"title":"Topcoder SRM553 Div1 1000pts","date":"2017-11-26T02:55:23.000Z","path":"2017/11/26/Topcoder SRM553 div1 1000pts/","text":"YamanoteLine 题目描述n个城市首尾依次通过n条边相连。存在两种约束，分别表示从$S$到$T$的顺时针路径小于等于$L$或大于等于$L$，求出n条边可能的总权值个数。 数据范围$n&lt;=50$ 题解根据题目条件易知应按权值前缀和建立差分约束系统，并且二分答案。对于一个节点顺时针走到标号更小节点的情况，应该将当前二分的答案代入式子中进行化简，如果图最短路中存在负环（亦或最长路存在正环），则当前答案不合法，难点主要在此时答案应该增大还是减小上，应将当前二分答案的系数代入环中，判断系数的正负性，如果系数为$0$，则负环与二分值无关，即为无穷多解，如果系数大于$0$，则答案增大时负环权值增大，如果系数小于$0$，则答案减小时负环权值增大。两次二分出可行区间的左右端点，即为所求。（需要注意的是，由于要得到答案在环上的系数，所以当找到负环时，应只返回负环的系数，而不应返回整条路径的系数） CODE#include&lt;bits/stdc++.h&gt; #define vi vector&lt;int&gt; #define mp make_pair #define sd second #define fr first using namespace std; typedef long long ll; const int N = 1e3+1; const ll inf = 1e14; int head[N],cnt; struct nd{ int ne,to,f,fr;ll w; }e[N*2]; void in(int x,int y,ll w,int f){ e[++cnt].to=y;e[cnt].fr=x;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;e[cnt].f=f; } class YamanoteLine{ public: ll howMany(int n,vi s1,vi t1,vi l1,vi s2,vi t2,vi l2){ ll l=n,r=inf,L=-1,R=inf; for(int i=0;i&lt;s1.size();++i)s1[i]++,t1[i]++; for(int i=0;i&lt;s2.size();++i)s2[i]++,t2[i]++; while(l!=r){ ll mid=(l+r+1)&gt;&gt;1; pair&lt;bool,ll&gt;ck=can(mid,n,s1,t1,l1,s2,t2,l2); if(ck.fr||ck.sd&gt;0)l=mid; else r=mid-1; } R=l; l=n,r=inf; while(l!=r){ ll mid=(l+r)&gt;&gt;1; pair&lt;bool,ll&gt;ck=can(mid,n,s1,t1,l1,s2,t2,l2); if(ck.fr||ck.sd&lt;0)r=mid; else l=mid+1; } L=l; if(L&gt;=n&amp;&amp;R==inf)return -1; if(L&gt;R)return 0; return R-L+1; } private: int q[N],cntx; pair&lt;ll,ll&gt; d[N]; bool vis[N]; pair&lt;bool,ll&gt; spfa(int n,int x){ vis[x]=1; for(int i=head[x];i;i=e[i].ne){ int y=e[i].to; pair&lt;ll,ll&gt; t=mp(d[x].fr+e[i].w,d[x].sd+e[i].f); if(d[y].fr&gt;t.fr){ q[++cntx]=i; d[y]=t; if(vis[y]){ int tot=0; while(e[q[cntx]].fr!=y)tot+=e[q[cntx]].f,cntx--; tot+=e[q[cntx]].f; return mp(0,tot); } pair&lt;bool,ll&gt;res=spfa(n,y); cntx--; if(!res.fr)return res; } } vis[x]=0; return mp(1,0ll); } pair&lt;bool,ll&gt; can(ll ans,int n,vi s1,vi t1,vi l1,vi s2,vi t2,vi l2){ memset(head,0,sizeof(head));cnt=0; for(int i=0;i&lt;s1.size();++i){ int x=s1[i],y=t1[i];ll w=l1[i]; if(y&gt;x)in(y,x,-w,0); else in(y,x,ans-w,1); } for(int i=0;i&lt;s2.size();++i){ int x=s2[i],y=t2[i];ll w=l2[i]; if(y&gt;x)in(x,y,w,0); else in(x,y,w-ans,-1); } in(0,n,ans,1);in(n,0,-ans,-1); for(int i=1;i&lt;=n;++i)in(i,i-1,-1,0),in(0,i,ans,1); for(int i=1;i&lt;=n;++i)d[i]=mp(inf,0); d[0]=mp(0,0); memset(vis,0,sizeof(vis)); cntx=0; return spfa(n,0); } };","raw":"title: Topcoder SRM553 div1 1000pts\ndate: 2017-11-26 10:55:23\ncategories:\n  - Topcoder\ntags:\n  - 差分约束系统\n  - 二分答案\n---\n\n# YamanoteLine\n---\n## 题目描述\nn个城市首尾依次通过n条边相连。存在两种约束，分别表示从$S$到$T$的顺时针路径小于等于$L$或大于等于$L$，求出n条边可能的总权值个数。\n\n\n### 数据范围\n$n<=50$\n\n---\n## 题解\n根据题目条件易知应按权值前缀和建立差分约束系统，并且二分答案。对于一个节点顺时针走到标号更小节点的情况，应该将当前二分的答案代入式子中进行化简，如果图最短路中存在负环（亦或最长路存在正环），则当前答案不合法，难点主要在此时答案应该增大还是减小上，应将当前二分答案的系数代入环中，判断系数的正负性，如果系数为$0$，则负环与二分值无关，即为无穷多解，如果系数大于$0$，则答案增大时负环权值增大，如果系数小于$0$，则答案减小时负环权值增大。两次二分出可行区间的左右端点，即为所求。（需要注意的是，由于要得到答案在环上的系数，所以当找到负环时，应只返回负环的系数，而不应返回整条路径的系数）\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    #define vi vector<int>\n    #define mp make_pair\n    #define sd second\n    #define fr first\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e3+1;\n    const ll inf = 1e14;\n    int head[N],cnt;\n    struct nd{\n        int ne,to,f,fr;ll w;\n    }e[N*2];\n    void in(int x,int y,ll w,int f){\n        e[++cnt].to=y;e[cnt].fr=x;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;e[cnt].f=f;\n    }\n    class YamanoteLine{\n        public:\n        ll howMany(int n,vi s1,vi t1,vi l1,vi s2,vi t2,vi l2){\n            ll l=n,r=inf,L=-1,R=inf;\n            for(int i=0;i<s1.size();++i)s1[i]++,t1[i]++;\n            for(int i=0;i<s2.size();++i)s2[i]++,t2[i]++;\n            while(l!=r){\n                ll mid=(l+r+1)>>1;\n                pair<bool,ll>ck=can(mid,n,s1,t1,l1,s2,t2,l2);\n                if(ck.fr||ck.sd>0)l=mid;\n                else\tr=mid-1;\n            }\n            R=l;\n            l=n,r=inf;\n            while(l!=r){\n                ll mid=(l+r)>>1;\n                pair<bool,ll>ck=can(mid,n,s1,t1,l1,s2,t2,l2);\n                if(ck.fr||ck.sd<0)r=mid;\n                else\tl=mid+1;\n            }\n            L=l;\n            if(L>=n&&R==inf)return -1;\n            if(L>R)return 0;\n            return R-L+1;\n        }\n        private:\n        int q[N],cntx;\n        pair<ll,ll> d[N];\n        bool vis[N];\n        pair<bool,ll> spfa(int n,int x){\n            vis[x]=1;\n            for(int i=head[x];i;i=e[i].ne){\n                int y=e[i].to;\n                pair<ll,ll> t=mp(d[x].fr+e[i].w,d[x].sd+e[i].f);\n                if(d[y].fr>t.fr){\n                    q[++cntx]=i;\n                    d[y]=t;\n                    if(vis[y]){\n                        int tot=0;\n                        while(e[q[cntx]].fr!=y)tot+=e[q[cntx]].f,cntx--;\n                        tot+=e[q[cntx]].f;\n                        return mp(0,tot);\n                    }\n                    pair<bool,ll>res=spfa(n,y);\n                    cntx--;\n                    if(!res.fr)return res;\n                }\n            }\n            vis[x]=0;\n            return mp(1,0ll);\n        }\n        pair<bool,ll> can(ll ans,int n,vi s1,vi t1,vi l1,vi s2,vi t2,vi l2){\n            memset(head,0,sizeof(head));cnt=0;\n            for(int i=0;i<s1.size();++i){\n                int x=s1[i],y=t1[i];ll w=l1[i];\n                if(y>x)in(y,x,-w,0);\n                else\tin(y,x,ans-w,1);\n            }\n            for(int i=0;i<s2.size();++i){\n                int x=s2[i],y=t2[i];ll w=l2[i];\n                if(y>x)in(x,y,w,0);\n                else\tin(x,y,w-ans,-1);\n            }\n            in(0,n,ans,1);in(n,0,-ans,-1);\n            for(int i=1;i<=n;++i)in(i,i-1,-1,0),in(0,i,ans,1);\n            for(int i=1;i<=n;++i)d[i]=mp(inf,0);\n            d[0]=mp(0,0);\n            memset(vis,0,sizeof(vis));\n            cntx=0;\n            return spfa(n,0);\n        }\n    };\n","content":"<h1 id=\"YamanoteLine\"><a href=\"#YamanoteLine\" class=\"headerlink\" title=\"YamanoteLine\"></a>YamanoteLine</h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>n个城市首尾依次通过n条边相连。存在两种约束，分别表示从$S$到$T$的顺时针路径小于等于$L$或大于等于$L$，求出n条边可能的总权值个数。</p>\n<h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>$n&lt;=50$</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>根据题目条件易知应按权值前缀和建立差分约束系统，并且二分答案。对于一个节点顺时针走到标号更小节点的情况，应该将当前二分的答案代入式子中进行化简，如果图最短路中存在负环（亦或最长路存在正环），则当前答案不合法，难点主要在此时答案应该增大还是减小上，应将当前二分答案的系数代入环中，判断系数的正负性，如果系数为$0$，则负环与二分值无关，即为无穷多解，如果系数大于$0$，则答案增大时负环权值增大，如果系数小于$0$，则答案减小时负环权值增大。两次二分出可行区间的左右端点，即为所求。（需要注意的是，由于要得到答案在环上的系数，所以当找到负环时，应只返回负环的系数，而不应返回整条路径的系数）</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\n#define vi vector&lt;int&gt;\n#define mp make_pair\n#define sd second\n#define fr first\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e3+1;\nconst ll inf = 1e14;\nint head[N],cnt;\nstruct nd{\n    int ne,to,f,fr;ll w;\n}e[N*2];\nvoid in(int x,int y,ll w,int f){\n    e[++cnt].to=y;e[cnt].fr=x;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;e[cnt].f=f;\n}\nclass YamanoteLine{\n    public:\n    ll howMany(int n,vi s1,vi t1,vi l1,vi s2,vi t2,vi l2){\n        ll l=n,r=inf,L=-1,R=inf;\n        for(int i=0;i&lt;s1.size();++i)s1[i]++,t1[i]++;\n        for(int i=0;i&lt;s2.size();++i)s2[i]++,t2[i]++;\n        while(l!=r){\n            ll mid=(l+r+1)&gt;&gt;1;\n            pair&lt;bool,ll&gt;ck=can(mid,n,s1,t1,l1,s2,t2,l2);\n            if(ck.fr||ck.sd&gt;0)l=mid;\n            else    r=mid-1;\n        }\n        R=l;\n        l=n,r=inf;\n        while(l!=r){\n            ll mid=(l+r)&gt;&gt;1;\n            pair&lt;bool,ll&gt;ck=can(mid,n,s1,t1,l1,s2,t2,l2);\n            if(ck.fr||ck.sd&lt;0)r=mid;\n            else    l=mid+1;\n        }\n        L=l;\n        if(L&gt;=n&amp;&amp;R==inf)return -1;\n        if(L&gt;R)return 0;\n        return R-L+1;\n    }\n    private:\n    int q[N],cntx;\n    pair&lt;ll,ll&gt; d[N];\n    bool vis[N];\n    pair&lt;bool,ll&gt; spfa(int n,int x){\n        vis[x]=1;\n        for(int i=head[x];i;i=e[i].ne){\n            int y=e[i].to;\n            pair&lt;ll,ll&gt; t=mp(d[x].fr+e[i].w,d[x].sd+e[i].f);\n            if(d[y].fr&gt;t.fr){\n                q[++cntx]=i;\n                d[y]=t;\n                if(vis[y]){\n                    int tot=0;\n                    while(e[q[cntx]].fr!=y)tot+=e[q[cntx]].f,cntx--;\n                    tot+=e[q[cntx]].f;\n                    return mp(0,tot);\n                }\n                pair&lt;bool,ll&gt;res=spfa(n,y);\n                cntx--;\n                if(!res.fr)return res;\n            }\n        }\n        vis[x]=0;\n        return mp(1,0ll);\n    }\n    pair&lt;bool,ll&gt; can(ll ans,int n,vi s1,vi t1,vi l1,vi s2,vi t2,vi l2){\n        memset(head,0,sizeof(head));cnt=0;\n        for(int i=0;i&lt;s1.size();++i){\n            int x=s1[i],y=t1[i];ll w=l1[i];\n            if(y&gt;x)in(y,x,-w,0);\n            else    in(y,x,ans-w,1);\n        }\n        for(int i=0;i&lt;s2.size();++i){\n            int x=s2[i],y=t2[i];ll w=l2[i];\n            if(y&gt;x)in(x,y,w,0);\n            else    in(x,y,w-ans,-1);\n        }\n        in(0,n,ans,1);in(n,0,-ans,-1);\n        for(int i=1;i&lt;=n;++i)in(i,i-1,-1,0),in(0,i,ans,1);\n        for(int i=1;i&lt;=n;++i)d[i]=mp(inf,0);\n        d[0]=mp(0,0);\n        memset(vis,0,sizeof(vis));\n        cntx=0;\n        return spfa(n,0);\n    }\n};\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/11/26/Topcoder SRM553 div1 1000pts/","excerpt":"","categories":[{"name":"Topcoder","slug":"Topcoder","permalink":"https://prostkhala.github.io/categories/Topcoder/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://prostkhala.github.io/tags/二分答案/"},{"name":"差分约束系统","slug":"差分约束系统","permalink":"https://prostkhala.github.io/tags/差分约束系统/"}]},{"title":"NOI2014 购票","date":"2017-09-28T08:03:14.000Z","path":"2017/09/28/NOI2014购票/","text":"购票 题目描述今年夏天，NOI在SZ市迎来了她30周岁的生日。来自全国nn城市的OIer们都会从各地出发，到SZ市参加这次盛会。 全国的城市构成了一棵以SZ市为根的有根树，每个城市与它的父亲用道路连接。为了方便起见，我们将全国的nn个城市用 1 到nn的整数编号。其中SZ市的编号为11。对于除SZ市之外的任意一个城市vv,我们给出了它在这棵树上的父亲城市fvfv以及到父亲城市道路的长度svsv。 从城市vv前往SZ市的方法为：选择城市vv的一个祖先aa，支付购票的费用，乘坐交通工具到达aa。再选择城市aa的一个祖先bb，支付费用并到达bb。以此类推，直至到达SZ市。 对于任意一个城市vv，我们会给出一个交通工具的距离限制lvlv。对于城市vv的祖先aa，只有当它们之间所有道路的总长度不超过lvlv时，从城市vv才可以通过一次购票到达城市aa，否则不能通过一次购票到达。对于每个城市vv，我们还会给出两个非负整数pv,qvpv,qv作为票价参数。若城市vv到城市aa所有道路的总长度为dd，那么从城市vv到城市aa购买的票价为dpv+qvdpv+qv。 每个城市的OIer都希望自己到达SZ市时，用于购票的总资金最少。你的任务就是，告诉每个城市的OIer他们所花的最少资金是多少。 输入输出格式输入格式:输入文件的第1行包含2个非负整数n,tn,t，分别表示城市的个数和数据类型（其意义将在后面提到）。 输入文件的第2到nn行，每行描述一个除SZ之外的城市。其中第vv行包含5个非负整数fv,sv,pv,qv,lvfv,sv,pv,qv,lv，分别表示城市vv的父亲城市，它到父亲城市道路的长度，票价的两个参数和距离限制。 请注意：输入不包含编号为1的SZ市，第2行到第n行分别描述的是城市2到城市n。 输出格式：输出包含n−1n−1行，每行包含一个整数。其中第vv行表示从城市v+1v+1出发，到达SZ市最少的购票费用。 同样请注意：输出不包含编号为1的SZ市。 输入输出样例输入样例：7 3 1 2 20 0 3 1 5 10 100 5 2 4 10 10 10 2 9 1 100 10 3 5 20 100 10 4 4 20 0 10 输出样例：40 150 70 149 300 150 数据范围对于所有测试数据，保证0≤pv≤1060≤pv≤106，0≤qv≤10120≤qv≤1012，1≤fv&lt;v1≤fv&lt;v；保证0&lt;sv≤lv≤2×10110&lt;sv≤lv≤2×1011，且任意城市到SZ市的总路程长度不超过2×10112×1011。 输入的tt表示数据类型，0≤t&lt;40≤t&lt;4，其中： 当t=0t=0或22时，对输入的所有城市vv，都有 fv=v−1fv=v−1，即所有城市构成一个以SZ市为终点的链； 当t=0t=0或11时，对输入的所有城市vv，都有 lv=2×1011lv=2×1011，即没有移动的距离限制，每个城市都能到达它的所有祖先。 当t=3t=3时，数据没有特殊性质。 题解设$f_x$表示从x到根节点的最小花费，易得动态规划方程为: $f_x=min(f_y+(d_x-d_y)*p_x+q_x)$ 容易观察到该方程具有决策单调性，当x从k转移优于从j转移时推得斜率方程为： $ (f_k-f_j)/(d_k-d_j)&lt;p_x$ 此处便可以通过树分治来计算答案，由于在$更新f_x$时其所有父亲节点都已经处理，所以得到重心后，应先递归深度小的部分，然后处理当前分治结构，再递归深度大的部分。 对于当前分治结构，应计算重心的所有父亲节点对于子树的贡献（即父亲节点要加入单调栈），考虑到$l_x$的限制，我们可以将需要更新的节点按其所能达到的最浅深度从大到小排序，这样处理不会对单调栈要求删除操作，在得到更新的单调栈后，在凸包上根据斜率方程二分即可得到答案。需要注意由于此处并没有计算重心的贡献，需要特别处理一下。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef double db; const int N = 2e5+1; const ll inf = 2e15; int fa[N],n,tp,head[N],cnt; int sz[N],mx[N],tot,rt,q[N],qq[N]; ll p1[N],q1[N],w[N],l[N],d[N],f[N]; bool vis[N]; struct nd{ int ne,to,w; }e[N*2]; void in(int x,int y,ll w){ e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w; } bool cmp(int x,int y){ return l[x]&gt;l[y]; } void getrt(int x,int f){ sz[x]=1;mx[x]=0; for(int i=head[x];i;i=e[i].ne) if(e[i].to!=f&amp;&amp;!vis[e[i].to]){ int y=e[i].to; getrt(y,x); sz[x]+=sz[y]; mx[x]=max(mx[x],sz[y]); } mx[x]=max(mx[x],tot-sz[x]); if(mx[x]&lt;mx[rt])rt=x; } void dfs1(int x,int f){ sz[x]=1; for(int i=head[x];i;i=e[i].ne) if(e[i].to!=f&amp;&amp;!vis[e[i].to]){ dfs1(e[i].to,x); sz[x]+=sz[e[i].to]; } } void dfs2(int x,int f){ q[++q[0]]=x; for(int i=head[x];i;i=e[i].ne) if(e[i].to!=f&amp;&amp;!vis[e[i].to]){ dfs2(e[i].to,x); } } db k(int x,int y){ return (db)(f[x]-f[y])/(d[x]-d[y]); } void CDQ(int y,int x){ dfs1(x,-1); vis[x]=1; if(x!=1&amp;&amp;!vis[fa[x]]){ tot=sz[fa[x]]; rt=0; getrt(fa[x],-1); CDQ(y,rt); } q[0]=0;dfs2(x,fa[x]); sort(q+1,q+q[0]+1,cmp); int top=0; for(int i=1,now=fa[x];i&lt;=q[0];++i){ while(now!=fa[y]&amp;&amp;l[q[i]]&lt;=d[now]){ // if(!now)break; while(top&gt;1&amp;&amp;k(qq[top-1],qq[top])&lt;=k(qq[top],now))top--; qq[++top]=now;now=fa[now]; } if(!top)continue; int l=1,r=top; while(l!=r){ int mid=l+r&gt;&gt;1; if(k(qq[mid],qq[mid+1])&lt;p1[q[i]])r=mid; else l=mid+1; } int j=q[i]; f[j]=min(f[j],f[qq[l]]+(d[j]-d[qq[l]])*p1[j]+q1[j]); } for(int i=1;i&lt;=q[0];++i) if(q[i]!=x&amp;&amp;l[q[i]]&lt;=d[x]){ int j=q[i]; f[j]=min(f[j],f[x]+(d[j]-d[x])*p1[j]+q1[j]); } for(int i=head[x];i;i=e[i].ne) if(!vis[e[i].to]&amp;&amp;e[i].to!=fa[x]){ tot=sz[e[i].to]; rt=0; getrt(e[i].to,x); CDQ(e[i].to,rt); } } int main(){ // freopen(&quot;ex_ticket2.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;ex_ticket2.out&quot;,&quot;w&quot;,stdout); mx[0]=1e9; memset(f,0x3f,sizeof(f)); f[1]=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;tp); for(int i=2;i&lt;=n;++i){ scanf(&quot;%d%lld%lld%lld%lld&quot;,&amp;fa[i],&amp;w[i],&amp;p1[i],&amp;q1[i],&amp;l[i]); in(fa[i],i,w[i]);in(i,fa[i],w[i]); d[i]=d[fa[i]]+w[i]; } for(int i=2;i&lt;=n;++i)l[i]=d[i]-l[i]; tot=n; getrt(1,-1); CDQ(1,rt); for(int i=2;i&lt;=n;++i)printf(&quot;%lld\\n&quot;,f[i]); }","raw":"title: NOI2014 购票\ndate: 2017-09-28 16:03:14\ncategories:\n  - 动态规划\n  - 单调性优化\ntags:\n  - 树分治\n  - CDQ分治\n  - 动态规划\n  - 斜率优化\n  - 决策单调性\n---\n\n# [购票](http://uoj.ac/problem/7)\n---\n## 题目描述\n今年夏天，NOI在SZ市迎来了她30周岁的生日。来自全国nn城市的OIer们都会从各地出发，到SZ市参加这次盛会。\n\n全国的城市构成了一棵以SZ市为根的有根树，每个城市与它的父亲用道路连接。为了方便起见，我们将全国的nn个城市用 1 到nn的整数编号。其中SZ市的编号为11。对于除SZ市之外的任意一个城市vv,我们给出了它在这棵树上的父亲城市fvfv以及到父亲城市道路的长度svsv。\n\n从城市vv前往SZ市的方法为：选择城市vv的一个祖先aa，支付购票的费用，乘坐交通工具到达aa。再选择城市aa的一个祖先bb，支付费用并到达bb。以此类推，直至到达SZ市。\n\n对于任意一个城市vv，我们会给出一个交通工具的距离限制lvlv。对于城市vv的祖先aa，只有当它们之间所有道路的总长度不超过lvlv时，从城市vv才可以通过一次购票到达城市aa，否则不能通过一次购票到达。对于每个城市vv，我们还会给出两个非负整数pv,qvpv,qv作为票价参数。若城市vv到城市aa所有道路的总长度为dd，那么从城市vv到城市aa购买的票价为dpv+qvdpv+qv。\n\n每个城市的OIer都希望自己到达SZ市时，用于购票的总资金最少。你的任务就是，告诉每个城市的OIer他们所花的最少资金是多少。\n\n### 输入输出格式\n#### 输入格式:\n输入文件的第1行包含2个非负整数n,tn,t，分别表示城市的个数和数据类型（其意义将在后面提到）。 输入文件的第2到nn行，每行描述一个除SZ之外的城市。其中第vv行包含5个非负整数fv,sv,pv,qv,lvfv,sv,pv,qv,lv，分别表示城市vv的父亲城市，它到父亲城市道路的长度，票价的两个参数和距离限制。\n\n请注意：输入不包含编号为1的SZ市，第2行到第n行分别描述的是城市2到城市n。\n\n#### 输出格式：\n输出包含n−1n−1行，每行包含一个整数。其中第vv行表示从城市v+1v+1出发，到达SZ市最少的购票费用。\n\n同样请注意：输出不包含编号为1的SZ市。\n\n### 输入输出样例\n#### 输入样例：\n    7 3\n    1 2 20 0 3\n    1 5 10 100 5\n    2 4 10 10 10\n    2 9 1 100 10\n    3 5 20 100 10\n    4 4 20 0 10\n\n#### 输出样例：\n    40\n    150\n    70\n    149\n    300\n    150\n\n### 数据范围\n对于所有测试数据，保证0≤pv≤1060≤pv≤106，0≤qv≤10120≤qv≤1012，1≤fv<v1≤fv<v；保证0<sv≤lv≤2×10110<sv≤lv≤2×1011，且任意城市到SZ市的总路程长度不超过2×10112×1011。\n\n输入的tt表示数据类型，0≤t<40≤t<4，其中：\n\n当t=0t=0或22时，对输入的所有城市vv，都有 fv=v−1fv=v−1，即所有城市构成一个以SZ市为终点的链；\n\n当t=0t=0或11时，对输入的所有城市vv，都有 lv=2×1011lv=2×1011，即没有移动的距离限制，每个城市都能到达它的所有祖先。\n\n当t=3t=3时，数据没有特殊性质。\n\n---\n## 题解\n设$f_x$表示从x到根节点的最小花费，易得动态规划方程为:\n\n$f_x=min(f_y+(d_x-d_y)*p_x+q_x)$\n\n容易观察到该方程具有决策单调性，当x从k转移优于从j转移时推得斜率方程为：\n\n$ (f_k-f_j)/(d_k-d_j)<p_x$\n\n此处便可以通过树分治来计算答案，由于在$更新f_x$时其所有父亲节点都已经处理，所以得到重心后，应先递归深度小的部分，然后处理当前分治结构，再递归深度大的部分。\n\n对于当前分治结构，应计算重心的所有父亲节点对于子树的贡献（即父亲节点要加入单调栈），考虑到$l_x$的限制，我们可以将需要更新的节点按其所能达到的最浅深度从大到小排序，这样处理不会对单调栈要求删除操作，在得到更新的单调栈后，在凸包上根据斜率方程二分即可得到答案。需要注意由于此处并没有计算重心的贡献，需要特别处理一下。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    typedef double db;\n    const int N = 2e5+1;\n    const ll inf = 2e15;\n    int fa[N],n,tp,head[N],cnt;\n    int sz[N],mx[N],tot,rt,q[N],qq[N];\n    ll p1[N],q1[N],w[N],l[N],d[N],f[N];\n    bool vis[N];\n\n    struct nd{\n        int ne,to,w;\n    }e[N*2];\n\n    void in(int x,int y,ll w){\n        e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;\n    }\n\n    bool cmp(int x,int y){\n        return l[x]>l[y];\n    }\n\n    void getrt(int x,int f){\n        sz[x]=1;mx[x]=0;\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=f&&!vis[e[i].to]){\n            int y=e[i].to;\n            getrt(y,x);\n            sz[x]+=sz[y];\n            mx[x]=max(mx[x],sz[y]);\n        }\n        mx[x]=max(mx[x],tot-sz[x]);\n        if(mx[x]<mx[rt])rt=x;\n    }\n\n    void dfs1(int x,int f){\n        sz[x]=1;\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=f&&!vis[e[i].to]){\n            dfs1(e[i].to,x);\n            sz[x]+=sz[e[i].to];\n        }\n    }\n\n    void dfs2(int x,int f){\n        q[++q[0]]=x;\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=f&&!vis[e[i].to]){\n            dfs2(e[i].to,x);\n        }\n    }\n\n    db k(int x,int y){\n        return (db)(f[x]-f[y])/(d[x]-d[y]);\n    }\n\n    void CDQ(int y,int x){\n        dfs1(x,-1);\n        vis[x]=1;\n        if(x!=1&&!vis[fa[x]]){\n            tot=sz[fa[x]];\n            rt=0;\n            getrt(fa[x],-1);\n            CDQ(y,rt);\n        }\n        q[0]=0;dfs2(x,fa[x]);\n        sort(q+1,q+q[0]+1,cmp);\n        int top=0;\n        for(int i=1,now=fa[x];i<=q[0];++i){\n            while(now!=fa[y]&&l[q[i]]<=d[now]){\n    //\t\t\tif(!now)break;\n                while(top>1&&k(qq[top-1],qq[top])<=k(qq[top],now))top--;\n                qq[++top]=now;now=fa[now];\n            }\n            if(!top)continue;\n            int l=1,r=top;\n            while(l!=r){\n                int mid=l+r>>1;\n                if(k(qq[mid],qq[mid+1])<p1[q[i]])r=mid;\n                else\tl=mid+1;\n            }\n            int j=q[i];\n            f[j]=min(f[j],f[qq[l]]+(d[j]-d[qq[l]])*p1[j]+q1[j]);\n        }\n        for(int i=1;i<=q[0];++i)\n        if(q[i]!=x&&l[q[i]]<=d[x]){\n            int j=q[i];\n            f[j]=min(f[j],f[x]+(d[j]-d[x])*p1[j]+q1[j]);\n        }\n        for(int i=head[x];i;i=e[i].ne)\n        if(!vis[e[i].to]&&e[i].to!=fa[x]){\n            tot=sz[e[i].to];\n            rt=0;\n            getrt(e[i].to,x);\n            CDQ(e[i].to,rt);\n        }\n    }\n    int main(){\n    //\tfreopen(\"ex_ticket2.in\",\"r\",stdin);\n    //\tfreopen(\"ex_ticket2.out\",\"w\",stdout);\n        mx[0]=1e9;\n        memset(f,0x3f,sizeof(f));\n        f[1]=0;\n        scanf(\"%d%d\",&n,&tp);\n        for(int i=2;i<=n;++i){\n            scanf(\"%d%lld%lld%lld%lld\",&fa[i],&w[i],&p1[i],&q1[i],&l[i]);\n            in(fa[i],i,w[i]);in(i,fa[i],w[i]);\n            d[i]=d[fa[i]]+w[i];\n        }\n        for(int i=2;i<=n;++i)l[i]=d[i]-l[i];\n        tot=n;\n        getrt(1,-1);\n        CDQ(1,rt);\n        for(int i=2;i<=n;++i)printf(\"%lld\\n\",f[i]);\n    }\n","content":"<h1 id=\"购票\"><a href=\"#购票\" class=\"headerlink\" title=\"购票\"></a><a href=\"http://uoj.ac/problem/7\" target=\"_blank\" rel=\"external\">购票</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>今年夏天，NOI在SZ市迎来了她30周岁的生日。来自全国nn城市的OIer们都会从各地出发，到SZ市参加这次盛会。</p>\n<p>全国的城市构成了一棵以SZ市为根的有根树，每个城市与它的父亲用道路连接。为了方便起见，我们将全国的nn个城市用 1 到nn的整数编号。其中SZ市的编号为11。对于除SZ市之外的任意一个城市vv,我们给出了它在这棵树上的父亲城市fvfv以及到父亲城市道路的长度svsv。</p>\n<p>从城市vv前往SZ市的方法为：选择城市vv的一个祖先aa，支付购票的费用，乘坐交通工具到达aa。再选择城市aa的一个祖先bb，支付费用并到达bb。以此类推，直至到达SZ市。</p>\n<p>对于任意一个城市vv，我们会给出一个交通工具的距离限制lvlv。对于城市vv的祖先aa，只有当它们之间所有道路的总长度不超过lvlv时，从城市vv才可以通过一次购票到达城市aa，否则不能通过一次购票到达。对于每个城市vv，我们还会给出两个非负整数pv,qvpv,qv作为票价参数。若城市vv到城市aa所有道路的总长度为dd，那么从城市vv到城市aa购买的票价为dpv+qvdpv+qv。</p>\n<p>每个城市的OIer都希望自己到达SZ市时，用于购票的总资金最少。你的任务就是，告诉每个城市的OIer他们所花的最少资金是多少。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>输入文件的第1行包含2个非负整数n,tn,t，分别表示城市的个数和数据类型（其意义将在后面提到）。 输入文件的第2到nn行，每行描述一个除SZ之外的城市。其中第vv行包含5个非负整数fv,sv,pv,qv,lvfv,sv,pv,qv,lv，分别表示城市vv的父亲城市，它到父亲城市道路的长度，票价的两个参数和距离限制。</p>\n<p>请注意：输入不包含编号为1的SZ市，第2行到第n行分别描述的是城市2到城市n。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出包含n−1n−1行，每行包含一个整数。其中第vv行表示从城市v+1v+1出发，到达SZ市最少的购票费用。</p>\n<p>同样请注意：输出不包含编号为1的SZ市。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>7 3\n1 2 20 0 3\n1 5 10 100 5\n2 4 10 10 10\n2 9 1 100 10\n3 5 20 100 10\n4 4 20 0 10\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>40\n150\n70\n149\n300\n150\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于所有测试数据，保证0≤pv≤1060≤pv≤106，0≤qv≤10120≤qv≤1012，1≤fv&lt;v1≤fv&lt;v；保证0&lt;sv≤lv≤2×10110&lt;sv≤lv≤2×1011，且任意城市到SZ市的总路程长度不超过2×10112×1011。</p>\n<p>输入的tt表示数据类型，0≤t&lt;40≤t&lt;4，其中：</p>\n<p>当t=0t=0或22时，对输入的所有城市vv，都有 fv=v−1fv=v−1，即所有城市构成一个以SZ市为终点的链；</p>\n<p>当t=0t=0或11时，对输入的所有城市vv，都有 lv=2×1011lv=2×1011，即没有移动的距离限制，每个城市都能到达它的所有祖先。</p>\n<p>当t=3t=3时，数据没有特殊性质。</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>设$f_x$表示从x到根节点的最小花费，易得动态规划方程为:</p>\n<p>$f_x=min(f_y+(d_x-d_y)*p_x+q_x)$</p>\n<p>容易观察到该方程具有决策单调性，当x从k转移优于从j转移时推得斜率方程为：</p>\n<p>$ (f_k-f_j)/(d_k-d_j)&lt;p_x$</p>\n<p>此处便可以通过树分治来计算答案，由于在$更新f_x$时其所有父亲节点都已经处理，所以得到重心后，应先递归深度小的部分，然后处理当前分治结构，再递归深度大的部分。</p>\n<p>对于当前分治结构，应计算重心的所有父亲节点对于子树的贡献（即父亲节点要加入单调栈），考虑到$l_x$的限制，我们可以将需要更新的节点按其所能达到的最浅深度从大到小排序，这样处理不会对单调栈要求删除操作，在得到更新的单调栈后，在凸包上根据斜率方程二分即可得到答案。需要注意由于此处并没有计算重心的贡献，需要特别处理一下。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N = 2e5+1;\nconst ll inf = 2e15;\nint fa[N],n,tp,head[N],cnt;\nint sz[N],mx[N],tot,rt,q[N],qq[N];\nll p1[N],q1[N],w[N],l[N],d[N],f[N];\nbool vis[N];\n\nstruct nd{\n    int ne,to,w;\n}e[N*2];\n\nvoid in(int x,int y,ll w){\n    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;\n}\n\nbool cmp(int x,int y){\n    return l[x]&gt;l[y];\n}\n\nvoid getrt(int x,int f){\n    sz[x]=1;mx[x]=0;\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=f&amp;&amp;!vis[e[i].to]){\n        int y=e[i].to;\n        getrt(y,x);\n        sz[x]+=sz[y];\n        mx[x]=max(mx[x],sz[y]);\n    }\n    mx[x]=max(mx[x],tot-sz[x]);\n    if(mx[x]&lt;mx[rt])rt=x;\n}\n\nvoid dfs1(int x,int f){\n    sz[x]=1;\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=f&amp;&amp;!vis[e[i].to]){\n        dfs1(e[i].to,x);\n        sz[x]+=sz[e[i].to];\n    }\n}\n\nvoid dfs2(int x,int f){\n    q[++q[0]]=x;\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=f&amp;&amp;!vis[e[i].to]){\n        dfs2(e[i].to,x);\n    }\n}\n\ndb k(int x,int y){\n    return (db)(f[x]-f[y])/(d[x]-d[y]);\n}\n\nvoid CDQ(int y,int x){\n    dfs1(x,-1);\n    vis[x]=1;\n    if(x!=1&amp;&amp;!vis[fa[x]]){\n        tot=sz[fa[x]];\n        rt=0;\n        getrt(fa[x],-1);\n        CDQ(y,rt);\n    }\n    q[0]=0;dfs2(x,fa[x]);\n    sort(q+1,q+q[0]+1,cmp);\n    int top=0;\n    for(int i=1,now=fa[x];i&lt;=q[0];++i){\n        while(now!=fa[y]&amp;&amp;l[q[i]]&lt;=d[now]){\n//            if(!now)break;\n            while(top&gt;1&amp;&amp;k(qq[top-1],qq[top])&lt;=k(qq[top],now))top--;\n            qq[++top]=now;now=fa[now];\n        }\n        if(!top)continue;\n        int l=1,r=top;\n        while(l!=r){\n            int mid=l+r&gt;&gt;1;\n            if(k(qq[mid],qq[mid+1])&lt;p1[q[i]])r=mid;\n            else    l=mid+1;\n        }\n        int j=q[i];\n        f[j]=min(f[j],f[qq[l]]+(d[j]-d[qq[l]])*p1[j]+q1[j]);\n    }\n    for(int i=1;i&lt;=q[0];++i)\n    if(q[i]!=x&amp;&amp;l[q[i]]&lt;=d[x]){\n        int j=q[i];\n        f[j]=min(f[j],f[x]+(d[j]-d[x])*p1[j]+q1[j]);\n    }\n    for(int i=head[x];i;i=e[i].ne)\n    if(!vis[e[i].to]&amp;&amp;e[i].to!=fa[x]){\n        tot=sz[e[i].to];\n        rt=0;\n        getrt(e[i].to,x);\n        CDQ(e[i].to,rt);\n    }\n}\nint main(){\n//    freopen(&quot;ex_ticket2.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;ex_ticket2.out&quot;,&quot;w&quot;,stdout);\n    mx[0]=1e9;\n    memset(f,0x3f,sizeof(f));\n    f[1]=0;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;tp);\n    for(int i=2;i&lt;=n;++i){\n        scanf(&quot;%d%lld%lld%lld%lld&quot;,&amp;fa[i],&amp;w[i],&amp;p1[i],&amp;q1[i],&amp;l[i]);\n        in(fa[i],i,w[i]);in(i,fa[i],w[i]);\n        d[i]=d[fa[i]]+w[i];\n    }\n    for(int i=2;i&lt;=n;++i)l[i]=d[i]-l[i];\n    tot=n;\n    getrt(1,-1);\n    CDQ(1,rt);\n    for(int i=2;i&lt;=n;++i)printf(&quot;%lld\\n&quot;,f[i]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/09/28/NOI2014购票/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"},{"name":"单调性优化","slug":"动态规划/单调性优化","permalink":"https://prostkhala.github.io/categories/动态规划/单调性优化/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://prostkhala.github.io/tags/斜率优化/"},{"name":"树分治","slug":"树分治","permalink":"https://prostkhala.github.io/tags/树分治/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"https://prostkhala.github.io/tags/CDQ分治/"}]},{"title":"NOIP2013 华容道","date":"2017-09-21T07:26:25.000Z","path":"2017/09/21/NOIP2013华容道/","text":"华容道 题目描述 输入输出及样例解释 数据范围题解在本题中，真正可以自由移动的只有空格子，考虑对于指定格子的移动，必然是将空格格子移动到当前节点与目标节点的路径上，并将其于当前节点互换，重复以上过程直到当前节点与目标节点重合，以上过程用普通的BFS即可模拟。 但是本题中询问次数过多，实际上存在很多重复计算，可以考虑进行预处理优化。 由于每次都要将空格子移动到当前节点旁边，所以空格子的路径不能经过当前节点，否则将会导致答案不为最少时间，如果空格子的路径必须经过当前节点，则显然无解。（见样例2）那么可以设$f[x][y][k][h]$表示从$(x,y)$的$k$方向节点在不经过$(x,y)$的情况下移动到$h$方向节点的最小时间，对其进行预处理，然后每次询问通过SPFA求解即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #define mp make_pair using namespace std; typedef long long ll; const int inf = 0x3f3f3f3f; const int N =31+1; int n,m,Q,e1,e2,s1,s2,t1,t2; int f[N][N][4][4],d[N][N],dis[N][N][5],a[N][N]; bool vis[N][N],in[N][N][5]; int fx[4]={-1,1,0,0}; int fy[4]={0,0,-1,1}; struct nd{ int x,y,k; }; queue&lt;nd&gt;q,q1; int rev(int x){ if(x==1)return 0; if(x==0)return 1; if(x==2)return 3; if(x==3)return 2; } int bfs(int x1,int y1,int x2,int y2){ if(!a[x1][y1]||!a[x2][y2])return inf; memset(vis,0,sizeof(vis)); memset(d,0x3f,sizeof(d)); nd p; d[x1][y1]=0; vis[x1][y1]=1; while(!q1.empty())q1.pop(); q1.push((nd){x1,y1,0}); while(!q1.empty()&amp;&amp;!vis[x2][y2]){ p=q1.front();q1.pop(); for(int i=0;i&lt;4;++i){ int x=p.x+fx[i],y=p.y+fy[i]; if(!vis[x][y]&amp;&amp;a[x][y]){ vis[x][y]=1; d[x][y]=d[p.x][p.y]+1; q1.push((nd){x,y,0}); } } } return d[x2][y2]; } void init(){ memset(f,0x3f,sizeof(f)); for(int i=1;i&lt;=n;++i) for(int t=1;t&lt;=m;++t) if(a[i][t]){ a[i][t]=0; for(int k=0;k&lt;4;++k) for(int h=0;h&lt;4;++h){ if(h&lt;k){f[i][t][k][h]=f[i][t][h][k];continue;} int x=i+fx[k],y=t+fy[k]; int x11=i+fx[h],y11=t+fy[h]; if(!a[x][y]||!a[x11][y11])continue; f[i][t][k][h]=bfs(x,y,x11,y11)+1; // cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;&quot; &quot;&lt;&lt;f[i][t][k][h]&lt;&lt;endl; } a[i][t]=1; } } int spfa(int x1,int y1,int x2,int y2,int e1,int e2){ if(x1==x2&amp;&amp;y1==y2)return 0; if(!a[x1][y1]||!a[x2][y2])return -1; memset(dis,0x3f,sizeof(dis)); memset(in,0,sizeof(in)); while(!q.empty())q.pop(); a[x1][y1]=0; for(int k=0;k&lt;4;++k){ q.push((nd){x1,y1,k}); in[x1][y1][k]=1; dis[x1][y1][k]=bfs(e1,e2,x1+fx[k],y1+fy[k]); } a[x1][y1]=1; nd x,y; while(!q.empty()){ x=q.front();q.pop(); in[x.x][x.y][x.k]=0; for(int h=0;h&lt;4;++h){ y.x=x.x+fx[h],y.y=x.y+fy[h]; y.k=rev(h); if(dis[y.x][y.y][y.k]&gt;dis[x.x][x.y][x.k]+f[x.x][x.y][x.k][h]){ dis[y.x][y.y][y.k]=dis[x.x][x.y][x.k]+f[x.x][x.y][x.k][h]; if(!in[y.x][y.y][y.k])in[y.x][y.y][y.k]=1,q.push(y); } } } int ret=inf; for(int i=0;i&lt;4;++i)ret=min(ret,dis[x2][y2][i]); return ret&lt;inf?ret:-1; } int main(){ freopen(&quot;PuzzleNOIP2013.in&quot;,&quot;r&quot;,stdin); freopen(&quot;PuzzleNOIP2013.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q); for(int i=1;i&lt;=n;++i) for(int t=1;t&lt;=m;++t) scanf(&quot;%d&quot;,&amp;a[i][t]); init(); while(Q--){ scanf(&quot;%d%d%d%d%d%d&quot;,&amp;e1,&amp;e2,&amp;s1,&amp;s2,&amp;t1,&amp;t2); int ans=0,tot=0; printf(&quot;%d\\n&quot;,spfa(s1,s2,t1,t2,e1,e2)); dddd:; } } /* 3 4 2 0 1 1 1 0 1 1 0 0 1 0 0 3 2 1 2 2 2 1 2 2 2 3 2 */ /* 3 3 1 1 1 0 1 1 0 1 1 0 3 1 1 1 3 1 */","raw":"title: NOIP2013 华容道\ndate: 2017-09-21 15:26:25\ncategories:\n  - BFS\ntags:\n  - BFS\n---\n\n# [华容道](http://cogs.pro/cogs/problem/problem.php?pid=1442)\n---\n## 题目描述\n![](http://cogs.pro/upload/image/20131118/20131118201912_84538.png)\n### 输入输出及样例解释\n![](http://cogs.pro/upload/image/20131118/20131118201920_74338.png)\n![](http://cogs.pro/upload/image/20131118/20131118201931_43656.png)\n### 数据范围\n![](http://cogs.pro/upload/image/20131118/20131118201940_40826.png)\n---\n## 题解\n在本题中，真正可以自由移动的只有空格子，考虑对于指定格子的移动，必然是将空格格子移动到当前节点与目标节点的路径上，并将其于当前节点互换，重复以上过程直到当前节点与目标节点重合，以上过程用普通的BFS即可模拟。\n\n但是本题中询问次数过多，实际上存在很多重复计算，可以考虑进行预处理优化。\n\n由于每次都要将空格子移动到当前节点旁边，所以空格子的路径不能经过当前节点，否则将会导致答案不为最少时间，如果空格子的路径必须经过当前节点，则显然无解。（见样例2）那么可以设$f[x][y][k][h]$表示从$(x,y)$的$k$方向节点在不经过$(x,y)$的情况下移动到$h$方向节点的最小时间，对其进行预处理，然后每次询问通过SPFA求解即可。\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<queue>\n    #include<cstring>\n    #define mp make_pair \n    using namespace std;\n    typedef long long ll;\n    const int inf = 0x3f3f3f3f;\n    const int N =31+1;\n    int n,m,Q,e1,e2,s1,s2,t1,t2;\n    int f[N][N][4][4],d[N][N],dis[N][N][5],a[N][N];\n    bool vis[N][N],in[N][N][5];\n    int fx[4]={-1,1,0,0};\n    int fy[4]={0,0,-1,1};\n    struct nd{\n        int x,y,k;\n    };\n    queue<nd>q,q1;\n\n    int rev(int x){\n        if(x==1)return 0;\n        if(x==0)return 1;\n        if(x==2)return 3;\n        if(x==3)return 2;\n    }\n\n    int bfs(int x1,int y1,int x2,int y2){\n        if(!a[x1][y1]||!a[x2][y2])return inf;\n        memset(vis,0,sizeof(vis));\n        memset(d,0x3f,sizeof(d));\n        nd p;\n        d[x1][y1]=0;\n        vis[x1][y1]=1;\n        while(!q1.empty())q1.pop();\n        q1.push((nd){x1,y1,0});\n        while(!q1.empty()&&!vis[x2][y2]){\n            p=q1.front();q1.pop();\n            for(int i=0;i<4;++i){\n                int x=p.x+fx[i],y=p.y+fy[i];\n                if(!vis[x][y]&&a[x][y]){\n                    vis[x][y]=1;\n                    d[x][y]=d[p.x][p.y]+1;\n                    q1.push((nd){x,y,0});\n                }\n            }\n        }\n        return d[x2][y2];\n    }\n\n    void init(){\n        memset(f,0x3f,sizeof(f));\n        for(int i=1;i<=n;++i)\n        for(int t=1;t<=m;++t)\n        if(a[i][t]){\n            a[i][t]=0;\n            for(int k=0;k<4;++k)\n            for(int h=0;h<4;++h){\n                if(h<k){f[i][t][k][h]=f[i][t][h][k];continue;}\n                int x=i+fx[k],y=t+fy[k];\n                int x11=i+fx[h],y11=t+fy[h];\n                if(!a[x][y]||!a[x11][y11])continue;\n                f[i][t][k][h]=bfs(x,y,x11,y11)+1;\n    //\t\t\tcout<<i<<\" \"<<t<<\" \"<<f[i][t][k][h]<<endl;\n            }\n            a[i][t]=1;\n        }\n    }\n\n    int spfa(int x1,int y1,int x2,int y2,int e1,int e2){\n        if(x1==x2&&y1==y2)return 0;\n        if(!a[x1][y1]||!a[x2][y2])return -1;\n        memset(dis,0x3f,sizeof(dis));\n        memset(in,0,sizeof(in));\n        while(!q.empty())q.pop();\n        a[x1][y1]=0;\n        for(int k=0;k<4;++k){\n            q.push((nd){x1,y1,k});\n            in[x1][y1][k]=1;\n            dis[x1][y1][k]=bfs(e1,e2,x1+fx[k],y1+fy[k]);\n        }\n        a[x1][y1]=1;\n        nd x,y;\n        while(!q.empty()){\n            x=q.front();q.pop();\n            in[x.x][x.y][x.k]=0;\n            for(int h=0;h<4;++h){\n                y.x=x.x+fx[h],y.y=x.y+fy[h];\n                y.k=rev(h);\n                if(dis[y.x][y.y][y.k]>dis[x.x][x.y][x.k]+f[x.x][x.y][x.k][h]){\n                    dis[y.x][y.y][y.k]=dis[x.x][x.y][x.k]+f[x.x][x.y][x.k][h];\n                    if(!in[y.x][y.y][y.k])in[y.x][y.y][y.k]=1,q.push(y);\n                }\n            }\n        }\n        int ret=inf;\n        for(int i=0;i<4;++i)ret=min(ret,dis[x2][y2][i]);\n        return ret<inf?ret:-1;\n    }\n    int main(){\n        freopen(\"PuzzleNOIP2013.in\",\"r\",stdin);\n        freopen(\"PuzzleNOIP2013.out\",\"w\",stdout);\n        scanf(\"%d%d%d\",&n,&m,&Q);\n        for(int i=1;i<=n;++i)\n        for(int t=1;t<=m;++t)\n        scanf(\"%d\",&a[i][t]);\n        init();\n        while(Q--){\n            scanf(\"%d%d%d%d%d%d\",&e1,&e2,&s1,&s2,&t1,&t2);\n            int ans=0,tot=0;\n            printf(\"%d\\n\",spfa(s1,s2,t1,t2,e1,e2));\n            dddd:;\n        }\n    }\n    /*\n    3 4 2\n    0 1 1 1\n    0 1 1 0\n    0 1 0 0\n    3 2 1 2 2 2\n    1 2 2 2 3 2\n    */\n    /*\n\n\n    3 3 1\n    1 1 0\n    1 1 0\n    1 1 0\n    3 1 1 1 3 1\n\n\n    */","content":"<h1 id=\"华容道\"><a href=\"#华容道\" class=\"headerlink\" title=\"华容道\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1442\" target=\"_blank\" rel=\"external\">华容道</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><img src=\"http://cogs.pro/upload/image/20131118/20131118201912_84538.png\" alt=\"\"></p>\n<h3 id=\"输入输出及样例解释\"><a href=\"#输入输出及样例解释\" class=\"headerlink\" title=\"输入输出及样例解释\"></a>输入输出及样例解释</h3><p><img src=\"http://cogs.pro/upload/image/20131118/20131118201920_74338.png\" alt=\"\"><br><img src=\"http://cogs.pro/upload/image/20131118/20131118201931_43656.png\" alt=\"\"></p>\n<h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://cogs.pro/upload/image/20131118/20131118201940_40826.png\" alt=\"\"></h2><h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>在本题中，真正可以自由移动的只有空格子，考虑对于指定格子的移动，必然是将空格格子移动到当前节点与目标节点的路径上，并将其于当前节点互换，重复以上过程直到当前节点与目标节点重合，以上过程用普通的BFS即可模拟。</p>\n<p>但是本题中询问次数过多，实际上存在很多重复计算，可以考虑进行预处理优化。</p>\n<p>由于每次都要将空格子移动到当前节点旁边，所以空格子的路径不能经过当前节点，否则将会导致答案不为最少时间，如果空格子的路径必须经过当前节点，则显然无解。（见样例2）那么可以设$f[x][y][k][h]$表示从$(x,y)$的$k$方向节点在不经过$(x,y)$的情况下移动到$h$方向节点的最小时间，对其进行预处理，然后每次询问通过SPFA求解即可。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;queue&gt;\n#include&lt;cstring&gt;\n#define mp make_pair \nusing namespace std;\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\nconst int N =31+1;\nint n,m,Q,e1,e2,s1,s2,t1,t2;\nint f[N][N][4][4],d[N][N],dis[N][N][5],a[N][N];\nbool vis[N][N],in[N][N][5];\nint fx[4]={-1,1,0,0};\nint fy[4]={0,0,-1,1};\nstruct nd{\n    int x,y,k;\n};\nqueue&lt;nd&gt;q,q1;\n\nint rev(int x){\n    if(x==1)return 0;\n    if(x==0)return 1;\n    if(x==2)return 3;\n    if(x==3)return 2;\n}\n\nint bfs(int x1,int y1,int x2,int y2){\n    if(!a[x1][y1]||!a[x2][y2])return inf;\n    memset(vis,0,sizeof(vis));\n    memset(d,0x3f,sizeof(d));\n    nd p;\n    d[x1][y1]=0;\n    vis[x1][y1]=1;\n    while(!q1.empty())q1.pop();\n    q1.push((nd){x1,y1,0});\n    while(!q1.empty()&amp;&amp;!vis[x2][y2]){\n        p=q1.front();q1.pop();\n        for(int i=0;i&lt;4;++i){\n            int x=p.x+fx[i],y=p.y+fy[i];\n            if(!vis[x][y]&amp;&amp;a[x][y]){\n                vis[x][y]=1;\n                d[x][y]=d[p.x][p.y]+1;\n                q1.push((nd){x,y,0});\n            }\n        }\n    }\n    return d[x2][y2];\n}\n\nvoid init(){\n    memset(f,0x3f,sizeof(f));\n    for(int i=1;i&lt;=n;++i)\n    for(int t=1;t&lt;=m;++t)\n    if(a[i][t]){\n        a[i][t]=0;\n        for(int k=0;k&lt;4;++k)\n        for(int h=0;h&lt;4;++h){\n            if(h&lt;k){f[i][t][k][h]=f[i][t][h][k];continue;}\n            int x=i+fx[k],y=t+fy[k];\n            int x11=i+fx[h],y11=t+fy[h];\n            if(!a[x][y]||!a[x11][y11])continue;\n            f[i][t][k][h]=bfs(x,y,x11,y11)+1;\n//            cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;&quot; &quot;&lt;&lt;f[i][t][k][h]&lt;&lt;endl;\n        }\n        a[i][t]=1;\n    }\n}\n\nint spfa(int x1,int y1,int x2,int y2,int e1,int e2){\n    if(x1==x2&amp;&amp;y1==y2)return 0;\n    if(!a[x1][y1]||!a[x2][y2])return -1;\n    memset(dis,0x3f,sizeof(dis));\n    memset(in,0,sizeof(in));\n    while(!q.empty())q.pop();\n    a[x1][y1]=0;\n    for(int k=0;k&lt;4;++k){\n        q.push((nd){x1,y1,k});\n        in[x1][y1][k]=1;\n        dis[x1][y1][k]=bfs(e1,e2,x1+fx[k],y1+fy[k]);\n    }\n    a[x1][y1]=1;\n    nd x,y;\n    while(!q.empty()){\n        x=q.front();q.pop();\n        in[x.x][x.y][x.k]=0;\n        for(int h=0;h&lt;4;++h){\n            y.x=x.x+fx[h],y.y=x.y+fy[h];\n            y.k=rev(h);\n            if(dis[y.x][y.y][y.k]&gt;dis[x.x][x.y][x.k]+f[x.x][x.y][x.k][h]){\n                dis[y.x][y.y][y.k]=dis[x.x][x.y][x.k]+f[x.x][x.y][x.k][h];\n                if(!in[y.x][y.y][y.k])in[y.x][y.y][y.k]=1,q.push(y);\n            }\n        }\n    }\n    int ret=inf;\n    for(int i=0;i&lt;4;++i)ret=min(ret,dis[x2][y2][i]);\n    return ret&lt;inf?ret:-1;\n}\nint main(){\n    freopen(&quot;PuzzleNOIP2013.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;PuzzleNOIP2013.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);\n    for(int i=1;i&lt;=n;++i)\n    for(int t=1;t&lt;=m;++t)\n    scanf(&quot;%d&quot;,&amp;a[i][t]);\n    init();\n    while(Q--){\n        scanf(&quot;%d%d%d%d%d%d&quot;,&amp;e1,&amp;e2,&amp;s1,&amp;s2,&amp;t1,&amp;t2);\n        int ans=0,tot=0;\n        printf(&quot;%d\\n&quot;,spfa(s1,s2,t1,t2,e1,e2));\n        dddd:;\n    }\n}\n/*\n3 4 2\n0 1 1 1\n0 1 1 0\n0 1 0 0\n3 2 1 2 2 2\n1 2 2 2 3 2\n*/\n/*\n\n\n3 3 1\n1 1 0\n1 1 0\n1 1 0\n3 1 1 1 3 1\n\n\n*/\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/09/21/NOIP2013华容道/","excerpt":"","categories":[{"name":"BFS","slug":"BFS","permalink":"https://prostkhala.github.io/categories/BFS/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://prostkhala.github.io/tags/BFS/"}]},{"title":"Codeforces852I Dating","date":"2017-09-13T13:21:25.000Z","path":"2017/09/13/Codeforces852I/","text":"Dating 题目描述This story is happening in a town named BubbleLand. There are n houses in BubbleLand. In each of these n houses lives a boy or a girl. People there really love numbers and everyone has their favorite number $f$. That means that the boy or girl that lives in the $i-th$ house has favorite number equal to $f_i$. The houses are numerated with numbers $1$ to $n$. The houses are connected with $n - 1$ bidirectional roads and you can travel from any house to any other house in the town. There is exactly one path between every pair of houses. A new dating had agency opened their offices in this mysterious town and the citizens were very excited. They immediately sent $q$ questions to the agency and each question was of the following format: $a b$ — asking how many ways are there to choose a couple (boy and girl) that have the same favorite number and live in one of the houses on the unique path from house $a to house b$. Help the dating agency to answer the questions and grow their business. 输入输出样例输入样例：7 1 0 0 1 0 1 0 9 2 9 2 2 9 9 2 6 1 2 4 2 6 5 3 6 7 4 2 1 3 7 5 输出样例： 2 3 题解树上莫队裸题，题目大意为给$q$次询问，询问两点之间的链中权值相同的男生个数与女生个数的乘积，并对所有权值求和。 对于序列中的莫队算法来说，需要对于先对于左区间所在的块为第一关键字，右区间为第二关键字进行查询，树上莫队也不例外。 首先应该用DFS序表示该树。对于子树的查询，在DFS序中为连续的一段，其求解与序列中的莫队相同，而对于链的查询，其在序列中不为连续的一段，所以需要特殊的处理： LCA为两端点中的任意一个，则应插入$[st[a],st[b]]$区间，容易发现除了链上的点被计算了一遍，其他点都被计算了0遍或2遍，可以将偶数次的插入视为删除即可。 LCA不为两节点中的任意一个，此处应插入$[ed[a],st[b]]$区间，计算方法与上文相同，但需要注意此时利用的是DFS序而不是欧拉序，LCA实际上没有参与运算，加上即可，单个不在区间中节点的插入对时间复杂度没有影响。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e5+1; const int MXB =19; int head[N],cnt,n,Q,id[N],f1[N],f2[N],d[N],f[N][MXB],st[N],ed[N],dfx[N*2],totw,block; int tong[2][N]; ll ans[N]; bool inq[N]; //int th[N]; struct nd{int ne,to;}e[N*2]; struct questions{int id,m,l,r,b;}q[N*2]; bool cmp(questions a,questions b) { if(a.b!=b.b)return a.b&lt;b.b; return a.r&gt;b.r; } void in(int x,int y){e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;} void dfs(int x,int fa) { st[x]=++totw;dfx[totw]=x; for(int i=head[x];i;i=e[i].ne) if(e[i].to!=fa) { int y=e[i].to; d[y]=d[x]+1; f[y][0]=x; dfs(y,x); } ed[x]=++totw;dfx[totw]=x; } int lca(int x,int y) { if(d[x]&lt;d[y])swap(x,y); for(int i=MXB-1;i&gt;=0;--i) if(d[f[x][i]]&gt;=d[y])x=f[x][i]; if(x==y)return x; for(int i=MXB-1;i&gt;=0;--i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; } void Pre() { d[1]=1;dfs(1,-1); for(int i=1;i&lt;MXB;++i) for(int t=1;t&lt;=n;++t) f[t][i]=f[f[t][i-1]][i-1]; } ll ret=0; void insert(int x) { inq[x]^=1; if(inq[x]) { tong[id[x]][f1[x]]++; ret+=tong[id[x]^1][f1[x]]; // th[x]++; } else { tong[id[x]][f1[x]]--; ret-=tong[id[x]^1][f1[x]]; // th[x]--; } } int main() { // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;,&amp;n); block=sqrt(n)+1; for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,id+i); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,f1+i),f2[i]=f1[i]; sort(f2+1,f2+n+1); int nn=unique(f2+1,f2+n+1)-f2-1; for(int i=1;i&lt;=n;++i)f1[i]=lower_bound(f2+1,f2+nn+1,f1[i])-f2; // for(int i=1;i&lt;=n;++i)cout&lt;&lt;id[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; // for(int i=1;i&lt;=n;++i)cout&lt;&lt;f1[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; for(int i=1,x,y;i&lt;n;++i)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x); Pre(); scanf(&quot;%d&quot;,&amp;Q); for(int i=1,a,b;i&lt;=Q;++i) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); q[i].id=i; int p=lca(a,b); if(st[a]&gt;st[b])swap(a,b); if(p==a)q[i].l=st[a],q[i].r=st[b],q[i].m=0; else q[i].l=ed[a],q[i].r=st[b],q[i].m=p; q[i].b=q[i].l/block+1; } int L=1,R=0; sort(q+1,q+Q+1,cmp); for(int i=1;i&lt;=Q;++i) { int l=q[i].l,r=q[i].r; while(L&lt;l)insert(dfx[L]),L++; while(L&gt;l)L--,insert(dfx[L]); while(R&gt;r)insert(dfx[R]),R--; while(R&lt;r)R++,insert(dfx[R]); if(q[i].m)insert(q[i].m); // for(int t=1;t&lt;=n;++t)cout&lt;&lt;th[t]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; ans[q[i].id]=ret; if(q[i].m)insert(q[i].m); // cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; } for(int i=1;i&lt;=Q;++i)printf(&quot;%I64d\\n&quot;,ans[i]); }","raw":"title: Codeforces852I Dating\ndate: 2017-09-13 21:21:25\ncategories:\n  - Codeforces&AtCoder\ntags:\n  - 莫队算法\n---\n\n\n# [Dating](http://codeforces.com/contest/852/problem/I)\n---\n## 题目描述\nThis story is happening in a town named BubbleLand. There are n houses in BubbleLand. In each of these n houses lives a boy or a girl. People there really love numbers and everyone has their favorite number $f$. That means that the boy or girl that lives in the $i-th$ house has favorite number equal to $f_i$.\n\nThe houses are numerated with numbers $1$ to $n$.\n\nThe houses are connected with $n - 1$ bidirectional roads and you can travel from any house to any other house in the town. There is exactly one path between every pair of houses.\n\nA new dating had agency opened their offices in this mysterious town and the citizens were very excited. They immediately sent $q$ questions to the agency and each question was of the following format:\n\n - $a b$ — asking how many ways are there to choose a couple (boy and girl) that have the same favorite number and live in one of the houses on the unique path from house $a to house b$. \n\nHelp the dating agency to answer the questions and grow their business.\n### 输入输出样例\n#### 输入样例：\n    7\n    1 0 0 1 0 1 0\n    9 2 9 2 2 9 9\n    2 6\n    1 2\n    4 2\n    6 5\n    3 6\n    7 4\n    2\n    1 3\n    7 5\n#### 输出样例：\n---\n    2\n    3\n## 题解\n树上莫队裸题，题目大意为给$q$次询问，询问两点之间的链中权值相同的男生个数与女生个数的乘积，并对所有权值求和。\n\n对于序列中的莫队算法来说，需要对于先对于左区间所在的块为第一关键字，右区间为第二关键字进行查询，树上莫队也不例外。\n\n首先应该用DFS序表示该树。对于子树的查询，在DFS序中为连续的一段，其求解与序列中的莫队相同，而对于链的查询，其在序列中不为连续的一段，所以需要特殊的处理：\n\n- LCA为两端点中的任意一个，则应插入$[st[a],st[b]]$区间，容易发现除了链上的点被计算了一遍，其他点都被计算了0遍或2遍，可以将偶数次的插入视为删除即可。\n- LCA不为两节点中的任意一个，此处应插入$[ed[a],st[b]]$区间，计算方法与上文相同，但需要注意此时利用的是DFS序而不是欧拉序，LCA实际上没有参与运算，加上即可，单个不在区间中节点的插入对时间复杂度没有影响。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e5+1;\n    const int MXB =19;\n    int head[N],cnt,n,Q,id[N],f1[N],f2[N],d[N],f[N][MXB],st[N],ed[N],dfx[N*2],totw,block;\n    int tong[2][N];\n    ll ans[N];\n    bool inq[N];\n    //int th[N];\n    struct nd{int ne,to;}e[N*2];\n    struct questions{int id,m,l,r,b;}q[N*2];\n\n    bool cmp(questions a,questions b)\n    {\n        if(a.b!=b.b)return a.b<b.b;\n        return a.r>b.r;\n    }\n\n    void in(int x,int y){e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;}\n\n    void dfs(int x,int fa)\n    {\n        st[x]=++totw;dfx[totw]=x;\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=fa)\n        {\n            int y=e[i].to;\n            d[y]=d[x]+1;\n            f[y][0]=x;\n            dfs(y,x);\n        }\n        ed[x]=++totw;dfx[totw]=x;\n    }\n\n    int lca(int x,int y)\n    {\n        if(d[x]<d[y])swap(x,y);\n        for(int i=MXB-1;i>=0;--i)\n        if(d[f[x][i]]>=d[y])x=f[x][i];\n        if(x==y)return x;\n        for(int i=MXB-1;i>=0;--i)\n        if(f[x][i]!=f[y][i])\n        x=f[x][i],y=f[y][i];\n        return f[x][0];\n    }\n\n    void Pre()\n    {\n        d[1]=1;dfs(1,-1);\n        for(int i=1;i<MXB;++i)\n        for(int t=1;t<=n;++t)\n        f[t][i]=f[f[t][i-1]][i-1];\n    }\n    ll ret=0;\n    void insert(int x)\n    {\n        inq[x]^=1;\n        if(inq[x])\n        {\n            tong[id[x]][f1[x]]++;\n            ret+=tong[id[x]^1][f1[x]];\n    //\t\tth[x]++;\n        }\n        else\n        {\n            tong[id[x]][f1[x]]--;\n            ret-=tong[id[x]^1][f1[x]];\n    //\t\tth[x]--;\n        }\n    }\n\n\n    int main()\n    {\n    //\tfreopen(\"1.txt\",\"r\",stdin);\n        scanf(\"%d\",&n);\n        block=sqrt(n)+1;\n        for(int i=1;i<=n;++i)scanf(\"%d\",id+i);\n        for(int i=1;i<=n;++i)scanf(\"%d\",f1+i),f2[i]=f1[i];\n        sort(f2+1,f2+n+1);\n        int nn=unique(f2+1,f2+n+1)-f2-1;\n        for(int i=1;i<=n;++i)f1[i]=lower_bound(f2+1,f2+nn+1,f1[i])-f2;\n    //\tfor(int i=1;i<=n;++i)cout<<id[i]<<\" \";cout<<endl;\n    //\tfor(int i=1;i<=n;++i)cout<<f1[i]<<\" \";cout<<endl;\n        for(int i=1,x,y;i<n;++i)scanf(\"%d%d\",&x,&y),in(x,y),in(y,x);\n        Pre();\n        scanf(\"%d\",&Q);\n        for(int i=1,a,b;i<=Q;++i)\n        {\n            scanf(\"%d%d\",&a,&b);\n            q[i].id=i;\n            int p=lca(a,b);\n            if(st[a]>st[b])swap(a,b);\n            if(p==a)q[i].l=st[a],q[i].r=st[b],q[i].m=0;\n            else\tq[i].l=ed[a],q[i].r=st[b],q[i].m=p;\n            q[i].b=q[i].l/block+1;\n        }\n        int L=1,R=0;\n        sort(q+1,q+Q+1,cmp);\n        for(int i=1;i<=Q;++i)\n        {\n            int l=q[i].l,r=q[i].r;\n            while(L<l)insert(dfx[L]),L++;\n            while(L>l)L--,insert(dfx[L]);\n            while(R>r)insert(dfx[R]),R--;\n            while(R<r)R++,insert(dfx[R]);\n            if(q[i].m)insert(q[i].m);\n    //\t\tfor(int t=1;t<=n;++t)cout<<th[t]<<\" \";cout<<endl;\n            ans[q[i].id]=ret;\n            if(q[i].m)insert(q[i].m);\n    //\t\tcout<<endl<<endl<<endl;\n        }\n        for(int i=1;i<=Q;++i)printf(\"%I64d\\n\",ans[i]);\n    }","content":"<h1 id=\"Dating\"><a href=\"#Dating\" class=\"headerlink\" title=\"Dating\"></a><a href=\"http://codeforces.com/contest/852/problem/I\" target=\"_blank\" rel=\"external\">Dating</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>This story is happening in a town named BubbleLand. There are n houses in BubbleLand. In each of these n houses lives a boy or a girl. People there really love numbers and everyone has their favorite number $f$. That means that the boy or girl that lives in the $i-th$ house has favorite number equal to $f_i$.</p>\n<p>The houses are numerated with numbers $1$ to $n$.</p>\n<p>The houses are connected with $n - 1$ bidirectional roads and you can travel from any house to any other house in the town. There is exactly one path between every pair of houses.</p>\n<p>A new dating had agency opened their offices in this mysterious town and the citizens were very excited. They immediately sent $q$ questions to the agency and each question was of the following format:</p>\n<ul>\n<li>$a b$ — asking how many ways are there to choose a couple (boy and girl) that have the same favorite number and live in one of the houses on the unique path from house $a to house b$. </li>\n</ul>\n<p>Help the dating agency to answer the questions and grow their business.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>7\n1 0 0 1 0 1 0\n9 2 9 2 2 9 9\n2 6\n1 2\n4 2\n6 5\n3 6\n7 4\n2\n1 3\n7 5\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><hr>\n<pre><code>2\n3\n</code></pre><h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>树上莫队裸题，题目大意为给$q$次询问，询问两点之间的链中权值相同的男生个数与女生个数的乘积，并对所有权值求和。</p>\n<p>对于序列中的莫队算法来说，需要对于先对于左区间所在的块为第一关键字，右区间为第二关键字进行查询，树上莫队也不例外。</p>\n<p>首先应该用DFS序表示该树。对于子树的查询，在DFS序中为连续的一段，其求解与序列中的莫队相同，而对于链的查询，其在序列中不为连续的一段，所以需要特殊的处理：</p>\n<ul>\n<li>LCA为两端点中的任意一个，则应插入$[st[a],st[b]]$区间，容易发现除了链上的点被计算了一遍，其他点都被计算了0遍或2遍，可以将偶数次的插入视为删除即可。</li>\n<li>LCA不为两节点中的任意一个，此处应插入$[ed[a],st[b]]$区间，计算方法与上文相同，但需要注意此时利用的是DFS序而不是欧拉序，LCA实际上没有参与运算，加上即可，单个不在区间中节点的插入对时间复杂度没有影响。</li>\n</ul>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+1;\nconst int MXB =19;\nint head[N],cnt,n,Q,id[N],f1[N],f2[N],d[N],f[N][MXB],st[N],ed[N],dfx[N*2],totw,block;\nint tong[2][N];\nll ans[N];\nbool inq[N];\n//int th[N];\nstruct nd{int ne,to;}e[N*2];\nstruct questions{int id,m,l,r,b;}q[N*2];\n\nbool cmp(questions a,questions b)\n{\n    if(a.b!=b.b)return a.b&lt;b.b;\n    return a.r&gt;b.r;\n}\n\nvoid in(int x,int y){e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;}\n\nvoid dfs(int x,int fa)\n{\n    st[x]=++totw;dfx[totw]=x;\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=fa)\n    {\n        int y=e[i].to;\n        d[y]=d[x]+1;\n        f[y][0]=x;\n        dfs(y,x);\n    }\n    ed[x]=++totw;dfx[totw]=x;\n}\n\nint lca(int x,int y)\n{\n    if(d[x]&lt;d[y])swap(x,y);\n    for(int i=MXB-1;i&gt;=0;--i)\n    if(d[f[x][i]]&gt;=d[y])x=f[x][i];\n    if(x==y)return x;\n    for(int i=MXB-1;i&gt;=0;--i)\n    if(f[x][i]!=f[y][i])\n    x=f[x][i],y=f[y][i];\n    return f[x][0];\n}\n\nvoid Pre()\n{\n    d[1]=1;dfs(1,-1);\n    for(int i=1;i&lt;MXB;++i)\n    for(int t=1;t&lt;=n;++t)\n    f[t][i]=f[f[t][i-1]][i-1];\n}\nll ret=0;\nvoid insert(int x)\n{\n    inq[x]^=1;\n    if(inq[x])\n    {\n        tong[id[x]][f1[x]]++;\n        ret+=tong[id[x]^1][f1[x]];\n//        th[x]++;\n    }\n    else\n    {\n        tong[id[x]][f1[x]]--;\n        ret-=tong[id[x]^1][f1[x]];\n//        th[x]--;\n    }\n}\n\n\nint main()\n{\n//    freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);\n    scanf(&quot;%d&quot;,&amp;n);\n    block=sqrt(n)+1;\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,id+i);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,f1+i),f2[i]=f1[i];\n    sort(f2+1,f2+n+1);\n    int nn=unique(f2+1,f2+n+1)-f2-1;\n    for(int i=1;i&lt;=n;++i)f1[i]=lower_bound(f2+1,f2+nn+1,f1[i])-f2;\n//    for(int i=1;i&lt;=n;++i)cout&lt;&lt;id[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;\n//    for(int i=1;i&lt;=n;++i)cout&lt;&lt;f1[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;\n    for(int i=1,x,y;i&lt;n;++i)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x);\n    Pre();\n    scanf(&quot;%d&quot;,&amp;Q);\n    for(int i=1,a,b;i&lt;=Q;++i)\n    {\n        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);\n        q[i].id=i;\n        int p=lca(a,b);\n        if(st[a]&gt;st[b])swap(a,b);\n        if(p==a)q[i].l=st[a],q[i].r=st[b],q[i].m=0;\n        else    q[i].l=ed[a],q[i].r=st[b],q[i].m=p;\n        q[i].b=q[i].l/block+1;\n    }\n    int L=1,R=0;\n    sort(q+1,q+Q+1,cmp);\n    for(int i=1;i&lt;=Q;++i)\n    {\n        int l=q[i].l,r=q[i].r;\n        while(L&lt;l)insert(dfx[L]),L++;\n        while(L&gt;l)L--,insert(dfx[L]);\n        while(R&gt;r)insert(dfx[R]),R--;\n        while(R&lt;r)R++,insert(dfx[R]);\n        if(q[i].m)insert(q[i].m);\n//        for(int t=1;t&lt;=n;++t)cout&lt;&lt;th[t]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;\n        ans[q[i].id]=ret;\n        if(q[i].m)insert(q[i].m);\n//        cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;\n    }\n    for(int i=1;i&lt;=Q;++i)printf(&quot;%I64d\\n&quot;,ans[i]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/09/13/Codeforces852I/","excerpt":"","categories":[{"name":"Codeforces&AtCoder","slug":"Codeforces-AtCoder","permalink":"https://prostkhala.github.io/categories/Codeforces-AtCoder/"}],"tags":[{"name":"莫队算法","slug":"莫队算法","permalink":"https://prostkhala.github.io/tags/莫队算法/"}]},{"title":"Codeforces856D Masha and Cactus","date":"2017-09-13T12:40:33.000Z","path":"2017/09/13/Codeforces856D/","text":"Masha and Cactus 题目描述Masha is fond of cacti. When she was a little girl, she decided to plant a tree. Now Masha wants to make a nice cactus out of her tree. Recall that tree is a connected undirected graph that has no cycles. Cactus is a connected undirected graph such that each vertex belongs to at most one cycle. Masha has some additional edges that she can add to a tree. For each edge she knows which vertices it would connect and the beauty of this edge. Masha can add some of these edges to the graph if the resulting graph is a cactus. Beauty of the resulting cactus is sum of beauties of all added edges. Help Masha find out what maximum beauty of the resulting cactus she can achieve. 输入输出格式输入格式:The first line of the input data contains two integers n and m — the number of vertices in a tree, and the number of additional edges available $(3 ≤ n ≤ 2·105; 0 ≤ m ≤ 2·10^5)$. Let us describe Masha’s tree. It has a root at vertex 1. The second line contains n - 1 integers: $p_2, p_3, …, p_n$, here $p_i$ — is the parent of a vertex i — the first vertex on a path from the vertex i to the root of the tree $(1 ≤ p_i &lt; i)$. The following m lines contain three integers ui, vi and ci — pairs of vertices to be connected by the additional edges that Masha can add to the tree and beauty of edge $(1 ≤ ui, vi ≤ n; ui ≠ vi; 1 ≤ ci ≤ 10^4)$. It is guaranteed that no additional edge coincides with the edge of the tree. 输出格式：Output one integer — the maximum beauty of a cactus Masha can achieve. 输入输出样例输入样例：7 3 1 1 2 2 3 3 4 5 1 6 7 1 2 3 1 输出样例：2 题解题目大意为有$n$个点，$m$条带权链，每个点只能被链覆盖一次，问可行覆盖方案的最大权值和。 该题动态规划方程较容易设计，可以设$f_x$为以$x$为根的子树所能达到的最大权值和，如果没有链以该点为LCA，那么$f_x=\\sum f_{son}$，否则$f_x= \\sum f_{不在链中且父亲节点在链中的子节点}+w$,但是对于第二种情况如果直接暴力找子节点，显然时间复杂度为$O(nq)$，不在可接受范围之内。 我们可以利用该种子节点的性质来为每个节点赋值，使得$ \\sum f_{不在链中且父亲节点在链中的子节点}$=$w_{x-&gt;y}$和，从而通过树链剖分来实现$O(logn)$查询。考虑对于每一个已经求出的$f_x$，不妨将$w_{fa_x}+=f_x$，$w_x-=f_x$即可满足条件，理由如下： 对于父亲和自己均在链中的节点，则其贡献被计算了两次，一次为正，一次为负，即为没有贡献。 对于父亲和自己均不在链中的节点，则其没有贡献。 对于父亲在链中而自己不在链中的节点，其贡献只被计算了一次正值。 对于自己的链中而父亲不在链中的节点，显然只有当前节点（即询问节点的LCA），其$w$尚没有赋值。 CODE#include&lt;bits/stdc++.h&gt; #define lb(x) x&amp;(-x) using namespace std; typedef long long ll; const int N = 1e6+1; int n,m,fa[N],st[N],ed[N],top[N],d[N],sz[N],son[N],totw; int a[N],f[N],g[N],X[N],Y[N],W[N]; struct nd { int ne[N*2],to[N*2]; int head[N],cnt; void in(int x,int y){to[++cnt]=y;ne[cnt]=head[x];head[x]=cnt;} void init(){memset(head,0,sizeof(head));cnt=0;} }e,e1; void dfs1(int x) { sz[x]=1; for(int i=e.head[x];i;i=e.ne[i]) { int y=e.to[i]; d[y]=d[x]+1; dfs1(y); sz[x]+=sz[y]; if(sz[son[x]]&lt;sz[y])son[x]=y; } } void dfs2(int x) { st[x]=++totw; int y=son[x];if(!y)return; top[y]=top[x];dfs2(y); for(int i=e.head[x];i;i=e.ne[i]) { y=e.to[i]; if(y==son[x])continue; top[y]=y; dfs2(y); } ed[x]=totw; } void insert(int x,int d) { for(int i=x;i&lt;=n;i+=lb(i))a[i]+=d; } int sum(int x,int y) { if(!x||!y)return 0; int ret=0; for(int i=y;i;i-=lb(i))ret+=a[i]; for(int i=x-1;i;i-=lb(i))ret-=a[i]; return ret; } int lca(int x,int y) { while(top[x]!=top[y]) { if(d[top[x]]&lt;d[top[y]])swap(x,y); x=fa[top[x]]; } if(d[x]&lt;d[y])return x; return y; } int query(int x,int y) { int ret=0; while(top[x]!=top[y]) { if(d[top[x]]&lt;d[top[y]])swap(x,y); ret+=sum(st[top[x]],st[x]); x=fa[top[x]]; } if(st[x]&gt;st[y])swap(x,y); ret+=sum(st[x],st[y]); return ret; } int dp(int x) { for(int i=e.head[x];i;i=e.ne[i]) dp(e.to[i]),g[x]+=f[e.to[i]]; f[x]=g[x]; for(int i=e1.head[x];i;i=e1.ne[i]) { int to=e1.to[i]; f[x]=max(f[x],query(X[to],Y[to])+W[to]); } insert(st[x],-f[x]); if(fa[x])insert(st[fa[x]],f[x]); } int main() { // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;c.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=2;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;fa[i]),e.in(fa[i],i); top[1]=1;dfs1(1);dfs2(1); for(int i=1;i&lt;=m;++i) { scanf(&quot;%d%d%d&quot;,&amp;X[i],&amp;Y[i],&amp;W[i]); e1.in(lca(X[i],Y[i]),i); } dp(1); cout&lt;&lt;f[1]; }","raw":"title: Codeforces856D Masha and Cactus\ndate: 2017-09-13 20:40:33\ncategories:\n  - Codeforces&AtCoder\ntags:\n  - 动态规划\n  - 树链剖分\n---\n\n# [Masha and Cactus](Masha and Cactus)\n---\n## 题目描述\nMasha is fond of cacti. When she was a little girl, she decided to plant a tree. Now Masha wants to make a nice cactus out of her tree.\n\nRecall that tree is a connected undirected graph that has no cycles. Cactus is a connected undirected graph such that each vertex belongs to at most one cycle.\n\nMasha has some additional edges that she can add to a tree. For each edge she knows which vertices it would connect and the beauty of this edge. Masha can add some of these edges to the graph if the resulting graph is a cactus. Beauty of the resulting cactus is sum of beauties of all added edges.\n\nHelp Masha find out what maximum beauty of the resulting cactus she can achieve.\n### 输入输出格式\n#### 输入格式:\nThe first line of the input data contains two integers n and m — the number of vertices in a tree, and the number of additional edges available $(3 ≤ n ≤ 2·105; 0 ≤ m ≤ 2·10^5)$.\n\nLet us describe Masha's tree. It has a root at vertex 1. The second line contains n - 1 integers: $p_2, p_3, ..., p_n$, here $p_i$ — is the parent of a vertex i — the first vertex on a path from the vertex i to the root of the tree $(1 ≤ p_i < i)$.\n\nThe following m lines contain three integers ui, vi and ci — pairs of vertices to be connected by the additional edges that Masha can add to the tree and beauty of edge $(1 ≤ ui, vi ≤ n; ui ≠ vi; 1 ≤ ci ≤ 10^4)$.\n\nIt is guaranteed that no additional edge coincides with the edge of the tree.\n#### 输出格式：\nOutput one integer — the maximum beauty of a cactus Masha can achieve.\n### 输入输出样例\n#### 输入样例：\n    7 3\n    1 1 2 2 3 3\n    4 5 1\n    6 7 1\n    2 3 1\n#### 输出样例：\n\t2\n\n---\n\n## 题解\n题目大意为有$n$个点，$m$条带权链，每个点只能被链覆盖一次，问可行覆盖方案的最大权值和。\n\n该题动态规划方程较容易设计，可以设$f_x$为以$x$为根的子树所能达到的最大权值和，如果没有链以该点为LCA，那么$f_x=\\sum f_{son}$，否则$f_x= \\sum f_{不在链中且父亲节点在链中的子节点}+w$,但是对于第二种情况如果直接暴力找子节点，显然时间复杂度为$O(nq)$，不在可接受范围之内。\n\n我们可以利用该种子节点的性质来为每个节点赋值，使得$ \\sum f_{不在链中且父亲节点在链中的子节点}$=$w_{x->y}$和，从而通过树链剖分来实现$O(logn)$查询。考虑对于每一个已经求出的$f_x$，不妨将$w_{fa_x}+=f_x$，$w_x-=f_x$即可满足条件，理由如下：\n\n- 对于父亲和自己均在链中的节点，则其贡献被计算了两次，一次为正，一次为负，即为没有贡献。\n- 对于父亲和自己均不在链中的节点，则其没有贡献。\n- 对于父亲在链中而自己不在链中的节点，其贡献只被计算了一次正值。\n- 对于自己的链中而父亲不在链中的节点，显然只有当前节点（即询问节点的LCA），其$w$尚没有赋值。\n\n---\n### CODE\n\n    #include<bits/stdc++.h>\n    #define lb(x) x&(-x)\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e6+1;\n\n    int n,m,fa[N],st[N],ed[N],top[N],d[N],sz[N],son[N],totw;\n    int a[N],f[N],g[N],X[N],Y[N],W[N];\n\n    struct nd\n    {\n        int ne[N*2],to[N*2];\n        int head[N],cnt;\n        void in(int x,int y){to[++cnt]=y;ne[cnt]=head[x];head[x]=cnt;}\n        void init(){memset(head,0,sizeof(head));cnt=0;}\n    }e,e1;\n\n    void dfs1(int x)\n    {\n        sz[x]=1;\n        for(int i=e.head[x];i;i=e.ne[i])\n        {\n            int y=e.to[i];\n            d[y]=d[x]+1;\n            dfs1(y);\n\n            sz[x]+=sz[y];\n            if(sz[son[x]]<sz[y])son[x]=y;\n        }\n    }\n\n    void dfs2(int x)\n    {\n        st[x]=++totw;\n        int y=son[x];if(!y)return;\n        top[y]=top[x];dfs2(y);\n        for(int i=e.head[x];i;i=e.ne[i])\n        {\n            y=e.to[i];\n            if(y==son[x])continue;\n            top[y]=y;\n            dfs2(y);\n        }\n        ed[x]=totw;\n    }\n\n    void insert(int x,int d)\n    {\n        for(int i=x;i<=n;i+=lb(i))a[i]+=d;\n    }\n\n    int sum(int x,int y)\n    {\n        if(!x||!y)return 0;\n        int ret=0;\n        for(int i=y;i;i-=lb(i))ret+=a[i];\n        for(int i=x-1;i;i-=lb(i))ret-=a[i];\n        return ret;\n    }\n\n    int lca(int x,int y)\n    {\n        while(top[x]!=top[y])\n        {\n            if(d[top[x]]<d[top[y]])swap(x,y);\n            x=fa[top[x]];\t\n        }\n        if(d[x]<d[y])return x;\n        return y;\n    }\n\n    int query(int x,int y)\n    {\n        int ret=0;\n        while(top[x]!=top[y])\n        {\n            if(d[top[x]]<d[top[y]])swap(x,y);\n            ret+=sum(st[top[x]],st[x]);\n            x=fa[top[x]];\n        }\n        if(st[x]>st[y])swap(x,y);\n        ret+=sum(st[x],st[y]);\n        return ret;\n    }\n\n    int dp(int x)\n    {\n        for(int i=e.head[x];i;i=e.ne[i])\n        dp(e.to[i]),g[x]+=f[e.to[i]];\n        f[x]=g[x];\n        for(int i=e1.head[x];i;i=e1.ne[i])\n        {\n            int to=e1.to[i];\n            f[x]=max(f[x],query(X[to],Y[to])+W[to]);\n        }\n        insert(st[x],-f[x]);\n        if(fa[x])insert(st[fa[x]],f[x]);\n    }\n\n    int main()\n    {\n    // \tfreopen(\"c.in\",\"r\",stdin);\n    //\tfreopen(\"c.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        for(int i=2;i<=n;++i)scanf(\"%d\",&fa[i]),e.in(fa[i],i);\n        top[1]=1;dfs1(1);dfs2(1);\n        for(int i=1;i<=m;++i)\n        {\n            scanf(\"%d%d%d\",&X[i],&Y[i],&W[i]);\n            e1.in(lca(X[i],Y[i]),i);\n        }\n        dp(1);\n        cout<<f[1];\n    }\n\n","content":"<h1 id=\"Masha-and-Cactus\"><a href=\"#Masha-and-Cactus\" class=\"headerlink\" title=\"Masha and Cactus\"></a><a href=\"Masha and Cactus\">Masha and Cactus</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Masha is fond of cacti. When she was a little girl, she decided to plant a tree. Now Masha wants to make a nice cactus out of her tree.</p>\n<p>Recall that tree is a connected undirected graph that has no cycles. Cactus is a connected undirected graph such that each vertex belongs to at most one cycle.</p>\n<p>Masha has some additional edges that she can add to a tree. For each edge she knows which vertices it would connect and the beauty of this edge. Masha can add some of these edges to the graph if the resulting graph is a cactus. Beauty of the resulting cactus is sum of beauties of all added edges.</p>\n<p>Help Masha find out what maximum beauty of the resulting cactus she can achieve.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>The first line of the input data contains two integers n and m — the number of vertices in a tree, and the number of additional edges available $(3 ≤ n ≤ 2·105; 0 ≤ m ≤ 2·10^5)$.</p>\n<p>Let us describe Masha’s tree. It has a root at vertex 1. The second line contains n - 1 integers: $p_2, p_3, …, p_n$, here $p_i$ — is the parent of a vertex i — the first vertex on a path from the vertex i to the root of the tree $(1 ≤ p_i &lt; i)$.</p>\n<p>The following m lines contain three integers ui, vi and ci — pairs of vertices to be connected by the additional edges that Masha can add to the tree and beauty of edge $(1 ≤ ui, vi ≤ n; ui ≠ vi; 1 ≤ ci ≤ 10^4)$.</p>\n<p>It is guaranteed that no additional edge coincides with the edge of the tree.</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>Output one integer — the maximum beauty of a cactus Masha can achieve.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>7 3\n1 1 2 2 3 3\n4 5 1\n6 7 1\n2 3 1\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>2\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意为有$n$个点，$m$条带权链，每个点只能被链覆盖一次，问可行覆盖方案的最大权值和。</p>\n<p>该题动态规划方程较容易设计，可以设$f_x$为以$x$为根的子树所能达到的最大权值和，如果没有链以该点为LCA，那么$f_x=\\sum f_{son}$，否则$f_x= \\sum f_{不在链中且父亲节点在链中的子节点}+w$,但是对于第二种情况如果直接暴力找子节点，显然时间复杂度为$O(nq)$，不在可接受范围之内。</p>\n<p>我们可以利用该种子节点的性质来为每个节点赋值，使得$ \\sum f_{不在链中且父亲节点在链中的子节点}$=$w_{x-&gt;y}$和，从而通过树链剖分来实现$O(logn)$查询。考虑对于每一个已经求出的$f_x$，不妨将$w_{fa_x}+=f_x$，$w_x-=f_x$即可满足条件，理由如下：</p>\n<ul>\n<li>对于父亲和自己均在链中的节点，则其贡献被计算了两次，一次为正，一次为负，即为没有贡献。</li>\n<li>对于父亲和自己均不在链中的节点，则其没有贡献。</li>\n<li>对于父亲在链中而自己不在链中的节点，其贡献只被计算了一次正值。</li>\n<li>对于自己的链中而父亲不在链中的节点，显然只有当前节点（即询问节点的LCA），其$w$尚没有赋值。</li>\n</ul>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\n#define lb(x) x&amp;(-x)\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6+1;\n\nint n,m,fa[N],st[N],ed[N],top[N],d[N],sz[N],son[N],totw;\nint a[N],f[N],g[N],X[N],Y[N],W[N];\n\nstruct nd\n{\n    int ne[N*2],to[N*2];\n    int head[N],cnt;\n    void in(int x,int y){to[++cnt]=y;ne[cnt]=head[x];head[x]=cnt;}\n    void init(){memset(head,0,sizeof(head));cnt=0;}\n}e,e1;\n\nvoid dfs1(int x)\n{\n    sz[x]=1;\n    for(int i=e.head[x];i;i=e.ne[i])\n    {\n        int y=e.to[i];\n        d[y]=d[x]+1;\n        dfs1(y);\n\n        sz[x]+=sz[y];\n        if(sz[son[x]]&lt;sz[y])son[x]=y;\n    }\n}\n\nvoid dfs2(int x)\n{\n    st[x]=++totw;\n    int y=son[x];if(!y)return;\n    top[y]=top[x];dfs2(y);\n    for(int i=e.head[x];i;i=e.ne[i])\n    {\n        y=e.to[i];\n        if(y==son[x])continue;\n        top[y]=y;\n        dfs2(y);\n    }\n    ed[x]=totw;\n}\n\nvoid insert(int x,int d)\n{\n    for(int i=x;i&lt;=n;i+=lb(i))a[i]+=d;\n}\n\nint sum(int x,int y)\n{\n    if(!x||!y)return 0;\n    int ret=0;\n    for(int i=y;i;i-=lb(i))ret+=a[i];\n    for(int i=x-1;i;i-=lb(i))ret-=a[i];\n    return ret;\n}\n\nint lca(int x,int y)\n{\n    while(top[x]!=top[y])\n    {\n        if(d[top[x]]&lt;d[top[y]])swap(x,y);\n        x=fa[top[x]];    \n    }\n    if(d[x]&lt;d[y])return x;\n    return y;\n}\n\nint query(int x,int y)\n{\n    int ret=0;\n    while(top[x]!=top[y])\n    {\n        if(d[top[x]]&lt;d[top[y]])swap(x,y);\n        ret+=sum(st[top[x]],st[x]);\n        x=fa[top[x]];\n    }\n    if(st[x]&gt;st[y])swap(x,y);\n    ret+=sum(st[x],st[y]);\n    return ret;\n}\n\nint dp(int x)\n{\n    for(int i=e.head[x];i;i=e.ne[i])\n    dp(e.to[i]),g[x]+=f[e.to[i]];\n    f[x]=g[x];\n    for(int i=e1.head[x];i;i=e1.ne[i])\n    {\n        int to=e1.to[i];\n        f[x]=max(f[x],query(X[to],Y[to])+W[to]);\n    }\n    insert(st[x],-f[x]);\n    if(fa[x])insert(st[fa[x]],f[x]);\n}\n\nint main()\n{\n//     freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;c.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=2;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;fa[i]),e.in(fa[i],i);\n    top[1]=1;dfs1(1);dfs2(1);\n    for(int i=1;i&lt;=m;++i)\n    {\n        scanf(&quot;%d%d%d&quot;,&amp;X[i],&amp;Y[i],&amp;W[i]);\n        e1.in(lca(X[i],Y[i]),i);\n    }\n    dp(1);\n    cout&lt;&lt;f[1];\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/09/13/Codeforces856D/","excerpt":"","categories":[{"name":"Codeforces&AtCoder","slug":"Codeforces-AtCoder","permalink":"https://prostkhala.github.io/categories/Codeforces-AtCoder/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://prostkhala.github.io/tags/树链剖分/"}]},{"title":"Codeforces787D Legacy","date":"2017-09-13T12:27:41.000Z","path":"2017/09/13/Codeforces787D/","text":"Legacy 题目描述Rick and his co-workers have made a new radioactive formula and a lot of bad guys are after them. So Rick wants to give his legacy to Morty before bad guys catch them. There are n planets in their universe numbered from 1 to n. Rick is in planet number s (the earth) and he doesn’t know where Morty is. As we all know, Rick owns a portal gun. With this gun he can open one-way portal from a planet he is in to any other planet (including that planet). But there are limits on this gun because he’s still using its free trial. By default he can not open any portal by this gun. There are q plans in the website that sells these guns. Every time you purchase a plan you can only use it once but you can purchase it again if you want to use it more. Plans on the website have three types: With a plan of this type you can open a portal from planet v to planet u. With a plan of this type you can open a portal from planet v to any planet with index in range $[l, r]$. With a plan of this type you can open a portal from any planet with index in range $[l, r]$ to planet v. Rick doesn’t known where Morty is, but Unity is going to inform him and he wants to be prepared for when he finds and start his journey immediately. So for each planet (including earth itself) he wants to know the minimum amount of money he needs to get from earth to that planet. 输入输出格式输入格式:The first line of input contains three integers n, q and s $(1 ≤ n, q ≤ 10^5, 1 ≤ s ≤ n)$ — number of planets, number of plans and index of earth respectively. The next q lines contain the plans. Each line starts with a number t, type of that plan $(1 ≤ t ≤ 3)$. If t = 1 then it is followed by three integers v, u and w where w is the cost of that plan $(1 ≤ v, u ≤ n, 1 ≤ w ≤ 10^9)$. Otherwise it is followed by four integers v, l, r and w where w is the cost of that plan $(1 ≤ v ≤ n, 1 ≤ l ≤ r ≤ n, 1 ≤ w ≤ 10^9)$. 输出格式：In the first and only line of output print n integers separated by spaces. i-th of them should be minimum money to get from earth to i-th planet, or $ - 1$ if it’s impossible to get to that planet. 输入输出样例输入样例：3 5 1 2 3 2 3 17 2 3 2 2 16 2 2 2 3 3 3 3 1 1 12 1 3 3 17 输出样例：0 28 12 题解线段树优化建图，对于向区间连边，可以将区间用线段树的节点表示出来，并从原节点向线段树中的节点建边，再对于线段树中长度为$1$的节点向原节点建边，跑最短路即可，注意对于区间向点建边的操作，需要另建一棵线段树，将上述操作反向进行，否则即默认任意节点之间存在一条长度为$0$的最短路。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 2e6+1; const ll inf = 2e18; int n,m,S,head[N*2],cnt,tot; ll d[N*2]; struct nd{int ne,to;ll w;}e[N*2]; void in(int x,int y,ll w){e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;} struct Segment_Tree { int ls[N],rs[N],id[N],rt; int build(bool tp,int l,int r) { int x=++tot; if(l==r) { if(!tp) in(x,l,0); else in(l,x,0); return x; } int mid=l+r&gt;&gt;1; ls[x]=build(tp,l,mid); rs[x]=build(tp,mid+1,r); // cout&lt;&lt;ls[x]&lt;&lt;&quot; &quot;&lt;&lt;rs[x]&lt;&lt;endl; if(!tp)in(x,ls[x],0),in(x,rs[x],0); else in(ls[x],x,0),in(rs[x],x,0); return x; } void change(int fr,int L,int R,ll d,bool tag,int x,int l,int r) { if(L&lt;=l&amp;&amp;r&lt;=R) { // cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl; if(!tag)in(fr,x,d); else in(x,fr,d); return; } int mid=l+r&gt;&gt;1; if(L&lt;=mid)change(fr,L,R,d,tag,ls[x],l,mid); if(R&gt;mid)change(fr,L,R,d,tag,rs[x],mid+1,r); return; } void init(bool tp){rt=build(tp,1,n);} }t1,t2; bool inq[N*2]; void spfa(int s) { queue&lt;int&gt;q;q.push(s); for(int i=1;i&lt;=tot;++i)d[i]=inf; d[s]=0;inq[s]=1; while(!q.empty()) { int x=q.front();q.pop();inq[x]=0; for(int i=head[x];i;i=e[i].ne) { int y=e[i].to; if(d[y]&gt;d[x]+e[i].w) { d[y]=d[x]+e[i].w; if(!inq[y])q.push(y),inq[y]=1; } } } } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;S); tot=n; t1.init(1); t2.init(0); for(int i=1,tp,x,y,l,r,w;i&lt;=m;++i) { scanf(&quot;%d&quot;,&amp;tp); if(tp==1) { scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w); in(x,y,w); } if(tp==2) { scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;l,&amp;r,&amp;w); t2.change(x,l,r,w,0,t2.rt,1,n); } if(tp==3) { scanf(&quot;%d%d%d%d&quot;,&amp;y,&amp;l,&amp;r,&amp;w); t1.change(y,l,r,w,1,t1.rt,1,n); } } spfa(S); for(int i=1;i&lt;=n;++i) printf(&quot;%I64d &quot;,(d[i]==inf?-1:d[i])); } /* 3 1 1 2 1 2 3 1 */","raw":"title: Codeforces787D Legacy\ndate: 2017-09-13 20:27:41\ncategories:\n  - Codeforces&AtCoder\ntags:\n  - 线段树\n---\n# [Legacy](http://codeforces.com/problemset/problem/787/D)\n---\n## 题目描述\nRick and his co-workers have made a new radioactive formula and a lot of bad guys are after them. So Rick wants to give his legacy to Morty before bad guys catch them.\n\nThere are n planets in their universe numbered from 1 to n. Rick is in planet number s (the earth) and he doesn't know where Morty is. As we all know, Rick owns a portal gun. With this gun he can open one-way portal from a planet he is in to any other planet (including that planet). But there are limits on this gun because he's still using its free trial.\n![](http://codeforces.com/predownloaded/ba/1b/ba1b063d9f3f1edc4550fe3a21159354e74734c9.png)\n\nBy default he can not open any portal by this gun. There are q plans in the website that sells these guns. Every time you purchase a plan you can only use it once but you can purchase it again if you want to use it more.\n\nPlans on the website have three types:\n\n - With a plan of this type you can open a portal from planet v to planet u.\n - With a plan of this type you can open a portal from planet v to any planet with index in range $[l, r]$.\n - With a plan of this type you can open a portal from any planet with index in range $[l, r]$ to planet v. \n\nRick doesn't known where Morty is, but Unity is going to inform him and he wants to be prepared for when he finds and start his journey immediately. So for each planet (including earth itself) he wants to know the minimum amount of money he needs to get from earth to that planet.\n### 输入输出格式\n#### 输入格式:\nThe first line of input contains three integers n, q and s $(1 ≤ n, q ≤ 10^5, 1 ≤ s ≤ n)$ — number of planets, number of plans and index of earth respectively.\n\nThe next q lines contain the plans. Each line starts with a number t, type of that plan $(1 ≤ t ≤ 3)$. If t = 1 then it is followed by three integers v, u and w where w is the cost of that plan $(1 ≤ v, u ≤ n, 1 ≤ w ≤ 10^9)$. Otherwise it is followed by four integers v, l, r and w where w is the cost of that plan $(1 ≤ v ≤ n, 1 ≤ l ≤ r ≤ n, 1 ≤ w ≤ 10^9)$.\n#### 输出格式：\nIn the first and only line of output print n integers separated by spaces. i-th of them should be minimum money to get from earth to i-th planet, or $ - 1$ if it's impossible to get to that planet.\n### 输入输出样例\n#### 输入样例：\n    3 5 1\n    2 3 2 3 17\n    2 3 2 2 16\n    2 2 2 3 3\n    3 3 1 1 12\n    1 3 3 17\n#### 输出样例：\n\t0 28 12 \n---\n## 题解\n线段树优化建图，对于向区间连边，可以将区间用线段树的节点表示出来，并从原节点向线段树中的节点建边，再对于线段树中长度为$1$的节点向原节点建边，跑最短路即可，注意对于区间向点建边的操作，需要另建一棵线段树，将上述操作反向进行，否则即默认任意节点之间存在一条长度为$0$的最短路。\n\n---\n### CODE\n\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 2e6+1;\n    const ll inf = 2e18;\n    int n,m,S,head[N*2],cnt,tot;\n\n    ll d[N*2];\n\n    struct nd{int ne,to;ll w;}e[N*2];\n\n    void in(int x,int y,ll w){e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;}\n\n    struct Segment_Tree\n    {\n        int ls[N],rs[N],id[N],rt;\n        int build(bool tp,int l,int r)\n        {\n            int x=++tot;\n            if(l==r)\n            {\n                if(!tp)\tin(x,l,0);\n                else\tin(l,x,0);\n                return x;\n            }\n            int mid=l+r>>1;\n            ls[x]=build(tp,l,mid);\n            rs[x]=build(tp,mid+1,r);\n    //\t\tcout<<ls[x]<<\" \"<<rs[x]<<endl;\n            if(!tp)in(x,ls[x],0),in(x,rs[x],0);\n            else in(ls[x],x,0),in(rs[x],x,0);\n            return x;\n        }\n\n        void change(int fr,int L,int R,ll d,bool tag,int x,int l,int r)\n        {\n            if(L<=l&&r<=R)\n            {\n    //\t\t\tcout<<x<<\" \"<<l<<\" \"<<r<<endl;\n                if(!tag)in(fr,x,d);\n                else\tin(x,fr,d);\n                return;\n            }\n            int mid=l+r>>1;\n            if(L<=mid)change(fr,L,R,d,tag,ls[x],l,mid);\n            if(R>mid)change(fr,L,R,d,tag,rs[x],mid+1,r);\n            return;\n        }\n\n        void init(bool tp){rt=build(tp,1,n);}\n    }t1,t2;\n    bool inq[N*2];\n    void spfa(int s)\n    {\n        queue<int>q;q.push(s);\n        for(int i=1;i<=tot;++i)d[i]=inf;\n        d[s]=0;inq[s]=1;\n        while(!q.empty())\n        {\n            int x=q.front();q.pop();inq[x]=0;\n            for(int i=head[x];i;i=e[i].ne)\n            {\n                int y=e[i].to;\n                if(d[y]>d[x]+e[i].w)\n                {\n                    d[y]=d[x]+e[i].w;\n                    if(!inq[y])q.push(y),inq[y]=1;\n                }\n            }\n        }\n    }\n    int main()\n    {\n        scanf(\"%d%d%d\",&n,&m,&S);\n        tot=n;\n        t1.init(1);\n        t2.init(0);\n        for(int i=1,tp,x,y,l,r,w;i<=m;++i)\n        {\n            scanf(\"%d\",&tp);\n            if(tp==1)\n            {\n                scanf(\"%d%d%d\",&x,&y,&w);\n                in(x,y,w);\n            }\n            if(tp==2)\n            {\n                scanf(\"%d%d%d%d\",&x,&l,&r,&w);\n                t2.change(x,l,r,w,0,t2.rt,1,n);\n            }\n            if(tp==3)\n            {\n                scanf(\"%d%d%d%d\",&y,&l,&r,&w);\n                t1.change(y,l,r,w,1,t1.rt,1,n);\n            }\n        }\n        spfa(S);\n        for(int i=1;i<=n;++i)\n        printf(\"%I64d \",(d[i]==inf?-1:d[i]));\n    }\n    /*\n    3 1 1\n    2 1 2 3 1\n    */","content":"<h1 id=\"Legacy\"><a href=\"#Legacy\" class=\"headerlink\" title=\"Legacy\"></a><a href=\"http://codeforces.com/problemset/problem/787/D\" target=\"_blank\" rel=\"external\">Legacy</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Rick and his co-workers have made a new radioactive formula and a lot of bad guys are after them. So Rick wants to give his legacy to Morty before bad guys catch them.</p>\n<p>There are n planets in their universe numbered from 1 to n. Rick is in planet number s (the earth) and he doesn’t know where Morty is. As we all know, Rick owns a portal gun. With this gun he can open one-way portal from a planet he is in to any other planet (including that planet). But there are limits on this gun because he’s still using its free trial.<br><img src=\"http://codeforces.com/predownloaded/ba/1b/ba1b063d9f3f1edc4550fe3a21159354e74734c9.png\" alt=\"\"></p>\n<p>By default he can not open any portal by this gun. There are q plans in the website that sells these guns. Every time you purchase a plan you can only use it once but you can purchase it again if you want to use it more.</p>\n<p>Plans on the website have three types:</p>\n<ul>\n<li>With a plan of this type you can open a portal from planet v to planet u.</li>\n<li>With a plan of this type you can open a portal from planet v to any planet with index in range $[l, r]$.</li>\n<li>With a plan of this type you can open a portal from any planet with index in range $[l, r]$ to planet v. </li>\n</ul>\n<p>Rick doesn’t known where Morty is, but Unity is going to inform him and he wants to be prepared for when he finds and start his journey immediately. So for each planet (including earth itself) he wants to know the minimum amount of money he needs to get from earth to that planet.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>The first line of input contains three integers n, q and s $(1 ≤ n, q ≤ 10^5, 1 ≤ s ≤ n)$ — number of planets, number of plans and index of earth respectively.</p>\n<p>The next q lines contain the plans. Each line starts with a number t, type of that plan $(1 ≤ t ≤ 3)$. If t = 1 then it is followed by three integers v, u and w where w is the cost of that plan $(1 ≤ v, u ≤ n, 1 ≤ w ≤ 10^9)$. Otherwise it is followed by four integers v, l, r and w where w is the cost of that plan $(1 ≤ v ≤ n, 1 ≤ l ≤ r ≤ n, 1 ≤ w ≤ 10^9)$.</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>In the first and only line of output print n integers separated by spaces. i-th of them should be minimum money to get from earth to i-th planet, or $ - 1$ if it’s impossible to get to that planet.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3 5 1\n2 3 2 3 17\n2 3 2 2 16\n2 2 2 3 3\n3 3 1 1 12\n1 3 3 17\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>0 28 12 \n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>线段树优化建图，对于向区间连边，可以将区间用线段树的节点表示出来，并从原节点向线段树中的节点建边，再对于线段树中长度为$1$的节点向原节点建边，跑最短路即可，注意对于区间向点建边的操作，需要另建一棵线段树，将上述操作反向进行，否则即默认任意节点之间存在一条长度为$0$的最短路。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e6+1;\nconst ll inf = 2e18;\nint n,m,S,head[N*2],cnt,tot;\n\nll d[N*2];\n\nstruct nd{int ne,to;ll w;}e[N*2];\n\nvoid in(int x,int y,ll w){e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;}\n\nstruct Segment_Tree\n{\n    int ls[N],rs[N],id[N],rt;\n    int build(bool tp,int l,int r)\n    {\n        int x=++tot;\n        if(l==r)\n        {\n            if(!tp)    in(x,l,0);\n            else    in(l,x,0);\n            return x;\n        }\n        int mid=l+r&gt;&gt;1;\n        ls[x]=build(tp,l,mid);\n        rs[x]=build(tp,mid+1,r);\n//        cout&lt;&lt;ls[x]&lt;&lt;&quot; &quot;&lt;&lt;rs[x]&lt;&lt;endl;\n        if(!tp)in(x,ls[x],0),in(x,rs[x],0);\n        else in(ls[x],x,0),in(rs[x],x,0);\n        return x;\n    }\n\n    void change(int fr,int L,int R,ll d,bool tag,int x,int l,int r)\n    {\n        if(L&lt;=l&amp;&amp;r&lt;=R)\n        {\n//            cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;\n            if(!tag)in(fr,x,d);\n            else    in(x,fr,d);\n            return;\n        }\n        int mid=l+r&gt;&gt;1;\n        if(L&lt;=mid)change(fr,L,R,d,tag,ls[x],l,mid);\n        if(R&gt;mid)change(fr,L,R,d,tag,rs[x],mid+1,r);\n        return;\n    }\n\n    void init(bool tp){rt=build(tp,1,n);}\n}t1,t2;\nbool inq[N*2];\nvoid spfa(int s)\n{\n    queue&lt;int&gt;q;q.push(s);\n    for(int i=1;i&lt;=tot;++i)d[i]=inf;\n    d[s]=0;inq[s]=1;\n    while(!q.empty())\n    {\n        int x=q.front();q.pop();inq[x]=0;\n        for(int i=head[x];i;i=e[i].ne)\n        {\n            int y=e[i].to;\n            if(d[y]&gt;d[x]+e[i].w)\n            {\n                d[y]=d[x]+e[i].w;\n                if(!inq[y])q.push(y),inq[y]=1;\n            }\n        }\n    }\n}\nint main()\n{\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;S);\n    tot=n;\n    t1.init(1);\n    t2.init(0);\n    for(int i=1,tp,x,y,l,r,w;i&lt;=m;++i)\n    {\n        scanf(&quot;%d&quot;,&amp;tp);\n        if(tp==1)\n        {\n            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w);\n            in(x,y,w);\n        }\n        if(tp==2)\n        {\n            scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;l,&amp;r,&amp;w);\n            t2.change(x,l,r,w,0,t2.rt,1,n);\n        }\n        if(tp==3)\n        {\n            scanf(&quot;%d%d%d%d&quot;,&amp;y,&amp;l,&amp;r,&amp;w);\n            t1.change(y,l,r,w,1,t1.rt,1,n);\n        }\n    }\n    spfa(S);\n    for(int i=1;i&lt;=n;++i)\n    printf(&quot;%I64d &quot;,(d[i]==inf?-1:d[i]));\n}\n/*\n3 1 1\n2 1 2 3 1\n*/\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/09/13/Codeforces787D/","excerpt":"","categories":[{"name":"Codeforces&AtCoder","slug":"Codeforces-AtCoder","permalink":"https://prostkhala.github.io/categories/Codeforces-AtCoder/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://prostkhala.github.io/tags/线段树/"}]},{"title":"Codeforces856C Eleventh Birthday","date":"2017-09-11T10:14:51.000Z","path":"2017/09/11/Codeforces856C/","text":"Eleventh Birthday 题目描述It is Borya’s eleventh birthday, and he has got a great present: $n$ cards with numbers. The $i$-th card has the number $a_i$ written on it. Borya wants to put his cards in a row to get one greater number. For example, if Borya has cards with numbers $1$, $31$, and $12$, and he puts them in a row in this order, he would get a number $13112$. He is only $11$, but he already knows that there are n! ways to put his cards in a row. But today is a special day, so he is only interested in such ways that the resulting big number is divisible by eleven. So, the way from the previous paragraph is good, because $13112 = 1192 × 11$, but if he puts the cards in the following order: $31, 1, 12$, he would get a number $31112$, it is not divisible by $11$, so this way is not good for Borya. Help Borya to find out how many good ways to put the cards are there. Borya considers all cards different, even if some of them contain the same number. For example, if Borya has two cards with 1 on it, there are two good ways. Help Borya, find the number of good ways to put the cards. This number can be large, so output it modulo $998244353$. 输入输出格式输入格式:Input data contains multiple test cases. The first line of the input data contains an integer t — the number of test cases $(1 ≤ t ≤ 100)$. The descriptions of test cases follow. Each test is described by two lines. The first line contains an integer $n (1 ≤ n ≤ 2000)$ — the number of cards in Borya’s present. The second line contains$ n$ integers$ a_i (1 ≤ a_i ≤ 10^9)$ — numbers written on the cards. It is guaranteed that the total number of cards in all tests of one input data doesn’t exceed $2000$. 输出格式：For each test case output one line: the number of ways to put the cards to the table so that the resulting big number was divisible by $11$, print the number modulo $998244353$. 输入输出样例输入样例：4 2 1 1 3 1 31 12 3 12345 67 84 9 1 2 3 4 5 6 7 8 9 输出样例：2 2 2 31680 题解根据数论知识可知如果该数可被$11$整除，要求其奇数位和与偶数位和在模$11$下同余，那么我们只需要记录通过背包DP出奇数位的和与偶数位的和为$0$时的方案数即可，但是该题中拼到一起的条件对于该数首位是奇数还是偶数是约束的，那么不妨设有$X$个数长度为奇数，$N-X$个数长度为偶数，考虑以下两种情况： 在当前数后拼入奇数长度的数时，下一个拼入的数的首位奇偶性将与该数相异。 在当前数后拼入偶数长度的数时，下一个拼入的数的首位奇偶性将与该数相同。 为了简便运算，可以设奇数长度的数每一个数奇数位与偶数位的差为$f_i$，偶数长度的数每一个数奇数位与偶数位的差为$g_i$，那么根据以上两种情况，可知最后拼出的数字的奇偶位差值，一定由$ (X+1)/2 $个$ +f $ 和 $ X/2 $ 个 $ -f $ 组成，而对于$N-X$个$g$值，其对最后数字的贡献首位奇偶性性任意（即正负号任意）。（需要注意的是，当$X=0$时，此时所有$N$个数的贡献均为正数，又因此这$N$个数的顺序任意，所以答案为 $N!$ 或 $0$ ，该情况特判掉即可） 对于以上约束，可以在背包时多开一维表示当前加入了几个正的贡献，并且对于 $f$ 与 $g$ 分别进行$DP$： $dp[i][j][k]$表示在$f$的前$i$中取了$j$个正的，达到背包容量为$k$时的总方案数。 $w[i][j][k]$表示在$g$的前$i$中取了$j$个正的，达到背包容量为$k$时的总方案数。 则$dp$的最终状态应为$dp[X][(X+1)/2][k]$,对应的$w$的合法状态为$w[N-X][j][11-k]$，累加计算即可，需要注意的是，对于方程的第二维，其加入的顺序可以是任意的，所以要乘以相应的排列。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 2e5+1; const int mod = 998244353; int T,n,t[2],k[N],f[N],q[N]; ll fac[N],dp[2][3001][11],w[2][3001][11]; int main() { // freopen(&quot;c.in&quot;,&quot;r&quot;,stdin); fac[0]=1; for(int i=1;i&lt;N;++i)fac[i]=(fac[i-1]*i)%mod; scanf(&quot;%d&quot;,&amp;T); while(T--) { memset(w,0,sizeof(w)); memset(dp,0,sizeof(dp)); scanf(&quot;%d&quot;,&amp;n); for(int i=1,x;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;x); int tmp=0; t[0]=t[1]=0; while(x) { ++tmp; t[tmp&amp;1]+=x%10; x/=10; } f[i]=(t[1]-t[0]+1100)%11; k[i]=tmp&amp;1; } q[0]=0; for(int i=1;i&lt;=n;++i) if(k[i])q[++q[0]]=i; if(q[0]==0) { int tot=0; for(int i=1;i&lt;=n;++i) tot=(tot+f[i])%11; if(tot==0)cout&lt;&lt;fac[n]&lt;&lt;endl; else cout&lt;&lt;0&lt;&lt;endl; continue; } dp[0][0][0]=1; for(int i=1;i&lt;=q[0];++i) { memset(dp[i&amp;1],0,sizeof(dp[i&amp;1])); int x=q[i]; for(int t1=0;t1&lt;=i;++t1) for(int k=0;k&lt;11;++k) { if(t1!=0)(dp[i&amp;1][t1][k]+=dp[(i-1)&amp;1][t1-1][(k-f[x]+11)%11]*t1)%=mod; if(t1!=i)(dp[i&amp;1][t1][k]+=dp[(i-1)&amp;1][t1][(k+f[x]+11)%11]*(i-t1))%=mod; } } int x=0,y=1; w[0][0][0]=1; int K=(q[0]+1)/2; int kk=q[0]-K+1; int tmp=0; for(int i=1;i&lt;=n;++i) if(!k[i]) { tmp++; swap(x,y); memset(w[x],0,sizeof(w[x])); for(int t1=0;t1&lt;=tmp;++t1) for(int k=0;k&lt;11;++k) { if(t1!=0)(w[x][t1][k]+=w[y][t1-1][(k-f[i]+11)%11]*(kk+(t1-1)))%=mod; if(t1!=tmp)(w[x][t1][k]+=w[y][t1][(k+f[i]+11)%11]*(K+(tmp-t1-1)))%=mod; } } ll ans=0; for(int i=0;i&lt;=n-q[0];++i) for(int j=0;j&lt;11;++j) { (ans+=dp[q[0]&amp;1][K][(11-j)%11]*w[x][i][j])%=mod; } cout&lt;&lt;ans&lt;&lt;endl; } } /* 1 3 1 1 11 */","raw":"title: Codeforces856C Eleventh Birthday\ndate: 2017-09-11 18:14:51\ncategories:\n  - Codeforces&AtCoder\ntags:\n  - 动态规划\n  - 组合数学\n  - 数论\n---\n# [Eleventh Birthday](http://codeforces.com/contest/856/problem/C)\n---\n## 题目描述\nIt is Borya's eleventh birthday, and he has got a great present: $n$ cards with numbers. The $i$-th card has the number $a_i$ written on it. Borya wants to put his cards in a row to get one greater number. For example, if Borya has cards with numbers $1$, $31$, and $12$, and he puts them in a row in this order, he would get a number $13112$.\n\nHe is only $11$, but he already knows that there are n! ways to put his cards in a row. But today is a special day, so he is only interested in such ways that the resulting big number is divisible by eleven. So, the way from the previous paragraph is good, because $13112 = 1192 × 11$, but if he puts the cards in the following order: $31, 1, 12$, he would get a number $31112$, it is not divisible by $11$, so this way is not good for Borya. Help Borya to find out how many good ways to put the cards are there.\n\nBorya considers all cards different, even if some of them contain the same number. For example, if Borya has two cards with 1 on it, there are two good ways.\n\nHelp Borya, find the number of good ways to put the cards. This number can be large, so output it modulo $998244353$.\n\n### 输入输出格式\n#### 输入格式:\nInput data contains multiple test cases. The first line of the input data contains an integer t — the number of test cases $(1 ≤ t ≤ 100)$. The descriptions of test cases follow.\n\nEach test is described by two lines.\n\nThe first line contains an integer $n (1 ≤ n ≤ 2000)$ — the number of cards in Borya's present.\n\nThe second line contains$ n$ integers$ a_i (1 ≤ a_i ≤ 10^9)$ — numbers written on the cards.\n\nIt is guaranteed that the total number of cards in all tests of one input data doesn't exceed $2000$.\n\n#### 输出格式：\nFor each test case output one line: the number of ways to put the cards to the table so that the resulting big number was divisible by $11$, print the number modulo $998244353$.\n\n### 输入输出样例\n#### 输入样例：\n    4\n    2\n    1 1\n    3\n    1 31 12\n    3\n    12345 67 84\n    9\n    1 2 3 4 5 6 7 8 9\n#### 输出样例：\n    2\n    2\n    2\n    31680\n\n---\n\n## 题解\n根据数论知识可知如果该数可被$11$整除，要求其奇数位和与偶数位和在模$11$下同余，那么我们只需要记录通过背包DP出奇数位的和与偶数位的和为$0$时的方案数即可，但是该题中拼到一起的条件对于该数首位是奇数还是偶数是约束的，那么不妨设有$X$个数长度为奇数，$N-X$个数长度为偶数，考虑以下两种情况：\n\n- 在当前数后拼入奇数长度的数时，下一个拼入的数的首位奇偶性将与该数相异。\n- 在当前数后拼入偶数长度的数时，下一个拼入的数的首位奇偶性将与该数相同。\n\n为了简便运算，可以设奇数长度的数每一个数奇数位与偶数位的差为$f_i$，偶数长度的数每一个数奇数位与偶数位的差为$g_i$，那么根据以上两种情况，可知最后拼出的数字的奇偶位差值，一定由$ \\ (X+1)/2 \\ $个$ \\ +f \\ $ 和 $ \\ X/2 \\ $ 个 $ \\ -f  \\ $ 组成，而对于$N-X$个$g$值，其对最后数字的贡献首位奇偶性性任意（即正负号任意）。（需要注意的是，当$X=0$时，此时所有$N$个数的贡献均为正数，又因此这$N$个数的顺序任意，所以答案为 $N!$ 或 $0$ ，该情况特判掉即可）\n\n对于以上约束，可以在背包时多开一维表示当前加入了几个正的贡献，并且对于 $f$ 与 $g$ 分别进行$DP$：\n\n- $dp[i][j][k]$表示在$f$的前$i$中取了$j$个正的，达到背包容量为$k$时的总方案数。\n- $w[i][j][k]$表示在$g$的前$i$中取了$j$个正的，达到背包容量为$k$时的总方案数。\n\n则$dp$的最终状态应为$dp[X][(X+1)/2][k]$,对应的$w$的合法状态为$w[N-X][j][11-k]$，累加计算即可，需要注意的是，对于方程的第二维，其加入的顺序可以是任意的，所以要乘以相应的排列。\n\n---\n### CODE\n\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 2e5+1;\n    const int mod = 998244353;\n    int T,n,t[2],k[N],f[N],q[N];\n    ll fac[N],dp[2][3001][11],w[2][3001][11];\n    int main()\n    {\n    //\tfreopen(\"c.in\",\"r\",stdin);\n        fac[0]=1;\n        for(int i=1;i<N;++i)fac[i]=(fac[i-1]*i)%mod;\n        scanf(\"%d\",&T);\n        while(T--)\n        {\n            memset(w,0,sizeof(w));\n            memset(dp,0,sizeof(dp));\n            scanf(\"%d\",&n);\n            for(int i=1,x;i<=n;++i)\n            {\n                scanf(\"%d\",&x);\n                int tmp=0;\n                t[0]=t[1]=0;\n                while(x)\n                {\n                    ++tmp;\n                    t[tmp&1]+=x%10;\n                    x/=10;\n                }\n                f[i]=(t[1]-t[0]+1100)%11;\n                k[i]=tmp&1;\n            }\n            q[0]=0;\n            for(int i=1;i<=n;++i)\n            if(k[i])q[++q[0]]=i;\n            if(q[0]==0)\n            {\n                int tot=0;\n                for(int i=1;i<=n;++i)\n                tot=(tot+f[i])%11;\n                if(tot==0)cout<<fac[n]<<endl;\n                else\tcout<<0<<endl;\n                continue;\n            }\n            dp[0][0][0]=1;\n            for(int i=1;i<=q[0];++i)\n            {\n                memset(dp[i&1],0,sizeof(dp[i&1]));\n                int x=q[i];\n                for(int t1=0;t1<=i;++t1)\n                for(int k=0;k<11;++k)\n                {\n                    if(t1!=0)(dp[i&1][t1][k]+=dp[(i-1)&1][t1-1][(k-f[x]+11)%11]*t1)%=mod;\n                    if(t1!=i)(dp[i&1][t1][k]+=dp[(i-1)&1][t1][(k+f[x]+11)%11]*(i-t1))%=mod;\n                }\n            }\n            int x=0,y=1;\n            w[0][0][0]=1;\n            int K=(q[0]+1)/2;\n            int kk=q[0]-K+1;\n            int tmp=0;\n            for(int i=1;i<=n;++i)\n            if(!k[i])\n            {\n                tmp++;\n                swap(x,y);\n                memset(w[x],0,sizeof(w[x]));\n                for(int t1=0;t1<=tmp;++t1)\n                for(int k=0;k<11;++k)\n                {\n                    if(t1!=0)(w[x][t1][k]+=w[y][t1-1][(k-f[i]+11)%11]*(kk+(t1-1)))%=mod;\n                    if(t1!=tmp)(w[x][t1][k]+=w[y][t1][(k+f[i]+11)%11]*(K+(tmp-t1-1)))%=mod;\n                }\n            }\n            ll ans=0;\n            for(int i=0;i<=n-q[0];++i)\n            for(int j=0;j<11;++j)\n            {\n                (ans+=dp[q[0]&1][K][(11-j)%11]*w[x][i][j])%=mod;\n            }\n            cout<<ans<<endl;\n        }\n    }\n    /*\n    1\n    3\n    1 1 11\n    */","content":"<h1 id=\"Eleventh-Birthday\"><a href=\"#Eleventh-Birthday\" class=\"headerlink\" title=\"Eleventh Birthday\"></a><a href=\"http://codeforces.com/contest/856/problem/C\" target=\"_blank\" rel=\"external\">Eleventh Birthday</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>It is Borya’s eleventh birthday, and he has got a great present: $n$ cards with numbers. The $i$-th card has the number $a_i$ written on it. Borya wants to put his cards in a row to get one greater number. For example, if Borya has cards with numbers $1$, $31$, and $12$, and he puts them in a row in this order, he would get a number $13112$.</p>\n<p>He is only $11$, but he already knows that there are n! ways to put his cards in a row. But today is a special day, so he is only interested in such ways that the resulting big number is divisible by eleven. So, the way from the previous paragraph is good, because $13112 = 1192 × 11$, but if he puts the cards in the following order: $31, 1, 12$, he would get a number $31112$, it is not divisible by $11$, so this way is not good for Borya. Help Borya to find out how many good ways to put the cards are there.</p>\n<p>Borya considers all cards different, even if some of them contain the same number. For example, if Borya has two cards with 1 on it, there are two good ways.</p>\n<p>Help Borya, find the number of good ways to put the cards. This number can be large, so output it modulo $998244353$.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>Input data contains multiple test cases. The first line of the input data contains an integer t — the number of test cases $(1 ≤ t ≤ 100)$. The descriptions of test cases follow.</p>\n<p>Each test is described by two lines.</p>\n<p>The first line contains an integer $n (1 ≤ n ≤ 2000)$ — the number of cards in Borya’s present.</p>\n<p>The second line contains$ n$ integers$ a_i (1 ≤ a_i ≤ 10^9)$ — numbers written on the cards.</p>\n<p>It is guaranteed that the total number of cards in all tests of one input data doesn’t exceed $2000$.</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>For each test case output one line: the number of ways to put the cards to the table so that the resulting big number was divisible by $11$, print the number modulo $998244353$.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>4\n2\n1 1\n3\n1 31 12\n3\n12345 67 84\n9\n1 2 3 4 5 6 7 8 9\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>2\n2\n2\n31680\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>根据数论知识可知如果该数可被$11$整除，要求其奇数位和与偶数位和在模$11$下同余，那么我们只需要记录通过背包DP出奇数位的和与偶数位的和为$0$时的方案数即可，但是该题中拼到一起的条件对于该数首位是奇数还是偶数是约束的，那么不妨设有$X$个数长度为奇数，$N-X$个数长度为偶数，考虑以下两种情况：</p>\n<ul>\n<li>在当前数后拼入奇数长度的数时，下一个拼入的数的首位奇偶性将与该数相异。</li>\n<li>在当前数后拼入偶数长度的数时，下一个拼入的数的首位奇偶性将与该数相同。</li>\n</ul>\n<p>为了简便运算，可以设奇数长度的数每一个数奇数位与偶数位的差为$f_i$，偶数长度的数每一个数奇数位与偶数位的差为$g_i$，那么根据以上两种情况，可知最后拼出的数字的奇偶位差值，一定由$  (X+1)/2  $个$  +f  $ 和 $  X/2  $ 个 $  -f   $ 组成，而对于$N-X$个$g$值，其对最后数字的贡献首位奇偶性性任意（即正负号任意）。（需要注意的是，当$X=0$时，此时所有$N$个数的贡献均为正数，又因此这$N$个数的顺序任意，所以答案为 $N!$ 或 $0$ ，该情况特判掉即可）</p>\n<p>对于以上约束，可以在背包时多开一维表示当前加入了几个正的贡献，并且对于 $f$ 与 $g$ 分别进行$DP$：</p>\n<ul>\n<li>$dp[i][j][k]$表示在$f$的前$i$中取了$j$个正的，达到背包容量为$k$时的总方案数。</li>\n<li>$w[i][j][k]$表示在$g$的前$i$中取了$j$个正的，达到背包容量为$k$时的总方案数。</li>\n</ul>\n<p>则$dp$的最终状态应为$dp[X][(X+1)/2][k]$,对应的$w$的合法状态为$w[N-X][j][11-k]$，累加计算即可，需要注意的是，对于方程的第二维，其加入的顺序可以是任意的，所以要乘以相应的排列。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5+1;\nconst int mod = 998244353;\nint T,n,t[2],k[N],f[N],q[N];\nll fac[N],dp[2][3001][11],w[2][3001][11];\nint main()\n{\n//    freopen(&quot;c.in&quot;,&quot;r&quot;,stdin);\n    fac[0]=1;\n    for(int i=1;i&lt;N;++i)fac[i]=(fac[i-1]*i)%mod;\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--)\n    {\n        memset(w,0,sizeof(w));\n        memset(dp,0,sizeof(dp));\n        scanf(&quot;%d&quot;,&amp;n);\n        for(int i=1,x;i&lt;=n;++i)\n        {\n            scanf(&quot;%d&quot;,&amp;x);\n            int tmp=0;\n            t[0]=t[1]=0;\n            while(x)\n            {\n                ++tmp;\n                t[tmp&amp;1]+=x%10;\n                x/=10;\n            }\n            f[i]=(t[1]-t[0]+1100)%11;\n            k[i]=tmp&amp;1;\n        }\n        q[0]=0;\n        for(int i=1;i&lt;=n;++i)\n        if(k[i])q[++q[0]]=i;\n        if(q[0]==0)\n        {\n            int tot=0;\n            for(int i=1;i&lt;=n;++i)\n            tot=(tot+f[i])%11;\n            if(tot==0)cout&lt;&lt;fac[n]&lt;&lt;endl;\n            else    cout&lt;&lt;0&lt;&lt;endl;\n            continue;\n        }\n        dp[0][0][0]=1;\n        for(int i=1;i&lt;=q[0];++i)\n        {\n            memset(dp[i&amp;1],0,sizeof(dp[i&amp;1]));\n            int x=q[i];\n            for(int t1=0;t1&lt;=i;++t1)\n            for(int k=0;k&lt;11;++k)\n            {\n                if(t1!=0)(dp[i&amp;1][t1][k]+=dp[(i-1)&amp;1][t1-1][(k-f[x]+11)%11]*t1)%=mod;\n                if(t1!=i)(dp[i&amp;1][t1][k]+=dp[(i-1)&amp;1][t1][(k+f[x]+11)%11]*(i-t1))%=mod;\n            }\n        }\n        int x=0,y=1;\n        w[0][0][0]=1;\n        int K=(q[0]+1)/2;\n        int kk=q[0]-K+1;\n        int tmp=0;\n        for(int i=1;i&lt;=n;++i)\n        if(!k[i])\n        {\n            tmp++;\n            swap(x,y);\n            memset(w[x],0,sizeof(w[x]));\n            for(int t1=0;t1&lt;=tmp;++t1)\n            for(int k=0;k&lt;11;++k)\n            {\n                if(t1!=0)(w[x][t1][k]+=w[y][t1-1][(k-f[i]+11)%11]*(kk+(t1-1)))%=mod;\n                if(t1!=tmp)(w[x][t1][k]+=w[y][t1][(k+f[i]+11)%11]*(K+(tmp-t1-1)))%=mod;\n            }\n        }\n        ll ans=0;\n        for(int i=0;i&lt;=n-q[0];++i)\n        for(int j=0;j&lt;11;++j)\n        {\n            (ans+=dp[q[0]&amp;1][K][(11-j)%11]*w[x][i][j])%=mod;\n        }\n        cout&lt;&lt;ans&lt;&lt;endl;\n    }\n}\n/*\n1\n3\n1 1 11\n*/\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/09/11/Codeforces856C/","excerpt":"","categories":[{"name":"Codeforces&AtCoder","slug":"Codeforces-AtCoder","permalink":"https://prostkhala.github.io/categories/Codeforces-AtCoder/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"}]},{"title":"Codeforces852F Product Transformation","date":"2017-09-06T07:59:15.000Z","path":"2017/09/06/Codeforces852F/","text":"Product transformation 题目描述Consider an array $A$ with $N$ elements, all being the same integer $a$. Define the product transformation as a simultaneous update $A_i = A_i·A_{i + 1}$, that is multiplying each element to the element right to it for , with the last number AN remaining the same. For example, if we start with an array $A$ with $a = 2$ and $N = 4$, then after one product transformation $A = [4, 4, 4, 2]$, and after two product transformations $A = [16, 16, 8, 2]$. Your simple task is to calculate the array $A$ after $M$ product transformations. Since the numbers can get quite big you should output them modulo $Q$. 输入输出样例输入样例：2 2 2 7 输出样例：1 2 题解已知数列中的底数全部相等，所以可以将操作看为指数相加，即 $S_i=S_i+S_{i+1}$ 那么以$S_{i,j}$表示处理了几次，递推式如下： $S_{i,j}=S_{i-1,j}+S_{i,j+1}$ 初始化为$S_{0,j}=1$（即$a$的$1$次方）将序列翻转，容易发现其递推式与组合数完全相同，只是初始化有些差异，组合数的初始化为$S_{0,0}=1$。考虑将两者进行转化。 容易发现，当$S_{0,j}=1(j&lt;1)$时，两者完全相同，而当$S_{0,j}=1(j&lt;2)$时，原式实际变为了杨辉三角形中代表的组合数与其右移一个单位后代表的组合数之和。一般性的，有$S_{i,j}=\\sum_{t=0}^{n-1}C_{i,j-t}$,即$S$为$C$的前缀和，那么只要计算出$C(m+1,i-1)$即可。 但是该题中$n$,$m$的范围均较大，所以必须用递推阶乘与阶乘逆元的方法求解，考虑题目中实际要对指数进行取模，且有满足$a^P=1(mod Q)$的最小$P$为质数，那么我们可以暴力求出这个$P$然后将指数对其取模。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e6+1; ll n,m,a,mod,rev[N],fac[N],ans[N],P; ll qpow(ll a,int b,ll mod) { ll ret=1; while(b) { if(b&amp;1)ret=ret*a%mod; b&gt;&gt;=1; a=a*a%mod; } return ret; } void pre() { fac[0]=1; for(int i=1;i&lt;=m;++i)fac[i]=fac[i-1]*i%P; rev[m]=qpow(fac[m],P-2,P); for(int i=m-1;i&gt;=0;--i)rev[i]=rev[i+1]*(i+1)%P; } ll C(ll n,ll m) { return n&lt;m?0:fac[n]*rev[m]%P*rev[n-m]%P; } int main() { // 2 2 2 7 cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;mod; if(mod==1){for(int i=1;i&lt;=n;++i)cout&lt;&lt;0&lt;&lt;&quot; &quot;;return 0;} ll now=1; for(int i=1;;++i) { now=now*a%mod; if(now==1){P=i;break;} } pre(); for(int i=1;i&lt;=n;++i) ans[i]=C(m,i-1); for(int i=1;i&lt;=n;++i)(ans[i]+=ans[i-1])%=P; for(int i=1;i&lt;=n;++i)ans[i]=qpow(a,ans[i],mod); for(int i=n;i&gt;=1;--i)printf(&quot;%I64d &quot;,ans[i]); //static int c[101][101],f[101][101]; // for(int i=0;i&lt;=10;++i) // { // c[i][i]=1; // for(int t=1;t&lt;i;++t) // c[i][t]=c[i-1][t]+c[i-1][t-1]; // } // for(int i=1;i&lt;=10;++i)f[1][i]=f[i][1]=1; // for(int i=2;i&lt;=10;++i) // for(int t=2;t&lt;=10;++t) // f[i][t]=f[i-1][t]+f[i-1][t-1]; // // for(int i=1;i&lt;=10;++i) // { // for(int t=1;t&lt;=i;++t) // cout&lt;&lt;c[i][t]&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; // } // // for(int i=1;i&lt;=10;++i) // { // for(int t=1;t&lt;=i;++t) // cout&lt;&lt;f[i][t]&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; // } // // for(int i=1;i&lt;=10;++i) // { // for(int t=1;t&lt;=i;++t) // cout&lt;&lt;f[i][t]-c[i][t]-c[i][t-1]-c[i][t-2]&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; // } }","raw":"title: Codeforces852F Product transformation\ndate: 2017-09-06 15:59:15\ncategories:\n  - Codeforces&AtCoder\ntags:\n  - 组合数学\n  - 数论\n---\n\n\n# [Product transformation](http://codeforces.com/contest/852/problem/F)\n---\n## 题目描述\nConsider an array $A$ with $N$ elements, all being the same integer $a$.\n\nDefine the product transformation as a simultaneous update $A_i = A_i·A_{i + 1}$, that is multiplying each element to the element right to it for![](http://codeforces.com/predownloaded/c7/8e/c78eb1252d951f3c7898473341d585062a5da2e5.png) , with the last number AN remaining the same. For example, if we start with an array $A$ with $a = 2$ and $N = 4$, then after one product transformation $A = [4,  4,  4,  2]$, and after two product transformations $A = [16,  16,  8,  2]$.\n\nYour simple task is to calculate the array $A$ after $M$ product transformations. Since the numbers can get quite big you should output them modulo $Q$.\n### 输入输出样例\n#### 输入样例：\n\t2 2 2 7\n#### 输出样例：\n\t1 2\n---\n\n## 题解\n已知数列中的底数全部相等，所以可以将操作看为指数相加，即\n\n$S_i=S_i+S_{i+1}$\n\n那么以$S_{i,j}$表示处理了几次，递推式如下：\n\n$S_{i,j}=S_{i-1,j}+S_{i,j+1}$\n\n初始化为$S_{0,j}=1$（即$a$的$1$次方）\n将序列翻转，容易发现其递推式与组合数完全相同，只是初始化有些差异，组合数的初始化为$S_{0,0}=1$。考虑将两者进行转化。\n\n容易发现，当$S_{0,j}=1(j<1)$时，两者完全相同，而当$S_{0,j}=1(j<2)$时，原式实际变为了杨辉三角形中代表的组合数与其右移一个单位后代表的组合数之和。一般性的，有\n$S_{i,j}=\\sum_{t=0}^{n-1}C_{i,j-t}$,即$S$为$C$的前缀和，那么只要计算出$C(m+1,i-1)$即可。\n\n但是该题中$n$,$m$的范围均较大，所以必须用递推阶乘与阶乘逆元的方法求解，考虑题目中实际要对指数进行取模，且有满足$a^P=1(mod \\ Q)$的最小$P$为质数，那么我们可以暴力求出这个$P$然后将指数对其取模。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e6+1;\n\n    ll n,m,a,mod,rev[N],fac[N],ans[N],P;\n    ll qpow(ll a,int b,ll mod)\n    {\n        ll ret=1;\n        while(b)\n        {\n            if(b&1)ret=ret*a%mod;\n            b>>=1;\n            a=a*a%mod;\n        }\n        return ret;\n    }\n    void pre()\n    {\n        fac[0]=1;\n        for(int i=1;i<=m;++i)fac[i]=fac[i-1]*i%P;\n        rev[m]=qpow(fac[m],P-2,P);\n        for(int i=m-1;i>=0;--i)rev[i]=rev[i+1]*(i+1)%P;\n    }\n    ll C(ll n,ll m)\n    {\n        return n<m?0:fac[n]*rev[m]%P*rev[n-m]%P;\n    }\n\n    int main()\n    {\n    //       2  2  2  7\n        cin>>n>>m>>a>>mod;\n        if(mod==1){for(int i=1;i<=n;++i)cout<<0<<\" \";return 0;}\n        ll now=1;\n        for(int i=1;;++i)\n        {\n            now=now*a%mod;\n            if(now==1){P=i;break;}\n\n        }\n        pre();\n        for(int i=1;i<=n;++i)\n        ans[i]=C(m,i-1);\n\n        for(int i=1;i<=n;++i)(ans[i]+=ans[i-1])%=P;\n        for(int i=1;i<=n;++i)ans[i]=qpow(a,ans[i],mod);\n        for(int i=n;i>=1;--i)printf(\"%I64d \",ans[i]);\n    //static int c[101][101],f[101][101];\n    //\tfor(int i=0;i<=10;++i)\n    //\t{\n    //\t\tc[i][i]=1;\n    //\t\tfor(int t=1;t<i;++t)\n    //\t\tc[i][t]=c[i-1][t]+c[i-1][t-1];\n    //\t}\n    //\tfor(int i=1;i<=10;++i)f[1][i]=f[i][1]=1;\n    //\tfor(int i=2;i<=10;++i)\n    //\tfor(int t=2;t<=10;++t)\n    //\tf[i][t]=f[i-1][t]+f[i-1][t-1];\n    //\t\n    //\tfor(int i=1;i<=10;++i)\n    //\t{\n    //\t\tfor(int t=1;t<=i;++t)\n    //\t\tcout<<c[i][t]<<\" \";\n    //\t\tcout<<endl;\n    //\t}\n    //\t\n    //\tfor(int i=1;i<=10;++i)\n    //\t{\n    //\t\tfor(int t=1;t<=i;++t)\n    //\t\tcout<<f[i][t]<<\" \";\n    //\t\tcout<<endl;\n    //\t}\n    //\t\n    //\tfor(int i=1;i<=10;++i)\n    //\t{\n    //\t\tfor(int t=1;t<=i;++t)\n    //\t\tcout<<f[i][t]-c[i][t]-c[i][t-1]-c[i][t-2]<<\" \";\n    //\t\tcout<<endl;\n    //\t}\n    }","content":"<h1 id=\"Product-transformation\"><a href=\"#Product-transformation\" class=\"headerlink\" title=\"Product transformation\"></a><a href=\"http://codeforces.com/contest/852/problem/F\" target=\"_blank\" rel=\"external\">Product transformation</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Consider an array $A$ with $N$ elements, all being the same integer $a$.</p>\n<p>Define the product transformation as a simultaneous update $A_i = A_i·A_{i + 1}$, that is multiplying each element to the element right to it for<img src=\"http://codeforces.com/predownloaded/c7/8e/c78eb1252d951f3c7898473341d585062a5da2e5.png\" alt=\"\"> , with the last number AN remaining the same. For example, if we start with an array $A$ with $a = 2$ and $N = 4$, then after one product transformation $A = [4,  4,  4,  2]$, and after two product transformations $A = [16,  16,  8,  2]$.</p>\n<p>Your simple task is to calculate the array $A$ after $M$ product transformations. Since the numbers can get quite big you should output them modulo $Q$.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>2 2 2 7\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>1 2\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>已知数列中的底数全部相等，所以可以将操作看为指数相加，即</p>\n<p>$S_i=S_i+S_{i+1}$</p>\n<p>那么以$S_{i,j}$表示处理了几次，递推式如下：</p>\n<p>$S_{i,j}=S_{i-1,j}+S_{i,j+1}$</p>\n<p>初始化为$S_{0,j}=1$（即$a$的$1$次方）<br>将序列翻转，容易发现其递推式与组合数完全相同，只是初始化有些差异，组合数的初始化为$S_{0,0}=1$。考虑将两者进行转化。</p>\n<p>容易发现，当$S_{0,j}=1(j&lt;1)$时，两者完全相同，而当$S_{0,j}=1(j&lt;2)$时，原式实际变为了杨辉三角形中代表的组合数与其右移一个单位后代表的组合数之和。一般性的，有<br>$S_{i,j}=\\sum_{t=0}^{n-1}C_{i,j-t}$,即$S$为$C$的前缀和，那么只要计算出$C(m+1,i-1)$即可。</p>\n<p>但是该题中$n$,$m$的范围均较大，所以必须用递推阶乘与阶乘逆元的方法求解，考虑题目中实际要对指数进行取模，且有满足$a^P=1(mod  Q)$的最小$P$为质数，那么我们可以暴力求出这个$P$然后将指数对其取模。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6+1;\n\nll n,m,a,mod,rev[N],fac[N],ans[N],P;\nll qpow(ll a,int b,ll mod)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&amp;1)ret=ret*a%mod;\n        b&gt;&gt;=1;\n        a=a*a%mod;\n    }\n    return ret;\n}\nvoid pre()\n{\n    fac[0]=1;\n    for(int i=1;i&lt;=m;++i)fac[i]=fac[i-1]*i%P;\n    rev[m]=qpow(fac[m],P-2,P);\n    for(int i=m-1;i&gt;=0;--i)rev[i]=rev[i+1]*(i+1)%P;\n}\nll C(ll n,ll m)\n{\n    return n&lt;m?0:fac[n]*rev[m]%P*rev[n-m]%P;\n}\n\nint main()\n{\n//       2  2  2  7\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;mod;\n    if(mod==1){for(int i=1;i&lt;=n;++i)cout&lt;&lt;0&lt;&lt;&quot; &quot;;return 0;}\n    ll now=1;\n    for(int i=1;;++i)\n    {\n        now=now*a%mod;\n        if(now==1){P=i;break;}\n\n    }\n    pre();\n    for(int i=1;i&lt;=n;++i)\n    ans[i]=C(m,i-1);\n\n    for(int i=1;i&lt;=n;++i)(ans[i]+=ans[i-1])%=P;\n    for(int i=1;i&lt;=n;++i)ans[i]=qpow(a,ans[i],mod);\n    for(int i=n;i&gt;=1;--i)printf(&quot;%I64d &quot;,ans[i]);\n//static int c[101][101],f[101][101];\n//    for(int i=0;i&lt;=10;++i)\n//    {\n//        c[i][i]=1;\n//        for(int t=1;t&lt;i;++t)\n//        c[i][t]=c[i-1][t]+c[i-1][t-1];\n//    }\n//    for(int i=1;i&lt;=10;++i)f[1][i]=f[i][1]=1;\n//    for(int i=2;i&lt;=10;++i)\n//    for(int t=2;t&lt;=10;++t)\n//    f[i][t]=f[i-1][t]+f[i-1][t-1];\n//    \n//    for(int i=1;i&lt;=10;++i)\n//    {\n//        for(int t=1;t&lt;=i;++t)\n//        cout&lt;&lt;c[i][t]&lt;&lt;&quot; &quot;;\n//        cout&lt;&lt;endl;\n//    }\n//    \n//    for(int i=1;i&lt;=10;++i)\n//    {\n//        for(int t=1;t&lt;=i;++t)\n//        cout&lt;&lt;f[i][t]&lt;&lt;&quot; &quot;;\n//        cout&lt;&lt;endl;\n//    }\n//    \n//    for(int i=1;i&lt;=10;++i)\n//    {\n//        for(int t=1;t&lt;=i;++t)\n//        cout&lt;&lt;f[i][t]-c[i][t]-c[i][t-1]-c[i][t-2]&lt;&lt;&quot; &quot;;\n//        cout&lt;&lt;endl;\n//    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/09/06/Codeforces852F/","excerpt":"","categories":[{"name":"Codeforces&AtCoder","slug":"Codeforces-AtCoder","permalink":"https://prostkhala.github.io/categories/Codeforces-AtCoder/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"}]},{"title":"Codeforces837G Functions on the Segments","date":"2017-09-01T02:55:17.000Z","path":"2017/09/01/Codeforces837G/","text":"Functions On The Segments 题目描述You have an array $f$ of $n$ functions.The function $f_i(x) (1 ≤ i ≤ n)$ is characterized by parameters: $x1, x2, y1, a, b, y2$ and take values: $y1$, if $x ≤ x1$. $a·x + b$, if $x1 &lt; x ≤ x2$. $y2$, if $x &gt; x2$. There are m queries. Each query is determined by numbers $l$, $r$ and $x$. For a query with number $i$ $(1 ≤ i ≤ m)$, you need to calculate the sum of all $f_j(x_i)$ where $l ≤ j ≤ r$. The value of xi is calculated as follows: $xi = (x + last)$ mod $1e9$, where last is the answer to the query with number $i - 1$. The value of last equals $0$ if $i = 1$. 输入输出格式输入格式：First line contains one integer number $n (1 ≤ n ≤ 75000)$. Each of the next n lines contains six integer numbers: $ x1, x2, y1, a, b, y2 (0 ≤ x1 &lt; x2 ≤ 2·1^5, 0 ≤ y1, y2 ≤ 10^9, 0 ≤ a, b ≤ 10^4)$. Next line contains one integer number $m (1 ≤ m ≤ 500000)$. Each of the next m lines contains three integer numbers: $l, r$ and $x (1 ≤ l ≤ r ≤ n, 0 ≤ x ≤ 10^9)$. 输入输出样例输入样例1：1 1 2 1 4 5 10 1 1 1 2 输出样例1：13 输入样例2：3 2 5 1 1 1 4 3 6 8 2 5 7 1 3 5 1 4 10 3 1 3 3 2 3 2 1 2 5 输出样例2：19 17 11 题解题目大意为给定$n$个函数，求将$x$代入连续的一段函数中所得的值的和，强制在线。考虑将求和信息更改为代入$(1,r)$中所得答案与代入 $(1,l-1)$ 所得答案相减，那么问题变可以通过主席树进行实现，每一个函数以下具有两种形式： 1： $y1$, if $x ≤ x1$. $b$, if $x1 &lt; x ≤ x2$. $y2$, if $x &gt; x2$. 2： $a*x$,if $x1 &lt; x ≤ x2$ 对于这两种形式各建一颗主席树，分别求和。需要注意该题可以直接将标记永久化，则不需要过于主席树中繁琐的pushdown。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 2e5+1; const int M = N*81; const int lim = 2e5+1; const ll mod = 1e9; int n,q; struct Chairman_Tree { int rt[N],lc[M],rc[M]; ll w[M]; int tot; void init(){tot=0;} int build(int l,int r) { int x=++tot; w[x]=0; if(l==r) return x; int mid=(l+r)&gt;&gt;1; lc[x]=build(l,mid); rc[x]=build(mid+1,r); return x; } int update(int x,int l,int r,int y1,int y2,int val) { int y=++tot; w[y]=w[x];lc[y]=lc[x];rc[y]=rc[x]; if(y1&lt;=l&amp;&amp;y2&gt;=r) { w[y]+=val; return y; } int mid=(l+r)&gt;&gt;1; if(y1&lt;=mid) lc[y]=update(lc[x],l,mid,y1,y2,val); if(y2&gt;mid) rc[y]=update(rc[x],mid+1,r,y1,y2,val); return y; } ll query(int x,int l,int r,int pos) { if(l==r) return w[x]; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query(lc[x],l,mid,pos)+w[x]; else return query(rc[x],mid+1,r,pos)+w[x]; } }T[2]; int main() { for(int i=0;i&lt;2;++i) { T[i].init(); T[i].rt[0]=T[i].build(0,lim); } scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) { int xx1,xx2,yy1,a,b,yy2; scanf(&quot;%d%d%d%d%d%d&quot;,&amp;xx1,&amp;xx2,&amp;yy1,&amp;a,&amp;b,&amp;yy2); int tmp; tmp=T[0].update(T[0].rt[i-1],0,lim,0,xx1,yy1); tmp=T[0].update(tmp,0,lim,xx1+1,xx2,b); T[0].rt[i]=T[0].update(tmp,0,lim,xx2+1,lim,yy2); T[1].rt[i]=T[1].update(T[1].rt[i-1],0,lim,xx1+1,xx2,a); } int q; scanf(&quot;%d&quot;,&amp;q); ll ans=0; while(q--) { int l,r,x; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x); x=(x+ans)%mod; int lx=min(x,lim); ans=0; ans+=T[0].query(T[0].rt[r],0,lim,lx)-T[0].query(T[0].rt[l-1],0,lim,lx); ans+=x*(T[1].query(T[1].rt[r],0,lim,lx)-T[1].query(T[1].rt[l-1],0,lim,lx)); printf(&quot;%I64d\\n&quot;,ans); } return 0; } #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e5+1; int w[N],a[N],add[N]; void up(int x){w[x]=w[x&lt;&lt;1]+w[x&lt;&lt;1|1];} void build(int x,int l,int r) { if(l==r) { w[x]=a[l]; return; } int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid);build(x&lt;&lt;1|1,mid+1,r); up(x); } void upd(int x,int l,int r,int L,int R,int d) { if(L&lt;=l&amp;&amp;r&lt;=R){add[x]+=d;return;} w[x]+=d*(R-L+1); int mid=l+r&gt;&gt;1; if(L&lt;=mid)upd(x&lt;&lt;1,l,mid,L,R,d); if(R&gt;mid)upd(x&lt;&lt;1|1,mid+1,r,L,R,d); return; } int query(int x,int l,int r,int L,int R) { int ret=add[x]*(R-L+1); if(L&lt;=l&amp;&amp;r&lt;=R){return ret+w[x];} int mid=l+r&gt;&gt;1; if(L&lt;=mid)ret+=query(x&lt;&lt;1,l,mid,L,R); if(R&gt;mid)ret+=query(x&lt;&lt;1|1,mid+1,r,L,R); return ret; } int n,m; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i); build(1,1,n); for(int i=1,q,x,y,k;i&lt;=m;++i) { scanf(&quot;%d&quot;,&amp;q); if(q==1) { scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;k); upd(1,1,n,x,y,k); } if(q==2) { scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,query(1,1,n,x,y)); } } }","raw":"title: Codeforces837G Functions On The Segments\ndate: 2017-09-01 10:55:17\ncategories:\n  - Codeforces&AtCoder\ntags:\n  - 主席树\n  - 线段树\n---\n\n# [Functions On The Segments](http://codeforces.com/contest/837/problem/G)\n---\n## 题目描述\n\nYou have an array $f$ of $n$ functions.The function $f_i(x) (1 ≤ i ≤ n)$ is characterized by parameters: $x1, x2, y1, a, b, y2$ and take values:\n\n * $y1$, if $x ≤ x1$.\n * $a·x + b$, if $x1 < x ≤ x2$.\n * $y2$, if $x > x2$. \n\nThere are m queries. Each query is determined by numbers $l$, $r$ and $x$. For a query with number $i$  $(1 ≤ i ≤ m)$, you need to calculate the sum of all $f_j(x_i)$ where $l ≤ j ≤ r$. The value of xi is calculated as follows: $xi = (x + last)$ mod $1e9$, where last is the answer to the query with number $i - 1$. The value of last equals $0$ if $i = 1$.\n\n### 输入输出格式\n#### 输入格式：\nFirst line contains one integer number $n (1 ≤ n ≤ 75000)$.\n\nEach of the next n lines contains six integer numbers:\n\n$ x1, x2, y1, a, b, y2 (0 ≤ x1 < x2 ≤ 2·1^5, 0 ≤ y1, y2 ≤ 10^9, 0 ≤ a, b ≤ 10^4)$.\n\nNext line contains one integer number $m (1 ≤ m ≤ 500000)$.\n\nEach of the next m lines contains three integer numbers: $l, r$ and $x (1 ≤ l ≤ r ≤ n, 0 ≤ x ≤ 10^9)$.\n### 输入输出样例\n#### 输入样例1：\n    1\n    1 2 1 4 5 10\n    1\n    1 1 2\n\n#### 输出样例1：\n    13\n#### 输入样例2：\n    3\n    2 5 1 1 1 4\n    3 6 8 2 5 7\n    1 3 5 1 4 10\n    3\n    1 3 3\n    2 3 2\n    1 2 5\n\n#### 输出样例2：\n    19\n    17\n    11\n---\n## 题解\n题目大意为给定$n$个函数，求将$x$代入连续的一段函数中所得的值的和，强制在线。考虑将求和信息更改为代入$(1,r)$中所得答案与代入 $(1,l-1)$ 所得答案相减，那么问题变可以通过\n主席树进行实现，每一个函数以下具有两种形式：\n\n- 1：\n\t- $y1$, if $x ≤ x1$.\n\t- $b$, if $x1 < x ≤ x2$.\n\t- $y2$, if $x > x2$. \n- 2：\n\t- $a*x$,if $x1 < x ≤ x2$\n\n对于这两种形式各建一颗主席树，分别求和。需要注意该题可以直接将标记永久化，则不需要过于主席树中繁琐的pushdown。\n\n\n\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 2e5+1;\n    const int M = N*81;\n    const int lim = 2e5+1;\n    const ll mod = 1e9;\n    int n,q;\n    struct Chairman_Tree\n    {\n        int rt[N],lc[M],rc[M];\n        ll w[M];\n        int tot;\n        void init(){tot=0;}\n        int build(int l,int r)\n        {\n            int x=++tot;\n            w[x]=0;\n            if(l==r) return x;\n            int mid=(l+r)>>1;\n            lc[x]=build(l,mid);\n            rc[x]=build(mid+1,r);\n            return x;\n        }\n        int update(int x,int l,int r,int y1,int y2,int val)\n        {\n            int y=++tot;\n            w[y]=w[x];lc[y]=lc[x];rc[y]=rc[x];\n            if(y1<=l&&y2>=r)\n            {\n                w[y]+=val;\n                return y;\n            }\n            int mid=(l+r)>>1;\n            if(y1<=mid) lc[y]=update(lc[x],l,mid,y1,y2,val);\n            if(y2>mid) rc[y]=update(rc[x],mid+1,r,y1,y2,val);\n            return y;\n        }\n        ll query(int x,int l,int r,int pos)\n        {\n            if(l==r) return w[x];\n            int mid=(l+r)>>1;\n            if(pos<=mid) return query(lc[x],l,mid,pos)+w[x];\n            else return query(rc[x],mid+1,r,pos)+w[x];\n        }\n    }T[2];\n    int main()\n    {\n        for(int i=0;i<2;++i) \n        {\n            T[i].init();\n            T[i].rt[0]=T[i].build(0,lim);\n        }\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;++i)\n        {\n            int xx1,xx2,yy1,a,b,yy2;\n            scanf(\"%d%d%d%d%d%d\",&xx1,&xx2,&yy1,&a,&b,&yy2);\n            int tmp;\n            tmp=T[0].update(T[0].rt[i-1],0,lim,0,xx1,yy1);\n            tmp=T[0].update(tmp,0,lim,xx1+1,xx2,b);\n            T[0].rt[i]=T[0].update(tmp,0,lim,xx2+1,lim,yy2);\n            T[1].rt[i]=T[1].update(T[1].rt[i-1],0,lim,xx1+1,xx2,a);\n        }\n        int q;\n        scanf(\"%d\",&q);\n        ll ans=0;\n        while(q--)\n        {\n            int l,r,x;\n            scanf(\"%d%d%d\",&l,&r,&x);\n            x=(x+ans)%mod;\n            int lx=min(x,lim);\n            ans=0;\n            ans+=T[0].query(T[0].rt[r],0,lim,lx)-T[0].query(T[0].rt[l-1],0,lim,lx);\n            ans+=x*(T[1].query(T[1].rt[r],0,lim,lx)-T[1].query(T[1].rt[l-1],0,lim,lx));\n            printf(\"%I64d\\n\",ans);\n        }\n        return 0;\n    }\n\n---\n\n---\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e5+1;\n    int w[N],a[N],add[N];\n    void up(int x){w[x]=w[x<<1]+w[x<<1|1];}\n    void build(int x,int l,int r)\n    {\n        if(l==r)\n        {\n            w[x]=a[l];\n            return;\n        }\n        int mid=l+r>>1;\n        build(x<<1,l,mid);build(x<<1|1,mid+1,r);\n        up(x);\n    }\n\n    void upd(int x,int l,int r,int L,int R,int d)\n    {\n        if(L<=l&&r<=R){add[x]+=d;return;}\n        w[x]+=d*(R-L+1);\n        int mid=l+r>>1;\n        if(L<=mid)upd(x<<1,l,mid,L,R,d);\n        if(R>mid)upd(x<<1|1,mid+1,r,L,R,d);\n        return;\n    }\n\n    int query(int x,int l,int r,int L,int R)\n    {\n        int ret=add[x]*(R-L+1);\n        if(L<=l&&r<=R){return ret+w[x];}\n        int mid=l+r>>1;\n        if(L<=mid)ret+=query(x<<1,l,mid,L,R);\n        if(R>mid)ret+=query(x<<1|1,mid+1,r,L,R);\n        return ret;\n    }\n    int n,m;\n    int main()\n    {\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n        build(1,1,n);\n        for(int i=1,q,x,y,k;i<=m;++i)\n        {\n            scanf(\"%d\",&q);\n            if(q==1)\n            {\n                scanf(\"%d%d%d\",&x,&y,&k);\n                upd(1,1,n,x,y,k);\n            }\n            if(q==2)\n            {\n                scanf(\"%d%d\",&x,&y);\n                printf(\"%d\\n\",query(1,1,n,x,y));\n            }\n        }\n    }","content":"<h1 id=\"Functions-On-The-Segments\"><a href=\"#Functions-On-The-Segments\" class=\"headerlink\" title=\"Functions On The Segments\"></a><a href=\"http://codeforces.com/contest/837/problem/G\" target=\"_blank\" rel=\"external\">Functions On The Segments</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>You have an array $f$ of $n$ functions.The function $f_i(x) (1 ≤ i ≤ n)$ is characterized by parameters: $x1, x2, y1, a, b, y2$ and take values:</p>\n<ul>\n<li>$y1$, if $x ≤ x1$.</li>\n<li>$a·x + b$, if $x1 &lt; x ≤ x2$.</li>\n<li>$y2$, if $x &gt; x2$. </li>\n</ul>\n<p>There are m queries. Each query is determined by numbers $l$, $r$ and $x$. For a query with number $i$  $(1 ≤ i ≤ m)$, you need to calculate the sum of all $f_j(x_i)$ where $l ≤ j ≤ r$. The value of xi is calculated as follows: $xi = (x + last)$ mod $1e9$, where last is the answer to the query with number $i - 1$. The value of last equals $0$ if $i = 1$.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>First line contains one integer number $n (1 ≤ n ≤ 75000)$.</p>\n<p>Each of the next n lines contains six integer numbers:</p>\n<p>$ x1, x2, y1, a, b, y2 (0 ≤ x1 &lt; x2 ≤ 2·1^5, 0 ≤ y1, y2 ≤ 10^9, 0 ≤ a, b ≤ 10^4)$.</p>\n<p>Next line contains one integer number $m (1 ≤ m ≤ 500000)$.</p>\n<p>Each of the next m lines contains three integer numbers: $l, r$ and $x (1 ≤ l ≤ r ≤ n, 0 ≤ x ≤ 10^9)$.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例1：\"><a href=\"#输入样例1：\" class=\"headerlink\" title=\"输入样例1：\"></a>输入样例1：</h4><pre><code>1\n1 2 1 4 5 10\n1\n1 1 2\n</code></pre><h4 id=\"输出样例1：\"><a href=\"#输出样例1：\" class=\"headerlink\" title=\"输出样例1：\"></a>输出样例1：</h4><pre><code>13\n</code></pre><h4 id=\"输入样例2：\"><a href=\"#输入样例2：\" class=\"headerlink\" title=\"输入样例2：\"></a>输入样例2：</h4><pre><code>3\n2 5 1 1 1 4\n3 6 8 2 5 7\n1 3 5 1 4 10\n3\n1 3 3\n2 3 2\n1 2 5\n</code></pre><h4 id=\"输出样例2：\"><a href=\"#输出样例2：\" class=\"headerlink\" title=\"输出样例2：\"></a>输出样例2：</h4><pre><code>19\n17\n11\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意为给定$n$个函数，求将$x$代入连续的一段函数中所得的值的和，强制在线。考虑将求和信息更改为代入$(1,r)$中所得答案与代入 $(1,l-1)$ 所得答案相减，那么问题变可以通过<br>主席树进行实现，每一个函数以下具有两种形式：</p>\n<ul>\n<li>1：<ul>\n<li>$y1$, if $x ≤ x1$.</li>\n<li>$b$, if $x1 &lt; x ≤ x2$.</li>\n<li>$y2$, if $x &gt; x2$. </li>\n</ul>\n</li>\n<li>2：<ul>\n<li>$a*x$,if $x1 &lt; x ≤ x2$</li>\n</ul>\n</li>\n</ul>\n<p>对于这两种形式各建一颗主席树，分别求和。需要注意该题可以直接将标记永久化，则不需要过于主席树中繁琐的pushdown。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5+1;\nconst int M = N*81;\nconst int lim = 2e5+1;\nconst ll mod = 1e9;\nint n,q;\nstruct Chairman_Tree\n{\n    int rt[N],lc[M],rc[M];\n    ll w[M];\n    int tot;\n    void init(){tot=0;}\n    int build(int l,int r)\n    {\n        int x=++tot;\n        w[x]=0;\n        if(l==r) return x;\n        int mid=(l+r)&gt;&gt;1;\n        lc[x]=build(l,mid);\n        rc[x]=build(mid+1,r);\n        return x;\n    }\n    int update(int x,int l,int r,int y1,int y2,int val)\n    {\n        int y=++tot;\n        w[y]=w[x];lc[y]=lc[x];rc[y]=rc[x];\n        if(y1&lt;=l&amp;&amp;y2&gt;=r)\n        {\n            w[y]+=val;\n            return y;\n        }\n        int mid=(l+r)&gt;&gt;1;\n        if(y1&lt;=mid) lc[y]=update(lc[x],l,mid,y1,y2,val);\n        if(y2&gt;mid) rc[y]=update(rc[x],mid+1,r,y1,y2,val);\n        return y;\n    }\n    ll query(int x,int l,int r,int pos)\n    {\n        if(l==r) return w[x];\n        int mid=(l+r)&gt;&gt;1;\n        if(pos&lt;=mid) return query(lc[x],l,mid,pos)+w[x];\n        else return query(rc[x],mid+1,r,pos)+w[x];\n    }\n}T[2];\nint main()\n{\n    for(int i=0;i&lt;2;++i) \n    {\n        T[i].init();\n        T[i].rt[0]=T[i].build(0,lim);\n    }\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1;i&lt;=n;++i)\n    {\n        int xx1,xx2,yy1,a,b,yy2;\n        scanf(&quot;%d%d%d%d%d%d&quot;,&amp;xx1,&amp;xx2,&amp;yy1,&amp;a,&amp;b,&amp;yy2);\n        int tmp;\n        tmp=T[0].update(T[0].rt[i-1],0,lim,0,xx1,yy1);\n        tmp=T[0].update(tmp,0,lim,xx1+1,xx2,b);\n        T[0].rt[i]=T[0].update(tmp,0,lim,xx2+1,lim,yy2);\n        T[1].rt[i]=T[1].update(T[1].rt[i-1],0,lim,xx1+1,xx2,a);\n    }\n    int q;\n    scanf(&quot;%d&quot;,&amp;q);\n    ll ans=0;\n    while(q--)\n    {\n        int l,r,x;\n        scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x);\n        x=(x+ans)%mod;\n        int lx=min(x,lim);\n        ans=0;\n        ans+=T[0].query(T[0].rt[r],0,lim,lx)-T[0].query(T[0].rt[l-1],0,lim,lx);\n        ans+=x*(T[1].query(T[1].rt[r],0,lim,lx)-T[1].query(T[1].rt[l-1],0,lim,lx));\n        printf(&quot;%I64d\\n&quot;,ans);\n    }\n    return 0;\n}\n</code></pre><hr>\n<hr>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+1;\nint w[N],a[N],add[N];\nvoid up(int x){w[x]=w[x&lt;&lt;1]+w[x&lt;&lt;1|1];}\nvoid build(int x,int l,int r)\n{\n    if(l==r)\n    {\n        w[x]=a[l];\n        return;\n    }\n    int mid=l+r&gt;&gt;1;\n    build(x&lt;&lt;1,l,mid);build(x&lt;&lt;1|1,mid+1,r);\n    up(x);\n}\n\nvoid upd(int x,int l,int r,int L,int R,int d)\n{\n    if(L&lt;=l&amp;&amp;r&lt;=R){add[x]+=d;return;}\n    w[x]+=d*(R-L+1);\n    int mid=l+r&gt;&gt;1;\n    if(L&lt;=mid)upd(x&lt;&lt;1,l,mid,L,R,d);\n    if(R&gt;mid)upd(x&lt;&lt;1|1,mid+1,r,L,R,d);\n    return;\n}\n\nint query(int x,int l,int r,int L,int R)\n{\n    int ret=add[x]*(R-L+1);\n    if(L&lt;=l&amp;&amp;r&lt;=R){return ret+w[x];}\n    int mid=l+r&gt;&gt;1;\n    if(L&lt;=mid)ret+=query(x&lt;&lt;1,l,mid,L,R);\n    if(R&gt;mid)ret+=query(x&lt;&lt;1|1,mid+1,r,L,R);\n    return ret;\n}\nint n,m;\nint main()\n{\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i);\n    build(1,1,n);\n    for(int i=1,q,x,y,k;i&lt;=m;++i)\n    {\n        scanf(&quot;%d&quot;,&amp;q);\n        if(q==1)\n        {\n            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;k);\n            upd(1,1,n,x,y,k);\n        }\n        if(q==2)\n        {\n            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\n            printf(&quot;%d\\n&quot;,query(1,1,n,x,y));\n        }\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/09/01/Codeforces837G/","excerpt":"","categories":[{"name":"Codeforces&AtCoder","slug":"Codeforces-AtCoder","permalink":"https://prostkhala.github.io/categories/Codeforces-AtCoder/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://prostkhala.github.io/tags/线段树/"},{"name":"主席树","slug":"主席树","permalink":"https://prostkhala.github.io/tags/主席树/"}]},{"title":"Codeforces798E Mike and Code of a Permutation","date":"2017-08-31T08:11:21.000Z","path":"2017/08/31/Codeforces798E/","text":"Mike and code of a permutation 题目描述Mike has discovered a new way to encode permutations. If he has a permutation P = [p1, p2, …, pn], he will encode it in the following way: Denote by A = [a1, a2, …, an] a sequence of length n which will represent the code of the permutation. For each i from 1 to n sequentially, he will choose the smallest unmarked j (1 ≤ j ≤ n) such that pi &lt; pj and will assign to ai the number j (in other words he performs ai = j) and will mark j. If there is no such j, he’ll assign to ai the number - 1 (he performs ai = - 1). Mike forgot his original permutation but he remembers its code. Your task is simple: find any permutation such that its code is the same as the code of Mike’s original permutation. You may assume that there will always be at least one valid permutation. 输入输出格式输入格式:The first line contains single integer n (1 ≤ n ≤ 500 000) — length of permutation. The second line contains n space-separated integers a1, a2, …, an (1 ≤ ai ≤ n or ai = - 1) — the code of Mike’s permutation. You may assume that all positive values from A are different. 输出格式：In first and only line print n numbers p1, p2, …, pn (1 ≤ pi ≤ n) — a permutation P which has the same code as the given one. Note that numbers in permutation are distinct. 输入输出样例输入样例1：6 2 -1 1 5 -1 4 输出样例1：2 6 1 4 5 3 输入样例2：8 2 -1 4 -1 6 -1 8 -1 输出样例2：1 8 2 7 3 6 4 5 题解设$to$数组为给出数组的逆，$ans$为答案数组，那么对于一个$i$有两种约束条件： 1：$ans[i]&gt;ans[b[i]]$ 2:$ans[j]i and j&lt;a[i] and j!=i)$ 此处可以利用查分约束，将关系用边表示然后进行拓扑排序，但遍历所有关系的时间复杂度为$O(n^2)$,无法通过极限数据。可以考虑用线段树进行优化，将第二种关系用线段树进行查询，并模拟原题中的mark操作，在遍历后从线段树中删除该点，期望时间复杂度$O(nlogn)$。 CODE#include&lt;bits/stdc++.h&gt; #define y second using namespace std; typedef long long ll; const int N = 1e6+1; const int inf = 0x7fffffff; int n,a[N],head[N],cnt,d[N],to[N]; bool vis[N]; pair&lt;int,int&gt;q; struct nd{int ne,to;}e[N*50]; struct segment_tree { pair&lt;int,int&gt;t[N]; void update(int x){t[x]=max(t[x&lt;&lt;1],t[x&lt;&lt;1|1]);} void build(int x,int l,int r) { if(l==r){t[x]=make_pair(to[l],l);return;} int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid);build(x&lt;&lt;1|1,mid+1,r); update(x); return; } pair&lt;int,int&gt; query(int x,int l,int r,int L,int R) { if(L&lt;=l&amp;&amp;r&lt;=R)return t[x]; int mid=l+r&gt;&gt;1; pair&lt;int,int&gt; ret=make_pair(0,0); if(L&lt;=mid) ret=max(ret,query(x&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) ret=max(ret,query(x&lt;&lt;1|1,mid+1,r,L,R)); return ret; } void delet(int x,int l,int r,int d) { if(l==r){t[x]=make_pair(0,l);return;} int mid=l+r&gt;&gt;1; if(d&lt;=mid) delet(x&lt;&lt;1,l,mid,d); else delet(x&lt;&lt;1|1,mid+1,r,d); update(x); return; } }T; int tot; int dfs(int x) { vis[x]=1; T.delet(1,1,n,x); if(to[x]!=n+1&amp;&amp;!vis[to[x]])dfs(to[x]); if(a[x]&gt;1) while(1) { pair&lt;int,int&gt; v=T.query(1,1,n,1,a[x]-1); if(v.first&gt;x)dfs(v.second); else break; } d[x]=++tot; } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i); for(int i=1;i&lt;=n;++i) if(a[i]!=-1) to[a[i]]=i; else a[i]=n+1; for(int i=1;i&lt;=n;++i)if(!to[i])to[i]=n+1; T.build(1,1,n); for(int i=1;i&lt;=n;++i)if(!vis[i])dfs(i); for(int i=1;i&lt;=n;++i)printf(&quot;%d &quot;,d[i]); }","raw":"title: Codeforces798E Mike and code of a permutation\ndate: 2017-08-31 16:11:21\ncategories:\n  -  Codeforces&AtCoder\ntags:\n  - 拓扑排序\n  - 线段树\n---\n\n\n# [Mike and code of a permutation](http://codeforces.com/contest/798/problem/E)\n---\n## 题目描述\n\nMike has discovered a new way to encode permutations. If he has a permutation P = [p1, p2, ..., pn], he will encode it in the following way:\n\nDenote by A = [a1, a2, ..., an] a sequence of length n which will represent the code of the permutation. For each i from 1 to n sequentially, he will choose the smallest unmarked j (1 ≤ j ≤ n) such that pi < pj and will assign to ai the number j (in other words he performs ai = j) and will mark j. If there is no such j, he'll assign to ai the number  - 1 (he performs ai =  - 1).\n\nMike forgot his original permutation but he remembers its code. Your task is simple: find any permutation such that its code is the same as the code of Mike's original permutation.\n\nYou may assume that there will always be at least one valid permutation.\n\n\n### 输入输出格式\n#### 输入格式:\n\nThe first line contains single integer n (1 ≤ n ≤ 500 000) — length of permutation.\n\nThe second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ n or ai =  - 1) — the code of Mike's permutation.\n\nYou may assume that all positive values from A are different.\n\n#### 输出格式：\n\nIn first and only line print n numbers p1, p2, ..., pn (1 ≤ pi ≤ n) — a permutation P which has the same code as the given one. Note that numbers in permutation are distinct.\n\n### 输入输出样例\n#### 输入样例1：\n    6\n    2 -1 1 5 -1 4\n#### 输出样例1：\n\t2 6 1 4 5 3\n#### 输入样例2：\n    8\n\t2 -1 4 -1 6 -1 8 -1\n#### 输出样例2：\n\t1 8 2 7 3 6 4 5\n---\n## 题解\n设$to$数组为给出数组的逆，$ans$为答案数组，那么对于一个$i$有两种约束条件：\n\n* 1：$ans[i]>ans[b[i]]$\n* 2:$ans[j]<ans[i](b[j]>i \\ and \\ j<a[i] \\ and \\ j!=i)$\n\n此处可以利用查分约束，将关系用边表示然后进行拓扑排序，但遍历所有关系的时间复杂度为$O(n^2)$,无法通过极限数据。可以考虑用线段树进行优化，将第二种关系用线段树进行查询，并模拟原题中的mark操作，在遍历后从线段树中删除该点，期望时间复杂度$O(nlogn)$。\n\n\n\n---\n### CODE\n\n    #include<bits/stdc++.h>\n    #define y second\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e6+1;\n    const int inf = 0x7fffffff;\n\n    int n,a[N],head[N],cnt,d[N],to[N];\n    bool vis[N];\n    pair<int,int>q;\n    struct nd{int ne,to;}e[N*50];\n\n    struct segment_tree\n    {\n        pair<int,int>t[N];\n\n        void update(int x){t[x]=max(t[x<<1],t[x<<1|1]);}\n\n        void build(int x,int l,int r)\n        {\n            if(l==r){t[x]=make_pair(to[l],l);return;}\n            int mid=l+r>>1;\n            build(x<<1,l,mid);build(x<<1|1,mid+1,r);\n            update(x);\n            return;\n        }\n\n        pair<int,int> query(int x,int l,int r,int L,int R)\n        {\n            if(L<=l&&r<=R)return t[x];\n            int mid=l+r>>1;\n            pair<int,int> ret=make_pair(0,0);\n            if(L<=mid)\tret=max(ret,query(x<<1,l,mid,L,R));\n            if(R>mid)\tret=max(ret,query(x<<1|1,mid+1,r,L,R));\n            return ret;\n        }\n\n        void delet(int x,int l,int r,int d)\n        {\n            if(l==r){t[x]=make_pair(0,l);return;}\n            int mid=l+r>>1;\n            if(d<=mid)\tdelet(x<<1,l,mid,d);\n            else\t\tdelet(x<<1|1,mid+1,r,d);\n            update(x);\n            return;\n        }\n\n    }T;\n    int tot;\n    int dfs(int x)\n    {\n        vis[x]=1;\n        T.delet(1,1,n,x);\n        if(to[x]!=n+1&&!vis[to[x]])dfs(to[x]);\n        if(a[x]>1)\n        while(1)\n        {\n            pair<int,int> v=T.query(1,1,n,1,a[x]-1);\n            if(v.first>x)dfs(v.second);\n            else\tbreak;\n        }\n        d[x]=++tot;\n    }\n\n    int main()\n    {\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n        for(int i=1;i<=n;++i)\n        if(a[i]!=-1)\tto[a[i]]=i;\n        else\ta[i]=n+1;\n        for(int i=1;i<=n;++i)if(!to[i])to[i]=n+1;\n        T.build(1,1,n);\n        for(int i=1;i<=n;++i)if(!vis[i])dfs(i);\n        for(int i=1;i<=n;++i)printf(\"%d \",d[i]);\n    }","content":"<h1 id=\"Mike-and-code-of-a-permutation\"><a href=\"#Mike-and-code-of-a-permutation\" class=\"headerlink\" title=\"Mike and code of a permutation\"></a><a href=\"http://codeforces.com/contest/798/problem/E\" target=\"_blank\" rel=\"external\">Mike and code of a permutation</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Mike has discovered a new way to encode permutations. If he has a permutation P = [p1, p2, …, pn], he will encode it in the following way:</p>\n<p>Denote by A = [a1, a2, …, an] a sequence of length n which will represent the code of the permutation. For each i from 1 to n sequentially, he will choose the smallest unmarked j (1 ≤ j ≤ n) such that pi &lt; pj and will assign to ai the number j (in other words he performs ai = j) and will mark j. If there is no such j, he’ll assign to ai the number  - 1 (he performs ai =  - 1).</p>\n<p>Mike forgot his original permutation but he remembers its code. Your task is simple: find any permutation such that its code is the same as the code of Mike’s original permutation.</p>\n<p>You may assume that there will always be at least one valid permutation.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>The first line contains single integer n (1 ≤ n ≤ 500 000) — length of permutation.</p>\n<p>The second line contains n space-separated integers a1, a2, …, an (1 ≤ ai ≤ n or ai =  - 1) — the code of Mike’s permutation.</p>\n<p>You may assume that all positive values from A are different.</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>In first and only line print n numbers p1, p2, …, pn (1 ≤ pi ≤ n) — a permutation P which has the same code as the given one. Note that numbers in permutation are distinct.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例1：\"><a href=\"#输入样例1：\" class=\"headerlink\" title=\"输入样例1：\"></a>输入样例1：</h4><pre><code>6\n2 -1 1 5 -1 4\n</code></pre><h4 id=\"输出样例1：\"><a href=\"#输出样例1：\" class=\"headerlink\" title=\"输出样例1：\"></a>输出样例1：</h4><pre><code>2 6 1 4 5 3\n</code></pre><h4 id=\"输入样例2：\"><a href=\"#输入样例2：\" class=\"headerlink\" title=\"输入样例2：\"></a>输入样例2：</h4><pre><code>8\n2 -1 4 -1 6 -1 8 -1\n</code></pre><h4 id=\"输出样例2：\"><a href=\"#输出样例2：\" class=\"headerlink\" title=\"输出样例2：\"></a>输出样例2：</h4><pre><code>1 8 2 7 3 6 4 5\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>设$to$数组为给出数组的逆，$ans$为答案数组，那么对于一个$i$有两种约束条件：</p>\n<ul>\n<li>1：$ans[i]&gt;ans[b[i]]$</li>\n<li>2:$ans[j]<ans[i](b[j]>i  and  j&lt;a[i]  and  j!=i)$</ans[i](b[j]></li>\n</ul>\n<p>此处可以利用查分约束，将关系用边表示然后进行拓扑排序，但遍历所有关系的时间复杂度为$O(n^2)$,无法通过极限数据。可以考虑用线段树进行优化，将第二种关系用线段树进行查询，并模拟原题中的mark操作，在遍历后从线段树中删除该点，期望时间复杂度$O(nlogn)$。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\n#define y second\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e6+1;\nconst int inf = 0x7fffffff;\n\nint n,a[N],head[N],cnt,d[N],to[N];\nbool vis[N];\npair&lt;int,int&gt;q;\nstruct nd{int ne,to;}e[N*50];\n\nstruct segment_tree\n{\n    pair&lt;int,int&gt;t[N];\n\n    void update(int x){t[x]=max(t[x&lt;&lt;1],t[x&lt;&lt;1|1]);}\n\n    void build(int x,int l,int r)\n    {\n        if(l==r){t[x]=make_pair(to[l],l);return;}\n        int mid=l+r&gt;&gt;1;\n        build(x&lt;&lt;1,l,mid);build(x&lt;&lt;1|1,mid+1,r);\n        update(x);\n        return;\n    }\n\n    pair&lt;int,int&gt; query(int x,int l,int r,int L,int R)\n    {\n        if(L&lt;=l&amp;&amp;r&lt;=R)return t[x];\n        int mid=l+r&gt;&gt;1;\n        pair&lt;int,int&gt; ret=make_pair(0,0);\n        if(L&lt;=mid)    ret=max(ret,query(x&lt;&lt;1,l,mid,L,R));\n        if(R&gt;mid)    ret=max(ret,query(x&lt;&lt;1|1,mid+1,r,L,R));\n        return ret;\n    }\n\n    void delet(int x,int l,int r,int d)\n    {\n        if(l==r){t[x]=make_pair(0,l);return;}\n        int mid=l+r&gt;&gt;1;\n        if(d&lt;=mid)    delet(x&lt;&lt;1,l,mid,d);\n        else        delet(x&lt;&lt;1|1,mid+1,r,d);\n        update(x);\n        return;\n    }\n\n}T;\nint tot;\nint dfs(int x)\n{\n    vis[x]=1;\n    T.delet(1,1,n,x);\n    if(to[x]!=n+1&amp;&amp;!vis[to[x]])dfs(to[x]);\n    if(a[x]&gt;1)\n    while(1)\n    {\n        pair&lt;int,int&gt; v=T.query(1,1,n,1,a[x]-1);\n        if(v.first&gt;x)dfs(v.second);\n        else    break;\n    }\n    d[x]=++tot;\n}\n\nint main()\n{\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i);\n    for(int i=1;i&lt;=n;++i)\n    if(a[i]!=-1)    to[a[i]]=i;\n    else    a[i]=n+1;\n    for(int i=1;i&lt;=n;++i)if(!to[i])to[i]=n+1;\n    T.build(1,1,n);\n    for(int i=1;i&lt;=n;++i)if(!vis[i])dfs(i);\n    for(int i=1;i&lt;=n;++i)printf(&quot;%d &quot;,d[i]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/08/31/Codeforces798E/","excerpt":"","categories":[{"name":"Codeforces&AtCoder","slug":"Codeforces-AtCoder","permalink":"https://prostkhala.github.io/categories/Codeforces-AtCoder/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://prostkhala.github.io/tags/线段树/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://prostkhala.github.io/tags/拓扑排序/"}]},{"title":"AtCoder Grand Contest 019 E  Shuffle and Swap","date":"2017-08-28T13:25:14.000Z","path":"2017/08/28/AtCoder Grand Contest 019 E  Shuffle and Swap/","text":"Shuffle and Swap 题目描述You have two strings A=A1A2…An and B=B1B2…Bn of the same length consisting of 0 and 1. The number of 1’s in A and B is equal. You’ve decided to transform A using the following algorithm: Let a1, a2, …, ak be the indices of 1’s in A. Let b1, b2, …, bk be the indices of 1’s in B. Replace a and b with their random permutations, chosen independently and uniformly. For each i from 1 to k, in order, swap Aai and Abi. Let P be the probability that strings A and B become equal after the procedure above. Let Z=P×(k!)2. Clearly, Z is an integer. Find Z modulo 998244353. 输入输出格式输入格式： Input is given from Standard Input in the following format: A B 输出格式： Print the value of Z modulo 998244353. 输入输出样例输入样例1：1010 1100 输出样例1：3 输入样例2：101010 010101 输出样例2：36 输入样例3：1101011011110 0111101011101 输出样例3：932171449 数据范围 1≤|A|=|B|≤10,000 A and B consist of 0 and 1. A and B contain the same number of 1’s. A and B contain at least one 1. 题解题目大意为将A与B中所有为一处的下标分别加入a，b集合，求有多少种a，b的排列满足在依次交换$A_{a_i}$，$A_{b_i}$后满足A=B。 交换操作实际为将A中的1调整匹配到B中1的位置，所以当不存在$A_i=B_i=1$时，不论如何打乱a，b的排列，在操作后总有A=B。当存在$A_i=B_i=1$时，$A_i$的交换有两种情况： $A_i$ 所对应的 $B_i$ 为 1。 $A_i$ 所对应的 $B_i$ 为 0。 在进行第一种交换后，如果与0进行交换后，需要在操作结束后重新交换回来。那么我们不妨从$A_i$到$B_i$连一条边，易知每一个点出度入度均不超过1，且根据以上结论，设x为$A_i=B_i=1$的个数，y为$A_i!=B_i and A_i=1$的个数，可知该生成图共有y条链，且x个点可以作为变换的中转节点加入y条链中，那么我们可设$f(i,j)$表示在前i条链加入j个节点点的方案数，转移方程如下： f[0][0]=1; for(int i=1;i&lt;=y;++i) for(int j=0;j&lt;=x;++j) for(int k=0;k&lt;=j;++k) (f[i][j]+=f[i-1][j-k]*rev[k+1])%=mod;(rev[k+1]为k+1阶乘的逆元) 该DP时间复杂度为$O（n^3）$，期望得分为1200。考虑进行优化，观察可知$f[i-1][j-k]×rev[k+1]$为卷积形式，可以用NTT进行优化，代码如下： f[0][0]=1; for(int i=1;i&lt;=y;++i) { for(int j=x+1;j&lt;=x*3;++j)a[j]=b[j]=0; for(int j=0;j&lt;=x;++j)a[j]=f[(i-1)&amp;1][j],b[j]=rev[j+1]; NTT(a,b,x); for(int j=0;j&lt;=x;++j)f[i&amp;1][j]=a[j]; } 此处观察易知，该方程实质上就是将f数组乘了y遍rev数组，加上快速幂优化即可通过极限数据，期望得分1700： a[0]=1; for(int i=0;i&lt;=x;++i)b[i]=rev[i+1]; for(int t=y;t;t&gt;&gt;=1) { for(int i=x+1;i&lt;N;++i)a[i]=b[i]=c[i]=d[i]=0; if(t&amp;1)NTT(a,b,x,0); NTT(b,b,x,1); } CODE#include&lt;bits/stdc++.h&gt; #define inv(x) qpow(x,mod-2) using namespace std; typedef long long ll; const int N = 5e4+1; const ll mod = 998244353; const ll G = 3; const double pi = acos(-1); char a1[N],b1[N]; int x,y; ll rev[N],fac[N],r[N]; ll a[N],b[N],c[N],d[N]; int qpow(ll a,int b) { ll ret=1; while(b) { if(b&amp;1)ret=(ret*a)%mod; b&gt;&gt;=1; a=(a*a)%mod; } return ret; } void pre() { ll i; for(i=1,fac[0]=1;i&lt;N;++i)fac[i]=(fac[i-1]*i)%mod; for(rev[N-1]=inv(fac[N-1]),i=N-2;i&gt;=0;--i)rev[i]=(rev[i+1]*(i+1))%mod; } inline void ntt(ll *a,int f,ll n) { for(int i=0;i&lt;n;i++)if(i&lt;r[i])swap(a[i],a[r[i]]); for(int i=1,t=1;i&lt;n;i&lt;&lt;=1,++t) { ll wn=qpow(G,(mod-1)/(1&lt;&lt;t)); if(f==-1) wn=inv(wn); for(int j=0;j&lt;n;j+=(i&lt;&lt;1)) for(ll k=0,w=1;k&lt;i;k++,w=w*wn%mod) { ll x=a[j+k],y=a[j+k+i]*w%mod; a[j+k]=(x+y)%mod;a[j+k+i]=(x-y+mod)%mod; } } } void NTT(ll *a,ll *b,ll len,bool tag) { ll n=1,m=0; while(n&lt;=2*len)n&lt;&lt;=1,m++; for(int i=0;i&lt;n;++i)r[i]=r[i&gt;&gt;1]&gt;&gt;1|(1&amp;i)&lt;&lt;(m-1); copy(a,a+x+1,c);copy(b,b+x+1,d); for(int i=x+1;i&lt;N;++i)a[i]=b[i]=c[i]=d[i]=0; ntt(c,1,n);ntt(d,1,n); for(int i=0;i&lt;n;++i)(c[i]*=d[i])%=mod; ntt(c,-1,n);ll t=inv(n); for(int i=0;i&lt;=len;++i)a[i]=c[i]*t%mod; return; } /* 1101011011110 0111101011101 */ int main() { pre(); scanf(&quot;%s%s&quot;,a1+1,b1+1); int len=strlen(a1+1); for(int i=1;i&lt;=len;++i) if(b1[i]==&#39;1&#39;&amp;&amp;a1[i]==&#39;1&#39;)x++; else if(a1[i]==&#39;1&#39;)y++; a[0]=1; for(int i=0;i&lt;=x;++i)b[i]=rev[i+1]; for(int t=y;t;t&gt;&gt;=1) { for(int i=x+1;i&lt;N;++i)a[i]=b[i]=c[i]=d[i]=0; if(t&amp;1)NTT(a,b,x,0); NTT(b,b,x,1); } ll ans=0; for(int i=0;i&lt;=x;++i)(ans+=a[i]*fac[x]%mod*fac[y]%mod*fac[x+y])%=mod; cout&lt;&lt;ans; }","raw":"title: AtCoder Grand Contest 019 E  Shuffle and Swap \ndate: 2017-08-28 21:25:14\ncategories:\n  - Codeforces&AtCoder\ntags:\n  - FFT\n  - 组合数学\n  - 动态规划\n  - 逆元\n  - 快速幂\n---\n\n\n# [Shuffle and Swap](http://agc019.contest.atcoder.jp/tasks/agc019_e)\n---\n## 题目描述\nYou have two strings A=A1A2…An and B=B1B2…Bn of the same length consisting of 0 and 1. The number of 1's in A and B is equal.\n\nYou've decided to transform A using the following algorithm:\n\n * Let a1, a2, ..., ak be the indices of 1's in A.\n *  Let b1, b2, ..., bk be the indices of 1's in B.\n *  Replace a and b with their random permutations, chosen independently and uniformly.\n *  For each i from 1 to k, in order, swap Aai and Abi.\n\nLet P be the probability that strings A and B become equal after the procedure above.\n\nLet Z=P×(k!)2. Clearly, Z is an integer.\n\nFind Z modulo 998244353.\n\n### 输入输出格式\n#### 输入格式：\n* Input is given from Standard Input in the following format:\n\n\n\tA\n    \n\tB\n\n\n\n\n#### 输出格式：\n* Print the value of Z modulo 998244353.\n\n\n### 输入输出样例\n#### 输入样例1：\n    1010\n\t1100\n\n#### 输出样例1：\n\t3\n    \n#### 输入样例2：\n\t101010\n\t010101\n\n#### 输出样例2：\n\t36\n#### 输入样例3：\n    1101011011110\n\t0111101011101\n\n#### 输出样例3：\n\t932171449\n\n### 数据范围\n\n  * 1≤|A|=|B|≤10,000\n  * A and B consist of 0 and 1.\n  * A and B contain the same number of 1's.\n  * A and B contain at least one 1.\n \n---\n\n## 题解\n题目大意为将A与B中所有为一处的下标分别加入a，b集合，求有多少种a，b的排列满足在依次交换$A_{a_i}$，$A_{b_i}$后满足A=B。\n\n交换操作实际为将A中的1调整匹配到B中1的位置，所以当不存在$A_i=B_i=1$时，不论如何打乱a，b的排列，在操作后总有A=B。当存在$A_i=B_i=1$时，$A_i$的交换有两种情况：\n\n* $A_i$ 所对应的 $B_i$ 为 1。\n* $A_i$ 所对应的 $B_i$ 为 0。\n\n在进行第一种交换后，如果与0进行交换后，需要在操作结束后重新交换回来。那么我们不妨从$A_i$到$B_i$连一条边，易知每一个点出度入度均不超过1，且根据以上结论，设x为$A_i=B_i=1$的个数，y为$A_i!=B_i \\ and \\ A_i=1$的个数，可知该生成图共有y条链，且x个点可以作为变换的中转节点加入y条链中，那么我们可设$f(i,j)$表示在前i条链加入j个节点点的方案数，转移方程如下：\n\n\tf[0][0]=1;\n\tfor(int i=1;i<=y;++i)\n\tfor(int j=0;j<=x;++j)\n\tfor(int k=0;k<=j;++k)\n\t(f[i][j]+=f[i-1][j-k]*rev[k+1])%=mod;(rev[k+1]为k+1阶乘的逆元)\n    \n该DP时间复杂度为$O（n^3）$，期望得分为1200。\n考虑进行优化，观察可知$f[i-1][j-k]×rev[k+1]$为卷积形式，可以用NTT进行优化，代码如下：\n\n\tf[0][0]=1;\n\tfor(int i=1;i<=y;++i)\n\t{\n\t\tfor(int j=x+1;j<=x*3;++j)a[j]=b[j]=0;\n\t\tfor(int j=0;j<=x;++j)a[j]=f[(i-1)&1][j],b[j]=rev[j+1];\n\t\tNTT(a,b,x);\n\t\tfor(int j=0;j<=x;++j)f[i&1][j]=a[j];\n\t}\n\n此处观察易知，该方程实质上就是将f数组乘了y遍rev数组，加上快速幂优化即可通过极限数据，期望得分1700：\n\n\ta[0]=1;\n\tfor(int i=0;i<=x;++i)b[i]=rev[i+1];\n\tfor(int t=y;t;t>>=1)\n\t{\n\t\tfor(int i=x+1;i<N;++i)a[i]=b[i]=c[i]=d[i]=0;\n\t\tif(t&1)NTT(a,b,x,0);\n\t\tNTT(b,b,x,1);\n\t}\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    #define inv(x) qpow(x,mod-2)\n    using namespace std;\n    typedef long long ll;\n\n    const int N = 5e4+1;\n    const ll mod = 998244353;\n    const ll G = 3;\n    const double pi = acos(-1);\n\n    char a1[N],b1[N];\n    int x,y;\n    ll rev[N],fac[N],r[N];\n    ll a[N],b[N],c[N],d[N];\n\n    int qpow(ll a,int b)\n    {\n        ll ret=1;\n        while(b)\n        {\n            if(b&1)ret=(ret*a)%mod;\n            b>>=1;\n            a=(a*a)%mod;\n        }\n        return ret;\n    }\n\n    void pre()\n    {\n        ll i;\n        for(i=1,fac[0]=1;i<N;++i)fac[i]=(fac[i-1]*i)%mod;\n        for(rev[N-1]=inv(fac[N-1]),i=N-2;i>=0;--i)rev[i]=(rev[i+1]*(i+1))%mod;\n    }\n\n    inline void ntt(ll *a,int f,ll n)\n    {\n        for(int i=0;i<n;i++)if(i<r[i])swap(a[i],a[r[i]]);\n        for(int i=1,t=1;i<n;i<<=1,++t)\n        {\n            ll wn=qpow(G,(mod-1)/(1<<t));\n            if(f==-1) wn=inv(wn);\n            for(int j=0;j<n;j+=(i<<1))\n            for(ll k=0,w=1;k<i;k++,w=w*wn%mod)\n            {\n                ll x=a[j+k],y=a[j+k+i]*w%mod;\n                a[j+k]=(x+y)%mod;a[j+k+i]=(x-y+mod)%mod;\n            }\n        }\n    }\n\n    void NTT(ll *a,ll *b,ll len,bool tag)\n    {\n        ll n=1,m=0;\n        while(n<=2*len)n<<=1,m++;\n        for(int i=0;i<n;++i)r[i]=r[i>>1]>>1|(1&i)<<(m-1);\n        copy(a,a+x+1,c);copy(b,b+x+1,d);\n        for(int i=x+1;i<N;++i)a[i]=b[i]=c[i]=d[i]=0;\n        ntt(c,1,n);ntt(d,1,n);\n        for(int i=0;i<n;++i)(c[i]*=d[i])%=mod;\n        ntt(c,-1,n);ll t=inv(n);\n        for(int i=0;i<=len;++i)a[i]=c[i]*t%mod;\n        return;\n    }\n\n    /*\n\n    1101011011110\n    0111101011101\n\n    */\n\n    int main()\n    {\n        pre();\n        scanf(\"%s%s\",a1+1,b1+1);\n        int len=strlen(a1+1);\n        for(int i=1;i<=len;++i)\n        if(b1[i]=='1'&&a1[i]=='1')x++;\n        else if(a1[i]=='1')y++;\n        a[0]=1;\n        for(int i=0;i<=x;++i)b[i]=rev[i+1];\n        for(int t=y;t;t>>=1)\n        {\n            for(int i=x+1;i<N;++i)a[i]=b[i]=c[i]=d[i]=0;\n            if(t&1)NTT(a,b,x,0);\n            NTT(b,b,x,1);\n        }\n        ll ans=0;\n        for(int i=0;i<=x;++i)(ans+=a[i]*fac[x]%mod*fac[y]%mod*fac[x+y])%=mod;\n        cout<<ans;\n    }","content":"<h1 id=\"Shuffle-and-Swap\"><a href=\"#Shuffle-and-Swap\" class=\"headerlink\" title=\"Shuffle and Swap\"></a><a href=\"http://agc019.contest.atcoder.jp/tasks/agc019_e\" target=\"_blank\" rel=\"external\">Shuffle and Swap</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>You have two strings A=A1A2…An and B=B1B2…Bn of the same length consisting of 0 and 1. The number of 1’s in A and B is equal.</p>\n<p>You’ve decided to transform A using the following algorithm:</p>\n<ul>\n<li>Let a1, a2, …, ak be the indices of 1’s in A.</li>\n<li>Let b1, b2, …, bk be the indices of 1’s in B.</li>\n<li>Replace a and b with their random permutations, chosen independently and uniformly.</li>\n<li>For each i from 1 to k, in order, swap Aai and Abi.</li>\n</ul>\n<p>Let P be the probability that strings A and B become equal after the procedure above.</p>\n<p>Let Z=P×(k!)2. Clearly, Z is an integer.</p>\n<p>Find Z modulo 998244353.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><ul>\n<li>Input is given from Standard Input in the following format:</li>\n</ul>\n<pre><code>A\n\nB\n</code></pre><h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><ul>\n<li>Print the value of Z modulo 998244353.</li>\n</ul>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例1：\"><a href=\"#输入样例1：\" class=\"headerlink\" title=\"输入样例1：\"></a>输入样例1：</h4><pre><code>1010\n1100\n</code></pre><h4 id=\"输出样例1：\"><a href=\"#输出样例1：\" class=\"headerlink\" title=\"输出样例1：\"></a>输出样例1：</h4><pre><code>3\n</code></pre><h4 id=\"输入样例2：\"><a href=\"#输入样例2：\" class=\"headerlink\" title=\"输入样例2：\"></a>输入样例2：</h4><pre><code>101010\n010101\n</code></pre><h4 id=\"输出样例2：\"><a href=\"#输出样例2：\" class=\"headerlink\" title=\"输出样例2：\"></a>输出样例2：</h4><pre><code>36\n</code></pre><h4 id=\"输入样例3：\"><a href=\"#输入样例3：\" class=\"headerlink\" title=\"输入样例3：\"></a>输入样例3：</h4><pre><code>1101011011110\n0111101011101\n</code></pre><h4 id=\"输出样例3：\"><a href=\"#输出样例3：\" class=\"headerlink\" title=\"输出样例3：\"></a>输出样例3：</h4><pre><code>932171449\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><ul>\n<li>1≤|A|=|B|≤10,000</li>\n<li>A and B consist of 0 and 1.</li>\n<li>A and B contain the same number of 1’s.</li>\n<li>A and B contain at least one 1.</li>\n</ul>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意为将A与B中所有为一处的下标分别加入a，b集合，求有多少种a，b的排列满足在依次交换$A_{a_i}$，$A_{b_i}$后满足A=B。</p>\n<p>交换操作实际为将A中的1调整匹配到B中1的位置，所以当不存在$A_i=B_i=1$时，不论如何打乱a，b的排列，在操作后总有A=B。当存在$A_i=B_i=1$时，$A_i$的交换有两种情况：</p>\n<ul>\n<li>$A_i$ 所对应的 $B_i$ 为 1。</li>\n<li>$A_i$ 所对应的 $B_i$ 为 0。</li>\n</ul>\n<p>在进行第一种交换后，如果与0进行交换后，需要在操作结束后重新交换回来。那么我们不妨从$A_i$到$B_i$连一条边，易知每一个点出度入度均不超过1，且根据以上结论，设x为$A_i=B_i=1$的个数，y为$A_i!=B_i  and  A_i=1$的个数，可知该生成图共有y条链，且x个点可以作为变换的中转节点加入y条链中，那么我们可设$f(i,j)$表示在前i条链加入j个节点点的方案数，转移方程如下：</p>\n<pre><code>f[0][0]=1;\nfor(int i=1;i&lt;=y;++i)\nfor(int j=0;j&lt;=x;++j)\nfor(int k=0;k&lt;=j;++k)\n(f[i][j]+=f[i-1][j-k]*rev[k+1])%=mod;(rev[k+1]为k+1阶乘的逆元)\n</code></pre><p>该DP时间复杂度为$O（n^3）$，期望得分为1200。<br>考虑进行优化，观察可知$f[i-1][j-k]×rev[k+1]$为卷积形式，可以用NTT进行优化，代码如下：</p>\n<pre><code>f[0][0]=1;\nfor(int i=1;i&lt;=y;++i)\n{\n    for(int j=x+1;j&lt;=x*3;++j)a[j]=b[j]=0;\n    for(int j=0;j&lt;=x;++j)a[j]=f[(i-1)&amp;1][j],b[j]=rev[j+1];\n    NTT(a,b,x);\n    for(int j=0;j&lt;=x;++j)f[i&amp;1][j]=a[j];\n}\n</code></pre><p>此处观察易知，该方程实质上就是将f数组乘了y遍rev数组，加上快速幂优化即可通过极限数据，期望得分1700：</p>\n<pre><code>a[0]=1;\nfor(int i=0;i&lt;=x;++i)b[i]=rev[i+1];\nfor(int t=y;t;t&gt;&gt;=1)\n{\n    for(int i=x+1;i&lt;N;++i)a[i]=b[i]=c[i]=d[i]=0;\n    if(t&amp;1)NTT(a,b,x,0);\n    NTT(b,b,x,1);\n}\n</code></pre><hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\n#define inv(x) qpow(x,mod-2)\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 5e4+1;\nconst ll mod = 998244353;\nconst ll G = 3;\nconst double pi = acos(-1);\n\nchar a1[N],b1[N];\nint x,y;\nll rev[N],fac[N],r[N];\nll a[N],b[N],c[N],d[N];\n\nint qpow(ll a,int b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&amp;1)ret=(ret*a)%mod;\n        b&gt;&gt;=1;\n        a=(a*a)%mod;\n    }\n    return ret;\n}\n\nvoid pre()\n{\n    ll i;\n    for(i=1,fac[0]=1;i&lt;N;++i)fac[i]=(fac[i-1]*i)%mod;\n    for(rev[N-1]=inv(fac[N-1]),i=N-2;i&gt;=0;--i)rev[i]=(rev[i+1]*(i+1))%mod;\n}\n\ninline void ntt(ll *a,int f,ll n)\n{\n    for(int i=0;i&lt;n;i++)if(i&lt;r[i])swap(a[i],a[r[i]]);\n    for(int i=1,t=1;i&lt;n;i&lt;&lt;=1,++t)\n    {\n        ll wn=qpow(G,(mod-1)/(1&lt;&lt;t));\n        if(f==-1) wn=inv(wn);\n        for(int j=0;j&lt;n;j+=(i&lt;&lt;1))\n        for(ll k=0,w=1;k&lt;i;k++,w=w*wn%mod)\n        {\n            ll x=a[j+k],y=a[j+k+i]*w%mod;\n            a[j+k]=(x+y)%mod;a[j+k+i]=(x-y+mod)%mod;\n        }\n    }\n}\n\nvoid NTT(ll *a,ll *b,ll len,bool tag)\n{\n    ll n=1,m=0;\n    while(n&lt;=2*len)n&lt;&lt;=1,m++;\n    for(int i=0;i&lt;n;++i)r[i]=r[i&gt;&gt;1]&gt;&gt;1|(1&amp;i)&lt;&lt;(m-1);\n    copy(a,a+x+1,c);copy(b,b+x+1,d);\n    for(int i=x+1;i&lt;N;++i)a[i]=b[i]=c[i]=d[i]=0;\n    ntt(c,1,n);ntt(d,1,n);\n    for(int i=0;i&lt;n;++i)(c[i]*=d[i])%=mod;\n    ntt(c,-1,n);ll t=inv(n);\n    for(int i=0;i&lt;=len;++i)a[i]=c[i]*t%mod;\n    return;\n}\n\n/*\n\n1101011011110\n0111101011101\n\n*/\n\nint main()\n{\n    pre();\n    scanf(&quot;%s%s&quot;,a1+1,b1+1);\n    int len=strlen(a1+1);\n    for(int i=1;i&lt;=len;++i)\n    if(b1[i]==&#39;1&#39;&amp;&amp;a1[i]==&#39;1&#39;)x++;\n    else if(a1[i]==&#39;1&#39;)y++;\n    a[0]=1;\n    for(int i=0;i&lt;=x;++i)b[i]=rev[i+1];\n    for(int t=y;t;t&gt;&gt;=1)\n    {\n        for(int i=x+1;i&lt;N;++i)a[i]=b[i]=c[i]=d[i]=0;\n        if(t&amp;1)NTT(a,b,x,0);\n        NTT(b,b,x,1);\n    }\n    ll ans=0;\n    for(int i=0;i&lt;=x;++i)(ans+=a[i]*fac[x]%mod*fac[y]%mod*fac[x+y])%=mod;\n    cout&lt;&lt;ans;\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/08/28/AtCoder Grand Contest 019 E  Shuffle and Swap/","excerpt":"","categories":[{"name":"Codeforces&AtCoder","slug":"Codeforces-AtCoder","permalink":"https://prostkhala.github.io/categories/Codeforces-AtCoder/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"},{"name":"逆元","slug":"逆元","permalink":"https://prostkhala.github.io/tags/逆元/"},{"name":"FFT","slug":"FFT","permalink":"https://prostkhala.github.io/tags/FFT/"},{"name":"快速幂","slug":"快速幂","permalink":"https://prostkhala.github.io/tags/快速幂/"}]},{"title":"线性基题目总结","date":"2017-08-28T13:25:14.000Z","path":"2017/08/28/线性基题目总结/","text":"题目描述 输入输出格式输入格式:第一行包含两个整数N和 M， 表示该无向图中点的数目与边的数目。 接下来M 行描述 M 条边，每行三个整数Si，Ti ，Di，表示 Si 与Ti之间存在 一条权值为 Di的无向边。 图中可能有重边或自环。 输出格式：仅包含一个整数，表示最大的XOR和（十进制结果）,注意输出后加换行回车。 输入输出样例输入样例：5 7 1 2 2 1 3 2 2 4 1 2 5 1 4 5 3 5 3 4 4 3 2 输出样例：6 数据范围：题解裸线性基，曾经在CF上做过这题，大致思路就是将所有能遍历到的环插入线性基内，因为一定能通过经过一条路径绕环一圈再从这个路径回来的方式，使得答案异或上环的权值，那么任取一条$1$到$n$的路径到线性基中求异或最大值即可。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 2e5+1; struct XOR{ ll a[63]; void add(ll x){ for(int i=62;i&gt;=0;--i) if((x&gt;&gt;i)&amp;1)x^=a[i]; for(int i=62;i&gt;=0;--i) if(((x&gt;&gt;i)&amp;1)&amp;&amp;!a[i]){ a[i]=x; for(int j=i+1;j&lt;=62;++j) if((a[j]&gt;&gt;i)&amp;1)a[j]^=x; return; } } ll sum(ll x){ for(int i=62;i&gt;=0;--i) if(((x&gt;&gt;i)&amp;1)==0)x^=a[i]; return x; } }T; int head[N],n,m; bool vis[N]; ll d[N]; struct nd{ int ne,to;ll w; }e[N*2]; void in(int x,int y,ll w){ static int cnt=0; e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w; } void dfs(int x,ll w){ vis[x]=1; d[x]=w; for(int i=head[x];i;i=e[i].ne){ int y=e[i].to; if(vis[y])T.add(d[x]^d[y]^e[i].w); else dfs(y,w^e[i].w); } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); ll w; for(int i=1,x,y;i&lt;=m;++i)scanf(&quot;%d%d%lld&quot;,&amp;x,&amp;y,&amp;w),in(x,y,w),in(y,x,w); dfs(1,0); printf(&quot;%lld\\n&quot;,T.sum(d[n])); } BZOJ2844 albus就是要第一个出场 题目描述已知一个长度为n的正整数序列A（下标从1开始）， 令 S = { x | 1 &lt;= x &lt;= n }, S 的幂集2^S定义为S 所有子集构成的集合。定义映射 f : 2^S -&gt; Zf(空集) = 0f(T) = XOR A[t] , 对于一切t属于T现在albus把2^S中每个集合的f值计算出来， 从小到大排成一行， 记为序列B（下标从1开始）。 给定一个数， 那么这个数在序列B中第1次出现时的下标是多少呢？ 输入输出格式输入格式:第一行一个数n, 为序列A的长度。接下来一行n个数， 为序列A， 用空格隔开。最后一个数Q， 为给定的数. 输出格式：共一行， 一个整数， 为Q在序列B中第一次出现时的下标模10086的值. 输入输出样例输入样例：3 1 2 3 1 输出样例：3 数据范围数据范围： 1 &lt;= N &lt;= 10,0000 其他所有输入均不超过10^9 题解此题实际上为求$k$小线性基的对偶问题，如不不考虑重复的话，直接二分皆可解决。考虑上重复的问题，不妨设$cnt$为线性基底个数，那么显然不重复的异或值只有$2^{cnt}$中，即有$n-cnt$个线性无关变量，即每一种异或值都可以经过$2^{n-cnt}$种变换仍不改变，即每一种异或值共重复了$2^{n-cnt}$次，去重二分后计算上重复次数即可得到答案。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e5+1; const ll mod = 10086; int n,q[N],Q,cnt; struct Xor{ int a[N],b[N]; void add(int x){ for(int i=31;i&gt;=0;--i) if((x&gt;&gt;i)&amp;1)x^=a[i]; for(int i=31;i&gt;=0;--i) if(((x&gt;&gt;i)&amp;1)&amp;&amp;!a[i]){ a[i]=x; for(int j=i+1;j&lt;=31;++j) if((a[j]&gt;&gt;i)&amp;1)a[j]^=x; return; } } void init(){ cnt=0; for(int i=0;i&lt;=31;++i) if(a[i])b[++cnt]=a[i]; } int kth(int k){ if(k&gt;(1&lt;&lt;cnt))return 2e9; int ret=0; for(int i=1;i&lt;=cnt;++i) if((k&gt;&gt;(i-1))&amp;1)ret^=b[i]; return ret; } }T; ll qpow(ll a,ll b){ ll ret=1; while(b){ if(b&amp;1)ret=ret*a%mod; b&gt;&gt;=1; a=a*a%mod; } return ret; } int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;q[i]),T.add(q[i]); scanf(&quot;%d&quot;,&amp;Q); T.init(); int l=0,r=(1&lt;&lt;cnt)-1; while(l!=r){ int mid=l+r&gt;&gt;1; if(T.kth(mid)&gt;=Q)r=mid; else l=mid+1; } printf(&quot;%d&quot;,(1ll+qpow(2,n-cnt)*(ll)l)%mod); } /* 3 1 2 3 3 */ CQOI2013 新Nim游戏 题目描述传统的Nim游戏是这样的：有一些火柴堆，每堆都有若干根火柴（不同堆的火柴数量可以不同）。两个游戏者轮流操作，每次可以选一个火柴堆拿走若干根火柴。可以只拿一根，也可以拿走整堆火柴，但不能同时从超过一堆火柴中拿。拿走最后一根火柴的游戏者胜利。 本题的游戏稍微有些不同：在第一个回合中，第一个游戏者可以直接拿走若干个整堆的火柴。可以一堆都不拿，但不可以全部拿走。第二回合也一样，第二个游戏者也有这样一次机会。从第三个回合（又轮到第一个游戏者）开始，规则和Nim游戏一样。 如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。 输入输出格式输入格式:第一行为整数k。即火柴堆数。第二行包含k个不超过109的正整数，即各堆的火柴个数。 输出格式：输出第一回合拿的火柴数目的最小值。如果不能保证取胜，输出-1。 输入输出样例输入样例：6 5 5 6 6 5 5 输出样例：21 数据范围k&lt;=100 题解对于后手玩家来说，只要存在多个基底异或值为零，即可将其余所有火柴删除，使得所有最后普通nim游戏有异或值为$0$，即后手胜。那么先手玩家为了避免这种情况需要删除所以可能导致异或值为$0$的情况，即可能有线性无关变量的情况（易知不存在先手必败的情况），那么如何将第一个人删除的尽可能少，可以将所有火柴排个序，从大到小插入线性基中，如果为线性无关变量，则直接统计进答案即可。（具体证明需要考虑拟阵，暂时没学。） CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e5+1; int n,a[N]; struct Xor{ int a[32]; bool add(int x){ for(int i=31;i&gt;=0;--i) if((x&gt;&gt;i)&amp;1)x^=a[i]; for(int i=31;i&gt;=0;--i) if(((x&gt;&gt;i)&amp;1)&amp;&amp;!a[i]){ a[i]=x; for(int j=i+1;j&lt;=31;++j) if((a[j]&gt;&gt;i)&amp;1)a[j]^=x; return 1; } return 0; } }T; int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); ll ans=0; for(int i=n;i&gt;=1;--i)if(!T.add(a[i]))ans+=a[i]; printf(&quot;%lld&quot;,ans); } /* 6 5 5 6 6 5 5 */ SCOI2016 幸运数字 题目描述A 国共有 n 座城市，这些城市由 n-1 条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。一些旅行者希望游览 A 国。旅行者计划乘飞机降落在 x 号城市，沿着 x 号城市到 y 号城市之间那条唯一的路径游览，最终从 y 城市起飞离开 A 国。在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。例如，游览者拍了 3 张照片，幸运值分别是 5，7，11，那么最终保留在自己身上的幸运值就是 9（5 xor 7 xor 11）。有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择 5和 11 ，可以保留的幸运值为 14 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。 输入输出格式输入格式:第一行包含 2 个正整数 n ，q，分别表示城市的数量和旅行者数量。第二行包含 n 个非负整数，其中第 i 个整数 Gi 表示 i 号城市的幸运值。随后 n-1 行，每行包含两个正整数 x ，y，表示 x 号城市和 y 号城市之间有一条道路相连。随后 q 行，每行包含两个正整数 x ，y，表示这名旅行者的旅行计划是从 x 号城市到 y 号城市。N&lt;=20000,Q&lt;=200000,Gi&lt;=2^60 输出格式： 输出需要包含 q 行，每行包含 1 个非负整数，表示这名旅行者可以保留的最大幸运值。 输入输出样例输入样例：4 2 11 5 7 9 1 2 1 3 1 4 2 3 1 4 输出样例：14 11 题解该题实际上就是将$x$到$y$中所有权值插入线性基中求异或最大值即为答案，观察$n&lt;=20000$的性质，可以通过倍增维护,每次查询启发式合并即可。 CODE#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 2e4+1; int read(){ int x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;,ch=getchar(); return x; } struct Xor{ ll a[61]; void add(ll x){ for(int i=60;i&gt;=0;--i) if((x&gt;&gt;i)&amp;1)x^=a[i]; if(!x)return; for(int i=60;i&gt;=0;--i) if(((x&gt;&gt;i)&amp;1)&amp;&amp;!a[i]){ a[i]=x; for(int j=i+1;j&lt;=60;++j) if((a[j]&gt;&gt;i)&amp;1)a[j]^=x; return; } } void init(){ memset(a,0,sizeof(a)); } ll mx(){ ll ret=0; for(int i=60;i&gt;=0;--i) if(((ret&gt;&gt;i)&amp;1)==0)ret^=a[i]; return ret; } }g[N][15],R; Xor mix(Xor a,Xor b){ Xor c;c.init(); int cnta=0,cntb=0; for(int i=0;i&lt;=60;++i)if(a.a[i])cnta++; for(int i=0;i&lt;=60;++i)if(b.a[i])cntb++; if(cnta&gt;=cntb){ for(int i=0;i&lt;=60;++i)c.a[i]=a.a[i]; for(int i=0;i&lt;=60;++i) if(b.a[i])c.add(b.a[i]); } else{ for(int i=0;i&lt;=60;++i)c.a[i]=b.a[i]; for(int i=0;i&lt;=60;++i) if(a.a[i])c.add(a.a[i]); } return c; } int head[N],cnt,n,m,Q,f[N][15],d[N],fa[N]; ll a[N]; struct nd{ int to,ne; }e[N*2]; void in(int x,int y){ e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt; } void dfs(int x){ for(int i=head[x];i;i=e[i].ne) if(e[i].to!=fa[x]){ int y=e[i].to; fa[y]=x; f[y][0]=x;g[y][0].add(a[x]); d[y]=d[x]+1; dfs(y); } } void pre(){ for(int j=1;j&lt;15;++j) for(int i=1;i&lt;=n;++i){ f[i][j]=f[f[i][j-1]][j-1]; g[i][j]=mix(g[f[i][j-1]][j-1],g[i][j-1]); } } int lca(int x,int y){ R.init(); if(d[x]&lt;d[y])swap(x,y); for(int i=14;i&gt;=0;--i) if(d[f[x][i]]&gt;=d[y]){ R=mix(R,g[x][i]); x=f[x][i]; } if(x==y)return x; for(int i=14;i&gt;=0;--i) if(f[x][i]!=f[y][i]){ R=mix(R,g[x][i]);R=mix(R,g[y][i]); x=f[x][i],y=f[y][i]; } R.add(a[f[x][0]]); return f[x][0]; } ll solve(int x,int y){ // cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; int l=lca(x,y); R.add(a[x]);R.add(a[y]); return R.mx(); } int main(){ n=read();Q=read(); for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=1,x,y;i&lt;n;++i)x=read(),y=read(),in(x,y),in(y,x); d[1]=1;dfs(1); pre(); for(int i=1,x,y;i&lt;=Q;++i)printf(&quot;%lld\\n&quot;,solve(read(),read())); } /* 4 2 11 5 7 9 1 2 1 3 1 4 2 3 1 4 */","raw":"title: 线性基题目总结\ndate: 2017-08-28 21:25:14\ncategories:\n  - 数论\ntags:\n  - 线性基\n  - 动态规划\n---\n\n# []()\n---\n## 题目描述\n![](http://www.lydsy.com/JudgeOnline/images/2606_1.jpg)\n### 输入输出格式\n#### 输入格式:\n第一行包含两个整数N和 M， 表示该无向图中点的数目与边的数目。 接下来M 行描述 M 条边，每行三个整数Si，Ti ，Di，表示 Si 与Ti之间存在 一条权值为 Di的无向边。 图中可能有重边或自环。\n#### 输出格式：\n仅包含一个整数，表示最大的XOR和（十进制结果）,注意输出后加换行回车。\n### 输入输出样例\n#### 输入样例：\n    5 7 \n    1 2 2 \n    1 3 2 \n    2 4 1 \n    2 5 1 \n    4 5 3 \n    5 3 4 \n    4 3 2 \n#### 输出样例：\n\t6\n### 数据范围：\n![](http://www.lydsy.com/JudgeOnline/images/2606_3.jpg)\n---\n## 题解\n裸线性基，曾经在CF上做过这题，大致思路就是将所有能遍历到的环插入线性基内，因为一定能通过经过一条路径绕环一圈再从这个路径回来的方式，使得答案异或上环的权值，那么任取一条$1$到$n$的路径到线性基中求异或最大值即可。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 2e5+1;\n\n    struct XOR{\n        ll a[63];\n        void add(ll x){\n            for(int i=62;i>=0;--i)\n            if((x>>i)&1)x^=a[i];\n            for(int i=62;i>=0;--i)\n            if(((x>>i)&1)&&!a[i]){\n                a[i]=x;\n                for(int j=i+1;j<=62;++j)\n                if((a[j]>>i)&1)a[j]^=x;\n                return;\n            }\n        }\n        ll sum(ll x){\n            for(int i=62;i>=0;--i)\n            if(((x>>i)&1)==0)x^=a[i];\n            return x;\n        }\n    }T;\n\n    int head[N],n,m;\n    bool vis[N];\n    ll d[N];\n\n    struct nd{\n        int ne,to;ll w;\n    }e[N*2];\n\n    void in(int x,int y,ll w){\n        static int cnt=0;\n        e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;\n    }\n\n    void dfs(int x,ll w){\n        vis[x]=1;\n        d[x]=w;\n        for(int i=head[x];i;i=e[i].ne){\n            int y=e[i].to;\n            if(vis[y])T.add(d[x]^d[y]^e[i].w);\n            else    dfs(y,w^e[i].w);\n        }\n    }\n\n    int main(){\n        scanf(\"%d%d\",&n,&m);\n        ll w;\n        for(int i=1,x,y;i<=m;++i)scanf(\"%d%d%lld\",&x,&y,&w),in(x,y,w),in(y,x,w);\n        dfs(1,0);\n        printf(\"%lld\\n\",T.sum(d[n]));\n    }\n---\n\n# [BZOJ2844 albus就是要第一个出场](http://www.lydsy.com/JudgeOnline/problem.php?id=2844)\n---\n## 题目描述\n已知一个长度为n的正整数序列A（下标从1开始）， 令 S = { x | 1 <= x <= n }, S 的幂集2^S定义为S 所有子\n集构成的集合。定义映射 f : 2^S -> Zf(空集) = 0f(T) = XOR A[t] , 对于一切t属于T现在albus把2^S中每个集\n合的f值计算出来， 从小到大排成一行， 记为序列B（下标从1开始）。 给定一个数， 那么这个数在序列B中第1\n次出现时的下标是多少呢？\n### 输入输出格式\n#### 输入格式:\n第一行一个数n, 为序列A的长度。接下来一行n个数， 为序列A， 用空格隔开。最后一个数Q， 为给定的数.\n#### 输出格式：\n共一行， 一个整数， 为Q在序列B中第一次出现时的下标模10086的值.\n### 输入输出样例\n#### 输入样例：\n    3\n    1 2 3\n    1\n#### 输出样例：\n\t3\n### 数据范围\n数据范围：\n\n1 <= N <= 10,0000\n\n其他所有输入均不超过10^9\n\n---\n\n## 题解\n此题实际上为求$k$小线性基的对偶问题，如不不考虑重复的话，直接二分皆可解决。考虑上重复的问题，不妨设$cnt$为线性基底个数，那么显然不重复的异或值只有$2^{cnt}$中，即有$n-cnt$个线性无关变量，即每一种异或值都可以经过$2^{n-cnt}$种变换仍不改变，即每一种异或值共重复了$2^{n-cnt}$次，去重二分后计算上重复次数即可得到答案。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e5+1;\n    const ll mod = 10086;\n    int n,q[N],Q,cnt;\n\n    struct Xor{\n        int a[N],b[N];\n        void add(int x){\n            for(int i=31;i>=0;--i)\n            if((x>>i)&1)x^=a[i];\n            for(int i=31;i>=0;--i)\n            if(((x>>i)&1)&&!a[i]){\n                a[i]=x;\n                for(int j=i+1;j<=31;++j)\n                if((a[j]>>i)&1)a[j]^=x;\n                return;\n            }\n        }\n        void init(){\n            cnt=0;\n            for(int i=0;i<=31;++i)\n            if(a[i])b[++cnt]=a[i];\n        }\n        int kth(int k){\n            if(k>(1<<cnt))return 2e9;\n            int ret=0;\n            for(int i=1;i<=cnt;++i)\n            if((k>>(i-1))&1)ret^=b[i];\n            return ret;\n        }\n    }T;\n\n    ll qpow(ll a,ll b){\n        ll ret=1;\n        while(b){\n            if(b&1)ret=ret*a%mod;\n            b>>=1;\n            a=a*a%mod;\n        }\n        return ret;\n    }\n\n    int main(){\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;++i)scanf(\"%d\",&q[i]),T.add(q[i]);\n        scanf(\"%d\",&Q);\n        T.init();\n        int l=0,r=(1<<cnt)-1;\n        while(l!=r){\n            int mid=l+r>>1;\n            if(T.kth(mid)>=Q)r=mid;\n            else    l=mid+1;\n        }\n        printf(\"%d\",(1ll+qpow(2,n-cnt)*(ll)l)%mod);\n    }\n    /*\n    3\n    1 2 3\n    3\n    */\n---\n\n# [CQOI2013 新Nim游戏](http://www.lydsy.com/JudgeOnline/problem.php?id=3105)\n---\n## 题目描述\n传统的Nim游戏是这样的：有一些火柴堆，每堆都有若干根火柴（不同堆的火柴数量可以不同）。两个游戏者轮流操作，每次可以选一个火柴堆拿走若干根火柴。可以只拿一根，也可以拿走整堆火柴，但不能同时从超过一堆火柴中拿。拿走最后一根火柴的游戏者胜利。\n\n本题的游戏稍微有些不同：在第一个回合中，第一个游戏者可以直接拿走若干个整堆的火柴。可以一堆都不拿，但不可以全部拿走。第二回合也一样，第二个游戏者也有这样一次机会。从第三个回合（又轮到第一个游戏者）开始，规则和Nim游戏一样。\n\n如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。\n \n### 输入输出格式\n#### 输入格式:\n第一行为整数k。即火柴堆数。第二行包含k个不超过109的正整数，即各堆的火柴个数。\n#### 输出格式：\n输出第一回合拿的火柴数目的最小值。如果不能保证取胜，输出-1。\n### 输入输出样例\n#### 输入样例：\n    6\n    5 5 6 6 5 5\n#### 输出样例：\n\t21\n### 数据范围\nk<=100\n\n---\n\n## 题解\n对于后手玩家来说，只要存在多个基底异或值为零，即可将其余所有火柴删除，使得所有最后普通nim游戏有异或值为$0$，即后手胜。那么先手玩家为了避免这种情况需要删除所以可能导致异或值为$0$的情况，即可能有线性无关变量的情况（易知不存在先手必败的情况），那么如何将第一个人删除的尽可能少，可以将所有火柴排个序，从大到小插入线性基中，如果为线性无关变量，则直接统计进答案即可。（具体证明需要考虑拟阵，暂时没学。）\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e5+1;\n    int n,a[N];\n    struct Xor{\n        int a[32];\n        bool add(int x){\n            for(int i=31;i>=0;--i)\n            if((x>>i)&1)x^=a[i];\n            for(int i=31;i>=0;--i)\n            if(((x>>i)&1)&&!a[i]){\n                a[i]=x;\n                for(int j=i+1;j<=31;++j)\n                if((a[j]>>i)&1)a[j]^=x;\n                return 1;\n            }\n            return 0;\n        }\n    }T;\n\n    int main(){\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n        sort(a+1,a+n+1);\n        ll ans=0;\n        for(int i=n;i>=1;--i)if(!T.add(a[i]))ans+=a[i];\n        printf(\"%lld\",ans);\n    }\n    /*\n    6\n    5 5 6 6 5 5\n    */\n---\n\n# [SCOI2016 幸运数字](http://www.lydsy.com/JudgeOnline/problem.php?id=4568)\n---\n## 题目描述\nA 国共有 n 座城市，这些城市由 n-1 条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个\n幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。一些旅行者希望游览 A 国。旅行者计划\n乘飞机降落在 x 号城市，沿着 x 号城市到 y 号城市之间那条唯一的路径游览，最终从 y 城市起飞离开 A 国。\n在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸\n运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。例如，\n游览者拍了 3 张照片，幸运值分别是 5，7，11，那么最终保留在自己身上的幸运值就是 9（5 xor 7 xor 11）。\n有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择 5 \n和 11 ，可以保留的幸运值为 14 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中\n可以保留的最大幸运值是多少。\n### 输入输出格式\n#### 输入格式:\n第一行包含 2 个正整数 n ，q，分别表示城市的数量和旅行者数量。第二行包含 n 个非负整数，其中第 i 个整\n数 Gi 表示 i 号城市的幸运值。随后 n-1 行，每行包含两个正整数 x ，y，表示 x 号城市和 y 号城市之间有一\n条道路相连。随后 q 行，每行包含两个正整数 x ，y，表示这名旅行者的旅行计划是从 x 号城市到 y 号城市。N\n<=20000,Q<=200000,Gi<=2^60\n#### 输出格式：\n 输出需要包含 q 行，每行包含 1 个非负整数，表示这名旅行者可以保留的最大幸运值。\n### 输入输出样例\n#### 输入样例：\n    4 2 \n    11 5 7 9 \n    1 2 \n    1 3 \n    1 4 \n    2 3 \n    1 4\n#### 输出样例：\n\t14\n    11\n\n---\n\n## 题解\n该题实际上就是将$x$到$y$中所有权值插入线性基中求异或最大值即为答案，观察$n<=20000$的性质，可以通过倍增维护,每次查询启发式合并即可。\n\n---\n### CODE\n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N = 2e4+1;\n\n    int read(){\n        int x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n        return x;\n    }\n\n    struct Xor{\n        ll a[61];\n        void add(ll x){\n            for(int i=60;i>=0;--i)\n            if((x>>i)&1)x^=a[i];\n            if(!x)return;\n            for(int i=60;i>=0;--i)\n            if(((x>>i)&1)&&!a[i]){\n                a[i]=x;\n                for(int j=i+1;j<=60;++j)\n                if((a[j]>>i)&1)a[j]^=x;\n                return;\n            }\n        }\n        void init(){\n            memset(a,0,sizeof(a));\n        }\n        ll mx(){\n            ll ret=0;\n            for(int i=60;i>=0;--i)\n            if(((ret>>i)&1)==0)ret^=a[i];\n            return ret;\n        }\n    }g[N][15],R;\n\n    Xor mix(Xor a,Xor b){\n        Xor c;c.init();\n        int cnta=0,cntb=0;\n        for(int i=0;i<=60;++i)if(a.a[i])cnta++;\n        for(int i=0;i<=60;++i)if(b.a[i])cntb++;\n        if(cnta>=cntb){\n            for(int i=0;i<=60;++i)c.a[i]=a.a[i];\n            for(int i=0;i<=60;++i)\n            if(b.a[i])c.add(b.a[i]);\n        }\n        else{\n            for(int i=0;i<=60;++i)c.a[i]=b.a[i];\n            for(int i=0;i<=60;++i)\n            if(a.a[i])c.add(a.a[i]);\n        }\n        return c;\n    }\n\n    int head[N],cnt,n,m,Q,f[N][15],d[N],fa[N];\n    ll a[N];\n    struct nd{\n        int to,ne;\n    }e[N*2];\n\n    void in(int x,int y){\n        e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;\n    }\n\n    void dfs(int x){\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=fa[x]){\n            int y=e[i].to;\n            fa[y]=x;\n            f[y][0]=x;g[y][0].add(a[x]);\n            d[y]=d[x]+1;\n            dfs(y);\n        }\n    }\n\n    void pre(){\n        for(int j=1;j<15;++j)\n        for(int i=1;i<=n;++i){\n            f[i][j]=f[f[i][j-1]][j-1];\n            g[i][j]=mix(g[f[i][j-1]][j-1],g[i][j-1]);\n        }\n    }\n\n    int lca(int x,int y){\n        R.init();\n        if(d[x]<d[y])swap(x,y);\n        for(int i=14;i>=0;--i)\n        if(d[f[x][i]]>=d[y]){\n            R=mix(R,g[x][i]);\n            x=f[x][i];\n        }\n        if(x==y)return x;\n        for(int i=14;i>=0;--i)\n        if(f[x][i]!=f[y][i]){\n            R=mix(R,g[x][i]);R=mix(R,g[y][i]);\n            x=f[x][i],y=f[y][i];\n        }\n        R.add(a[f[x][0]]);\n        return f[x][0];\n    }\n\n    ll solve(int x,int y){\n    //  cout<<x<<\" \"<<y<<endl;\n        int l=lca(x,y);\n        R.add(a[x]);R.add(a[y]);\n        return R.mx();\n    }\n\n    int main(){\n        n=read();Q=read();\n        for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]);\n        for(int i=1,x,y;i<n;++i)x=read(),y=read(),in(x,y),in(y,x);\n        d[1]=1;dfs(1);\n        pre();\n        for(int i=1,x,y;i<=Q;++i)printf(\"%lld\\n\",solve(read(),read()));\n    }\n    /*\n    4 2\n    11 5 7 9\n    1 2\n    1 3\n    1 4\n    2 3\n    1 4\n    */","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a href=\"\"></a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><img src=\"http://www.lydsy.com/JudgeOnline/images/2606_1.jpg\" alt=\"\"></p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>第一行包含两个整数N和 M， 表示该无向图中点的数目与边的数目。 接下来M 行描述 M 条边，每行三个整数Si，Ti ，Di，表示 Si 与Ti之间存在 一条权值为 Di的无向边。 图中可能有重边或自环。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>仅包含一个整数，表示最大的XOR和（十进制结果）,注意输出后加换行回车。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>5 7 \n1 2 2 \n1 3 2 \n2 4 1 \n2 5 1 \n4 5 3 \n5 3 4 \n4 3 2 \n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>6\n</code></pre><h3 id=\"数据范围：\"><a href=\"#数据范围：\" class=\"headerlink\" title=\"数据范围：\"></a>数据范围：</h3><h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><img src=\"http://www.lydsy.com/JudgeOnline/images/2606_3.jpg\" alt=\"\"></h2><h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>裸线性基，曾经在CF上做过这题，大致思路就是将所有能遍历到的环插入线性基内，因为一定能通过经过一条路径绕环一圈再从这个路径回来的方式，使得答案异或上环的权值，那么任取一条$1$到$n$的路径到线性基中求异或最大值即可。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e5+1;\n\nstruct XOR{\n    ll a[63];\n    void add(ll x){\n        for(int i=62;i&gt;=0;--i)\n        if((x&gt;&gt;i)&amp;1)x^=a[i];\n        for(int i=62;i&gt;=0;--i)\n        if(((x&gt;&gt;i)&amp;1)&amp;&amp;!a[i]){\n            a[i]=x;\n            for(int j=i+1;j&lt;=62;++j)\n            if((a[j]&gt;&gt;i)&amp;1)a[j]^=x;\n            return;\n        }\n    }\n    ll sum(ll x){\n        for(int i=62;i&gt;=0;--i)\n        if(((x&gt;&gt;i)&amp;1)==0)x^=a[i];\n        return x;\n    }\n}T;\n\nint head[N],n,m;\nbool vis[N];\nll d[N];\n\nstruct nd{\n    int ne,to;ll w;\n}e[N*2];\n\nvoid in(int x,int y,ll w){\n    static int cnt=0;\n    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;e[cnt].w=w;\n}\n\nvoid dfs(int x,ll w){\n    vis[x]=1;\n    d[x]=w;\n    for(int i=head[x];i;i=e[i].ne){\n        int y=e[i].to;\n        if(vis[y])T.add(d[x]^d[y]^e[i].w);\n        else    dfs(y,w^e[i].w);\n    }\n}\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    ll w;\n    for(int i=1,x,y;i&lt;=m;++i)scanf(&quot;%d%d%lld&quot;,&amp;x,&amp;y,&amp;w),in(x,y,w),in(y,x,w);\n    dfs(1,0);\n    printf(&quot;%lld\\n&quot;,T.sum(d[n]));\n}\n</code></pre><hr>\n<h1 id=\"BZOJ2844-albus就是要第一个出场\"><a href=\"#BZOJ2844-albus就是要第一个出场\" class=\"headerlink\" title=\"BZOJ2844 albus就是要第一个出场\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=2844\" target=\"_blank\" rel=\"external\">BZOJ2844 albus就是要第一个出场</a></h1><hr>\n<h2 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>已知一个长度为n的正整数序列A（下标从1开始）， 令 S = { x | 1 &lt;= x &lt;= n }, S 的幂集2^S定义为S 所有子<br>集构成的集合。定义映射 f : 2^S -&gt; Zf(空集) = 0f(T) = XOR A[t] , 对于一切t属于T现在albus把2^S中每个集<br>合的f值计算出来， 从小到大排成一行， 记为序列B（下标从1开始）。 给定一个数， 那么这个数在序列B中第1<br>次出现时的下标是多少呢？</p>\n<h3 id=\"输入输出格式-1\"><a href=\"#输入输出格式-1\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>第一行一个数n, 为序列A的长度。接下来一行n个数， 为序列A， 用空格隔开。最后一个数Q， 为给定的数.</p>\n<h4 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>共一行， 一个整数， 为Q在序列B中第一次出现时的下标模10086的值.</p>\n<h3 id=\"输入输出样例-1\"><a href=\"#输入输出样例-1\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\n1 2 3\n1\n</code></pre><h4 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>3\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>数据范围：</p>\n<p>1 &lt;= N &lt;= 10,0000</p>\n<p>其他所有输入均不超过10^9</p>\n<hr>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>此题实际上为求$k$小线性基的对偶问题，如不不考虑重复的话，直接二分皆可解决。考虑上重复的问题，不妨设$cnt$为线性基底个数，那么显然不重复的异或值只有$2^{cnt}$中，即有$n-cnt$个线性无关变量，即每一种异或值都可以经过$2^{n-cnt}$种变换仍不改变，即每一种异或值共重复了$2^{n-cnt}$次，去重二分后计算上重复次数即可得到答案。</p>\n<hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+1;\nconst ll mod = 10086;\nint n,q[N],Q,cnt;\n\nstruct Xor{\n    int a[N],b[N];\n    void add(int x){\n        for(int i=31;i&gt;=0;--i)\n        if((x&gt;&gt;i)&amp;1)x^=a[i];\n        for(int i=31;i&gt;=0;--i)\n        if(((x&gt;&gt;i)&amp;1)&amp;&amp;!a[i]){\n            a[i]=x;\n            for(int j=i+1;j&lt;=31;++j)\n            if((a[j]&gt;&gt;i)&amp;1)a[j]^=x;\n            return;\n        }\n    }\n    void init(){\n        cnt=0;\n        for(int i=0;i&lt;=31;++i)\n        if(a[i])b[++cnt]=a[i];\n    }\n    int kth(int k){\n        if(k&gt;(1&lt;&lt;cnt))return 2e9;\n        int ret=0;\n        for(int i=1;i&lt;=cnt;++i)\n        if((k&gt;&gt;(i-1))&amp;1)ret^=b[i];\n        return ret;\n    }\n}T;\n\nll qpow(ll a,ll b){\n    ll ret=1;\n    while(b){\n        if(b&amp;1)ret=ret*a%mod;\n        b&gt;&gt;=1;\n        a=a*a%mod;\n    }\n    return ret;\n}\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;q[i]),T.add(q[i]);\n    scanf(&quot;%d&quot;,&amp;Q);\n    T.init();\n    int l=0,r=(1&lt;&lt;cnt)-1;\n    while(l!=r){\n        int mid=l+r&gt;&gt;1;\n        if(T.kth(mid)&gt;=Q)r=mid;\n        else    l=mid+1;\n    }\n    printf(&quot;%d&quot;,(1ll+qpow(2,n-cnt)*(ll)l)%mod);\n}\n/*\n3\n1 2 3\n3\n*/\n</code></pre><hr>\n<h1 id=\"CQOI2013-新Nim游戏\"><a href=\"#CQOI2013-新Nim游戏\" class=\"headerlink\" title=\"CQOI2013 新Nim游戏\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=3105\" target=\"_blank\" rel=\"external\">CQOI2013 新Nim游戏</a></h1><hr>\n<h2 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>传统的Nim游戏是这样的：有一些火柴堆，每堆都有若干根火柴（不同堆的火柴数量可以不同）。两个游戏者轮流操作，每次可以选一个火柴堆拿走若干根火柴。可以只拿一根，也可以拿走整堆火柴，但不能同时从超过一堆火柴中拿。拿走最后一根火柴的游戏者胜利。</p>\n<p>本题的游戏稍微有些不同：在第一个回合中，第一个游戏者可以直接拿走若干个整堆的火柴。可以一堆都不拿，但不可以全部拿走。第二回合也一样，第二个游戏者也有这样一次机会。从第三个回合（又轮到第一个游戏者）开始，规则和Nim游戏一样。</p>\n<p>如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。</p>\n<h3 id=\"输入输出格式-2\"><a href=\"#输入输出格式-2\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式-2\"><a href=\"#输入格式-2\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>第一行为整数k。即火柴堆数。第二行包含k个不超过109的正整数，即各堆的火柴个数。</p>\n<h4 id=\"输出格式：-2\"><a href=\"#输出格式：-2\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出第一回合拿的火柴数目的最小值。如果不能保证取胜，输出-1。</p>\n<h3 id=\"输入输出样例-2\"><a href=\"#输入输出样例-2\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-2\"><a href=\"#输入样例：-2\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>6\n5 5 6 6 5 5\n</code></pre><h4 id=\"输出样例：-2\"><a href=\"#输出样例：-2\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>21\n</code></pre><h3 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>k&lt;=100</p>\n<hr>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>对于后手玩家来说，只要存在多个基底异或值为零，即可将其余所有火柴删除，使得所有最后普通nim游戏有异或值为$0$，即后手胜。那么先手玩家为了避免这种情况需要删除所以可能导致异或值为$0$的情况，即可能有线性无关变量的情况（易知不存在先手必败的情况），那么如何将第一个人删除的尽可能少，可以将所有火柴排个序，从大到小插入线性基中，如果为线性无关变量，则直接统计进答案即可。（具体证明需要考虑拟阵，暂时没学。）</p>\n<hr>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+1;\nint n,a[N];\nstruct Xor{\n    int a[32];\n    bool add(int x){\n        for(int i=31;i&gt;=0;--i)\n        if((x&gt;&gt;i)&amp;1)x^=a[i];\n        for(int i=31;i&gt;=0;--i)\n        if(((x&gt;&gt;i)&amp;1)&amp;&amp;!a[i]){\n            a[i]=x;\n            for(int j=i+1;j&lt;=31;++j)\n            if((a[j]&gt;&gt;i)&amp;1)a[j]^=x;\n            return 1;\n        }\n        return 0;\n    }\n}T;\n\nint main(){\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]);\n    sort(a+1,a+n+1);\n    ll ans=0;\n    for(int i=n;i&gt;=1;--i)if(!T.add(a[i]))ans+=a[i];\n    printf(&quot;%lld&quot;,ans);\n}\n/*\n6\n5 5 6 6 5 5\n*/\n</code></pre><hr>\n<h1 id=\"SCOI2016-幸运数字\"><a href=\"#SCOI2016-幸运数字\" class=\"headerlink\" title=\"SCOI2016 幸运数字\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=4568\" target=\"_blank\" rel=\"external\">SCOI2016 幸运数字</a></h1><hr>\n<h2 id=\"题目描述-3\"><a href=\"#题目描述-3\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>A 国共有 n 座城市，这些城市由 n-1 条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个<br>幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。一些旅行者希望游览 A 国。旅行者计划<br>乘飞机降落在 x 号城市，沿着 x 号城市到 y 号城市之间那条唯一的路径游览，最终从 y 城市起飞离开 A 国。<br>在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸<br>运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。例如，<br>游览者拍了 3 张照片，幸运值分别是 5，7，11，那么最终保留在自己身上的幸运值就是 9（5 xor 7 xor 11）。<br>有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择 5<br>和 11 ，可以保留的幸运值为 14 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中<br>可以保留的最大幸运值是多少。</p>\n<h3 id=\"输入输出格式-3\"><a href=\"#输入输出格式-3\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式-3\"><a href=\"#输入格式-3\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>第一行包含 2 个正整数 n ，q，分别表示城市的数量和旅行者数量。第二行包含 n 个非负整数，其中第 i 个整<br>数 Gi 表示 i 号城市的幸运值。随后 n-1 行，每行包含两个正整数 x ，y，表示 x 号城市和 y 号城市之间有一<br>条道路相连。随后 q 行，每行包含两个正整数 x ，y，表示这名旅行者的旅行计划是从 x 号城市到 y 号城市。N<br>&lt;=20000,Q&lt;=200000,Gi&lt;=2^60</p>\n<h4 id=\"输出格式：-3\"><a href=\"#输出格式：-3\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p> 输出需要包含 q 行，每行包含 1 个非负整数，表示这名旅行者可以保留的最大幸运值。</p>\n<h3 id=\"输入输出样例-3\"><a href=\"#输入输出样例-3\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-3\"><a href=\"#输入样例：-3\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>4 2 \n11 5 7 9 \n1 2 \n1 3 \n1 4 \n2 3 \n1 4\n</code></pre><h4 id=\"输出样例：-3\"><a href=\"#输出样例：-3\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>14\n11\n</code></pre><hr>\n<h2 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>该题实际上就是将$x$到$y$中所有权值插入线性基中求异或最大值即为答案，观察$n&lt;=20000$的性质，可以通过倍增维护,每次查询启发式合并即可。</p>\n<hr>\n<h3 id=\"CODE-3\"><a href=\"#CODE-3\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 2e4+1;\n\nint read(){\n    int x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;,ch=getchar();\n    return x;\n}\n\nstruct Xor{\n    ll a[61];\n    void add(ll x){\n        for(int i=60;i&gt;=0;--i)\n        if((x&gt;&gt;i)&amp;1)x^=a[i];\n        if(!x)return;\n        for(int i=60;i&gt;=0;--i)\n        if(((x&gt;&gt;i)&amp;1)&amp;&amp;!a[i]){\n            a[i]=x;\n            for(int j=i+1;j&lt;=60;++j)\n            if((a[j]&gt;&gt;i)&amp;1)a[j]^=x;\n            return;\n        }\n    }\n    void init(){\n        memset(a,0,sizeof(a));\n    }\n    ll mx(){\n        ll ret=0;\n        for(int i=60;i&gt;=0;--i)\n        if(((ret&gt;&gt;i)&amp;1)==0)ret^=a[i];\n        return ret;\n    }\n}g[N][15],R;\n\nXor mix(Xor a,Xor b){\n    Xor c;c.init();\n    int cnta=0,cntb=0;\n    for(int i=0;i&lt;=60;++i)if(a.a[i])cnta++;\n    for(int i=0;i&lt;=60;++i)if(b.a[i])cntb++;\n    if(cnta&gt;=cntb){\n        for(int i=0;i&lt;=60;++i)c.a[i]=a.a[i];\n        for(int i=0;i&lt;=60;++i)\n        if(b.a[i])c.add(b.a[i]);\n    }\n    else{\n        for(int i=0;i&lt;=60;++i)c.a[i]=b.a[i];\n        for(int i=0;i&lt;=60;++i)\n        if(a.a[i])c.add(a.a[i]);\n    }\n    return c;\n}\n\nint head[N],cnt,n,m,Q,f[N][15],d[N],fa[N];\nll a[N];\nstruct nd{\n    int to,ne;\n}e[N*2];\n\nvoid in(int x,int y){\n    e[++cnt].to=y;e[cnt].ne=head[x];head[x]=cnt;\n}\n\nvoid dfs(int x){\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=fa[x]){\n        int y=e[i].to;\n        fa[y]=x;\n        f[y][0]=x;g[y][0].add(a[x]);\n        d[y]=d[x]+1;\n        dfs(y);\n    }\n}\n\nvoid pre(){\n    for(int j=1;j&lt;15;++j)\n    for(int i=1;i&lt;=n;++i){\n        f[i][j]=f[f[i][j-1]][j-1];\n        g[i][j]=mix(g[f[i][j-1]][j-1],g[i][j-1]);\n    }\n}\n\nint lca(int x,int y){\n    R.init();\n    if(d[x]&lt;d[y])swap(x,y);\n    for(int i=14;i&gt;=0;--i)\n    if(d[f[x][i]]&gt;=d[y]){\n        R=mix(R,g[x][i]);\n        x=f[x][i];\n    }\n    if(x==y)return x;\n    for(int i=14;i&gt;=0;--i)\n    if(f[x][i]!=f[y][i]){\n        R=mix(R,g[x][i]);R=mix(R,g[y][i]);\n        x=f[x][i],y=f[y][i];\n    }\n    R.add(a[f[x][0]]);\n    return f[x][0];\n}\n\nll solve(int x,int y){\n//  cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;\n    int l=lca(x,y);\n    R.add(a[x]);R.add(a[y]);\n    return R.mx();\n}\n\nint main(){\n    n=read();Q=read();\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,&amp;a[i]);\n    for(int i=1,x,y;i&lt;n;++i)x=read(),y=read(),in(x,y),in(y,x);\n    d[1]=1;dfs(1);\n    pre();\n    for(int i=1,x,y;i&lt;=Q;++i)printf(&quot;%lld\\n&quot;,solve(read(),read()));\n}\n/*\n4 2\n11 5 7 9\n1 2\n1 3\n1 4\n2 3\n1 4\n*/\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/08/28/线性基题目总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"线性基","slug":"线性基","permalink":"https://prostkhala.github.io/tags/线性基/"}]},{"title":"二逼平衡树","date":"2017-06-21T07:15:11.000Z","path":"2017/06/21/二逼平衡树/","text":"TYVJ1730 二逼平衡树COGS1594 题目描述您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：1.查询k在区间内的排名2.查询区间内排名为k的值3.修改某一位值上的数值4.查询k在区间内的前驱(前驱定义为小于x，且最大的数)5.查询k在区间内的后继(后继定义为大于x，且最小的数) 输入输出格式输入格式：第一行两个数 n,m 表示长度为n的有序序列和m个操作第二行有n个数，表示有序序列下面有m行，opt表示操作标号若opt=1 则为操作1，之后有三个数l,r,k 表示查询k在区间[l,r]的排名若opt=2 则为操作2，之后有三个数l,r,k 表示查询区间[l,r]内排名为k的数若opt=3 则为操作3，之后有两个数pos,k 表示将pos位置的数修改为k若opt=4 则为操作4，之后有三个数l,r,k 表示查询区间[l,r]内k的前驱若opt=5 则为操作5，之后有三个数l,r,k 表示查询区间[l,r]内k的后继 输出格式：对于操作1,2,4,5各输出一行，表示查询结果 输入输出样例输入样例：9 6 4 2 2 1 9 4 0 1 1 2 1 4 3 3 4 10 2 1 4 3 1 2 5 9 4 3 9 5 5 2 8 5 输出样例：2 4 3 4 9 数据范围$n,m&lt;=50000$ 保证有序序列所有值在任何时刻满足$[0,10^8]$ 题解本题正解有很多种，较常见的为树状数组套主席树，SPLAY套线段树，TREAP套线段树，其中实际时间复杂度最低的是树状数组套主席树和用归并进行可持久化的SPLAY套线段树，而较容易实现的是SPLAY套线段树。 此处只介绍SPLAY套线段树和树状数组套主席树的方法。 SPLAY套线段树对于每个线段树中代表区间的节点建一颗SPLAY树，存储原数列中下标在该节点包含的区间内的信息，对于每一个下标，需要在$logn$个节点中存储，则实际的SPLAY空间只需要$2nlogn$的大小。对于大多数操作，均可以利用归并的的思想求解，而对于操作二，可以二分答案，找到最小的满足数列中$A[mid]$的排名为$k$的值。 对于SPLAY来说，其中寻找前驱后继和排名的操作如果每次插入新点的话，将会导致时间复杂度大大提高。 树状数组套主席树区间K大，修改数值都是树状数组套主席树所支持的基本操作，而对于操作二，同样可以通过二分答案实现，对于需要前驱后继的操作，可以通过操作一，二结合实现，即先找到该数值的排名$K$，在寻找排名$K-1$或$K+1$的数值，对于重复的问题需要根据题目进行特殊判断。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #define pd(i) (i&gt;=&#39;0&#39;&amp;&amp;i&lt;=&#39;9&#39;) using namespace std; const int N = 5e4+1; const int inf = 0x7fffffff; const int M = N*40; int son[M][2],n,m,fa[M],w[M],s[M],L[M],R[M],num[M],root[M],tot,a[N]; int in() { int t=0,f=1; char ch=getchar(); while (!pd(ch)) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (pd(ch)) t=(t&lt;&lt;3)+(t&lt;&lt;1)+ch-&#39;0&#39;,ch=getchar(); return f*t; } void up(int x){s[x]=s[son[x][0]]+s[son[x][1]]+num[x];} void rotate(int x) { int y=fa[x],z=fa[y],t=son[y][0]==x; fa[y]=x;fa[x]=z; if(z)son[z][son[z][1]==y]=x; son[y][!t]=son[x][t];fa[son[x][t]]=y; son[x][t]=y; up(y);up(x); } void splay(int i,int x,int f) { while(fa[x]!=f) { int y=fa[x],z=fa[y]; if(z!=f) { if(son[y][0]==x^son[z][0]==y)rotate(x); else rotate(y); } rotate(x); } if(!f)root[i]=x; } void insert(int i,int &amp;x,int f,int val) { if(!x) { x=++tot;fa[x]=f; son[x][0]=son[x][1]=0; w[x]=val;s[x]=num[x]=1; splay(i,x,0); return; } if(w[x]==val){s[x]++;num[x]++;splay(i,x,0);return;} insert(i,son[x][val&gt;w[x]],x,val); up(x); } int get(int i,int val) { int x=root[i]; while(x&amp;&amp;w[x]!=val)x=son[x][val&gt;w[x]]; return x; } void delet(int i,int x) { x=get(i,x);splay(i,x,0); if(num[x]&gt;1){num[x]--;s[x]--;return;} if(son[x][0]*son[x][1]==0)root[i]=son[x][0]+son[x][1]; else { int y=son[x][1];while(son[y][0])y=son[y][0]; splay(i,y,x); fa[son[x][0]]=y; son[y][0]=son[x][0]; root[i]=y; son[x][0]=son[x][1]=0; } fa[root[i]]=0; up(root[i]); } void build(int now,int l,int r,int x,int val) { L[now]=l;R[now]=r; insert(now,root[now],0,val); if(l==r)return; int mid=l+r&gt;&gt;1; if(x&lt;=mid) build(now*2,l,mid,x,val); else build(now*2+1,mid+1,r,x,val); return; } int rk(int i,int val) { int x=root[i],ret=0; while(x) { if(w[x]&lt;val)ret+=s[son[x][0]]+num[x],x=son[x][1]; else x=son[x][0]; } return ret; } int getrk(int now,int x,int y,int k) { int l=L[now],r=R[now]; if(x&lt;=l&amp;&amp;r&lt;=y)return rk(now,k); int mid=l+r&gt;&gt;1;int ret=0; if(x&lt;=mid) ret+=getrk(now*2,x,y,k); if(y&gt;mid) ret+=getrk(now*2+1,x,y,k); return ret; } int kth(int x,int y,int k) { int l=0,r=inf; while(l!=r) { int mid=l+r+1&gt;&gt;1; if(getrk(1,x,y,mid)+1&lt;=k) l=mid; else r=mid-1; } return l; } void change(int now,int x,int val,int __val) { int l=L[now],r=R[now]; delet(now,__val);insert(now,root[now],0,val); if(l==r)return; int mid=l+r&gt;&gt;1; if(x&lt;=mid) change(now*2,x,val,__val); else change(now*2+1,x,val,__val); return; } int pre(int i,int val) { int x=root[i],ret=-inf; while(x) { if(w[x]&gt;=val)x=son[x][0]; else ret=max(ret,w[x]),x=son[x][1]; } return ret; } int ne(int i,int val) { int x=root[i],ret=inf; while(x) { if(w[x]&gt;val)ret=min(ret,w[x]),x=son[x][0]; else x=son[x][1]; } return ret; } int getpre(int now,int x,int y,int val) { int l=L[now],r=R[now]; if(x&lt;=l&amp;&amp;r&lt;=y)return pre(now,val); int mid=l+r&gt;&gt;1,ret=-inf; if(x&lt;=mid) ret=max(ret,getpre(now*2,x,y,val)); if(y&gt;mid) ret=max(ret,getpre(now*2+1,x,y,val)); return ret; } int getne(int now,int x,int y,int val) { int l=L[now],r=R[now]; if(x&lt;=l&amp;&amp;r&lt;=y)return ne(now,val); int mid=l+r&gt;&gt;1,ret=inf; if(x&lt;=mid) ret=min(ret,getne(now*2,x,y,val)); if(y&gt;mid) ret=min(ret,getne(now*2+1,x,y,val)); return ret; } int main() { freopen(&quot;psh.in&quot;,&quot;r&quot;,stdin); freopen(&quot;psh.out&quot;,&quot;w&quot;,stdout); n=in();m=in(); for(int i=1;i&lt;=n;++i) { a[i]=in(); build(1,1,n,i,a[i]); } for(int i=1,op,x,y,k,pos;i&lt;=m;++i) { op=in(); switch(op) { case 1:x=in();y=in();k=in();printf(&quot;%d\\n&quot;,getrk(1,x,y,k)+1);break; case 2:x=in();y=in();k=in();printf(&quot;%d\\n&quot;,kth(x,y,k));break; case 3:pos=in();k=in();change(1,pos,k,a[pos]);a[pos]=k;break; case 4:x=in();y=in();k=in();printf(&quot;%d\\n&quot;,getpre(1,x,y,k));break; case 5:x=in();y=in();k=in();printf(&quot;%d\\n&quot;,getne(1,x,y,k));break; } } }","raw":"title: 二逼平衡树\ndate: 2017-06-21 15:15:11\ncategories:\n  - 数据结构\n  - 平衡树\n  - SPLAY\ntags:\n  - SPLAY\n  - 二分答案\n  - 线段树\n  - TREAP\n---\n\n# TYVJ1730 二逼平衡树\n\n## [COGS1594](http://cogs.pro/cogs/problem/problem.php?pid=1594)\n---\n## 题目描述\n您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：\n1.查询k在区间内的排名\n2.查询区间内排名为k的值\n3.修改某一位值上的数值\n4.查询k在区间内的前驱(前驱定义为小于x，且最大的数)\n5.查询k在区间内的后继(后继定义为大于x，且最小的数) \n\n### 输入输出格式\n#### 输入格式：\n第一行两个数 n,m 表示长度为n的有序序列和m个操作\n第二行有n个数，表示有序序列\n下面有m行，opt表示操作标号\n若opt=1 则为操作1，之后有三个数l,r,k 表示查询k在区间[l,r]的排名\n若opt=2 则为操作2，之后有三个数l,r,k 表示查询区间[l,r]内排名为k的数\n若opt=3 则为操作3，之后有两个数pos,k 表示将pos位置的数修改为k\n若opt=4 则为操作4，之后有三个数l,r,k 表示查询区间[l,r]内k的前驱\n若opt=5 则为操作5，之后有三个数l,r,k 表示查询区间[l,r]内k的后继 \n\n#### 输出格式：\n对于操作1,2,4,5各输出一行，表示查询结果 \n\n\n### 输入输出样例\n#### 输入样例：\n    9 6\n    4 2 2 1 9 4 0 1 1\n    2 1 4 3\n    3 4 10\n    2 1 4 3\n    1 2 5 9\n    4 3 9 5\n    5 2 8 5\n\n#### 输出样例：\n    2\n    4\n    3\n    4\n    9\n\n### 数据范围\n$n,m<=50000$   保证有序序列所有值在任何时刻满足$[0,10^8]$ \n\n---\n\n## 题解\n本题正解有很多种，较常见的为树状数组套主席树，SPLAY套线段树，TREAP套线段树，其中实际时间复杂度最低的是树状数组套主席树和用归并进行可持久化的SPLAY套线段树，而较容易实现的是SPLAY套线段树。\n\n此处只介绍SPLAY套线段树和树状数组套主席树的方法。\n\n### SPLAY套线段树\n\n对于每个线段树中代表区间的节点建一颗SPLAY树，存储原数列中下标在该节点包含的区间内的信息，对于每一个下标，需要在$logn$个节点中存储，则实际的SPLAY空间只需要$2nlogn$的大小。对于大多数操作，均可以利用归并的的思想求解，而对于操作二，可以二分答案，找到最小的满足数列中$A[mid]$的排名为$k$的值。\n\n对于SPLAY来说，其中寻找前驱后继和排名的操作如果每次插入新点的话，将会导致时间复杂度大大提高。\n\n### 树状数组套主席树\n区间K大，修改数值都是树状数组套主席树所支持的基本操作，而对于操作二，同样可以通过二分答案实现，对于需要前驱后继的操作，可以通过操作一，二结合实现，即先找到该数值的排名$K$，在寻找排名$K-1$或$K+1$的数值，对于重复的问题需要根据题目进行特殊判断。\n\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #define pd(i) (i>='0'&&i<='9')\n    using namespace std;\n    const int N = 5e4+1;\n    const int inf = 0x7fffffff;\n    const int M = N*40;\n\n    int son[M][2],n,m,fa[M],w[M],s[M],L[M],R[M],num[M],root[M],tot,a[N];\n\n    int in()\n    {\n        int t=0,f=1;\n        char ch=getchar();\n        while (!pd(ch))\n        {\n            if (ch=='-') f=-1;\n            ch=getchar();\n        }\n        while (pd(ch)) t=(t<<3)+(t<<1)+ch-'0',ch=getchar();\n        return f*t;\n    }\n\n    void up(int x){s[x]=s[son[x][0]]+s[son[x][1]]+num[x];}\n\n    void rotate(int x)\n    {\n        int y=fa[x],z=fa[y],t=son[y][0]==x;\n        fa[y]=x;fa[x]=z;\n        if(z)son[z][son[z][1]==y]=x;\n        son[y][!t]=son[x][t];fa[son[x][t]]=y;\n        son[x][t]=y;\n        up(y);up(x);\n    }\n\n    void splay(int i,int x,int f)\n    {\n        while(fa[x]!=f)\n        {\n            int y=fa[x],z=fa[y];\n            if(z!=f)\n            {\n                if(son[y][0]==x^son[z][0]==y)rotate(x);\n                else                        rotate(y);\n            }\n            rotate(x);\n        }\n        if(!f)root[i]=x;\n    }\n\n    void insert(int i,int &x,int f,int val)\n    {\n        if(!x)\n        {\n            x=++tot;fa[x]=f;\n            son[x][0]=son[x][1]=0;\n            w[x]=val;s[x]=num[x]=1;\n            splay(i,x,0);\n            return;\n        }\n        if(w[x]==val){s[x]++;num[x]++;splay(i,x,0);return;}\n        insert(i,son[x][val>w[x]],x,val);\n        up(x);\n    }\n\n    int get(int i,int val)\n    {\n        int x=root[i];\n        while(x&&w[x]!=val)x=son[x][val>w[x]];\n        return x;\n    }\n\n    void delet(int i,int x)\n    {\n        x=get(i,x);splay(i,x,0);\n        if(num[x]>1){num[x]--;s[x]--;return;}\n        if(son[x][0]*son[x][1]==0)root[i]=son[x][0]+son[x][1];\n        else\n        {\n            int y=son[x][1];while(son[y][0])y=son[y][0];\n            splay(i,y,x);\n            fa[son[x][0]]=y;\n            son[y][0]=son[x][0];\n            root[i]=y;\n            son[x][0]=son[x][1]=0;\n        }\n        fa[root[i]]=0;\n        up(root[i]);\n    }\n\n    void build(int now,int l,int r,int x,int val)\n    {\n        L[now]=l;R[now]=r;\n        insert(now,root[now],0,val);\n        if(l==r)return;\n        int mid=l+r>>1;\n        if(x<=mid) \tbuild(now*2,l,mid,x,val);\n        else\t\tbuild(now*2+1,mid+1,r,x,val);\n        return;\n    }\n\n    int rk(int i,int val)\n    {\n        int x=root[i],ret=0;\n        while(x)\n        {\n            if(w[x]<val)ret+=s[son[x][0]]+num[x],x=son[x][1];\n            else\tx=son[x][0];\n        }\n        return ret;\n    }\n\n    int getrk(int now,int x,int y,int k)\n    {\n        int l=L[now],r=R[now];\n        if(x<=l&&r<=y)return rk(now,k);\n        int mid=l+r>>1;int ret=0;\n        if(x<=mid)\tret+=getrk(now*2,x,y,k);\n        if(y>mid)\tret+=getrk(now*2+1,x,y,k);\n        return ret;\n    }\n\n    int kth(int x,int y,int k)\n    {\n        int l=0,r=inf;\n        while(l!=r)\n        {\n            int mid=l+r+1>>1;\n            if(getrk(1,x,y,mid)+1<=k)\n                    l=mid;\n            else\tr=mid-1;\n        }\n        return l;\n    }\n\n    void change(int now,int x,int val,int __val)\n    {\n        int l=L[now],r=R[now];\n        delet(now,__val);insert(now,root[now],0,val);\n        if(l==r)return;\n        int mid=l+r>>1;\n        if(x<=mid)\tchange(now*2,x,val,__val);\n        else\t\tchange(now*2+1,x,val,__val);\n        return;\n    }\n\n    int pre(int i,int val)\n    {\n        int x=root[i],ret=-inf;\n        while(x)\n        {\n            if(w[x]>=val)x=son[x][0];\n            else\tret=max(ret,w[x]),x=son[x][1];\n        }\n        return ret;\n    }\n\n    int ne(int i,int val)\n    {\n        int x=root[i],ret=inf;\n        while(x)\n        {\n            if(w[x]>val)ret=min(ret,w[x]),x=son[x][0];\n            else\tx=son[x][1];\n        }\n        return ret;\n    }\n\n    int getpre(int now,int x,int y,int val)\n    {\n        int l=L[now],r=R[now];\n        if(x<=l&&r<=y)return pre(now,val);\n        int mid=l+r>>1,ret=-inf;\n        if(x<=mid) \tret=max(ret,getpre(now*2,x,y,val));\n        if(y>mid)\tret=max(ret,getpre(now*2+1,x,y,val));\n        return ret;\n    }\n\n    int getne(int now,int x,int y,int val)\n    {\n        int l=L[now],r=R[now];\n        if(x<=l&&r<=y)return ne(now,val);\n        int mid=l+r>>1,ret=inf;\n        if(x<=mid)\tret=min(ret,getne(now*2,x,y,val));\n        if(y>mid)\tret=min(ret,getne(now*2+1,x,y,val));\n        return ret;\n    }\n\n    int main()\n    {\n        freopen(\"psh.in\",\"r\",stdin);\n        freopen(\"psh.out\",\"w\",stdout);\n        n=in();m=in();\n        for(int i=1;i<=n;++i)\n        {\n            a[i]=in();\n            build(1,1,n,i,a[i]);\n        }\n        for(int i=1,op,x,y,k,pos;i<=m;++i)\n        {\n            op=in();\n            switch(op)\n            {\n                case 1:x=in();y=in();k=in();printf(\"%d\\n\",getrk(1,x,y,k)+1);break;\n                case 2:x=in();y=in();k=in();printf(\"%d\\n\",kth(x,y,k));break;\n                case 3:pos=in();k=in();change(1,pos,k,a[pos]);a[pos]=k;break;\n                case 4:x=in();y=in();k=in();printf(\"%d\\n\",getpre(1,x,y,k));break;\n                case 5:x=in();y=in();k=in();printf(\"%d\\n\",getne(1,x,y,k));break;\n            }\n        }\n    }\n\n","content":"<h1 id=\"TYVJ1730-二逼平衡树\"><a href=\"#TYVJ1730-二逼平衡树\" class=\"headerlink\" title=\"TYVJ1730 二逼平衡树\"></a>TYVJ1730 二逼平衡树</h1><h2 id=\"COGS1594\"><a href=\"#COGS1594\" class=\"headerlink\" title=\"COGS1594\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1594\" target=\"_blank\" rel=\"external\">COGS1594</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：<br>1.查询k在区间内的排名<br>2.查询区间内排名为k的值<br>3.修改某一位值上的数值<br>4.查询k在区间内的前驱(前驱定义为小于x，且最大的数)<br>5.查询k在区间内的后继(后继定义为大于x，且最小的数) </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行两个数 n,m 表示长度为n的有序序列和m个操作<br>第二行有n个数，表示有序序列<br>下面有m行，opt表示操作标号<br>若opt=1 则为操作1，之后有三个数l,r,k 表示查询k在区间[l,r]的排名<br>若opt=2 则为操作2，之后有三个数l,r,k 表示查询区间[l,r]内排名为k的数<br>若opt=3 则为操作3，之后有两个数pos,k 表示将pos位置的数修改为k<br>若opt=4 则为操作4，之后有三个数l,r,k 表示查询区间[l,r]内k的前驱<br>若opt=5 则为操作5，之后有三个数l,r,k 表示查询区间[l,r]内k的后继 </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于操作1,2,4,5各输出一行，表示查询结果 </p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>9 6\n4 2 2 1 9 4 0 1 1\n2 1 4 3\n3 4 10\n2 1 4 3\n1 2 5 9\n4 3 9 5\n5 2 8 5\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>2\n4\n3\n4\n9\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>$n,m&lt;=50000$   保证有序序列所有值在任何时刻满足$[0,10^8]$ </p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>本题正解有很多种，较常见的为树状数组套主席树，SPLAY套线段树，TREAP套线段树，其中实际时间复杂度最低的是树状数组套主席树和用归并进行可持久化的SPLAY套线段树，而较容易实现的是SPLAY套线段树。</p>\n<p>此处只介绍SPLAY套线段树和树状数组套主席树的方法。</p>\n<h3 id=\"SPLAY套线段树\"><a href=\"#SPLAY套线段树\" class=\"headerlink\" title=\"SPLAY套线段树\"></a>SPLAY套线段树</h3><p>对于每个线段树中代表区间的节点建一颗SPLAY树，存储原数列中下标在该节点包含的区间内的信息，对于每一个下标，需要在$logn$个节点中存储，则实际的SPLAY空间只需要$2nlogn$的大小。对于大多数操作，均可以利用归并的的思想求解，而对于操作二，可以二分答案，找到最小的满足数列中$A[mid]$的排名为$k$的值。</p>\n<p>对于SPLAY来说，其中寻找前驱后继和排名的操作如果每次插入新点的话，将会导致时间复杂度大大提高。</p>\n<h3 id=\"树状数组套主席树\"><a href=\"#树状数组套主席树\" class=\"headerlink\" title=\"树状数组套主席树\"></a>树状数组套主席树</h3><p>区间K大，修改数值都是树状数组套主席树所支持的基本操作，而对于操作二，同样可以通过二分答案实现，对于需要前驱后继的操作，可以通过操作一，二结合实现，即先找到该数值的排名$K$，在寻找排名$K-1$或$K+1$的数值，对于重复的问题需要根据题目进行特殊判断。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#define pd(i) (i&gt;=&#39;0&#39;&amp;&amp;i&lt;=&#39;9&#39;)\nusing namespace std;\nconst int N = 5e4+1;\nconst int inf = 0x7fffffff;\nconst int M = N*40;\n\nint son[M][2],n,m,fa[M],w[M],s[M],L[M],R[M],num[M],root[M],tot,a[N];\n\nint in()\n{\n    int t=0,f=1;\n    char ch=getchar();\n    while (!pd(ch))\n    {\n        if (ch==&#39;-&#39;) f=-1;\n        ch=getchar();\n    }\n    while (pd(ch)) t=(t&lt;&lt;3)+(t&lt;&lt;1)+ch-&#39;0&#39;,ch=getchar();\n    return f*t;\n}\n\nvoid up(int x){s[x]=s[son[x][0]]+s[son[x][1]]+num[x];}\n\nvoid rotate(int x)\n{\n    int y=fa[x],z=fa[y],t=son[y][0]==x;\n    fa[y]=x;fa[x]=z;\n    if(z)son[z][son[z][1]==y]=x;\n    son[y][!t]=son[x][t];fa[son[x][t]]=y;\n    son[x][t]=y;\n    up(y);up(x);\n}\n\nvoid splay(int i,int x,int f)\n{\n    while(fa[x]!=f)\n    {\n        int y=fa[x],z=fa[y];\n        if(z!=f)\n        {\n            if(son[y][0]==x^son[z][0]==y)rotate(x);\n            else                        rotate(y);\n        }\n        rotate(x);\n    }\n    if(!f)root[i]=x;\n}\n\nvoid insert(int i,int &amp;x,int f,int val)\n{\n    if(!x)\n    {\n        x=++tot;fa[x]=f;\n        son[x][0]=son[x][1]=0;\n        w[x]=val;s[x]=num[x]=1;\n        splay(i,x,0);\n        return;\n    }\n    if(w[x]==val){s[x]++;num[x]++;splay(i,x,0);return;}\n    insert(i,son[x][val&gt;w[x]],x,val);\n    up(x);\n}\n\nint get(int i,int val)\n{\n    int x=root[i];\n    while(x&amp;&amp;w[x]!=val)x=son[x][val&gt;w[x]];\n    return x;\n}\n\nvoid delet(int i,int x)\n{\n    x=get(i,x);splay(i,x,0);\n    if(num[x]&gt;1){num[x]--;s[x]--;return;}\n    if(son[x][0]*son[x][1]==0)root[i]=son[x][0]+son[x][1];\n    else\n    {\n        int y=son[x][1];while(son[y][0])y=son[y][0];\n        splay(i,y,x);\n        fa[son[x][0]]=y;\n        son[y][0]=son[x][0];\n        root[i]=y;\n        son[x][0]=son[x][1]=0;\n    }\n    fa[root[i]]=0;\n    up(root[i]);\n}\n\nvoid build(int now,int l,int r,int x,int val)\n{\n    L[now]=l;R[now]=r;\n    insert(now,root[now],0,val);\n    if(l==r)return;\n    int mid=l+r&gt;&gt;1;\n    if(x&lt;=mid)     build(now*2,l,mid,x,val);\n    else        build(now*2+1,mid+1,r,x,val);\n    return;\n}\n\nint rk(int i,int val)\n{\n    int x=root[i],ret=0;\n    while(x)\n    {\n        if(w[x]&lt;val)ret+=s[son[x][0]]+num[x],x=son[x][1];\n        else    x=son[x][0];\n    }\n    return ret;\n}\n\nint getrk(int now,int x,int y,int k)\n{\n    int l=L[now],r=R[now];\n    if(x&lt;=l&amp;&amp;r&lt;=y)return rk(now,k);\n    int mid=l+r&gt;&gt;1;int ret=0;\n    if(x&lt;=mid)    ret+=getrk(now*2,x,y,k);\n    if(y&gt;mid)    ret+=getrk(now*2+1,x,y,k);\n    return ret;\n}\n\nint kth(int x,int y,int k)\n{\n    int l=0,r=inf;\n    while(l!=r)\n    {\n        int mid=l+r+1&gt;&gt;1;\n        if(getrk(1,x,y,mid)+1&lt;=k)\n                l=mid;\n        else    r=mid-1;\n    }\n    return l;\n}\n\nvoid change(int now,int x,int val,int __val)\n{\n    int l=L[now],r=R[now];\n    delet(now,__val);insert(now,root[now],0,val);\n    if(l==r)return;\n    int mid=l+r&gt;&gt;1;\n    if(x&lt;=mid)    change(now*2,x,val,__val);\n    else        change(now*2+1,x,val,__val);\n    return;\n}\n\nint pre(int i,int val)\n{\n    int x=root[i],ret=-inf;\n    while(x)\n    {\n        if(w[x]&gt;=val)x=son[x][0];\n        else    ret=max(ret,w[x]),x=son[x][1];\n    }\n    return ret;\n}\n\nint ne(int i,int val)\n{\n    int x=root[i],ret=inf;\n    while(x)\n    {\n        if(w[x]&gt;val)ret=min(ret,w[x]),x=son[x][0];\n        else    x=son[x][1];\n    }\n    return ret;\n}\n\nint getpre(int now,int x,int y,int val)\n{\n    int l=L[now],r=R[now];\n    if(x&lt;=l&amp;&amp;r&lt;=y)return pre(now,val);\n    int mid=l+r&gt;&gt;1,ret=-inf;\n    if(x&lt;=mid)     ret=max(ret,getpre(now*2,x,y,val));\n    if(y&gt;mid)    ret=max(ret,getpre(now*2+1,x,y,val));\n    return ret;\n}\n\nint getne(int now,int x,int y,int val)\n{\n    int l=L[now],r=R[now];\n    if(x&lt;=l&amp;&amp;r&lt;=y)return ne(now,val);\n    int mid=l+r&gt;&gt;1,ret=inf;\n    if(x&lt;=mid)    ret=min(ret,getne(now*2,x,y,val));\n    if(y&gt;mid)    ret=min(ret,getne(now*2+1,x,y,val));\n    return ret;\n}\n\nint main()\n{\n    freopen(&quot;psh.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;psh.out&quot;,&quot;w&quot;,stdout);\n    n=in();m=in();\n    for(int i=1;i&lt;=n;++i)\n    {\n        a[i]=in();\n        build(1,1,n,i,a[i]);\n    }\n    for(int i=1,op,x,y,k,pos;i&lt;=m;++i)\n    {\n        op=in();\n        switch(op)\n        {\n            case 1:x=in();y=in();k=in();printf(&quot;%d\\n&quot;,getrk(1,x,y,k)+1);break;\n            case 2:x=in();y=in();k=in();printf(&quot;%d\\n&quot;,kth(x,y,k));break;\n            case 3:pos=in();k=in();change(1,pos,k,a[pos]);a[pos]=k;break;\n            case 4:x=in();y=in();k=in();printf(&quot;%d\\n&quot;,getpre(1,x,y,k));break;\n            case 5:x=in();y=in();k=in();printf(&quot;%d\\n&quot;,getne(1,x,y,k));break;\n        }\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/06/21/二逼平衡树/","excerpt":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"平衡树","slug":"数据结构/平衡树","permalink":"https://prostkhala.github.io/categories/数据结构/平衡树/"},{"name":"SPLAY","slug":"数据结构/平衡树/SPLAY","permalink":"https://prostkhala.github.io/categories/数据结构/平衡树/SPLAY/"}],"tags":[{"name":"SPLAY","slug":"SPLAY","permalink":"https://prostkhala.github.io/tags/SPLAY/"},{"name":"二分答案","slug":"二分答案","permalink":"https://prostkhala.github.io/tags/二分答案/"},{"name":"线段树","slug":"线段树","permalink":"https://prostkhala.github.io/tags/线段树/"},{"name":"TREAP","slug":"TREAP","permalink":"https://prostkhala.github.io/tags/TREAP/"}]},{"title":"动态树总结","date":"2017-06-19T11:55:11.000Z","path":"2017/06/19/动态树总结/","text":"动态树总结概念动态树可以维护动态的森林，支持树的合并（LINK），拆分（CUT），动态LCA，换根，和所有树链剖分能支持的操作。动态树与树链剖分的区别在于树链剖分以线段树为基础，而动态树以SPLAY（按深度维护）为基础，这使得动态树相较前者可以支持动态的操作。 动态树中也有轻重链的概念，但其实现并不基于子树大小，而是在操作的过程中进行修改，使得每次需要操作的链处于同一SPLAY树中。需要特别说明的是，动态树对于子树的操作并不支持，但仍可以通过维护轻链的信息来完成简单点的操作。 核心操作动态树的核心操作有： ACCESS：将x到root的路径变为重链。 实现：将x一步一步向上跳，每次将其变为父亲的重儿子。 MAKEROOT：将x变为root。 实现：ACCESS（x）并将x旋转到该重链的根，然后对该平衡树进行翻转操作，使得x到root的深度顺序反转。 SPLIT：将x与y加入同一颗SPLAY树中。 实现：将x变为根节点，再ACCESS（y）。 LINK：树的合并。 实现：将x变为所在树的根节点，并将其接到y上。注意son数组记录的是SPLAY中关系，而fa数组记录的是整棵树和SPLAY树的关系。所以此处不需要更新son数组。 例题动态树COGS2701 题目描述开始时有n个点形成的森林，共m个操作。tp=1时，接下来一个参数u，表示将u所在的树树根变为u。tp=2时，接下来一个参数u，询问以u为根的子树的大小。tp=3时，接下来两个参数u,v，添加一条边(u,v)，并将u所在树的根作为两棵树合并后的根。 输入输出格式输入格式： 第一行两个整数n,m。 接下来m行，每行开头是一个整数tp。tp=1或tp=2时，接下来一个整数u。tp=3时，接下来两个整数(u,v)。 输出格式：对于每个询问，你需要输出以u为根的子树大小。 输入输出样例输入样例：5 10 3 2 3 3 4 5 3 2 4 2 1 2 5 3 1 2 2 4 1 3 2 1 2 4 输出样例：1 1 2 1 2 数据范围n&lt;=200000,m&lt;=400000 题解本题难点在于对于子树大小的查询，可以通过维护轻儿子的信息来实现，本题中SIZE数组维护的是子树大小而不是SPLAY中的信息，VIR数组维护的是轻儿子的信息。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 2e5+1; int son[N][2],mx[N],sum[N],w[N],size[N],rev[N],tag[N],fa[N],vir[N]; int n,m; bool isnotrt(int x){return son[fa[x]][0]==x||son[fa[x]][1]==x;} //void add(int x,int val) //{ // w[x]+=val;mx[x]+=val; // sum[x]+=size[x]*val; // tag[x]+=val; // return; //} void up(int x) { int l=son[x][0],r=son[x][1]; size[x]=size[l]+size[r]+vir[x]+1; // sum[x]=sum[l]+sum[r]+w[x]; // mx[x]=max(max(mx[l],mx[r]),w[x]); } void down(int x) { int &amp;l=son[x][0],&amp;r=son[x][1]; if(rev[x]) { rev[l]^=1;rev[r]^=1; swap(l,r); rev[x]=0; } // if(tag[x]) // { // add(son[x][0],tag[x]); // add(son[x][1],tag[x]); // tag[x]=0; // } return; } void rotate(int x) { down(fa[x]);down(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(isnotrt(y)) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; up(y);up(x); } void splay(int x) { down(x); while(isnotrt(x)) { int y=fa[x],z=fa[y]; if(isnotrt(y)) { if(son[y][0]==x^son[z][0]==y)rotate(x); else rotate(y); } rotate(x); } } void access(int x) { for(int y=0;x;y=x,x=fa[x]) { splay(x); vir[x]-=size[y]; vir[x]+=size[son[x][1]]; son[x][1]=y; up(x); } } void makert(int x){access(x);splay(x);rev[x]^=1;} void split(int x,int y){makert(x);access(y);splay(x);} void link(int x,int y){makert(y);fa[y]=x;vir[x]+=size[y];} void cut(int x,int y){split(x,y);son[x][1]=fa[y]=0;} int find(int x){access(x);splay(x);while(son[x][0])x=son[x][0];return x;} int main() { freopen(&quot;dynamic_tree.in&quot;,&quot;r&quot;,stdin); freopen(&quot;dynamic_tree.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x;i&lt;=n;i++)size[i]=1; for(int i=1,opt,x,y,z;i&lt;=m;++i) { scanf(&quot;%d%d&quot;,&amp;opt,&amp;x); if(opt==1) makert(x); else if(opt==2) { access(x); printf(&quot;%d\\n&quot;,vir[x]+1); } else if(opt==3) {scanf(&quot;%d&quot;,&amp;y);int z=find(x);link(x,y);makert(z);} } } /* 6 11 3 2 3 3 4 5 3 2 4 3 6 2 2 1 2 5 3 1 2 2 4 1 3 2 1 2 4 */ HNOI2010 弹飞绵羊COGS1689 题目描述某天，Lostmonkey发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 输入输出格式输入格式：第一行包含一个整数n，表示地上有n个装置，装置的编号从0到n-1,接下来一行有n个正整数，依次为那n个装置的初始弹力系数。第三行有一个正整数m，接下来m行每行至少有两个数i、j，若i=1，你要输出从j出发被弹几次后被弹飞，若i=2则还会再输入一个正整数k，表示第j个弹力装置的系数被修改成k。 输出格式：对于每个i=1的情况，你都要输出一个需要的步数，占一行。 输入输出样例输入样例：4 1 2 1 1 3 1 1 2 1 1 1 1 输出样例：2 3 数据范围对于10%的数据n,m&lt;=10000，对于100%的数据n&lt;=200000,m&lt;=100000 题解由于每个点的目标节点唯一，所以可以将其看为倒置的一棵树。设立一个哨兵节点n+1，每个会弹出去的位置都指向哨兵节点。那么每次查询实际上就是求x到根节点的链的长度，可以将链加入同一颗SPLAY中，然后查询SPLAY大小即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 3e5+1; int k[N],n,m,son[N][2],fa[N],size[N],sum[N],rev[N]; void up(int x){size[x]=size[son[x][0]]+size[son[x][1]]+1;} void down(int x) { if(rev[x]) { rev[x]^=1; rev[son[x][0]]^=1; rev[son[x][1]]^=1; swap(son[x][0],son[x][1]); } } int isrt(int x){return son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x;} void rotate(int x) { down(fa[x]);down(x); int y=fa[x],z=fa[y],t=son[y][0]==x; if(!isrt(y))son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[x][t]]=y; son[x][t]=y;fa[y]=x; up(y);up(x); } void splay(int x) { down(x); while(!isrt(x)) { int y=fa[x],z=fa[y]; if(!isrt(y)) { if(son[y][0]==x^son[z][0]==y)rotate(x); else rotate(y); } rotate(x); } } void access(int x) { for(int y=0;x;y=x,x=fa[x]) {splay(x);son[x][1]=y;up(x);} } void makert(int x){access(x);splay(x);rev[x]^=1;} void split(int x,int y){makert(x);access(y);splay(x);} void link(int x,int y){makert(x);fa[x]=y;} void cut(int x,int y){split(x,y);son[x][1]=fa[y]=0;} int main() { freopen(&quot;bzoj_2002.in&quot;,&quot;r&quot;,stdin); freopen(&quot;bzoj_2002.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;k[i]); if(k[i]+i&gt;=n+1)k[i]=n+1-i; link(i,i+k[i]); size[i]=1; } size[n+1]=1; scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;++i) { int op,x,val; scanf(&quot;%d%d&quot;,&amp;op,&amp;x); x++; if(op==1) { makert(n+1); makert(x); printf(&quot;%d\\n&quot;,size[x]-1); } else { scanf(&quot;%d&quot;,&amp;val); cut(x,x+k[x]); k[x]=val; if(k[x]+x&gt;=n+1)k[x]=n+1-x; link(x,x+k[x]); } } }","raw":"title: 动态树总结\ndate: 2017-06-19 19:55:11\ncategories:\n  - 数据结构\n  - 动态树\ntags:\n  - SPLAY\n  - 动态树\n---\n\n# 动态树总结\n\n## 概念\n\n动态树可以维护动态的森林，支持树的合并（LINK），拆分（CUT），动态LCA，换根，和所有树链剖分能支持的操作。动态树与树链剖分的区别在于树链剖分以线段树为基础，而动态树以SPLAY（按深度维护）为基础，这使得动态树相较前者可以支持动态的操作。\n\n动态树中也有轻重链的概念，但其实现并不基于子树大小，而是在操作的过程中进行修改，使得每次需要操作的链处于同一SPLAY树中。需要特别说明的是，动态树对于子树的操作并不支持，但仍可以通过维护轻链的信息来完成简单点的操作。\n\n---\n\n## 核心操作\n动态树的核心操作有：\n\n- ACCESS：将x到root的路径变为重链。\n\n> 实现：\n> 将x一步一步向上跳，每次将其变为父亲的重儿子。\n\n- MAKEROOT：将x变为root。\n\n> 实现：\n> ACCESS（x）并将x旋转到该重链的根，然后对该平衡树进行翻转操作，使得x到root的深度顺序反转。\n\n- SPLIT：将x与y加入同一颗SPLAY树中。\n- \n> 实现：将x变为根节点，再ACCESS（y）。\n\n- LINK：树的合并。\n\n> 实现：将x变为所在树的根节点，并将其接到y上。注意son数组记录的是SPLAY中关系，而fa数组记录的是整棵树和SPLAY树的关系。所以此处不需要更新son数组。\n\n\n---\n\n\n## 例题\n\n### 动态树\n\n#### [COGS2701](http://cogs.pro/cogs/problem/problem.php?pid=2701)\n---\n#### 题目描述\n开始时有n个点形成的森林，共m个操作。tp=1时，接下来一个参数u，表示将u所在的树树根变为u。tp=2时，接下来一个参数u，询问以u为根的子树的大小。tp=3时，接下来两个参数u,v，添加一条边(u,v)，并将u所在树的根作为两棵树合并后的根。 \n\n##### 输入输出格式\n###### 输入格式：\n 第一行两个整数n,m。\n\n接下来m行，每行开头是一个整数tp。tp=1或tp=2时，接下来一个整数u。tp=3时，接下来两个整数(u,v)。 \n\n###### 输出格式：\n对于每个询问，你需要输出以u为根的子树大小。 \n\n\n##### 输入输出样例\n###### 输入样例：\n    5 10\n    3 2 3\n    3 4 5\n    3 2 4\n    2 1\n    2 5\n    3 1 2\n    2 4\n    1 3\n    2 1\n    2 4\n  \n\n###### 输出样例：\n    1\n    1\n    2\n    1\n    2\n  \n\n##### 数据范围\nn<=200000,m<=400000 \n\n---\n\n#### 题解\n本题难点在于对于子树大小的查询，可以通过维护轻儿子的信息来实现，本题中SIZE数组维护的是子树大小而不是SPLAY中的信息，VIR数组维护的是轻儿子的信息。\n\n---\n##### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N = 2e5+1;\n    int son[N][2],mx[N],sum[N],w[N],size[N],rev[N],tag[N],fa[N],vir[N];\n    int n,m;\n\n    bool isnotrt(int x){return son[fa[x]][0]==x||son[fa[x]][1]==x;}\n\n    //void add(int x,int val)\n    //{\n    //\tw[x]+=val;mx[x]+=val;\n    //\tsum[x]+=size[x]*val;\n    //\ttag[x]+=val;\n    //\treturn;\n    //}\n\n    void up(int x)\n    {\n        int l=son[x][0],r=son[x][1];\n        size[x]=size[l]+size[r]+vir[x]+1;\n    //\tsum[x]=sum[l]+sum[r]+w[x];\n    //\tmx[x]=max(max(mx[l],mx[r]),w[x]);\n    }\n\n    void down(int x)\n    {\n        int &l=son[x][0],&r=son[x][1];\n        if(rev[x])\n        {\n            rev[l]^=1;rev[r]^=1;\n            swap(l,r);\n            rev[x]=0;\n        }\n    //\tif(tag[x])\n    //\t{\n    //\t\tadd(son[x][0],tag[x]);\n    //\t\tadd(son[x][1],tag[x]);\n    //\t\ttag[x]=0; \n    //\t}\n        return;\n    }\n\n    void rotate(int x)\n    {\n        down(fa[x]);down(x);\n        int y=fa[x],z=fa[y],t=(son[y][0]==x);\n        if(isnotrt(y)) son[z][son[z][1]==y]=x;fa[x]=z;\n        son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n        son[x][t]=y;fa[y]=x;\n        up(y);up(x);\n    }\n\n    void splay(int x)\n    {\n        down(x);\n        while(isnotrt(x))\n        {\n            int y=fa[x],z=fa[y];\n            if(isnotrt(y))\n            {\n                if(son[y][0]==x^son[z][0]==y)rotate(x);\n                else\trotate(y);\n            }\n            rotate(x);\n        }\n\n    }\n\n    void access(int x)\n    {\n        for(int y=0;x;y=x,x=fa[x])\n        {\n            splay(x);\n            vir[x]-=size[y];\n            vir[x]+=size[son[x][1]];\n            son[x][1]=y;\n            up(x);\n        }\n    }\n\n    void makert(int x){access(x);splay(x);rev[x]^=1;}\n\n    void split(int x,int y){makert(x);access(y);splay(x);}\n\n    void link(int x,int y){makert(y);fa[y]=x;vir[x]+=size[y];}\n\n    void cut(int x,int y){split(x,y);son[x][1]=fa[y]=0;}\n\n    int find(int x){access(x);splay(x);while(son[x][0])x=son[x][0];return x;}\n    int main()\n    {\n        freopen(\"dynamic_tree.in\",\"r\",stdin);\n        freopen(\"dynamic_tree.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1,x;i<=n;i++)size[i]=1;\n        for(int i=1,opt,x,y,z;i<=m;++i)\n        {\n            scanf(\"%d%d\",&opt,&x);\n            if(opt==1) makert(x);\n            else if(opt==2)\n            {\n                access(x);\n                printf(\"%d\\n\",vir[x]+1);\n            }\n            else if(opt==3) {scanf(\"%d\",&y);int z=find(x);link(x,y);makert(z);}\n        }\n    }\n    /*\n\n    6 11\n    3 2 3\n    3 4 5\n    3 2 4\n    3 6 2\n    2 1\n    2 5\n    3 1 2\n    2 4\n    1 3\n    2 1\n    2 4\n\n    */\n---\n\n\n\n### HNOI2010 弹飞绵羊\n\n#### [COGS1689](http://cogs.pro/cogs/problem/problem.php?pid=1689)\n---\n#### 题目描述\n某天，Lostmonkey发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 \n\n##### 输入输出格式\n###### 输入格式：\n第一行包含一个整数n，表示地上有n个装置，装置的编号从0到n-1,接下来一行有n个正整数，依次为那n个装置的初始弹力系数。第三行有一个正整数m，接下来m行每行至少有两个数i、j，若i=1，你要输出从j出发被弹几次后被弹飞，若i=2则还会再输入一个正整数k，表示第j个弹力装置的系数被修改成k。\n\n###### 输出格式：\n对于每个i=1的情况，你都要输出一个需要的步数，占一行。 \n\n\n##### 输入输出样例\n###### 输入样例：\n    4                              \n    1 2 1 1\t\t\t\t\t\t   \n    3\n    1 1\n    2 1 1\n    1 1\n  \n\n###### 输出样例：\n    2\n    3\n  \n\n##### 数据范围\n对于10%的数据n,m<=10000，对于100%的数据n<=200000,m<=100000 \n\n---\n\n#### 题解\n由于每个点的目标节点唯一，所以可以将其看为倒置的一棵树。设立一个哨兵节点n+1，每个会弹出去的位置都指向哨兵节点。\n那么每次查询实际上就是求x到根节点的链的长度，可以将链加入同一颗SPLAY中，然后查询SPLAY大小即可。\n\n---\n##### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 3e5+1;\n    int k[N],n,m,son[N][2],fa[N],size[N],sum[N],rev[N];\n\n    void up(int x){size[x]=size[son[x][0]]+size[son[x][1]]+1;}\n\n    void down(int x)\n    {\n        if(rev[x])\n        {\n            rev[x]^=1;\n            rev[son[x][0]]^=1;\n            rev[son[x][1]]^=1;\n            swap(son[x][0],son[x][1]);\n        }\n    }\n\n    int isrt(int x){return son[fa[x]][0]!=x&&son[fa[x]][1]!=x;}\n\n    void rotate(int x)\n    {\n        down(fa[x]);down(x);\n        int y=fa[x],z=fa[y],t=son[y][0]==x;\n        if(!isrt(y))son[z][son[z][1]==y]=x;fa[x]=z;\n        son[y][!t]=son[x][t];fa[son[x][t]]=y;\n        son[x][t]=y;fa[y]=x;\n        up(y);up(x);\n    }\n\n    void splay(int x)\n    {\n        down(x);\n        while(!isrt(x))\n        {\n            int y=fa[x],z=fa[y];\n            if(!isrt(y))\n            {\n                if(son[y][0]==x^son[z][0]==y)rotate(x);\n                else\trotate(y);\n            }\n            rotate(x);\n        }\n    }\n\n    void access(int x)\n    {\n        for(int y=0;x;y=x,x=fa[x])\n        {splay(x);son[x][1]=y;up(x);}\n    }\n\n    void makert(int x){access(x);splay(x);rev[x]^=1;}\n\n    void split(int x,int y){makert(x);access(y);splay(x);}\n\n    void link(int x,int y){makert(x);fa[x]=y;}\n\n    void cut(int x,int y){split(x,y);son[x][1]=fa[y]=0;}\n\n\n\n    int main()\n    {\n        freopen(\"bzoj_2002.in\",\"r\",stdin);\n        freopen(\"bzoj_2002.out\",\"w\",stdout);\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d\",&k[i]);\n            if(k[i]+i>=n+1)k[i]=n+1-i;\n            link(i,i+k[i]);\n            size[i]=1;\n        }\n        size[n+1]=1;\n        scanf(\"%d\",&m);\n        for(int i=1;i<=m;++i)\n        {\n            int op,x,val;\n            scanf(\"%d%d\",&op,&x);\n            x++;\n            if(op==1)\n            {\n                makert(n+1);\n                makert(x);\n                printf(\"%d\\n\",size[x]-1);\n            }\n            else\n            {\n                scanf(\"%d\",&val);\n                cut(x,x+k[x]);\n                k[x]=val;\n                if(k[x]+x>=n+1)k[x]=n+1-x;\n                link(x,x+k[x]);\n            }\n        }\n    }\n\n\n\n\n\n","content":"<h1 id=\"动态树总结\"><a href=\"#动态树总结\" class=\"headerlink\" title=\"动态树总结\"></a>动态树总结</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>动态树可以维护动态的森林，支持树的合并（LINK），拆分（CUT），动态LCA，换根，和所有树链剖分能支持的操作。动态树与树链剖分的区别在于树链剖分以线段树为基础，而动态树以SPLAY（按深度维护）为基础，这使得动态树相较前者可以支持动态的操作。</p>\n<p>动态树中也有轻重链的概念，但其实现并不基于子树大小，而是在操作的过程中进行修改，使得每次需要操作的链处于同一SPLAY树中。需要特别说明的是，动态树对于子树的操作并不支持，但仍可以通过维护轻链的信息来完成简单点的操作。</p>\n<hr>\n<h2 id=\"核心操作\"><a href=\"#核心操作\" class=\"headerlink\" title=\"核心操作\"></a>核心操作</h2><p>动态树的核心操作有：</p>\n<ul>\n<li>ACCESS：将x到root的路径变为重链。</li>\n</ul>\n<blockquote>\n<p>实现：<br>将x一步一步向上跳，每次将其变为父亲的重儿子。</p>\n</blockquote>\n<ul>\n<li>MAKEROOT：将x变为root。</li>\n</ul>\n<blockquote>\n<p>实现：<br>ACCESS（x）并将x旋转到该重链的根，然后对该平衡树进行翻转操作，使得x到root的深度顺序反转。</p>\n</blockquote>\n<ul>\n<li>SPLIT：将x与y加入同一颗SPLAY树中。</li>\n<li><blockquote>\n<p>实现：将x变为根节点，再ACCESS（y）。</p>\n</blockquote>\n</li>\n<li><p>LINK：树的合并。</p>\n</li>\n</ul>\n<blockquote>\n<p>实现：将x变为所在树的根节点，并将其接到y上。注意son数组记录的是SPLAY中关系，而fa数组记录的是整棵树和SPLAY树的关系。所以此处不需要更新son数组。</p>\n</blockquote>\n<hr>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><h3 id=\"动态树\"><a href=\"#动态树\" class=\"headerlink\" title=\"动态树\"></a>动态树</h3><h4 id=\"COGS2701\"><a href=\"#COGS2701\" class=\"headerlink\" title=\"COGS2701\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=2701\" target=\"_blank\" rel=\"external\">COGS2701</a></h4><hr>\n<h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><p>开始时有n个点形成的森林，共m个操作。tp=1时，接下来一个参数u，表示将u所在的树树根变为u。tp=2时，接下来一个参数u，询问以u为根的子树的大小。tp=3时，接下来两个参数u,v，添加一条边(u,v)，并将u所在树的根作为两棵树合并后的根。 </p>\n<h5 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h5><h6 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h6><p> 第一行两个整数n,m。</p>\n<p>接下来m行，每行开头是一个整数tp。tp=1或tp=2时，接下来一个整数u。tp=3时，接下来两个整数(u,v)。 </p>\n<h6 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h6><p>对于每个询问，你需要输出以u为根的子树大小。 </p>\n<h5 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h5><h6 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h6><pre><code>5 10\n3 2 3\n3 4 5\n3 2 4\n2 1\n2 5\n3 1 2\n2 4\n1 3\n2 1\n2 4\n</code></pre><h6 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h6><pre><code>1\n1\n2\n1\n2\n</code></pre><h5 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h5><p>n&lt;=200000,m&lt;=400000 </p>\n<hr>\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><p>本题难点在于对于子树大小的查询，可以通过维护轻儿子的信息来实现，本题中SIZE数组维护的是子树大小而不是SPLAY中的信息，VIR数组维护的是轻儿子的信息。</p>\n<hr>\n<h5 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h5><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N = 2e5+1;\nint son[N][2],mx[N],sum[N],w[N],size[N],rev[N],tag[N],fa[N],vir[N];\nint n,m;\n\nbool isnotrt(int x){return son[fa[x]][0]==x||son[fa[x]][1]==x;}\n\n//void add(int x,int val)\n//{\n//    w[x]+=val;mx[x]+=val;\n//    sum[x]+=size[x]*val;\n//    tag[x]+=val;\n//    return;\n//}\n\nvoid up(int x)\n{\n    int l=son[x][0],r=son[x][1];\n    size[x]=size[l]+size[r]+vir[x]+1;\n//    sum[x]=sum[l]+sum[r]+w[x];\n//    mx[x]=max(max(mx[l],mx[r]),w[x]);\n}\n\nvoid down(int x)\n{\n    int &amp;l=son[x][0],&amp;r=son[x][1];\n    if(rev[x])\n    {\n        rev[l]^=1;rev[r]^=1;\n        swap(l,r);\n        rev[x]=0;\n    }\n//    if(tag[x])\n//    {\n//        add(son[x][0],tag[x]);\n//        add(son[x][1],tag[x]);\n//        tag[x]=0; \n//    }\n    return;\n}\n\nvoid rotate(int x)\n{\n    down(fa[x]);down(x);\n    int y=fa[x],z=fa[y],t=(son[y][0]==x);\n    if(isnotrt(y)) son[z][son[z][1]==y]=x;fa[x]=z;\n    son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n    son[x][t]=y;fa[y]=x;\n    up(y);up(x);\n}\n\nvoid splay(int x)\n{\n    down(x);\n    while(isnotrt(x))\n    {\n        int y=fa[x],z=fa[y];\n        if(isnotrt(y))\n        {\n            if(son[y][0]==x^son[z][0]==y)rotate(x);\n            else    rotate(y);\n        }\n        rotate(x);\n    }\n\n}\n\nvoid access(int x)\n{\n    for(int y=0;x;y=x,x=fa[x])\n    {\n        splay(x);\n        vir[x]-=size[y];\n        vir[x]+=size[son[x][1]];\n        son[x][1]=y;\n        up(x);\n    }\n}\n\nvoid makert(int x){access(x);splay(x);rev[x]^=1;}\n\nvoid split(int x,int y){makert(x);access(y);splay(x);}\n\nvoid link(int x,int y){makert(y);fa[y]=x;vir[x]+=size[y];}\n\nvoid cut(int x,int y){split(x,y);son[x][1]=fa[y]=0;}\n\nint find(int x){access(x);splay(x);while(son[x][0])x=son[x][0];return x;}\nint main()\n{\n    freopen(&quot;dynamic_tree.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;dynamic_tree.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1,x;i&lt;=n;i++)size[i]=1;\n    for(int i=1,opt,x,y,z;i&lt;=m;++i)\n    {\n        scanf(&quot;%d%d&quot;,&amp;opt,&amp;x);\n        if(opt==1) makert(x);\n        else if(opt==2)\n        {\n            access(x);\n            printf(&quot;%d\\n&quot;,vir[x]+1);\n        }\n        else if(opt==3) {scanf(&quot;%d&quot;,&amp;y);int z=find(x);link(x,y);makert(z);}\n    }\n}\n/*\n\n6 11\n3 2 3\n3 4 5\n3 2 4\n3 6 2\n2 1\n2 5\n3 1 2\n2 4\n1 3\n2 1\n2 4\n\n*/\n</code></pre><hr>\n<h3 id=\"HNOI2010-弹飞绵羊\"><a href=\"#HNOI2010-弹飞绵羊\" class=\"headerlink\" title=\"HNOI2010 弹飞绵羊\"></a>HNOI2010 弹飞绵羊</h3><h4 id=\"COGS1689\"><a href=\"#COGS1689\" class=\"headerlink\" title=\"COGS1689\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1689\" target=\"_blank\" rel=\"external\">COGS1689</a></h4><hr>\n<h4 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><p>某天，Lostmonkey发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 </p>\n<h5 id=\"输入输出格式-1\"><a href=\"#输入输出格式-1\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h5><h6 id=\"输入格式：-1\"><a href=\"#输入格式：-1\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h6><p>第一行包含一个整数n，表示地上有n个装置，装置的编号从0到n-1,接下来一行有n个正整数，依次为那n个装置的初始弹力系数。第三行有一个正整数m，接下来m行每行至少有两个数i、j，若i=1，你要输出从j出发被弹几次后被弹飞，若i=2则还会再输入一个正整数k，表示第j个弹力装置的系数被修改成k。</p>\n<h6 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h6><p>对于每个i=1的情况，你都要输出一个需要的步数，占一行。 </p>\n<h5 id=\"输入输出样例-1\"><a href=\"#输入输出样例-1\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h5><h6 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h6><pre><code>4                              \n1 2 1 1                           \n3\n1 1\n2 1 1\n1 1\n</code></pre><h6 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h6><pre><code>2\n3\n</code></pre><h5 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h5><p>对于10%的数据n,m&lt;=10000，对于100%的数据n&lt;=200000,m&lt;=100000 </p>\n<hr>\n<h4 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h4><p>由于每个点的目标节点唯一，所以可以将其看为倒置的一棵树。设立一个哨兵节点n+1，每个会弹出去的位置都指向哨兵节点。<br>那么每次查询实际上就是求x到根节点的链的长度，可以将链加入同一颗SPLAY中，然后查询SPLAY大小即可。</p>\n<hr>\n<h5 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h5><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 3e5+1;\nint k[N],n,m,son[N][2],fa[N],size[N],sum[N],rev[N];\n\nvoid up(int x){size[x]=size[son[x][0]]+size[son[x][1]]+1;}\n\nvoid down(int x)\n{\n    if(rev[x])\n    {\n        rev[x]^=1;\n        rev[son[x][0]]^=1;\n        rev[son[x][1]]^=1;\n        swap(son[x][0],son[x][1]);\n    }\n}\n\nint isrt(int x){return son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x;}\n\nvoid rotate(int x)\n{\n    down(fa[x]);down(x);\n    int y=fa[x],z=fa[y],t=son[y][0]==x;\n    if(!isrt(y))son[z][son[z][1]==y]=x;fa[x]=z;\n    son[y][!t]=son[x][t];fa[son[x][t]]=y;\n    son[x][t]=y;fa[y]=x;\n    up(y);up(x);\n}\n\nvoid splay(int x)\n{\n    down(x);\n    while(!isrt(x))\n    {\n        int y=fa[x],z=fa[y];\n        if(!isrt(y))\n        {\n            if(son[y][0]==x^son[z][0]==y)rotate(x);\n            else    rotate(y);\n        }\n        rotate(x);\n    }\n}\n\nvoid access(int x)\n{\n    for(int y=0;x;y=x,x=fa[x])\n    {splay(x);son[x][1]=y;up(x);}\n}\n\nvoid makert(int x){access(x);splay(x);rev[x]^=1;}\n\nvoid split(int x,int y){makert(x);access(y);splay(x);}\n\nvoid link(int x,int y){makert(x);fa[x]=y;}\n\nvoid cut(int x,int y){split(x,y);son[x][1]=fa[y]=0;}\n\n\n\nint main()\n{\n    freopen(&quot;bzoj_2002.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;bzoj_2002.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1;i&lt;=n;i++)\n    {\n        scanf(&quot;%d&quot;,&amp;k[i]);\n        if(k[i]+i&gt;=n+1)k[i]=n+1-i;\n        link(i,i+k[i]);\n        size[i]=1;\n    }\n    size[n+1]=1;\n    scanf(&quot;%d&quot;,&amp;m);\n    for(int i=1;i&lt;=m;++i)\n    {\n        int op,x,val;\n        scanf(&quot;%d%d&quot;,&amp;op,&amp;x);\n        x++;\n        if(op==1)\n        {\n            makert(n+1);\n            makert(x);\n            printf(&quot;%d\\n&quot;,size[x]-1);\n        }\n        else\n        {\n            scanf(&quot;%d&quot;,&amp;val);\n            cut(x,x+k[x]);\n            k[x]=val;\n            if(k[x]+x&gt;=n+1)k[x]=n+1-x;\n            link(x,x+k[x]);\n        }\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/06/19/动态树总结/","excerpt":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"动态树","slug":"数据结构/动态树","permalink":"https://prostkhala.github.io/categories/数据结构/动态树/"}],"tags":[{"name":"SPLAY","slug":"SPLAY","permalink":"https://prostkhala.github.io/tags/SPLAY/"},{"name":"动态树","slug":"动态树","permalink":"https://prostkhala.github.io/tags/动态树/"}]},{"title":"线性基总结","date":"2017-06-17T03:21:12.000Z","path":"2017/06/17/线性基总结/","text":"概念张成对于一个集合$S$，其张成定义为其中所有子集的异或和，记为$span(S)$。 根据异或的性质，易知其张成满足或存在： 封闭性：对于任何两个元素，其异或和唯一。 结合律：$(a xor b) xor c=a xor (b xor c)$。 单位元：$e=0 $且$e xor a=a$。 逆元:$a xor a = e$。 则$span(S)$构成一个群。 线性相关对于一个集合 $S$，如果存在一个元素 $S_j$，使得$S$ 在去除这个元素后得到的集合 $ S’ $ 的张成不变，则称集合$S$线性相关，相应的，如果不存在这样的元素，则集合$S$线性无关。 线性基对于一个集合$S$，其线性基定义为满足线性无关的情况下的$span(S)$最小的子集，可以记为$span(S)’$，则有$span(span(S)’)$与 $span(S)$等价。 线性基的构造线性基的构造可以通过高斯消元或者一种类似贪心的算法完成，后者支持动态操作，所以在此处着重介绍。 已知集合 $S$ 中最大的数在二进制意义下有 $L$ 位，我们使用一个 $a[0…L]$来储存线性基，则该线性基的元素个数为$L$。 对于$a$数组，需要保证一下性质： 性质$a_i=0$ 则只有满足 $j&gt;i$的$a_j$的第$i$个二进制位可能为$1$；（性质一） $ai≠0$ 整个$a$数组中只有$a_i$的第$i$个二进制位为$1$；（性质二） $a_i$更高的二进制位一定为$0$；（性质三） $a_i$ 更低的二进制位可能为$1$； 对于异或最大和的问题，我们可以通过贪心求解，即从高位到低位枚举是否有元素的二进制当前位为$1$，如果有，则亦或上该元素，而该构造方法则可以类比于上述操作中将该元素记录下来，而下文中构造的操作，同样保证了每一个元素均可以由线性基构造出来。 流程对于每个新加入的元素$t$，从$L$枚举其二进制每一位$i$ $a_i≠0$那么将$t$异或上$a_i$（根据群的性质，可知该操作在保证张成不变的情况下使得$t$为$1$的位数尽可能少，并满足以上性质一以及性质二，且如果新插入一个元素已经在当前线性基的张成中，则在该操作后元素变为$0$） $a_i=0$那么将$a$数组中每一个下标大于$i$且第$i$位为$1$的元素异或上$t$。将$t$异或上$a$数组中每一个下标小于$i$且第$i$位为$1$的元素。并将$t$插入$a_i$（根据群的性质，可知该操作在保证张成不变的情况下使得数组中二进制$1$的个数尽可能少） 题目最大异或和题解直接套用线性基即可，如上所述，线性基实际上将贪心求解异或最大值的过程记录了下来，那么直接异或上线性基数组的值即可。、 CODE#include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; typedef long long ll; const int MAXN=55; ll B[MAXN]; int n,m; vector&lt;ll&gt; V; inline void insert(ll x) { for(int i=MAXN-1;i&gt;=0;--i) { if((x&amp;(1LL&lt;&lt;i))==0) continue; if(B[i]) x^=B[i]; else { for(int j=0;j&lt;i;++j) { if(x&amp;(1LL&lt;&lt;j)) x^=B[j]; } for(int j=i+1;j&lt;MAXN;++j) { if(B[j]&amp;(1LL&lt;&lt;i)) B[j]^=x; } B[i]^=x; return; } } } inline ll qry(ll x) { ll s=0; for(int i=0;i&lt;V.size();++i) { if(x&amp;(1LL&lt;&lt;i)) s^=V[i]; } return s; } int main() { scanf(&quot;%d&quot;,&amp;n); ll x; for(int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,&amp;x),insert(x); ll cnt=0; for(int i=0;i&lt;MAXN;++i) if(B[i])V.push_back(B[i]); for(int i=0;i&lt;V.size();++i)cnt^=V[i]; printf(&quot;%d\\n&quot;,cnt); return 0; } K小异或和题解 对于第K大的线性基，易知其为将原数组的张成中的元素的来源线性基先内部排序再先按顺序排列后的第K个。 以下分别表示所有的异或和的可能性，按以上顺序排序($L=3$,以下数字表示$a$数组的下标) （易知其张成的阶为$2^{span(span(S)’}-1$） 二进制表示 1 第1小 1 2 第2小 10 1 xor 2 第3小 11 3 第4小 100 1 xor 3 第5小 101 2 xor 3 第6小 110 1 xor 2 xor 3 第7小 111 观察可知，$K$小异或和即为$K$的二进制分解中为$1$的位置在$a$中作为下标的线性基的异或和 如$5=101(2)$，则有第$5$小为 $1 xor 3$（第一位，第三位均为$1$） CODE#include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; typedef long long ll; const int MAXN=55; ll B[MAXN]; int n,m; vector&lt;ll&gt; V; inline void insert(ll x) { for(int i=MAXN-1;i&gt;=0;--i) { if((x&amp;(1LL&lt;&lt;i))==0) continue; if(B[i]) x^=B[i]; else { for(int j=0;j&lt;i;++j) { if(x&amp;(1LL&lt;&lt;j)) x^=B[j]; } for(int j=i+1;j&lt;MAXN;++j) { if(B[j]&amp;(1LL&lt;&lt;i)) B[j]^=x; } B[i]^=x; return; } } } inline ll qry(ll x) { ll s=0; for(int i=0;i&lt;V.size();++i) { if(x&amp;(1LL&lt;&lt;i)) s^=V[i]; } return s; } int main() { scanf(&quot;%d&quot;,&amp;n); ll x; for(int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,&amp;x),insert(x); ll cnt=0; for(int i=0;i&lt;MAXN;++i) if(B[i])V.push_back(B[i]); scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;++i) { scanf(&quot;%lld&quot;,&amp;x); if(V.size()!=n) --x; if(x&gt;=(1LL&lt;&lt;V.size())) printf(&quot;-1\\n&quot;); else printf(&quot;%lld\\n&quot;,qry(x)); } return 0; } HAOI2017 八纵八横题目描述 输入格式 输出格式 样例输入4 4 3 1 2 1110 1 3 10 2 4 1110 2 3 100 Add 3 4 11 Change 1 101 Cancel 1 样例输出1000 1001 1111 1000 数据范围 题解CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;bitset&gt; #include&lt;algorithm&gt; using namespace std; const int N = 1e3+1; bitset&lt;1024&gt;a,e2[N],v[N],M[N],mat[N],dis[N]; int n,m,Q,head[N],cnt,cnt1,fa[N],e1[N][2],now,huan[N]; char opt[N],ch[N]; bitset&lt;1024&gt; readb() { bitset&lt;1024&gt;t;t.reset(); scanf(&quot;%s&quot;,ch); int len=strlen(ch); for(int i=0;i&lt;len;++i) t[len-i-1]=ch[i]-&#39;0&#39;; return t; } struct nd{int ne,to;bitset&lt;1024&gt;w;}e[N*2]; void in(int x,int y,bitset&lt;1024&gt;w) {e[++cnt].to=y;e[cnt].w=w;e[cnt].ne=head[x];head[x]=cnt;return;} int gf(int x){return fa[x]==x?x:fa[x]=gf(fa[x]);} void dfs(int x,int f) { for(int i=head[x];i;i=e[i].ne) if(e[i].to!=f) { dis[e[i].to]=dis[x]^e[i].w; dfs(e[i].to,x); } } int update(int x,bitset&lt;1024&gt;y) { now=0; for(int i=0;i&lt;N;++i) if(M[i][x]&amp;&amp;mat[i].none()) { now=i; break; } if(!now) for(int i=0;i&lt;N;++i) if(M[huan[i]][x]&amp;&amp;huan[i]!=0) { now=huan[i]; huan[i]=0; break; } for(int i=0;i&lt;N;++i) if(now!=i&amp;&amp;M[i][x]) { mat[i]=mat[i]^mat[now]; M[i]=M[i]^M[now]; } mat[now]^=y; for(int i=N;i&gt;=0;--i) if(mat[now][i]) { if(!huan[i]){huan[i]=now;break;} else mat[now]=mat[now]^mat[huan[i]],M[now]=M[now]^M[huan[i]]; } return 0; } void put() { bitset&lt;1024&gt;ans; ans.reset(); for(int i=N-1;i&gt;=0;--i) if(ans[i]==0&amp;&amp;huan[i]) ans^=mat[huan[i]]; char *tmp,tong[N]; if(ans.none()) puts(&quot;0&quot;); else { tmp=tong; for(int i=N-1;i&gt;=0;--i) if(ans[i]) { for(int j=i;j&gt;=0;--j) *(tmp++)=ans[j]+&#39;0&#39;; break; } *(tmp++)=&#39;\\0&#39;; puts(tong); } } int main() { freopen(&quot;eights.in&quot;,&quot;r&quot;,stdin); freopen(&quot;eights.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q); for(int i=1;i&lt;=n;++i)fa[i]=i; for(int i=1;i&lt;N;++i)M[i][i]=1; for(int i=1,x,y;i&lt;=m;++i) { scanf(&quot;%d%d&quot;,&amp;x,&amp;y); a=readb(); if(gf(x)==gf(y)) { e1[++cnt1][0]=x; e1[cnt1][1]=y; v[cnt1]=a; } else fa[gf(x)]=gf(y),in(x,y,a),in(y,x,a); } dfs(1,-1); int cntn=cnt1; for(int i=1;i&lt;=cnt1;++i) update(i,dis[e1[i][0]]^dis[e1[i][1]]^v[i]); put(); for(int i=1,x,y;i&lt;=Q;++i) { scanf(&quot;%s&quot;,opt); if(opt[1]==&#39;d&#39;) { scanf(&quot;%d%d&quot;,&amp;x,&amp;y); a=readb(); e1[++cnt1][0]=x;e1[cnt1][1]=y,e2[cnt]=a; v[cnt1]=a; update(cnt1,dis[e1[cnt1][0]]^dis[e1[cnt1][1]]^v[cnt1]); } if(opt[1]==&#39;h&#39;) { scanf(&quot;%d&quot;,&amp;x); a=readb(); update(x+cntn,v[x+cntn]^a); v[x+cntn]=a; } if(opt[1]==&#39;a&#39;) { scanf(&quot;%d&quot;,&amp;x); update(x+cntn,dis[e1[x+cntn][0]]^dis[e1[x+cntn][1]]^v[x+cntn]); v[x+cntn]=0; } put(); } }","raw":"title: 线性基总结\ndate: 2017-06-17 11:21:12\ncategories:\n  - 线性基\ntags:\n  - 线性基\n---\n\n# 概念\n\n## 张成 \n对于一个集合$S$，其张成定义为其中所有子集的异或和，记为$span(S)$。\n\n根据异或的性质，易知其张成满足或存在：\n- 封闭性：对于任何两个元素，其异或和唯一。\n- 结合律：$(a \\ xor \\ b) \\ xor \\  c=a \\ xor \\ (b \\ xor \\  c)$。\n- 单位元：$e=0 $且$e \\ xor \\ a=a$。\n- 逆元:$a \\ xor \\ a = e$。\n\n则$span(S)$构成一个群。\n\n## 线性相关\n\n对于一个集合 $S$，如果存在一个元素 $S_j$，使得$S$ 在去除这个元素后得到的集合 $ S' $ 的张成不变，则称集合$S$线性相关，相应的，如果不存在这样的元素，则集合$S$线性无关。\n\n\n## 线性基\n对于一个集合$S$，其线性基定义为满足线性无关的情况下的$span(S)$最小的子集，可以记为$span(S)'$，则有$span(span(S)')$与 $span(S)$等价。\n\n---\n\n# 线性基的构造\n\n线性基的构造可以通过高斯消元或者一种类似贪心的算法完成，后者支持动态操作，所以在此处着重介绍。\n\n已知集合 $S$ 中最大的数在二进制意义下有 $L$ 位，我们使用一个 $a[0…L]$来储存线性基，则该线性基的元素个数为$L$。\n\n对于$a$数组，需要保证一下性质：\n\n## 性质\n\n### $a_i=0$\n- 则只有满足 $j>i$的$a_j$的第$i$个二进制位可能为$1$；（性质一）\n\n### $ai≠0$\n\n- 整个$a$数组中只有$a_i$的第$i$个二进制位为$1$；（性质二）\n- $a_i$更高的二进制位一定为$0$；（性质三）\n- $a_i$ 更低的二进制位可能为$1$；\n\n对于异或最大和的问题，我们可以通过贪心求解，即从高位到低位枚举是否有元素的二进制当前位为$1$，如果有，则亦或上该元素，而该构造方法则可以类比于上述操作中将该元素记录下来，而下文中构造的操作，同样保证了每一个元素均可以由线性基构造出来。\n\n## 流程\n\n对于每个新加入的元素$t$，从$L$枚举其二进制每一位$i$\n### $a_i≠0$\n\n那么将$t$异或上$a_i$（根据群的性质，可知该操作在保证张成不变的情况下使得$t$为$1$的位数尽可能少，并满足以上性质一以及性质二，且如果新插入一个元素已经在当前线性基的张成中，则在该操作后元素变为$0$）\n\n### $a_i=0$\n\n那么将$a$数组中每一个下标大于$i$且第$i$位为$1$的元素异或上$t$。将$t$异或上$a$数组中每一个下标小于$i$且第$i$位为$1$的元素。并将$t$插入$a_i$（根据群的性质，可知该操作在保证张成不变的情况下使得数组中二进制$1$的个数尽可能少）\n\n---\n## 题目\n### 最大异或和\n\n#### 题解\n直接套用线性基即可，如上所述，线性基实际上将贪心求解异或最大值的过程记录了下来，那么直接异或上线性基数组的值即可。\n、\n#### CODE\n    #include <cstdio>\n    #include <vector>\n    using namespace std;\n    typedef long long ll;\n    const int MAXN=55;\n    ll B[MAXN];\n    int n,m;\n\n    vector<ll> V;\n\n    inline void insert(ll x)\n    {\n        for(int i=MAXN-1;i>=0;--i)\n        {\n            if((x&(1LL<<i))==0) continue;\n            if(B[i]) x^=B[i];\n            else\n            {\n                for(int j=0;j<i;++j)\n                {\n                    if(x&(1LL<<j))\n                        x^=B[j];\n                }\n                for(int j=i+1;j<MAXN;++j)\n                {\n                    if(B[j]&(1LL<<i))\n                        B[j]^=x;\n                }\n                B[i]^=x;\n                return;\n            }\n        }\n    }\n\n    inline ll qry(ll x)\n    {\n        ll s=0;\n        for(int i=0;i<V.size();++i)\n        {\n            if(x&(1LL<<i))\n                s^=V[i];\n        }\n        return s;\n    }\n\n    int main()\n    {\n        scanf(\"%d\",&n);\n        ll x;\n        for(int i=1;i<=n;++i)\n        scanf(\"%lld\",&x),insert(x);\n        ll cnt=0;\n        for(int i=0;i<MAXN;++i)\n        if(B[i])V.push_back(B[i]);\n        for(int i=0;i<V.size();++i)cnt^=V[i];\n        printf(\"%d\\n\",cnt);\n        return 0;\n    }\n\n\n    \n    \n ---\n \n ### K小异或和\n \n #### 题解\n 对于第K大的线性基，易知其为将原数组的张成中的元素的来源线性基先内部排序再先按顺序排列后的第K个。\n \n以下分别表示所有的异或和的可能性，按以上顺序排序($L=3$,以下数字表示$a$数组的下标)\n\n（易知其张成的阶为$2^{span(span(S)'}-1$）\n\n\t\t\t\t\t\t\t\t二进制表示\n \n     1              第1小\t\t\t1\n\n     2\t\t\t\t第2小\t\t\t10\n\n     1  xor  2\t\t第3小\t\t\t11\n\n     3\t\t\t\t第4小\t\t\t100\n\n     1  xor  3\t\t第5小\t\t\t101\n\n     2  xor  3\t\t第6小\t\t\t110\n     \n     1  xor  2  xor  3\t第7小\t\t111\n     \n  观察可知，$K$小异或和即为$K$的二进制分解中为$1$的位置在$a$中作为下标的线性基的异或和\n  \n  如$5=101(2)$，则有第$5$小为 $1 \\ xor \\ 3$（第一位，第三位均为$1$）\n\n\n#### CODE\n\n    #include <cstdio>\n    #include <vector>\n    using namespace std;\n    typedef long long ll;\n    const int MAXN=55;\n    ll B[MAXN];\n    int n,m;\n\n    vector<ll> V;\n\n    inline void insert(ll x)\n    {\n        for(int i=MAXN-1;i>=0;--i)\n        {\n            if((x&(1LL<<i))==0) continue;\n            if(B[i]) x^=B[i];\n            else\n            {\n                for(int j=0;j<i;++j)\n                {\n                    if(x&(1LL<<j))\n                        x^=B[j];\n                }\n                for(int j=i+1;j<MAXN;++j)\n                {\n                    if(B[j]&(1LL<<i))\n                        B[j]^=x;\n                }\n                B[i]^=x;\n                return;\n            }\n        }\n    }\n\n    inline ll qry(ll x)\n    {\n        ll s=0;\n        for(int i=0;i<V.size();++i)\n        {\n            if(x&(1LL<<i))\n                s^=V[i];\n        }\n        return s;\n    }\n\n    int main()\n    {\n        scanf(\"%d\",&n);\n        ll x;\n        for(int i=1;i<=n;++i)\n        scanf(\"%lld\",&x),insert(x);\n        ll cnt=0;\n        for(int i=0;i<MAXN;++i)\n        if(B[i])V.push_back(B[i]);\n        scanf(\"%d\",&m);\n        for(int i=1;i<=m;++i)\n        {\n            scanf(\"%lld\",&x);\n            if(V.size()!=n) --x;\n            if(x>=(1LL<<V.size())) \n                    printf(\"-1\\n\");\n            else \tprintf(\"%lld\\n\",qry(x));\n        }\n        return 0;\n    }\n\n\n---\n\n### HAOI2017 八纵八横\n\n#### 题目描述\n\n![](http://cogs.pro/upload/image/20170425/20170425110608_53125.png)\n\n##### 输入格式\n![](http://cogs.pro/upload/image/20170425/20170425110628_17349.png)\n\n##### 输出格式\n![](http://cogs.pro/upload/image/20170425/20170425110642_17321.png)\n\n##### 样例输入\n    4 4 3\n    1 2 1110\n    1 3 10\n    2 4 1110\n    2 3 100\n    Add 3 4 11\n    Change 1 101\n    Cancel 1\n##### 样例输出\n    1000\n    1001\n    1111\n    1000\n    \n##### 数据范围\n\n![](http://cogs.pro/upload/image/20170425/20170425110728_24299.png)\n\n#### 题解\n\n#### CODE\n\n\t#include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<bitset>\n    #include<algorithm>\n    using namespace std;\n    const int N = 1e3+1;\n    bitset<1024>a,e2[N],v[N],M[N],mat[N],dis[N];\n    int n,m,Q,head[N],cnt,cnt1,fa[N],e1[N][2],now,huan[N];\n    char opt[N],ch[N];\n    bitset<1024> readb()\n    {\n        bitset<1024>t;t.reset();\n        scanf(\"%s\",ch);\n        int len=strlen(ch);\n        for(int i=0;i<len;++i)\n        t[len-i-1]=ch[i]-'0';\n        return t;\n    }\n    struct nd{int ne,to;bitset<1024>w;}e[N*2];\n    void in(int x,int y,bitset<1024>w)\n    {e[++cnt].to=y;e[cnt].w=w;e[cnt].ne=head[x];head[x]=cnt;return;}\n    int gf(int x){return fa[x]==x?x:fa[x]=gf(fa[x]);}\n    void dfs(int x,int f)\n    {\n        for(int i=head[x];i;i=e[i].ne)\n        if(e[i].to!=f)\n        {\n            dis[e[i].to]=dis[x]^e[i].w;  \n            dfs(e[i].to,x);\n        }\n    }\n    int update(int x,bitset<1024>y)\n    {\n        now=0;\n        for(int i=0;i<N;++i)\n        if(M[i][x]&&mat[i].none())\n        {\n            now=i;\n            break;\n        }\n        if(!now)\n\n        for(int i=0;i<N;++i)\n        if(M[huan[i]][x]&&huan[i]!=0)\n        {\n            now=huan[i];\n            huan[i]=0;\n            break;\n        }\n        for(int i=0;i<N;++i)\n        if(now!=i&&M[i][x])\n        {\n            mat[i]=mat[i]^mat[now];\n            M[i]=M[i]^M[now];\n        }\n        mat[now]^=y;\n        for(int i=N;i>=0;--i)\n        if(mat[now][i])\n        {\n            if(!huan[i]){huan[i]=now;break;}\n            else mat[now]=mat[now]^mat[huan[i]],M[now]=M[now]^M[huan[i]];\n        }\n        return 0;\n    }\n    void put()\n    {\n        bitset<1024>ans;\n        ans.reset();\n        for(int i=N-1;i>=0;--i)\n        if(ans[i]==0&&huan[i])\n        ans^=mat[huan[i]];\n        char *tmp,tong[N];\n        if(ans.none()) puts(\"0\");\n        else\n        {\n            tmp=tong;\n            for(int i=N-1;i>=0;--i)\n            if(ans[i])\n            {\n                for(int j=i;j>=0;--j)\n                *(tmp++)=ans[j]+'0';\n                break;\n            }\n            *(tmp++)='\\0';  \n            puts(tong);\n        }\n    }\n    int main()\n    {\n        freopen(\"eights.in\",\"r\",stdin);\n        freopen(\"eights.out\",\"w\",stdout);\n        scanf(\"%d%d%d\",&n,&m,&Q);\n        for(int i=1;i<=n;++i)fa[i]=i;\n        for(int i=1;i<N;++i)M[i][i]=1;\n        for(int i=1,x,y;i<=m;++i)\n        {\n            scanf(\"%d%d\",&x,&y);\n            a=readb();\n            if(gf(x)==gf(y))\n            {\n                e1[++cnt1][0]=x;\n                e1[cnt1][1]=y;\n                v[cnt1]=a;\n            }\n            else\n            fa[gf(x)]=gf(y),in(x,y,a),in(y,x,a);\n        }\n        dfs(1,-1);\n        int cntn=cnt1;\n        for(int i=1;i<=cnt1;++i)\n        update(i,dis[e1[i][0]]^dis[e1[i][1]]^v[i]);\n        put();\n        for(int i=1,x,y;i<=Q;++i)\n        {\n            scanf(\"%s\",opt);\n            if(opt[1]=='d')\n            {\n                scanf(\"%d%d\",&x,&y);\n                a=readb();\n                e1[++cnt1][0]=x;e1[cnt1][1]=y,e2[cnt]=a;\n                v[cnt1]=a;\n                update(cnt1,dis[e1[cnt1][0]]^dis[e1[cnt1][1]]^v[cnt1]);\n            }\n            if(opt[1]=='h')\n            {\n                scanf(\"%d\",&x);\n                a=readb();\n                update(x+cntn,v[x+cntn]^a);\n                v[x+cntn]=a;\n            }\n            if(opt[1]=='a')\n            {\n                scanf(\"%d\",&x);\n                update(x+cntn,dis[e1[x+cntn][0]]^dis[e1[x+cntn][1]]^v[x+cntn]);\n                v[x+cntn]=0;\n            }\n            put();\n        }\n    }\n","content":"<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><h2 id=\"张成\"><a href=\"#张成\" class=\"headerlink\" title=\"张成\"></a>张成</h2><p>对于一个集合$S$，其张成定义为其中所有子集的异或和，记为$span(S)$。</p>\n<p>根据异或的性质，易知其张成满足或存在：</p>\n<ul>\n<li>封闭性：对于任何两个元素，其异或和唯一。</li>\n<li>结合律：$(a  xor  b)  xor   c=a  xor  (b  xor   c)$。</li>\n<li>单位元：$e=0 $且$e  xor  a=a$。</li>\n<li>逆元:$a  xor  a = e$。</li>\n</ul>\n<p>则$span(S)$构成一个群。</p>\n<h2 id=\"线性相关\"><a href=\"#线性相关\" class=\"headerlink\" title=\"线性相关\"></a>线性相关</h2><p>对于一个集合 $S$，如果存在一个元素 $S_j$，使得$S$ 在去除这个元素后得到的集合 $ S’ $ 的张成不变，则称集合$S$线性相关，相应的，如果不存在这样的元素，则集合$S$线性无关。</p>\n<h2 id=\"线性基\"><a href=\"#线性基\" class=\"headerlink\" title=\"线性基\"></a>线性基</h2><p>对于一个集合$S$，其线性基定义为满足线性无关的情况下的$span(S)$最小的子集，可以记为$span(S)’$，则有$span(span(S)’)$与 $span(S)$等价。</p>\n<hr>\n<h1 id=\"线性基的构造\"><a href=\"#线性基的构造\" class=\"headerlink\" title=\"线性基的构造\"></a>线性基的构造</h1><p>线性基的构造可以通过高斯消元或者一种类似贪心的算法完成，后者支持动态操作，所以在此处着重介绍。</p>\n<p>已知集合 $S$ 中最大的数在二进制意义下有 $L$ 位，我们使用一个 $a[0…L]$来储存线性基，则该线性基的元素个数为$L$。</p>\n<p>对于$a$数组，需要保证一下性质：</p>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><h3 id=\"a-i-0\"><a href=\"#a-i-0\" class=\"headerlink\" title=\"$a_i=0$\"></a>$a_i=0$</h3><ul>\n<li>则只有满足 $j&gt;i$的$a_j$的第$i$个二进制位可能为$1$；（性质一）</li>\n</ul>\n<h3 id=\"ai≠0\"><a href=\"#ai≠0\" class=\"headerlink\" title=\"$ai≠0$\"></a>$ai≠0$</h3><ul>\n<li>整个$a$数组中只有$a_i$的第$i$个二进制位为$1$；（性质二）</li>\n<li>$a_i$更高的二进制位一定为$0$；（性质三）</li>\n<li>$a_i$ 更低的二进制位可能为$1$；</li>\n</ul>\n<p>对于异或最大和的问题，我们可以通过贪心求解，即从高位到低位枚举是否有元素的二进制当前位为$1$，如果有，则亦或上该元素，而该构造方法则可以类比于上述操作中将该元素记录下来，而下文中构造的操作，同样保证了每一个元素均可以由线性基构造出来。</p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p>对于每个新加入的元素$t$，从$L$枚举其二进制每一位$i$</p>\n<h3 id=\"a-i≠0\"><a href=\"#a-i≠0\" class=\"headerlink\" title=\"$a_i≠0$\"></a>$a_i≠0$</h3><p>那么将$t$异或上$a_i$（根据群的性质，可知该操作在保证张成不变的情况下使得$t$为$1$的位数尽可能少，并满足以上性质一以及性质二，且如果新插入一个元素已经在当前线性基的张成中，则在该操作后元素变为$0$）</p>\n<h3 id=\"a-i-0-1\"><a href=\"#a-i-0-1\" class=\"headerlink\" title=\"$a_i=0$\"></a>$a_i=0$</h3><p>那么将$a$数组中每一个下标大于$i$且第$i$位为$1$的元素异或上$t$。将$t$异或上$a$数组中每一个下标小于$i$且第$i$位为$1$的元素。并将$t$插入$a_i$（根据群的性质，可知该操作在保证张成不变的情况下使得数组中二进制$1$的个数尽可能少）</p>\n<hr>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h3 id=\"最大异或和\"><a href=\"#最大异或和\" class=\"headerlink\" title=\"最大异或和\"></a>最大异或和</h3><h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><p>直接套用线性基即可，如上所述，线性基实际上将贪心求解异或最大值的过程记录了下来，那么直接异或上线性基数组的值即可。<br>、</p>\n<h4 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include &lt;cstdio&gt;\n#include &lt;vector&gt;\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=55;\nll B[MAXN];\nint n,m;\n\nvector&lt;ll&gt; V;\n\ninline void insert(ll x)\n{\n    for(int i=MAXN-1;i&gt;=0;--i)\n    {\n        if((x&amp;(1LL&lt;&lt;i))==0) continue;\n        if(B[i]) x^=B[i];\n        else\n        {\n            for(int j=0;j&lt;i;++j)\n            {\n                if(x&amp;(1LL&lt;&lt;j))\n                    x^=B[j];\n            }\n            for(int j=i+1;j&lt;MAXN;++j)\n            {\n                if(B[j]&amp;(1LL&lt;&lt;i))\n                    B[j]^=x;\n            }\n            B[i]^=x;\n            return;\n        }\n    }\n}\n\ninline ll qry(ll x)\n{\n    ll s=0;\n    for(int i=0;i&lt;V.size();++i)\n    {\n        if(x&amp;(1LL&lt;&lt;i))\n            s^=V[i];\n    }\n    return s;\n}\n\nint main()\n{\n    scanf(&quot;%d&quot;,&amp;n);\n    ll x;\n    for(int i=1;i&lt;=n;++i)\n    scanf(&quot;%lld&quot;,&amp;x),insert(x);\n    ll cnt=0;\n    for(int i=0;i&lt;MAXN;++i)\n    if(B[i])V.push_back(B[i]);\n    for(int i=0;i&lt;V.size();++i)cnt^=V[i];\n    printf(&quot;%d\\n&quot;,cnt);\n    return 0;\n}\n</code></pre><hr>\n<h3 id=\"K小异或和\"><a href=\"#K小异或和\" class=\"headerlink\" title=\"K小异或和\"></a>K小异或和</h3><h4 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h4><p> 对于第K大的线性基，易知其为将原数组的张成中的元素的来源线性基先内部排序再先按顺序排列后的第K个。</p>\n<p>以下分别表示所有的异或和的可能性，按以上顺序排序($L=3$,以下数字表示$a$数组的下标)</p>\n<p>（易知其张成的阶为$2^{span(span(S)’}-1$）</p>\n<pre><code>                            二进制表示\n\n 1              第1小            1\n\n 2                第2小            10\n\n 1  xor  2        第3小            11\n\n 3                第4小            100\n\n 1  xor  3        第5小            101\n\n 2  xor  3        第6小            110\n\n 1  xor  2  xor  3    第7小        111\n</code></pre><p>  观察可知，$K$小异或和即为$K$的二进制分解中为$1$的位置在$a$中作为下标的线性基的异或和</p>\n<p>  如$5=101(2)$，则有第$5$小为 $1  xor  3$（第一位，第三位均为$1$）</p>\n<h4 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include &lt;cstdio&gt;\n#include &lt;vector&gt;\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=55;\nll B[MAXN];\nint n,m;\n\nvector&lt;ll&gt; V;\n\ninline void insert(ll x)\n{\n    for(int i=MAXN-1;i&gt;=0;--i)\n    {\n        if((x&amp;(1LL&lt;&lt;i))==0) continue;\n        if(B[i]) x^=B[i];\n        else\n        {\n            for(int j=0;j&lt;i;++j)\n            {\n                if(x&amp;(1LL&lt;&lt;j))\n                    x^=B[j];\n            }\n            for(int j=i+1;j&lt;MAXN;++j)\n            {\n                if(B[j]&amp;(1LL&lt;&lt;i))\n                    B[j]^=x;\n            }\n            B[i]^=x;\n            return;\n        }\n    }\n}\n\ninline ll qry(ll x)\n{\n    ll s=0;\n    for(int i=0;i&lt;V.size();++i)\n    {\n        if(x&amp;(1LL&lt;&lt;i))\n            s^=V[i];\n    }\n    return s;\n}\n\nint main()\n{\n    scanf(&quot;%d&quot;,&amp;n);\n    ll x;\n    for(int i=1;i&lt;=n;++i)\n    scanf(&quot;%lld&quot;,&amp;x),insert(x);\n    ll cnt=0;\n    for(int i=0;i&lt;MAXN;++i)\n    if(B[i])V.push_back(B[i]);\n    scanf(&quot;%d&quot;,&amp;m);\n    for(int i=1;i&lt;=m;++i)\n    {\n        scanf(&quot;%lld&quot;,&amp;x);\n        if(V.size()!=n) --x;\n        if(x&gt;=(1LL&lt;&lt;V.size())) \n                printf(&quot;-1\\n&quot;);\n        else     printf(&quot;%lld\\n&quot;,qry(x));\n    }\n    return 0;\n}\n</code></pre><hr>\n<h3 id=\"HAOI2017-八纵八横\"><a href=\"#HAOI2017-八纵八横\" class=\"headerlink\" title=\"HAOI2017 八纵八横\"></a>HAOI2017 八纵八横</h3><h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><p><img src=\"http://cogs.pro/upload/image/20170425/20170425110608_53125.png\" alt=\"\"></p>\n<h5 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h5><p><img src=\"http://cogs.pro/upload/image/20170425/20170425110628_17349.png\" alt=\"\"></p>\n<h5 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h5><p><img src=\"http://cogs.pro/upload/image/20170425/20170425110642_17321.png\" alt=\"\"></p>\n<h5 id=\"样例输入\"><a href=\"#样例输入\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h5><pre><code>4 4 3\n1 2 1110\n1 3 10\n2 4 1110\n2 3 100\nAdd 3 4 11\nChange 1 101\nCancel 1\n</code></pre><h5 id=\"样例输出\"><a href=\"#样例输出\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h5><pre><code>1000\n1001\n1111\n1000\n</code></pre><h5 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h5><p><img src=\"http://cogs.pro/upload/image/20170425/20170425110728_24299.png\" alt=\"\"></p>\n<h4 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h4 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;bitset&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N = 1e3+1;\nbitset&lt;1024&gt;a,e2[N],v[N],M[N],mat[N],dis[N];\nint n,m,Q,head[N],cnt,cnt1,fa[N],e1[N][2],now,huan[N];\nchar opt[N],ch[N];\nbitset&lt;1024&gt; readb()\n{\n    bitset&lt;1024&gt;t;t.reset();\n    scanf(&quot;%s&quot;,ch);\n    int len=strlen(ch);\n    for(int i=0;i&lt;len;++i)\n    t[len-i-1]=ch[i]-&#39;0&#39;;\n    return t;\n}\nstruct nd{int ne,to;bitset&lt;1024&gt;w;}e[N*2];\nvoid in(int x,int y,bitset&lt;1024&gt;w)\n{e[++cnt].to=y;e[cnt].w=w;e[cnt].ne=head[x];head[x]=cnt;return;}\nint gf(int x){return fa[x]==x?x:fa[x]=gf(fa[x]);}\nvoid dfs(int x,int f)\n{\n    for(int i=head[x];i;i=e[i].ne)\n    if(e[i].to!=f)\n    {\n        dis[e[i].to]=dis[x]^e[i].w;  \n        dfs(e[i].to,x);\n    }\n}\nint update(int x,bitset&lt;1024&gt;y)\n{\n    now=0;\n    for(int i=0;i&lt;N;++i)\n    if(M[i][x]&amp;&amp;mat[i].none())\n    {\n        now=i;\n        break;\n    }\n    if(!now)\n\n    for(int i=0;i&lt;N;++i)\n    if(M[huan[i]][x]&amp;&amp;huan[i]!=0)\n    {\n        now=huan[i];\n        huan[i]=0;\n        break;\n    }\n    for(int i=0;i&lt;N;++i)\n    if(now!=i&amp;&amp;M[i][x])\n    {\n        mat[i]=mat[i]^mat[now];\n        M[i]=M[i]^M[now];\n    }\n    mat[now]^=y;\n    for(int i=N;i&gt;=0;--i)\n    if(mat[now][i])\n    {\n        if(!huan[i]){huan[i]=now;break;}\n        else mat[now]=mat[now]^mat[huan[i]],M[now]=M[now]^M[huan[i]];\n    }\n    return 0;\n}\nvoid put()\n{\n    bitset&lt;1024&gt;ans;\n    ans.reset();\n    for(int i=N-1;i&gt;=0;--i)\n    if(ans[i]==0&amp;&amp;huan[i])\n    ans^=mat[huan[i]];\n    char *tmp,tong[N];\n    if(ans.none()) puts(&quot;0&quot;);\n    else\n    {\n        tmp=tong;\n        for(int i=N-1;i&gt;=0;--i)\n        if(ans[i])\n        {\n            for(int j=i;j&gt;=0;--j)\n            *(tmp++)=ans[j]+&#39;0&#39;;\n            break;\n        }\n        *(tmp++)=&#39;\\0&#39;;  \n        puts(tong);\n    }\n}\nint main()\n{\n    freopen(&quot;eights.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;eights.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);\n    for(int i=1;i&lt;=n;++i)fa[i]=i;\n    for(int i=1;i&lt;N;++i)M[i][i]=1;\n    for(int i=1,x,y;i&lt;=m;++i)\n    {\n        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\n        a=readb();\n        if(gf(x)==gf(y))\n        {\n            e1[++cnt1][0]=x;\n            e1[cnt1][1]=y;\n            v[cnt1]=a;\n        }\n        else\n        fa[gf(x)]=gf(y),in(x,y,a),in(y,x,a);\n    }\n    dfs(1,-1);\n    int cntn=cnt1;\n    for(int i=1;i&lt;=cnt1;++i)\n    update(i,dis[e1[i][0]]^dis[e1[i][1]]^v[i]);\n    put();\n    for(int i=1,x,y;i&lt;=Q;++i)\n    {\n        scanf(&quot;%s&quot;,opt);\n        if(opt[1]==&#39;d&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\n            a=readb();\n            e1[++cnt1][0]=x;e1[cnt1][1]=y,e2[cnt]=a;\n            v[cnt1]=a;\n            update(cnt1,dis[e1[cnt1][0]]^dis[e1[cnt1][1]]^v[cnt1]);\n        }\n        if(opt[1]==&#39;h&#39;)\n        {\n            scanf(&quot;%d&quot;,&amp;x);\n            a=readb();\n            update(x+cntn,v[x+cntn]^a);\n            v[x+cntn]=a;\n        }\n        if(opt[1]==&#39;a&#39;)\n        {\n            scanf(&quot;%d&quot;,&amp;x);\n            update(x+cntn,dis[e1[x+cntn][0]]^dis[e1[x+cntn][1]]^v[x+cntn]);\n            v[x+cntn]=0;\n        }\n        put();\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/06/17/线性基总结/","excerpt":"","categories":[{"name":"线性基","slug":"线性基","permalink":"https://prostkhala.github.io/categories/线性基/"}],"tags":[{"name":"线性基","slug":"线性基","permalink":"https://prostkhala.github.io/tags/线性基/"}]},{"title":"Codeforces811E Vladik and Entertaining Flags","date":"2017-06-08T03:09:17.000Z","path":"2017/06/08/Codeforces811E/","text":"Vladik and Entertaining Flags 题目描述In his spare time Vladik estimates beauty of the flags. Every flag could be represented as the matrix n × m which consists of positive integers. Let’s define the beauty of the flag as number of components in its matrix. We call component a set of cells with same numbers and between any pair of cells from that set there exists a path through adjacent cells from same component. Here is the example of the partitioning some flag matrix into components: But this time he decided to change something in the process. Now he wants to estimate not the entire flag, but some segment. Segment of flag can be described as a submatrix of the flag matrix with opposite corners at (1, l) and (n, r), where conditions 1 ≤ l ≤ r ≤ m are satisfied. Help Vladik to calculate the beauty for some segments of the given flag. 输入输出格式输入格式：First line contains three space-separated integers n, m, q — dimensions of flag matrix and number of segments respectively. Each of next n lines contains m space-separated integers — description of flag matrix. All elements of flag matrix is positive integers not exceeding 106. Each of next q lines contains two space-separated integers l, r (1 ≤ l ≤ r ≤ m) — borders of segment which beauty Vladik wants to know. 输出格式：For each segment print the result on the corresponding line. 输入输出样例输入样例：4 5 4 1 1 1 1 1 1 2 2 3 3 1 1 1 2 5 4 4 5 5 5 1 5 2 5 1 2 4 5 输出样例：6 7 3 4 数据范围 (1 ≤ n ≤ 10, 1 ≤ m, q ≤ 105) 题解考虑到$n$的范围较小，可以直接通过并查集暴力每一列的联通性，每次询问通过归并查询，可以先用线段树预处理以降低时间复杂度。$ls，rs$数组表示当前需要合并的$[l，r]$的左右两边的连通性，归并时向上更新，$l,r$数组表示线段树当前节点的$[l，r]$的连通性，需要提前预处理。对于合并操作，考虑需要合并的两个区间，连通性改变的部分只有两个区间相邻的部分，同样可以通过并查集暴力求解。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; const int N = 5e5+1; int a[13][N],l[N*2][13],sum[N*2],r[N*2][13],rs[11],ls[11],n,m,cnt,q; int f[13*N*2],flag; int gf(int x){return f[x]==x?x:f[x]=gf(f[x]);} int update(int ll, int rr,int x) { int ls=x*2,rs=x*2+1; sum[x]=sum[ls]+sum[rs]; for(int i=1;i&lt;=n;++i) { f[l[ls][i]]=l[ls][i]; f[r[rs][i]]=r[rs][i]; f[l[rs][i]]=l[rs][i]; f[r[ls][i]]=r[ls][i]; } int mid=ll+rr&gt;&gt;1; for(int i=1;i&lt;=n;++i) if(a[i][mid]==a[i][mid+1]) { int t1=gf(l[rs][i]),t2=gf(r[ls][i]); if(t1!=t2) { f[t1]=t2; sum[x]--; } } for(int i=1;i&lt;=n;++i) l[x][i]=gf(l[ls][i]),r[x][i]=gf(r[rs][i]); return 0; } int build(int ll,int rr,int x) { if(ll==rr) { for(int i=1;i&lt;=n;++i) if(a[i][ll]==a[i-1][ll])l[x][i]=r[x][i]=l[x][i-1]; else l[x][i]=r[x][i]=++cnt,sum[x]++; return 0; } int mid=ll+rr&gt;&gt;1; build(ll,mid,x*2);build(mid+1,rr,x*2+1); update(ll,rr,x); } int mergesort(int ll,int rr,int x,int y,int now) { int lss=now*2,rss=now*2+1; if(x&lt;=ll&amp;&amp;rr&lt;=y) { if(flag) { flag=0; for(int i=1;i&lt;=n;++i) ls[i]=l[now][i],rs[i]=r[now][i]; return sum[now]; } else { int ret=sum[now]; for(int i=1;i&lt;=n;++i) { f[ls[i]]=ls[i]; f[rs[i]]=rs[i]; f[l[now][i]]=l[now][i]; f[r[now][i]]=r[now][i]; } for(int i=1;i&lt;=n;++i) { if(a[i][ll]==a[i][ll-1]) { int t1=gf(rs[i]),t2=gf(l[now][i]); if(t1!=t2) { f[t2]=t1; ret--; } } } for(int i=1;i&lt;=n;++i) ls[i]=gf(ls[i]),rs[i]=gf(r[now][i]); return ret; } } int ret=0; int mid=ll+rr&gt;&gt;1; if(x&lt;=mid) ret+=mergesort(ll,mid,x,y,now*2); if(mid&lt;y) ret+=mergesort(mid+1,rr,x,y,now*2+1); return ret; } int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;++i) for(int t=1;t&lt;=m;++t) scanf(&quot;%d&quot;,&amp;a[i][t]); build(1,m,1); for(int i=1,ll,rr;i&lt;=q;++i) { scanf(&quot;%d%d&quot;,&amp;ll,&amp;rr); flag=1; printf(&quot;%d\\n&quot;,mergesort(1,m,ll,rr,1)); } }","raw":"title: Codeforces811E Vladik and Entertaining Flags\ndate: 2017-06-08 11:09:17\ncategories:\n  - Codeforces&AtCoder\ntags:\n  - 并查集\n  - 线段树\n  - 归并排序\n---\n\n# [Vladik and Entertaining Flags](http://codeforces.com/contest/811/problem/E)\n---\n## 题目描述\nIn his spare time Vladik estimates beauty of the flags.\n\nEvery flag could be represented as the matrix n × m which consists of positive integers.\n\nLet's define the beauty of the flag as number of components in its matrix. We call component a set of cells with same numbers and between any pair of cells from that set there exists a path through adjacent cells from same component. Here is the example of the partitioning some flag matrix into components:\n![](http://i1.piimg.com/1949/417a3106618464c4.png)\n\nBut this time he decided to change something in the process. Now he wants to estimate not the entire flag, but some segment. Segment of flag can be described as a submatrix of the flag matrix with opposite corners at (1, l) and (n, r), where conditions 1 ≤ l ≤ r ≤ m are satisfied.\n\nHelp Vladik to calculate the beauty for some segments of the given flag.\n### 输入输出格式\n#### 输入格式：\nFirst line contains three space-separated integers n, m, q  — dimensions of flag matrix and number of segments respectively.\n\nEach of next n lines contains m space-separated integers — description of flag matrix. All elements of flag matrix is positive integers not exceeding 106.\n\nEach of next q lines contains two space-separated integers l, r (1 ≤ l ≤ r ≤ m) — borders of segment which beauty Vladik wants to know.\n\n#### 输出格式：\nFor each segment print the result on the corresponding line.\n\n\n### 输入输出样例\n#### 输入样例：\n    4 5 4\n    1 1 1 1 1\n    1 2 2 3 3\n    1 1 1 2 5\n    4 4 5 5 5\n    1 5\n    2 5\n    1 2\n    4 5\n\n#### 输出样例：\n    6\n    7\n    3\n    4\n\n### 数据范围\n (1 ≤ n ≤ 10, 1 ≤ m, q ≤ 105)\n \n---\n\n## 题解\n考虑到$n$的范围较小，可以直接通过并查集暴力每一列的联通性，每次询问通过归并查询，可以先用线段树预处理以降低时间复杂度。\n$ls，rs$数组表示当前需要合并的$[l，r]$的左右两边的连通性，归并时向上更新，$l,r$数组表示线段树当前节点的$[l，r]$的连通性，需要提前预处理。对于合并操作，考虑需要合并的两个区间，连通性改变的部分只有两个区间相邻的部分，同样可以通过并查集暴力求解。\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    using namespace std;\n    const int N = 5e5+1;\n    int a[13][N],l[N*2][13],sum[N*2],r[N*2][13],rs[11],ls[11],n,m,cnt,q;\n    int f[13*N*2],flag;\n    int gf(int x){return f[x]==x?x:f[x]=gf(f[x]);}\n    int update(int ll, int rr,int x)\n    {\n        int ls=x*2,rs=x*2+1;\n        sum[x]=sum[ls]+sum[rs];\n        for(int i=1;i<=n;++i)\n        {\n            f[l[ls][i]]=l[ls][i];\n            f[r[rs][i]]=r[rs][i];\n            f[l[rs][i]]=l[rs][i];\n            f[r[ls][i]]=r[ls][i];\n        }\n        int mid=ll+rr>>1;\n        for(int i=1;i<=n;++i)\n        if(a[i][mid]==a[i][mid+1])\n        {\n            int t1=gf(l[rs][i]),t2=gf(r[ls][i]);\n            if(t1!=t2)\n            {\n                f[t1]=t2;\n                sum[x]--;\n            }\n        }\n        for(int i=1;i<=n;++i)\n        l[x][i]=gf(l[ls][i]),r[x][i]=gf(r[rs][i]);\n        return 0;\n    }\n\n\n    int build(int ll,int rr,int x)\n    {\n        if(ll==rr)\n        {\n            for(int i=1;i<=n;++i)\n            if(a[i][ll]==a[i-1][ll])l[x][i]=r[x][i]=l[x][i-1];\n            else\tl[x][i]=r[x][i]=++cnt,sum[x]++;\n            return 0;\n        }\n        int mid=ll+rr>>1;\n        build(ll,mid,x*2);build(mid+1,rr,x*2+1);\n        update(ll,rr,x);\n    }\n\n    int mergesort(int ll,int rr,int x,int y,int now)\n    {\n        int lss=now*2,rss=now*2+1;\n        if(x<=ll&&rr<=y)\n        {\n            if(flag)\n            {\n                flag=0;\n                for(int i=1;i<=n;++i)\n                ls[i]=l[now][i],rs[i]=r[now][i];\n                return sum[now];\n            }\n        else\n        {\n            int ret=sum[now];\n            for(int i=1;i<=n;++i)\n            {\n                f[ls[i]]=ls[i];\n                f[rs[i]]=rs[i];\n                f[l[now][i]]=l[now][i];\n                f[r[now][i]]=r[now][i];\n            }\n            for(int i=1;i<=n;++i)\n            {\n                if(a[i][ll]==a[i][ll-1])\n                {\n                    int t1=gf(rs[i]),t2=gf(l[now][i]);\n                    if(t1!=t2)\n                    {\n                        f[t2]=t1;\n                        ret--;\n                    }\n                }\n            }\n            for(int i=1;i<=n;++i)\n            ls[i]=gf(ls[i]),rs[i]=gf(r[now][i]);\n            return ret;\n        }\n        }\n        int ret=0;\n        int mid=ll+rr>>1;\n        if(x<=mid) ret+=mergesort(ll,mid,x,y,now*2);\n        if(mid<y)\tret+=mergesort(mid+1,rr,x,y,now*2+1);\n        return ret;\n    }\n\n    int main()\n    {\n        scanf(\"%d%d%d\",&n,&m,&q);\n        for(int i=1;i<=n;++i)\n        for(int t=1;t<=m;++t)\n        scanf(\"%d\",&a[i][t]);\n        build(1,m,1);\n        for(int i=1,ll,rr;i<=q;++i)\n        {\n            scanf(\"%d%d\",&ll,&rr);\n            flag=1;\n            printf(\"%d\\n\",mergesort(1,m,ll,rr,1));\n        }\n    }\n\n---\n","content":"<h1 id=\"Vladik-and-Entertaining-Flags\"><a href=\"#Vladik-and-Entertaining-Flags\" class=\"headerlink\" title=\"Vladik and Entertaining Flags\"></a><a href=\"http://codeforces.com/contest/811/problem/E\" target=\"_blank\" rel=\"external\">Vladik and Entertaining Flags</a></h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>In his spare time Vladik estimates beauty of the flags.</p>\n<p>Every flag could be represented as the matrix n × m which consists of positive integers.</p>\n<p>Let’s define the beauty of the flag as number of components in its matrix. We call component a set of cells with same numbers and between any pair of cells from that set there exists a path through adjacent cells from same component. Here is the example of the partitioning some flag matrix into components:<br><img src=\"http://i1.piimg.com/1949/417a3106618464c4.png\" alt=\"\"></p>\n<p>But this time he decided to change something in the process. Now he wants to estimate not the entire flag, but some segment. Segment of flag can be described as a submatrix of the flag matrix with opposite corners at (1, l) and (n, r), where conditions 1 ≤ l ≤ r ≤ m are satisfied.</p>\n<p>Help Vladik to calculate the beauty for some segments of the given flag.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>First line contains three space-separated integers n, m, q  — dimensions of flag matrix and number of segments respectively.</p>\n<p>Each of next n lines contains m space-separated integers — description of flag matrix. All elements of flag matrix is positive integers not exceeding 106.</p>\n<p>Each of next q lines contains two space-separated integers l, r (1 ≤ l ≤ r ≤ m) — borders of segment which beauty Vladik wants to know.</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>For each segment print the result on the corresponding line.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>4 5 4\n1 1 1 1 1\n1 2 2 3 3\n1 1 1 2 5\n4 4 5 5 5\n1 5\n2 5\n1 2\n4 5\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>6\n7\n3\n4\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p> (1 ≤ n ≤ 10, 1 ≤ m, q ≤ 105)</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>考虑到$n$的范围较小，可以直接通过并查集暴力每一列的联通性，每次询问通过归并查询，可以先用线段树预处理以降低时间复杂度。<br>$ls，rs$数组表示当前需要合并的$[l，r]$的左右两边的连通性，归并时向上更新，$l,r$数组表示线段树当前节点的$[l，r]$的连通性，需要提前预处理。对于合并操作，考虑需要合并的两个区间，连通性改变的部分只有两个区间相邻的部分，同样可以通过并查集暴力求解。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nconst int N = 5e5+1;\nint a[13][N],l[N*2][13],sum[N*2],r[N*2][13],rs[11],ls[11],n,m,cnt,q;\nint f[13*N*2],flag;\nint gf(int x){return f[x]==x?x:f[x]=gf(f[x]);}\nint update(int ll, int rr,int x)\n{\n    int ls=x*2,rs=x*2+1;\n    sum[x]=sum[ls]+sum[rs];\n    for(int i=1;i&lt;=n;++i)\n    {\n        f[l[ls][i]]=l[ls][i];\n        f[r[rs][i]]=r[rs][i];\n        f[l[rs][i]]=l[rs][i];\n        f[r[ls][i]]=r[ls][i];\n    }\n    int mid=ll+rr&gt;&gt;1;\n    for(int i=1;i&lt;=n;++i)\n    if(a[i][mid]==a[i][mid+1])\n    {\n        int t1=gf(l[rs][i]),t2=gf(r[ls][i]);\n        if(t1!=t2)\n        {\n            f[t1]=t2;\n            sum[x]--;\n        }\n    }\n    for(int i=1;i&lt;=n;++i)\n    l[x][i]=gf(l[ls][i]),r[x][i]=gf(r[rs][i]);\n    return 0;\n}\n\n\nint build(int ll,int rr,int x)\n{\n    if(ll==rr)\n    {\n        for(int i=1;i&lt;=n;++i)\n        if(a[i][ll]==a[i-1][ll])l[x][i]=r[x][i]=l[x][i-1];\n        else    l[x][i]=r[x][i]=++cnt,sum[x]++;\n        return 0;\n    }\n    int mid=ll+rr&gt;&gt;1;\n    build(ll,mid,x*2);build(mid+1,rr,x*2+1);\n    update(ll,rr,x);\n}\n\nint mergesort(int ll,int rr,int x,int y,int now)\n{\n    int lss=now*2,rss=now*2+1;\n    if(x&lt;=ll&amp;&amp;rr&lt;=y)\n    {\n        if(flag)\n        {\n            flag=0;\n            for(int i=1;i&lt;=n;++i)\n            ls[i]=l[now][i],rs[i]=r[now][i];\n            return sum[now];\n        }\n    else\n    {\n        int ret=sum[now];\n        for(int i=1;i&lt;=n;++i)\n        {\n            f[ls[i]]=ls[i];\n            f[rs[i]]=rs[i];\n            f[l[now][i]]=l[now][i];\n            f[r[now][i]]=r[now][i];\n        }\n        for(int i=1;i&lt;=n;++i)\n        {\n            if(a[i][ll]==a[i][ll-1])\n            {\n                int t1=gf(rs[i]),t2=gf(l[now][i]);\n                if(t1!=t2)\n                {\n                    f[t2]=t1;\n                    ret--;\n                }\n            }\n        }\n        for(int i=1;i&lt;=n;++i)\n        ls[i]=gf(ls[i]),rs[i]=gf(r[now][i]);\n        return ret;\n    }\n    }\n    int ret=0;\n    int mid=ll+rr&gt;&gt;1;\n    if(x&lt;=mid) ret+=mergesort(ll,mid,x,y,now*2);\n    if(mid&lt;y)    ret+=mergesort(mid+1,rr,x,y,now*2+1);\n    return ret;\n}\n\nint main()\n{\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);\n    for(int i=1;i&lt;=n;++i)\n    for(int t=1;t&lt;=m;++t)\n    scanf(&quot;%d&quot;,&amp;a[i][t]);\n    build(1,m,1);\n    for(int i=1,ll,rr;i&lt;=q;++i)\n    {\n        scanf(&quot;%d%d&quot;,&amp;ll,&amp;rr);\n        flag=1;\n        printf(&quot;%d\\n&quot;,mergesort(1,m,ll,rr,1));\n    }\n}\n</code></pre><hr>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/06/08/Codeforces811E/","excerpt":"","categories":[{"name":"Codeforces&AtCoder","slug":"Codeforces-AtCoder","permalink":"https://prostkhala.github.io/categories/Codeforces-AtCoder/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://prostkhala.github.io/tags/并查集/"},{"name":"线段树","slug":"线段树","permalink":"https://prostkhala.github.io/tags/线段树/"},{"name":"归并排序","slug":"归并排序","permalink":"https://prostkhala.github.io/tags/归并排序/"}]},{"title":"主席树总结","date":"2017-06-07T02:44:12.000Z","path":"2017/06/07/主席树总结/","text":"概略主席树又称可持久化线段树，相对与普通的线段树，其解决的是各种不适用于结合律的区间问题，诸如区间第K大，区间种类个数等。 线段树的每个结点，保存的是这个区间含有的数字的性质的结合。 主席树的每个结点，保存的元素以元素大小为第一维位置，同时保证以区间为第二维位置，直接实现是$O（n^2logn）$的时间空间复杂度，即每一个区间都要建一棵树，考虑每颗线段树的大小和形态是一样的，那么我们便可以利用主席树之间相互进行加减运算的性质，进行可持久化建树。 具体过程是按区间位置进行建树，每次插入新的数，只需要重新插入一条链，因为对于那些性质没有改变的前缀（如插入元素的大小是$3$，那么节点： $ [ 1 , 2 ] $ 就没有必要改变），只需要重新调用皆可，否则利用原节点建一个新的节点（如插入元素的大小是$3$，那么节点： $ [ 3 , 4 ] $ 的性质一定发生了改变，但又要保证原区间的该节点性质不变，那么便可以先将该节点粘过来，再在此基础上建一个新的节点，插入在当前根节点下），这样时间空间复杂度均降到了$O(nlog^2n)$（可持久化线段树按权值建树，其时间复杂度实际与权值范围有关（所以要离散化），本文全部以$n$代替）。 当然，这样实现也会导致整个数据结构实际上完全不是一棵树了，但是却仍满足每个节点最多有两个后继的限制，因此查询时只要调用$l-1$，$r$两个根节点即可。 如图， $n=3，a=[ 1 , 3 , 2 ]$ 题目区间第K大COGS1534 题目描述区间第$K$大。 给出一个长度为$n$的序列$a1~an$，有$m$次询问$(x,y,k)$，每次询问$a[x]~a[y]$内的第$K$小数。 输入输出格式输入格式：输入第一行为$n,m$，第二行为$a1~an$，接下来$m$行是$m$个$(x,y,k)$。 由于数据较大，请使用C风格的输入输出。 输出格式：对于每次询问输出一行要求的K小数。 输入输出样例输入样例：7 3 1 5 2 6 3 7 4 2 5 3 4 4 1 1 7 3 输出样例：5 6 3 数据范围$1&lt;=n&lt;=100000,1&lt;=m&lt;=5000$ 题解实现与按权值维护的平衡树类似，直接递归查询即可。 CODE#include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; const int N = 1e5+1; int n,m,totn,a[N],b[N]; struct nd{int ls,rs,sum;}t[N*20]; int tot,root[N]; void insert(int l,int r,int x,int &amp;y,int v) { y=++tot; t[y]=t[x];t[y].sum+=1; if(l==r)return; int mid=l+r&gt;&gt;1; if(v&lt;=mid) insert(l,mid,t[x].ls,t[y].ls,v); else insert(mid+1,r,t[x].rs,t[y].rs,v); } int get(int l,int r,int x,int y,int k) { if(l==r)return l; int mid=(l+r)&gt;&gt;1; int v=t[t[y].ls].sum-t[t[x].ls].sum; if(v&gt;=k) return get(l,mid,t[x].ls,t[y].ls,k); else return get(mid+1,r,t[x].rs,t[y].rs,k-v); } int main() { // freopen(&quot;kthnumber.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;kthnumber.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i]; sort(b+1,b+n+1); totn=unique(b+1,b+n+1)-b-1; for(int i=1;i&lt;=n;i++) insert(1,totn,root[i-1],root[i],lower_bound(b+1,b+totn+1,a[i])-b); for(int i=1,x,y,z;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z), printf(&quot;%d\\n&quot;,b[get(1,totn,root[x-1],root[y],z)]); } HH的项链COGS421 题目描述区间种类个数。 HH有一串由各种漂亮的贝壳组成的项链。HH相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答。。。因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。 输入输出格式输入格式：第一行：一个整数$N$，表示项链的长度。第二行：$N$个整数，表示依次表示项链中贝壳的编号（编号为$0$到$1000000$之间的整数）。第三行：一个整数$M$，表示HH询问的个数。接下来$M$行：每行两个整数，$L$和$R（1 ≤ L ≤ R ≤ N）$，表示询问的区间。 输出格式：$M$行，每行一个整数，依次表示询问对应的答案。 输入输出样例输入样例：6 1 2 3 4 3 5 3 1 2 3 5 2 6 输出样例：2 2 4 数据范围对于20%的数据，$N ≤ 100，M ≤ 1000$； 对于40%的数据，$N ≤ 3000，M ≤ 200000$； 对于100%的数据，$N ≤ 50000，M ≤ 200000$。 题解对于每一个元素，记录其在数列内下一个种类相同的元素的位置（以 $to$ 数组表示），那么问题就转化为了求区间内有多少个元素的 $to$ 值大于查询的右区间位置，将 $to$ 数组插入到主席树中，直接建树求解即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 5e4+1; struct nd{int rs,ls,sum;}t[N*25]; int a[N],tot,b[N],totn,n,m,root[N],vis[N],to[N]; void insert(int l,int r,int x,int &amp;y,int k) { y=++tot; t[y]=t[x]; t[y].sum++; if(l==r)return; int mid=l+r&gt;&gt;1; if(k&lt;=mid) insert(l,mid,t[x].ls,t[y].ls,k); else insert(mid+1,r,t[x].rs,t[y].rs,k); } int get(int l,int r,int x,int y,int v) { if(r&lt;v)return 0; if(l&gt;=v)return t[y].sum-t[x].sum; int mid=l+r&gt;&gt;1; return get(l,mid,t[x].ls,t[y].ls,v)+get(mid+1,r,t[x].rs,t[y].rs,v); } int main() { freopen(&quot;diff.in&quot;,&quot;r&quot;,stdin); freopen(&quot;diff.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1,x;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;x); if(vis[x])to[vis[x]]=i; vis[x]=i; } for(int i=1;i&lt;=n;++i)if(!to[i])to[i]=n+1; for(int i=1;i&lt;=n;++i) insert(1,n+1,root[i-1],root[i],to[i]); scanf(&quot;%d&quot;,&amp;m); for(int i=1,l,r;i&lt;=m;++i) { scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\\n&quot;,get(1,n+1,root[l-1],root[r],r+1)); } } 动态排名系统COGS257 题目描述带修改的区间第K大。 给定一个长度为N的已知序列Ai，要求维护这个序列，能够支持以下两种操作：1、查询A[i],A[i+1],A[i+2],…,Aj中，升序排列后排名第k的数。2、修改A[i]的值为j。 所谓排名第k，指一些数按照升序排列后，第k位的数。例如序列{6,1,9,6,6}，排名第3的数是6，排名第5的数是9。 输入输出格式输入格式：第一行包含一个整数$D(0&lt;=D&lt;=4)$，表示测试数据的数目。接下来有$D$组测试数据，每组测试数据中，首先是两个整数$N$，表示序列的长度为$N$，有$M$个操作。接下来的$N$个不大于$1,000,000,000$正整数，第$i$个表示序列$A[i]$的初始值。然后的$M$行，每行为一个操作 $Q i j k $或者 $C i j$ 分别表示查询$A[i],A[i+1],A[i+2],…,Aj$中，升序排列后排名第k的数，和修改$A[i]$的值为$j$。 输出格式：对于每个查询，输出一行整数，为查询的结果。测试数据之间不应有空行。 输入输出样例输入样例：2 5 3 3 2 1 4 7 Q 1 4 3 C 2 6 Q 2 5 3 5 3 3 2 1 4 7 Q 1 4 3 C 2 6 Q 2 5 3 输出样例：3 6 3 6 数据范围$N(1&lt;=N&lt;=50000),M(1&lt;=M&lt;=10000)$ 题解本题为裸的带修改区间第K大，如果直接在例1的基础上修改，则会导致超时，因为每次修改都要修改$nlogn$个节点，即最坏情况下每一个根都要修改$log$个没有指向前面节点的节点。那么可以考虑，主席树维护的实际上是数列的前缀的性质，可以利用树状数组优化，即将原先的对于每一个新元素的前缀建树，改为对于树状数组中的前缀建树，那么修改时只要修改$log^2n$个节点即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define lowbit(x) x&amp;(-x) using namespace std; const int N = 8e6+1; struct nd{int ls,rs,sum;}t[N]; int T,n,m,A[N],B[N],C[N],b[N],a[N],X[N],Y[N],root[N],totx,toty,totn,tot; char s[3]; void insert(int l,int r,int x,int &amp;y,int k,int v) { y=++tot; t[y]=t[x]; t[y].sum+=v; if(l==r)return; int mid=l+r&gt;&gt;1; if(k&lt;=mid) insert(l,mid,t[x].ls,t[y].ls,k,v); else insert(mid+1,r,t[x].rs,t[y].rs,k,v); return; } void add(int x,int v) { int k=lower_bound(b+1,b+totn+1,a[x])-b; for(int i=x;i&lt;=n;i+=lowbit(i)) insert(1,totn,root[i],root[i],k,v); } int query(int l,int r,int k) { int sum=0,mid=l+r&gt;&gt;1; if(l==r)return l; for(int i=1;i&lt;=totx;++i)sum-=t[t[X[i]].ls].sum; for(int i=1;i&lt;=toty;++i)sum+=t[t[Y[i]].ls].sum; if(k&lt;=sum) { for(int i=1;i&lt;=totx;++i)X[i]=t[X[i]].ls; for(int i=1;i&lt;=toty;++i)Y[i]=t[Y[i]].ls; return query(l,mid,k); } else { for(int i=1;i&lt;=totx;++i)X[i]=t[X[i]].rs; for(int i=1;i&lt;=toty;++i)Y[i]=t[Y[i]].rs; return query(mid+1,r,k-sum); } } int main() { freopen(&quot;dynrank.in&quot;,&quot;r&quot;,stdin); freopen(&quot;dynrank.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); while(T--) { memset(root,0,sizeof(root)); memset(C,0,sizeof(C)); totn=tot=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,a+i),b[++totn]=a[i]; for(int i=1;i&lt;=m;++i) { scanf(&quot;%s%d%d&quot;,s,A+i,B+i); if(s[0]==&#39;Q&#39;) scanf(&quot;%d&quot;,C+i); else b[++totn]=B[i]; } sort(b+1,b+totn+1); totn=unique(b+1,b+totn+1)-b-1; for(int i=1;i&lt;=n;++i)add(i,1); for(int i=1;i&lt;=m;++i) if(C[i]) { totx=toty=0; for(int j=A[i]-1;j;j-=lowbit(j))X[++totx]=root[j]; for(int j=B[i];j;j-=lowbit(j)) Y[++toty]=root[j]; printf(&quot;%d\\n&quot;,b[query(1,totn,C[i])]); } else { add(A[i],-1); a[A[i]]=B[i]; add(A[i],1); } } } 国家集训队2011 数颜色COGS1901 BZOJ2120 题目描述带修改的区间种类个数。 墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会像你发布如下指令： 1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。 2、 R P Col 把第P支画笔替换为颜色Col。为了满足墨墨的要求，你知道你需要干什么了吗？ 输入输出格式输入格式：第1行两个整数N，M，分别代表初始画笔的数量以及墨墨会做的事情的个数。第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。 输出格式：对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。 输入输出样例输入样例：6 5 1 2 3 4 5 5 Q 1 4 Q 2 6 R 1 2 Q 1 4 Q 2 6 输出样例：4 4 3 4 数据范围对于100%的数据，N≤10000，M≤10000，修改操作不多于1000次，所有的输入数据中出现的所有整数均大于等于1且不超过10^6。 题解同样是记录$to$数组，对于修改操作，可以暴力求出修改后该位置 $to$ 的变化，考虑一下可能造成的在该元素前的元素的 $to$ 指针的变化即可（注意同样要修改主席树），详见代码。（对于to数组的查询和修改可以用平衡树优化） CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define lowbit(x) x&amp;(-x) using namespace std; typedef int ll; const ll N = 1e4+1; struct nd{ll ls,rs,sum;}t[N*600]; ll n,m,a[N],b[N],X[55],Y[55],A[N],B[N],C[N],to[N],vis[1000001]; ll root[N],totn,tot,totx,toty; char s[3]; void insert(ll l,ll r,ll x,ll &amp;y,ll k,ll v) { if(!y){y=++tot;t[y]=t[x];} t[y].sum+=v; if(l==r)return; ll mid=l+r&gt;&gt;1; if(k&lt;=mid) insert(l,mid,t[x].ls,t[y].ls,k,v); else insert(mid+1,r,t[x].rs,t[y].rs,k,v); return; } void add(ll x,ll v) { for(ll i=x;i&lt;=n+1;i+=lowbit(i)) insert(1,n+1,root[i],root[i],to[x],v); } ll get(ll l,ll r,ll v) { if(r&lt;v)return 0; if(l&gt;=v) { ll sum=0; for(ll i=1;i&lt;=totx;++i)sum-=t[X[i]].sum; for(ll i=1;i&lt;=toty;++i)sum+=t[Y[i]].sum; return sum; } ll X1[55],Y1[55]; for(ll i=1;i&lt;=totx;++i)X1[i]=X[i]; for(ll i=1;i&lt;=toty;++i)Y1[i]=Y[i]; ll mid=l+r&gt;&gt;1; ll sum=0; for(ll i=1;i&lt;=totx;++i)X[i]=t[X1[i]].ls; for(ll i=1;i&lt;=toty;++i)Y[i]=t[Y1[i]].ls; sum+=get(l,mid,v); for(ll i=1;i&lt;=totx;++i)X[i]=t[X1[i]].rs; for(ll i=1;i&lt;=toty;++i)Y[i]=t[Y1[i]].rs; sum+=get(mid+1,r,v); return sum; } int main() { freopen(&quot;nt2011_color.in&quot;,&quot;r&quot;,stdin); freopen(&quot;nt2011_color.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(ll i=1,x;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;x); a[i]=x; if(vis[x])to[vis[x]]=i; vis[x]=i; } for(ll i=1;i&lt;=n;++i)if(!to[i])to[i]=n+1; for(ll i=1;i&lt;=m;++i) { scanf(&quot;%s%d%d&quot;,s,A+i,B+i); if(s[0]==&#39;R&#39;); else C[i]=1; } // sort(b+1,b+totn+1); for(ll i=1;i&lt;=n;++i)add(i,1); for(ll i=1;i&lt;=m;++i) { totx=toty=0; if(C[i]) { memset(X,0,sizeof(X)); memset(Y,0,sizeof(Y)); for(ll j=A[i]-1;j;j-=lowbit(j)) X[++totx]=root[j]; for(ll j=B[i];j;j-=lowbit(j)) Y[++toty]=root[j]; printf(&quot;%d\\n&quot;,get(1,n+1,B[i]+1)); } else { add(A[i],-1); a[A[i]]=B[i]; to[A[i]]=n+1; for(ll t=A[i]+1;t&lt;=n;++t) if(a[t]==B[i]){to[A[i]]=t;break;} add(A[i],1); for(int j=A[i]-1;j&gt;=1;--j) { if(to[j]==A[i]) { add(j,-1); to[j]=n+1; for(int t=j+1;t&lt;=n;++t) if(a[t]==a[j]){to[j]=t;break;} add(j,1); } if(a[j]==B[i]&amp;&amp;to[j]&gt;A[i]) { add(j,-1); to[j]=A[i]; add(j,1); } } } } } /* 6 6 1 1 1 2 2 2 Q 1 3 R 2 2 Q 1 3 R 3 2 Q 1 3 Q 1 2 */","raw":"title: 主席树总结\ndate: 2017-06-07 10:44:12\ncategories:\n  - 数据结构\n  - 主席树\ntags:\n  - 主席树\n  - 线段树\n  - 树状数组\n---\n# 概略\n主席树又称可持久化线段树，相对与普通的线段树，其解决的是各种不适用于结合律的区间问题，诸如区间第K大，区间种类个数等。\n\n线段树的每个结点，保存的是这个区间含有的数字的性质的结合。\n\n主席树的每个结点，保存的元素以元素大小为第一维位置，同时保证以区间为第二维位置，直接实现是$O（n^2logn）$的时间空间复杂度，即每一个区间都要建一棵树，考虑每颗线段树的大小和形态是一样的，那么我们便可以利用主席树之间相互进行加减运算的性质，进行可持久化建树。\n\n具体过程是按区间位置进行建树，每次插入新的数，只需要重新插入一条链，因为对于那些性质没有改变的前缀（如插入元素的大小是$3$，那么节点： $ [\\ 1\\ ,\\ 2\\ ]\\ $ 就没有必要改变），只需要重新调用皆可，否则利用原节点建一个新的节点（如插入元素的大小是$3$，那么节点： $ [\\ 3\\ ,\\ 4\\ ]\\ $ 的性质一定发生了改变，但又要保证原区间的该节点性质不变，那么便可以先将该节点粘过来，再在此基础上建一个新的节点，插入在当前根节点下），这样时间空间复杂度均降到了$O(nlog^2n)$（可持久化线段树按权值建树，其时间复杂度实际与权值范围有关（所以要离散化），本文全部以$n$代替）。\n\n当然，这样实现也会导致整个数据结构实际上完全不是一棵树了，但是却仍满足每个节点最多有两个后继的限制，因此查询时只要调用$l-1$，$r$两个根节点即可。\n\n如图，\n\n$n=3，a=[\\ 1\\ ,\\ 3\\ ,\\ 2\\ ]$\n\n![](http://i1.piimg.com/1949/8785d9d077857f7c.png)\n\n# 题目\n\n## 区间第K大\n\n### [COGS1534](http://cogs.pro/cogs/problem/problem.php?pid=1534)\n\n---\n### 题目描述\n区间第$K$大。\n\n给出一个长度为$n$的序列$a1~an$，有$m$次询问$(x,y,k)$，每次询问$a[x]~a[y]$内的第$K$小数。\n\n\n\n\n#### 输入输出格式\n##### 输入格式：\n\n输入第一行为$n,m$，第二行为$a1~an$，接下来$m$行是$m$个$(x,y,k)$。\n\n由于数据较大，请使用C风格的输入输出。 \n\n##### 输出格式：\n对于每次询问输出一行要求的K小数。\n\n\n#### 输入输出样例\n##### 输入样例：\n\n\t7 3\n    1 5 2 6 3 7 4\n    2 5 3\n    4 4 1\n    1 7 3 \n\n##### 输出样例：\n\n    5\n    6\n    3\n\n#### 数据范围\n$1<=n<=100000,1<=m<=5000$ \n\n---\n\n### 题解\n实现与按权值维护的平衡树类似，直接递归查询即可。\n\n---\n### CODE\n\n    #include<algorithm>\n    #include<cstdio>\n    using namespace std;\n    const int N = 1e5+1;\n    int n,m,totn,a[N],b[N];\n    struct nd{int ls,rs,sum;}t[N*20];\n    int tot,root[N];\n    void insert(int l,int r,int x,int &y,int v)\n    {\n        y=++tot;\n        t[y]=t[x];t[y].sum+=1;\n        if(l==r)return;\n        int mid=l+r>>1;\n        if(v<=mid) \tinsert(l,mid,t[x].ls,t[y].ls,v);\n        else \t\tinsert(mid+1,r,t[x].rs,t[y].rs,v);\n    }\n    int get(int l,int r,int x,int y,int k)\n    {\n        if(l==r)return l;\n        int mid=(l+r)>>1;\n    \tint v=t[t[y].ls].sum-t[t[x].ls].sum;\n        if(v>=k) \treturn get(l,mid,t[x].ls,t[y].ls,k);\n        else \t\treturn get(mid+1,r,t[x].rs,t[y].rs,k-v);\n    }\n    int main()\n    {\n    //\tfreopen(\"kthnumber.in\",\"r\",stdin);\n    //\tfreopen(\"kthnumber.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),b[i]=a[i];\n        sort(b+1,b+n+1);\n        totn=unique(b+1,b+n+1)-b-1;\n        for(int i=1;i<=n;i++)\n          insert(1,totn,root[i-1],root[i],lower_bound(b+1,b+totn+1,a[i])-b);\n        for(int i=1,x,y,z;i<=m;i++)\n          scanf(\"%d%d%d\",&x,&y,&z),\n          printf(\"%d\\n\",b[get(1,totn,root[x-1],root[y],z)]);\n    }\n    \n    \n ---\n \n \n ## HH的项链\n ### [COGS421](http://cogs.pro/cogs/problem/problem.php?pid=421)\n \n---\n### 题目描述\n区间种类个数。\n\nHH有一串由各种漂亮的贝壳组成的项链。HH相信不同的贝壳会带来好运，所以每次散步\n完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH不断地收集新的贝壳，因此，\n他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同\n的贝壳？这个问题很难回答。。。因为项链实在是太长了。于是，他只好求助睿智的你，来解\n决这个问题。\n\n\n\n\n#### 输入输出格式\n##### 输入格式：\n\n第一行：一个整数$N$，表示项链的长度。\n第二行：$N$个整数，表示依次表示项链中贝壳的编号（编号为$0$到$1000000$之间的整数）。\n第三行：一个整数$M$，表示HH询问的个数。\n接下来$M$行：每行两个整数，$L$和$R（1 ≤ L ≤ R ≤ N）$，表示询问的区间。 \n\n##### 输出格式：\n$M$行，每行一个整数，依次表示询问对应的答案。\n\n\n#### 输入输出样例\n##### 输入样例：\n\n\t6\n    1 2 3 4 3 5\n    3\n    1 2\n    3 5\n    2 6\n\n##### 输出样例：\n\n    2\n    2\n    4\n\n#### 数据范围\n对于20%的数据，$N ≤ 100，M ≤ 1000$；\n\n对于40%的数据，$N ≤ 3000，M ≤ 200000$；\n\n对于100%的数据，$N ≤ 50000，M ≤ 200000$。\n\n---\n\n### 题解\n对于每一个元素，记录其在数列内下一个种类相同的元素的位置（以 $to$ 数组表示），那么问题就转化为了求区间内有多少个元素的 $to$ 值大于查询的右区间位置，将 $to$ 数组插入到主席树中，直接建树求解即可。\n\n\n---\n### CODE\n\n\t#include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N = 5e4+1;\n    struct nd{int rs,ls,sum;}t[N*25];\n    int a[N],tot,b[N],totn,n,m,root[N],vis[N],to[N];\n    void insert(int l,int r,int x,int &y,int k)\n    {\n        y=++tot;\n        t[y]=t[x];\n        t[y].sum++;\n        if(l==r)return;\n        int mid=l+r>>1;\n        if(k<=mid)\tinsert(l,mid,t[x].ls,t[y].ls,k);\n        else\t\tinsert(mid+1,r,t[x].rs,t[y].rs,k);\n    }\n\n    int get(int l,int r,int x,int y,int v)\n    {\n        if(r<v)return 0;\n        if(l>=v)return t[y].sum-t[x].sum;\n        int mid=l+r>>1;\n        return get(l,mid,t[x].ls,t[y].ls,v)+get(mid+1,r,t[x].rs,t[y].rs,v);\n    }\n\n    int main()\n    {\n        freopen(\"diff.in\",\"r\",stdin);\n        freopen(\"diff.out\",\"w\",stdout);\n        scanf(\"%d\",&n);\n        for(int i=1,x;i<=n;++i)\n        {\n            scanf(\"%d\",&x);\n            if(vis[x])to[vis[x]]=i;\n            vis[x]=i;\n        }\n        for(int i=1;i<=n;++i)if(!to[i])to[i]=n+1;\n        for(int i=1;i<=n;++i)\n        insert(1,n+1,root[i-1],root[i],to[i]);\n        scanf(\"%d\",&m);\n        for(int i=1,l,r;i<=m;++i)\n        {\n            scanf(\"%d%d\",&l,&r);\n            printf(\"%d\\n\",get(1,n+1,root[l-1],root[r],r+1));\n        }\n\n    }\n\n\n    \n    \n ---\n \n \n  ## 动态排名系统\n ### [COGS257](http://cogs.pro/cogs/problem/problem.php?pid=257)\n \n---\n### 题目描述\n带修改的区间第K大。\n\n给定一个长度为N的已知序列A[i](1<=i<=N)，要求维护这个序列，能够支持以下两种操作：\n1、查询A[i],A[i+1],A[i+2],...,A[j](1<=i<=j<=N)中，升序排列后排名第k的数。\n2、修改A[i]的值为j。\n\n所谓排名第k，指一些数按照升序排列后，第k位的数。例如序列{6,1,9,6,6}，排名第3的数是6，排名第5的数是9。\n\n\n\n\n#### 输入输出格式\n##### 输入格式：\n第一行包含一个整数$D(0<=D<=4)$，表示测试数据的数目。接下来有$D$组测试数据，每组测试数据中，首先是两个整数$N$，表示序列的长度为$N$，有$M$个操作。接下来的$N$个不大于$1,000,000,000$正整数，第$i$个表示序列$A[i]$的初始值。然后的$M$行，每行为一个操作\n\n$Q i j k $或者\n\n$C i j$\n\n分别表示查询$A[i],A[i+1],A[i+2],...,A[j](1<=i<=j<=N)$中，升序排列后排名第k的数，和修改$A[i]$的值为$j$。\n\n##### 输出格式：\n对于每个查询，输出一行整数，为查询的结果。测试数据之间不应有空行。\n\n#### 输入输出样例\n##### 输入样例：\n    2\n    5 3\n    3 2 1 4 7\n    Q 1 4 3\n    C 2 6\n    Q 2 5 3\n    5 3\n    3 2 1 4 7\n    Q 1 4 3\n    C 2 6\n    Q 2 5 3\n\n ##### 输出样例：\n    3\n    6\n    3\n    6\n#### 数据范围\n$N(1<=N<=50000),M(1<=M<=10000)$\n\n---\n\n### 题解\n本题为裸的带修改区间第K大，如果直接在例1的基础上修改，则会导致超时，因为每次修改都要修改$nlogn$个节点，即最坏情况下每一个根都要修改$log$个没有指向前面节点的节点。那么可以考虑，主席树维护的实际上是数列的前缀的性质，可以利用树状数组优化，即将原先的对于每一个新元素的前缀建树，改为对于树状数组中的前缀建树，那么修改时只要修改$log^2n$个节点即可。\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #define lowbit(x) x&(-x)\n    using namespace std;\n    const int N = 8e6+1;\n    struct nd{int ls,rs,sum;}t[N];\n    int T,n,m,A[N],B[N],C[N],b[N],a[N],X[N],Y[N],root[N],totx,toty,totn,tot;\n    char s[3];\n    void insert(int l,int r,int x,int &y,int k,int v)\n    {\n    \ty=++tot;\n    \tt[y]=t[x];\n    \tt[y].sum+=v;\n    \tif(l==r)return;\n    \tint mid=l+r>>1;\n    \tif(k<=mid)\tinsert(l,mid,t[x].ls,t[y].ls,k,v);\n    \telse\t\tinsert(mid+1,r,t[x].rs,t[y].rs,k,v);\n    \treturn;\n    }\n     \n     \n    void add(int x,int v)\n    {\n    \tint k=lower_bound(b+1,b+totn+1,a[x])-b;\n    \tfor(int i=x;i<=n;i+=lowbit(i))\n    \tinsert(1,totn,root[i],root[i],k,v);\n    }\n    int query(int l,int r,int k)\n    {\n    \tint sum=0,mid=l+r>>1;\n    \tif(l==r)return l;\n    \tfor(int i=1;i<=totx;++i)sum-=t[t[X[i]].ls].sum;\n    \tfor(int i=1;i<=toty;++i)sum+=t[t[Y[i]].ls].sum;\n    \tif(k<=sum)\n    \t{\n    \t\tfor(int i=1;i<=totx;++i)X[i]=t[X[i]].ls;\n    \t\tfor(int i=1;i<=toty;++i)Y[i]=t[Y[i]].ls;\n    \t\treturn query(l,mid,k);\n    \t}\n    \telse\n    \t{\n    \t\tfor(int i=1;i<=totx;++i)X[i]=t[X[i]].rs;\n    \t\tfor(int i=1;i<=toty;++i)Y[i]=t[Y[i]].rs;\n    \t\treturn query(mid+1,r,k-sum);\n    \t}\n    }\n     \n     \n     \n    int main()\n    {\n    \tfreopen(\"dynrank.in\",\"r\",stdin);\n    \tfreopen(\"dynrank.out\",\"w\",stdout);\n    \tscanf(\"%d\",&T);\n    \twhile(T--)\n    \t{\n    \t\tmemset(root,0,sizeof(root));\n    \t\tmemset(C,0,sizeof(C));\n    \t\ttotn=tot=0;\n    \t\tscanf(\"%d%d\",&n,&m);\n    \t\tfor(int i=1;i<=n;++i)\n    \t\tscanf(\"%d\",a+i),b[++totn]=a[i];\n    \t\tfor(int i=1;i<=m;++i)\n    \t\t{\n    \t\t\tscanf(\"%s%d%d\",s,A+i,B+i);\n    \t\t\tif(s[0]=='Q')\tscanf(\"%d\",C+i);\n    \t\t\telse\t\t\tb[++totn]=B[i];\n    \t\t}\n    \t\tsort(b+1,b+totn+1);\n    \t\ttotn=unique(b+1,b+totn+1)-b-1;\n    \t\tfor(int i=1;i<=n;++i)add(i,1);\n    \t\tfor(int i=1;i<=m;++i)\n    \t\tif(C[i])\n    \t\t{\n    \t\t\ttotx=toty=0;\n    \t\t\tfor(int j=A[i]-1;j;j-=lowbit(j))X[++totx]=root[j];\n    \t\t\tfor(int j=B[i];j;j-=lowbit(j))\tY[++toty]=root[j];\n    \t\t\tprintf(\"%d\\n\",b[query(1,totn,C[i])]);\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tadd(A[i],-1);\n    \t\t\ta[A[i]]=B[i];\n    \t\t\tadd(A[i],1);\n    \t\t}\n    \t}\n    }\n    \n    \n ---\n \n \n ## 国家集训队2011 数颜色\n\n### [COGS1901](http://cogs.pro/cogs/problem/problem.php?pid=1901) [BZOJ2120](http://www.lydsy.com/JudgeOnline/problem.php?id=2120)\n\n---\n### 题目描述\n带修改的区间种类个数。\n\n墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会像你发布如下指令： 1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。 2、 R P Col 把第P支画笔替换为颜色Col。为了满足墨墨的要求，你知道你需要干什么了吗？\n\n\n#### 输入输出格式\n##### 输入格式：\n第1行两个整数N，M，分别代表初始画笔的数量以及墨墨会做的事情的个数。第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。\n\n##### 输出格式：\n对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。\n\n#### 输入输出样例\n##### 输入样例：\n    6 5\n\n    1 2 3 4 5 5\n\n    Q 1 4\n\n    Q 2 6\n\n    R 1 2\n\n    Q 1 4\n\n    Q 2 6\n\n##### 输出样例：\n    4\n\n    4\n\n    3\n\n    4\n\n#### 数据范围\n对于100%的数据，N≤10000，M≤10000，修改操作不多于1000次，所有的输入数据中出现的所有整数均大于等于1且不超过10^6。\n\n---\n\n### 题解\n同样是记录$to$数组，对于修改操作，可以暴力求出修改后该位置 $to$ 的变化，考虑一下可能造成的在该元素前的元素的 $to$ 指针的变化即可（注意同样要修改主席树），详见代码。（对于to数组的查询和修改可以用平衡树优化）\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<algorithm>\n    #include<cstring>\n    #define lowbit(x) x&(-x)\n    using namespace std;\n    typedef int ll;\n    const ll N = 1e4+1;\n    struct nd{ll ls,rs,sum;}t[N*600];\n    ll n,m,a[N],b[N],X[55],Y[55],A[N],B[N],C[N],to[N],vis[1000001];\n    ll root[N],totn,tot,totx,toty;\n    char s[3];\n\n    void insert(ll l,ll r,ll x,ll &y,ll k,ll v)\n    {\n        if(!y){y=++tot;t[y]=t[x];}\n        t[y].sum+=v;\n        if(l==r)return;\n        ll mid=l+r>>1;\n        if(k<=mid)\tinsert(l,mid,t[x].ls,t[y].ls,k,v);\n        else\t\tinsert(mid+1,r,t[x].rs,t[y].rs,k,v);\n        return;\n    }\n\n    void add(ll x,ll v)\n    {\n        for(ll i=x;i<=n+1;i+=lowbit(i))\n        insert(1,n+1,root[i],root[i],to[x],v);\n    }\n\n    ll get(ll l,ll r,ll v)\n    {\n        if(r<v)return 0;\n        if(l>=v)\n        {\n            ll sum=0;\n            for(ll i=1;i<=totx;++i)sum-=t[X[i]].sum;\n            for(ll i=1;i<=toty;++i)sum+=t[Y[i]].sum;\n            return sum;\n        }\n        ll X1[55],Y1[55];\n        for(ll i=1;i<=totx;++i)X1[i]=X[i];\n        for(ll i=1;i<=toty;++i)Y1[i]=Y[i];\n\n        ll mid=l+r>>1;\n        ll sum=0;\n        for(ll i=1;i<=totx;++i)X[i]=t[X1[i]].ls;\n        for(ll i=1;i<=toty;++i)Y[i]=t[Y1[i]].ls;\n        sum+=get(l,mid,v);\n\n        for(ll i=1;i<=totx;++i)X[i]=t[X1[i]].rs;\n        for(ll i=1;i<=toty;++i)Y[i]=t[Y1[i]].rs;\n        sum+=get(mid+1,r,v);\n        return sum;\n    }\n    int main()\n    {\n\n        freopen(\"nt2011_color.in\",\"r\",stdin);\n        freopen(\"nt2011_color.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        for(ll i=1,x;i<=n;++i)\n        {\n            scanf(\"%d\",&x);\n            a[i]=x;\n            if(vis[x])to[vis[x]]=i;\n            vis[x]=i;\n        }\n        for(ll i=1;i<=n;++i)if(!to[i])to[i]=n+1;\n        for(ll i=1;i<=m;++i)\n        {\n            scanf(\"%s%d%d\",s,A+i,B+i);\n            if(s[0]=='R');\n            else C[i]=1;\n        }\n    //\tsort(b+1,b+totn+1);\n        for(ll i=1;i<=n;++i)add(i,1);\n        for(ll i=1;i<=m;++i)\n        {\n            totx=toty=0;\n            if(C[i])\n            {\n                memset(X,0,sizeof(X));\n                memset(Y,0,sizeof(Y));\n                for(ll j=A[i]-1;j;j-=lowbit(j))\tX[++totx]=root[j];\n                for(ll j=B[i];j;j-=lowbit(j))\tY[++toty]=root[j];\n                printf(\"%d\\n\",get(1,n+1,B[i]+1));\n            }\n            else\n            {\n                add(A[i],-1);\n                a[A[i]]=B[i];\n                to[A[i]]=n+1;\n                for(ll t=A[i]+1;t<=n;++t)\n                if(a[t]==B[i]){to[A[i]]=t;break;}\n                add(A[i],1);\n                for(int j=A[i]-1;j>=1;--j)\n                {\n                    if(to[j]==A[i])\n                    {\n                        add(j,-1);\n                        to[j]=n+1;\n                        for(int t=j+1;t<=n;++t)\n                        if(a[t]==a[j]){to[j]=t;break;}\n                        add(j,1);\n                    }\n                    if(a[j]==B[i]&&to[j]>A[i])\n                    {\n                        add(j,-1);\n                        to[j]=A[i];\n                        add(j,1);\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    6 6\n    1 1 1 2 2 2\n    Q 1 3\n    R 2 2\n    Q 1 3\n    R 3 2\n    Q 1 3\n    Q 1 2\n    */\n\n    \n    \n ---\n ","content":"<h1 id=\"概略\"><a href=\"#概略\" class=\"headerlink\" title=\"概略\"></a>概略</h1><p>主席树又称可持久化线段树，相对与普通的线段树，其解决的是各种不适用于结合律的区间问题，诸如区间第K大，区间种类个数等。</p>\n<p>线段树的每个结点，保存的是这个区间含有的数字的性质的结合。</p>\n<p>主席树的每个结点，保存的元素以元素大小为第一维位置，同时保证以区间为第二维位置，直接实现是$O（n^2logn）$的时间空间复杂度，即每一个区间都要建一棵树，考虑每颗线段树的大小和形态是一样的，那么我们便可以利用主席树之间相互进行加减运算的性质，进行可持久化建树。</p>\n<p>具体过程是按区间位置进行建树，每次插入新的数，只需要重新插入一条链，因为对于那些性质没有改变的前缀（如插入元素的大小是$3$，那么节点： $ [ 1 , 2 ] $ 就没有必要改变），只需要重新调用皆可，否则利用原节点建一个新的节点（如插入元素的大小是$3$，那么节点： $ [ 3 , 4 ] $ 的性质一定发生了改变，但又要保证原区间的该节点性质不变，那么便可以先将该节点粘过来，再在此基础上建一个新的节点，插入在当前根节点下），这样时间空间复杂度均降到了$O(nlog^2n)$（可持久化线段树按权值建树，其时间复杂度实际与权值范围有关（所以要离散化），本文全部以$n$代替）。</p>\n<p>当然，这样实现也会导致整个数据结构实际上完全不是一棵树了，但是却仍满足每个节点最多有两个后继的限制，因此查询时只要调用$l-1$，$r$两个根节点即可。</p>\n<p>如图，</p>\n<p>$n=3，a=[ 1 , 3 , 2 ]$</p>\n<p><img src=\"http://i1.piimg.com/1949/8785d9d077857f7c.png\" alt=\"\"></p>\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><h2 id=\"区间第K大\"><a href=\"#区间第K大\" class=\"headerlink\" title=\"区间第K大\"></a>区间第K大</h2><h3 id=\"COGS1534\"><a href=\"#COGS1534\" class=\"headerlink\" title=\"COGS1534\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1534\" target=\"_blank\" rel=\"external\">COGS1534</a></h3><hr>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>区间第$K$大。</p>\n<p>给出一个长度为$n$的序列$a1~an$，有$m$次询问$(x,y,k)$，每次询问$a[x]~a[y]$内的第$K$小数。</p>\n<h4 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><h5 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h5><p>输入第一行为$n,m$，第二行为$a1~an$，接下来$m$行是$m$个$(x,y,k)$。</p>\n<p>由于数据较大，请使用C风格的输入输出。 </p>\n<h5 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h5><p>对于每次询问输出一行要求的K小数。</p>\n<h4 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><h5 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h5><pre><code>7 3\n1 5 2 6 3 7 4\n2 5 3\n4 4 1\n1 7 3 \n</code></pre><h5 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h5><pre><code>5\n6\n3\n</code></pre><h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>$1&lt;=n&lt;=100000,1&lt;=m&lt;=5000$ </p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>实现与按权值维护的平衡树类似，直接递归查询即可。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nconst int N = 1e5+1;\nint n,m,totn,a[N],b[N];\nstruct nd{int ls,rs,sum;}t[N*20];\nint tot,root[N];\nvoid insert(int l,int r,int x,int &amp;y,int v)\n{\n    y=++tot;\n    t[y]=t[x];t[y].sum+=1;\n    if(l==r)return;\n    int mid=l+r&gt;&gt;1;\n    if(v&lt;=mid)     insert(l,mid,t[x].ls,t[y].ls,v);\n    else         insert(mid+1,r,t[x].rs,t[y].rs,v);\n}\nint get(int l,int r,int x,int y,int k)\n{\n    if(l==r)return l;\n    int mid=(l+r)&gt;&gt;1;\n    int v=t[t[y].ls].sum-t[t[x].ls].sum;\n    if(v&gt;=k)     return get(l,mid,t[x].ls,t[y].ls,k);\n    else         return get(mid+1,r,t[x].rs,t[y].rs,k-v);\n}\nint main()\n{\n//    freopen(&quot;kthnumber.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;kthnumber.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i];\n    sort(b+1,b+n+1);\n    totn=unique(b+1,b+n+1)-b-1;\n    for(int i=1;i&lt;=n;i++)\n      insert(1,totn,root[i-1],root[i],lower_bound(b+1,b+totn+1,a[i])-b);\n    for(int i=1,x,y,z;i&lt;=m;i++)\n      scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),\n      printf(&quot;%d\\n&quot;,b[get(1,totn,root[x-1],root[y],z)]);\n}\n</code></pre><hr>\n<h2 id=\"HH的项链\"><a href=\"#HH的项链\" class=\"headerlink\" title=\"HH的项链\"></a>HH的项链</h2><h3 id=\"COGS421\"><a href=\"#COGS421\" class=\"headerlink\" title=\"COGS421\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=421\" target=\"_blank\" rel=\"external\">COGS421</a></h3><hr>\n<h3 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>区间种类个数。</p>\n<p>HH有一串由各种漂亮的贝壳组成的项链。HH相信不同的贝壳会带来好运，所以每次散步<br>完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH不断地收集新的贝壳，因此，<br>他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同<br>的贝壳？这个问题很难回答。。。因为项链实在是太长了。于是，他只好求助睿智的你，来解<br>决这个问题。</p>\n<h4 id=\"输入输出格式-1\"><a href=\"#输入输出格式-1\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><h5 id=\"输入格式：-1\"><a href=\"#输入格式：-1\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h5><p>第一行：一个整数$N$，表示项链的长度。<br>第二行：$N$个整数，表示依次表示项链中贝壳的编号（编号为$0$到$1000000$之间的整数）。<br>第三行：一个整数$M$，表示HH询问的个数。<br>接下来$M$行：每行两个整数，$L$和$R（1 ≤ L ≤ R ≤ N）$，表示询问的区间。 </p>\n<h5 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h5><p>$M$行，每行一个整数，依次表示询问对应的答案。</p>\n<h4 id=\"输入输出样例-1\"><a href=\"#输入输出样例-1\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><h5 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h5><pre><code>6\n1 2 3 4 3 5\n3\n1 2\n3 5\n2 6\n</code></pre><h5 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h5><pre><code>2\n2\n4\n</code></pre><h4 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于20%的数据，$N ≤ 100，M ≤ 1000$；</p>\n<p>对于40%的数据，$N ≤ 3000，M ≤ 200000$；</p>\n<p>对于100%的数据，$N ≤ 50000，M ≤ 200000$。</p>\n<hr>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>对于每一个元素，记录其在数列内下一个种类相同的元素的位置（以 $to$ 数组表示），那么问题就转化为了求区间内有多少个元素的 $to$ 值大于查询的右区间位置，将 $to$ 数组插入到主席树中，直接建树求解即可。</p>\n<hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N = 5e4+1;\nstruct nd{int rs,ls,sum;}t[N*25];\nint a[N],tot,b[N],totn,n,m,root[N],vis[N],to[N];\nvoid insert(int l,int r,int x,int &amp;y,int k)\n{\n    y=++tot;\n    t[y]=t[x];\n    t[y].sum++;\n    if(l==r)return;\n    int mid=l+r&gt;&gt;1;\n    if(k&lt;=mid)    insert(l,mid,t[x].ls,t[y].ls,k);\n    else        insert(mid+1,r,t[x].rs,t[y].rs,k);\n}\n\nint get(int l,int r,int x,int y,int v)\n{\n    if(r&lt;v)return 0;\n    if(l&gt;=v)return t[y].sum-t[x].sum;\n    int mid=l+r&gt;&gt;1;\n    return get(l,mid,t[x].ls,t[y].ls,v)+get(mid+1,r,t[x].rs,t[y].rs,v);\n}\n\nint main()\n{\n    freopen(&quot;diff.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;diff.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1,x;i&lt;=n;++i)\n    {\n        scanf(&quot;%d&quot;,&amp;x);\n        if(vis[x])to[vis[x]]=i;\n        vis[x]=i;\n    }\n    for(int i=1;i&lt;=n;++i)if(!to[i])to[i]=n+1;\n    for(int i=1;i&lt;=n;++i)\n    insert(1,n+1,root[i-1],root[i],to[i]);\n    scanf(&quot;%d&quot;,&amp;m);\n    for(int i=1,l,r;i&lt;=m;++i)\n    {\n        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n        printf(&quot;%d\\n&quot;,get(1,n+1,root[l-1],root[r],r+1));\n    }\n\n}\n</code></pre><hr>\n<h2 id=\"动态排名系统\"><a href=\"#动态排名系统\" class=\"headerlink\" title=\"动态排名系统\"></a>动态排名系统</h2><h3 id=\"COGS257\"><a href=\"#COGS257\" class=\"headerlink\" title=\"COGS257\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=257\" target=\"_blank\" rel=\"external\">COGS257</a></h3><hr>\n<h3 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>带修改的区间第K大。</p>\n<p>给定一个长度为N的已知序列A<a href=\"1&lt;=i&lt;=N\">i</a>，要求维护这个序列，能够支持以下两种操作：<br>1、查询A[i],A[i+1],A[i+2],…,A<a href=\"1&lt;=i&lt;=j&lt;=N\">j</a>中，升序排列后排名第k的数。<br>2、修改A[i]的值为j。</p>\n<p>所谓排名第k，指一些数按照升序排列后，第k位的数。例如序列{6,1,9,6,6}，排名第3的数是6，排名第5的数是9。</p>\n<h4 id=\"输入输出格式-2\"><a href=\"#输入输出格式-2\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><h5 id=\"输入格式：-2\"><a href=\"#输入格式：-2\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h5><p>第一行包含一个整数$D(0&lt;=D&lt;=4)$，表示测试数据的数目。接下来有$D$组测试数据，每组测试数据中，首先是两个整数$N$，表示序列的长度为$N$，有$M$个操作。接下来的$N$个不大于$1,000,000,000$正整数，第$i$个表示序列$A[i]$的初始值。然后的$M$行，每行为一个操作</p>\n<p>$Q i j k $或者</p>\n<p>$C i j$</p>\n<p>分别表示查询$A[i],A[i+1],A[i+2],…,A<a href=\"1&lt;=i&lt;=j&lt;=N\">j</a>$中，升序排列后排名第k的数，和修改$A[i]$的值为$j$。</p>\n<h5 id=\"输出格式：-2\"><a href=\"#输出格式：-2\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h5><p>对于每个查询，输出一行整数，为查询的结果。测试数据之间不应有空行。</p>\n<h4 id=\"输入输出样例-2\"><a href=\"#输入输出样例-2\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><h5 id=\"输入样例：-2\"><a href=\"#输入样例：-2\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h5><pre><code>2\n5 3\n3 2 1 4 7\nQ 1 4 3\nC 2 6\nQ 2 5 3\n5 3\n3 2 1 4 7\nQ 1 4 3\nC 2 6\nQ 2 5 3\n</code></pre><h5 id=\"输出样例：-2\"><a href=\"#输出样例：-2\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h5><pre><code>3\n6\n3\n6\n</code></pre><h4 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>$N(1&lt;=N&lt;=50000),M(1&lt;=M&lt;=10000)$</p>\n<hr>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>本题为裸的带修改区间第K大，如果直接在例1的基础上修改，则会导致超时，因为每次修改都要修改$nlogn$个节点，即最坏情况下每一个根都要修改$log$个没有指向前面节点的节点。那么可以考虑，主席树维护的实际上是数列的前缀的性质，可以利用树状数组优化，即将原先的对于每一个新元素的前缀建树，改为对于树状数组中的前缀建树，那么修改时只要修改$log^2n$个节点即可。</p>\n<hr>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#define lowbit(x) x&amp;(-x)\nusing namespace std;\nconst int N = 8e6+1;\nstruct nd{int ls,rs,sum;}t[N];\nint T,n,m,A[N],B[N],C[N],b[N],a[N],X[N],Y[N],root[N],totx,toty,totn,tot;\nchar s[3];\nvoid insert(int l,int r,int x,int &amp;y,int k,int v)\n{\n    y=++tot;\n    t[y]=t[x];\n    t[y].sum+=v;\n    if(l==r)return;\n    int mid=l+r&gt;&gt;1;\n    if(k&lt;=mid)    insert(l,mid,t[x].ls,t[y].ls,k,v);\n    else        insert(mid+1,r,t[x].rs,t[y].rs,k,v);\n    return;\n}\n\n\nvoid add(int x,int v)\n{\n    int k=lower_bound(b+1,b+totn+1,a[x])-b;\n    for(int i=x;i&lt;=n;i+=lowbit(i))\n    insert(1,totn,root[i],root[i],k,v);\n}\nint query(int l,int r,int k)\n{\n    int sum=0,mid=l+r&gt;&gt;1;\n    if(l==r)return l;\n    for(int i=1;i&lt;=totx;++i)sum-=t[t[X[i]].ls].sum;\n    for(int i=1;i&lt;=toty;++i)sum+=t[t[Y[i]].ls].sum;\n    if(k&lt;=sum)\n    {\n        for(int i=1;i&lt;=totx;++i)X[i]=t[X[i]].ls;\n        for(int i=1;i&lt;=toty;++i)Y[i]=t[Y[i]].ls;\n        return query(l,mid,k);\n    }\n    else\n    {\n        for(int i=1;i&lt;=totx;++i)X[i]=t[X[i]].rs;\n        for(int i=1;i&lt;=toty;++i)Y[i]=t[Y[i]].rs;\n        return query(mid+1,r,k-sum);\n    }\n}\n\n\n\nint main()\n{\n    freopen(&quot;dynrank.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;dynrank.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--)\n    {\n        memset(root,0,sizeof(root));\n        memset(C,0,sizeof(C));\n        totn=tot=0;\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        for(int i=1;i&lt;=n;++i)\n        scanf(&quot;%d&quot;,a+i),b[++totn]=a[i];\n        for(int i=1;i&lt;=m;++i)\n        {\n            scanf(&quot;%s%d%d&quot;,s,A+i,B+i);\n            if(s[0]==&#39;Q&#39;)    scanf(&quot;%d&quot;,C+i);\n            else            b[++totn]=B[i];\n        }\n        sort(b+1,b+totn+1);\n        totn=unique(b+1,b+totn+1)-b-1;\n        for(int i=1;i&lt;=n;++i)add(i,1);\n        for(int i=1;i&lt;=m;++i)\n        if(C[i])\n        {\n            totx=toty=0;\n            for(int j=A[i]-1;j;j-=lowbit(j))X[++totx]=root[j];\n            for(int j=B[i];j;j-=lowbit(j))    Y[++toty]=root[j];\n            printf(&quot;%d\\n&quot;,b[query(1,totn,C[i])]);\n        }\n        else\n        {\n            add(A[i],-1);\n            a[A[i]]=B[i];\n            add(A[i],1);\n        }\n    }\n}\n</code></pre><hr>\n<h2 id=\"国家集训队2011-数颜色\"><a href=\"#国家集训队2011-数颜色\" class=\"headerlink\" title=\"国家集训队2011 数颜色\"></a>国家集训队2011 数颜色</h2><h3 id=\"COGS1901-BZOJ2120\"><a href=\"#COGS1901-BZOJ2120\" class=\"headerlink\" title=\"COGS1901 BZOJ2120\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1901\" target=\"_blank\" rel=\"external\">COGS1901</a> <a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=2120\" target=\"_blank\" rel=\"external\">BZOJ2120</a></h3><hr>\n<h3 id=\"题目描述-3\"><a href=\"#题目描述-3\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>带修改的区间种类个数。</p>\n<p>墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会像你发布如下指令： 1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。 2、 R P Col 把第P支画笔替换为颜色Col。为了满足墨墨的要求，你知道你需要干什么了吗？</p>\n<h4 id=\"输入输出格式-3\"><a href=\"#输入输出格式-3\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h4><h5 id=\"输入格式：-3\"><a href=\"#输入格式：-3\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h5><p>第1行两个整数N，M，分别代表初始画笔的数量以及墨墨会做的事情的个数。第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。</p>\n<h5 id=\"输出格式：-3\"><a href=\"#输出格式：-3\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h5><p>对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p>\n<h4 id=\"输入输出样例-3\"><a href=\"#输入输出样例-3\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h4><h5 id=\"输入样例：-3\"><a href=\"#输入样例：-3\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h5><pre><code>6 5\n\n1 2 3 4 5 5\n\nQ 1 4\n\nQ 2 6\n\nR 1 2\n\nQ 1 4\n\nQ 2 6\n</code></pre><h5 id=\"输出样例：-3\"><a href=\"#输出样例：-3\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h5><pre><code>4\n\n4\n\n3\n\n4\n</code></pre><h4 id=\"数据范围-3\"><a href=\"#数据范围-3\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于100%的数据，N≤10000，M≤10000，修改操作不多于1000次，所有的输入数据中出现的所有整数均大于等于1且不超过10^6。</p>\n<hr>\n<h3 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>同样是记录$to$数组，对于修改操作，可以暴力求出修改后该位置 $to$ 的变化，考虑一下可能造成的在该元素前的元素的 $to$ 指针的变化即可（注意同样要修改主席树），详见代码。（对于to数组的查询和修改可以用平衡树优化）</p>\n<hr>\n<h3 id=\"CODE-3\"><a href=\"#CODE-3\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#define lowbit(x) x&amp;(-x)\nusing namespace std;\ntypedef int ll;\nconst ll N = 1e4+1;\nstruct nd{ll ls,rs,sum;}t[N*600];\nll n,m,a[N],b[N],X[55],Y[55],A[N],B[N],C[N],to[N],vis[1000001];\nll root[N],totn,tot,totx,toty;\nchar s[3];\n\nvoid insert(ll l,ll r,ll x,ll &amp;y,ll k,ll v)\n{\n    if(!y){y=++tot;t[y]=t[x];}\n    t[y].sum+=v;\n    if(l==r)return;\n    ll mid=l+r&gt;&gt;1;\n    if(k&lt;=mid)    insert(l,mid,t[x].ls,t[y].ls,k,v);\n    else        insert(mid+1,r,t[x].rs,t[y].rs,k,v);\n    return;\n}\n\nvoid add(ll x,ll v)\n{\n    for(ll i=x;i&lt;=n+1;i+=lowbit(i))\n    insert(1,n+1,root[i],root[i],to[x],v);\n}\n\nll get(ll l,ll r,ll v)\n{\n    if(r&lt;v)return 0;\n    if(l&gt;=v)\n    {\n        ll sum=0;\n        for(ll i=1;i&lt;=totx;++i)sum-=t[X[i]].sum;\n        for(ll i=1;i&lt;=toty;++i)sum+=t[Y[i]].sum;\n        return sum;\n    }\n    ll X1[55],Y1[55];\n    for(ll i=1;i&lt;=totx;++i)X1[i]=X[i];\n    for(ll i=1;i&lt;=toty;++i)Y1[i]=Y[i];\n\n    ll mid=l+r&gt;&gt;1;\n    ll sum=0;\n    for(ll i=1;i&lt;=totx;++i)X[i]=t[X1[i]].ls;\n    for(ll i=1;i&lt;=toty;++i)Y[i]=t[Y1[i]].ls;\n    sum+=get(l,mid,v);\n\n    for(ll i=1;i&lt;=totx;++i)X[i]=t[X1[i]].rs;\n    for(ll i=1;i&lt;=toty;++i)Y[i]=t[Y1[i]].rs;\n    sum+=get(mid+1,r,v);\n    return sum;\n}\nint main()\n{\n\n    freopen(&quot;nt2011_color.in&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;nt2011_color.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(ll i=1,x;i&lt;=n;++i)\n    {\n        scanf(&quot;%d&quot;,&amp;x);\n        a[i]=x;\n        if(vis[x])to[vis[x]]=i;\n        vis[x]=i;\n    }\n    for(ll i=1;i&lt;=n;++i)if(!to[i])to[i]=n+1;\n    for(ll i=1;i&lt;=m;++i)\n    {\n        scanf(&quot;%s%d%d&quot;,s,A+i,B+i);\n        if(s[0]==&#39;R&#39;);\n        else C[i]=1;\n    }\n//    sort(b+1,b+totn+1);\n    for(ll i=1;i&lt;=n;++i)add(i,1);\n    for(ll i=1;i&lt;=m;++i)\n    {\n        totx=toty=0;\n        if(C[i])\n        {\n            memset(X,0,sizeof(X));\n            memset(Y,0,sizeof(Y));\n            for(ll j=A[i]-1;j;j-=lowbit(j))    X[++totx]=root[j];\n            for(ll j=B[i];j;j-=lowbit(j))    Y[++toty]=root[j];\n            printf(&quot;%d\\n&quot;,get(1,n+1,B[i]+1));\n        }\n        else\n        {\n            add(A[i],-1);\n            a[A[i]]=B[i];\n            to[A[i]]=n+1;\n            for(ll t=A[i]+1;t&lt;=n;++t)\n            if(a[t]==B[i]){to[A[i]]=t;break;}\n            add(A[i],1);\n            for(int j=A[i]-1;j&gt;=1;--j)\n            {\n                if(to[j]==A[i])\n                {\n                    add(j,-1);\n                    to[j]=n+1;\n                    for(int t=j+1;t&lt;=n;++t)\n                    if(a[t]==a[j]){to[j]=t;break;}\n                    add(j,1);\n                }\n                if(a[j]==B[i]&amp;&amp;to[j]&gt;A[i])\n                {\n                    add(j,-1);\n                    to[j]=A[i];\n                    add(j,1);\n                }\n            }\n        }\n    }\n}\n\n/*\n6 6\n1 1 1 2 2 2\nQ 1 3\nR 2 2\nQ 1 3\nR 3 2\nQ 1 3\nQ 1 2\n*/\n</code></pre><hr>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/06/07/主席树总结/","excerpt":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"主席树","slug":"数据结构/主席树","permalink":"https://prostkhala.github.io/categories/数据结构/主席树/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://prostkhala.github.io/tags/线段树/"},{"name":"主席树","slug":"主席树","permalink":"https://prostkhala.github.io/tags/主席树/"},{"name":"树状数组","slug":"树状数组","permalink":"https://prostkhala.github.io/tags/树状数组/"}]},{"title":"2017年5月 题目总结","date":"2017-05-02T00:04:05.000Z","path":"2017/05/02/2017年5月 题目总结/","text":"BZOJ1023 SHOI2008 cactus仙人掌图题意为求仙人掌图的直径。这题看起来完全没思路，最后看的题解。get了一种Tarjan的用法，先用其求出DFS树，用dp更新树边的直径最大值，考虑将其他非树边以环形dp更新，由于边的权值均为1，所以可以进行单调队列优化。其中利用到了仙人掌的一些性质。 BZOJ1024 SCOI2009 生日快乐搜索，考虑切成n块后面积是一样的，那么实际上对于每一个切割后的蛋糕，需要继续处理的操作数的一定的，深搜即可。核心代码如下： double work(double x,double y,int k)//x，y为长与宽，k为对于该块蛋糕剩余操作个数。 { if (k==1)return max(x,y)/min(x,y); double ans=inf; for(int i=1;i&lt;k;++i) ans=min(ans,max(work(x,y/k*i,i),work(x,y/k*(k-i),k-i))); //取min是因为答案要求最小值，取max是因为属于同一块蛋糕。 for(int i=1;i&lt;k;++i) ans=min(ans,max(work(x/k*i,y,i),work(x/k*(k-i),y,k-i))); return ans; } BZOJ1025 SCOI2009 游戏题意为给定$n$个元素，求在$n$的全排列的置换中的周期（即为各个循环节的公倍数），等价于$n$的整数拆分中的最小公倍数数量，直接枚举显然会超时，不妨用dp处理，枚举质因子以及幂即可。 BZOJ1026 SCOI2009 windy数数位DP（一般是求在$[L,R]$之间有多少满足条件的数，然而并没有学过，膜的题解），先预处理有$k$位时，最高位为$i$时的答案，通过交集，并集的关系求一下即可。 BZOJ1027 JSOI2007 合金构造题，已知$a+b+c=1$，可将第三维浓度去掉，那么目标浓度可由条件浓度转化而来，当且仅当$min(a_{condition})&lt;a_{target}&lt;max(a_{condition})$$min(b_{condition})&lt;b_{target}&lt;max(b_{condition})$那么可以将其转化为二维平面的凸包问题，给定可选点，要求用最少的点使其凸包包含所有目标点。 BZOJ1028 JSOI2007 麻将观察$n,m$的范围，可知贪心就能过。 BZOJ1029 JSOI2007 建筑抢修还是贪心，涨自信题。 BZOJ1030 JSOI2007 文本生成器AC自动机模板题，见DNA Sequence,不过这题$m$范围很小，而子串的长度更大，所以不需要矩阵快速幂（会TLE），直接DP即可。 BZOJ1031 JSOI2007 字符加密后缀数组模板题，利用后缀的性质将条件串接到自己后面，这样就包换了所有情况，求sa即可。 BZOJ1032 JSOI2007 祖码区间DP，标程没有考虑到连续消除的问题，导致数据都错了。 BZOJ1034 ZJOI2008 泡泡堂贪心，对于最好情况，先将对手实力值与ZJ实力值排序，如果ZJ最低的实力值比对手最低的实力值大，那么为了战胜对手，将两者比试的代价最小，如果ZJ最高的实力值比对手最高的实力值大时，那么为了战胜对手，此时只要ZJ取一个比对手该实力值高的元素即可，为了方便，可以取最后一个。当两者均不满足时，则与对手实力值最高的元素比试总不能获胜，为了代价最小，将ZJ实力值最小的元素与其进行比试。","raw":"title: 2017年5月 题目总结\ndate: 2017-05-02 8:04:05\ncategories:\n  - 总结\ntags:\n  - 仙人掌图\n  - Tarjan\n  - 动态规划\n  - 数位动态规划\n  - 凸包\n---\n\n### [BZOJ1023](http://www.lydsy.com/JudgeOnline/problem.php?id=1023) SHOI2008 cactus仙人掌图\n题意为求仙人掌图的直径。这题看起来完全没思路，最后看的题解。get了一种Tarjan的用法，先用其求出DFS树，用dp更新树边的直径最大值，考虑将其他非树边以环形dp更新，由于边的权值均为1，所以可以进行单调队列优化。其中利用到了仙人掌的一些性质。\n\n---\n### [BZOJ1024](http://www.lydsy.com/JudgeOnline/problem.php?id=1024) SCOI2009 生日快乐\n搜索，考虑切成n块后面积是一样的，那么实际上对于每一个切割后的蛋糕，需要继续处理的操作数的一定的，深搜即可。核心代码如下：\n\n\tdouble work(double x,double y,int k)//x，y为长与宽，k为对于该块蛋糕剩余操作个数。\n    {\n        if (k==1)return max(x,y)/min(x,y);\n        double ans=inf;\n        for(int i=1;i<k;++i)\n        ans=min(ans,max(work(x,y/k*i,i),work(x,y/k*(k-i),k-i)));\n        //取min是因为答案要求最小值，取max是因为属于同一块蛋糕。\n        for(int i=1;i<k;++i)\n        ans=min(ans,max(work(x/k*i,y,i),work(x/k*(k-i),y,k-i)));\n        return ans;\n    }\n\n\n\n---\n### [BZOJ1025](http://www.lydsy.com/JudgeOnline/problem.php?id=1025) SCOI2009 游戏\n题意为给定$n$个元素，求在$n$的全排列的置换中的周期（即为各个循环节的公倍数），等价于$n$的整数拆分中的最小公倍数数量，直接枚举显然会超时，不妨用dp处理，枚举质因子以及幂即可。\n\n---\n### [BZOJ1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1025) SCOI2009 windy数\n数位DP（一般是求在$[L,R]$之间有多少满足条件的数，然而并没有学过，膜的题解），先预处理有$k$位时，最高位为$i$时的\n答案，通过交集，并集的关系求一下即可。\n\n---\n### [BZOJ1027](http://www.lydsy.com/JudgeOnline/problem.php?id=1027) JSOI2007 合金\n构造题，已知$a+b+c=1$，可将第三维浓度去掉，那么目标浓度可由条件浓度转化而来，当且仅当$min(a_{condition})<a_{target}<max(a_{condition})$\n$min(b_{condition})<b_{target}<max(b_{condition})$\n那么可以将其转化为二维平面的凸包问题，给定可选点，要求用最少的点使其凸包包含所有目标点。\n\n---\n### [BZOJ1028](http://www.lydsy.com/JudgeOnline/problem.php?id=1028) JSOI2007 麻将\n观察$n,m$的范围，可知贪心就能过。\n\n---\n### [BZOJ1029](http://www.lydsy.com/JudgeOnline/problem.php?id=1029) JSOI2007 建筑抢修\n还是贪心，涨自信题。\n\n---\n### [BZOJ1030](http://www.lydsy.com/JudgeOnline/problem.php?id=1030) JSOI2007 文本生成器\nAC自动机模板题，见[DNA Sequence](https://prostkhala.github.io/2017/03/18/DNA%20Sequence/#more),不过这题$m$范围很小，而子串的长度更大，所以不需要矩阵快速幂（会TLE），直接DP即可。\n\n---\n### [BZOJ1031](http://www.lydsy.com/JudgeOnline/problem.php?id=1031) JSOI2007 字符加密\n后缀数组模板题，利用后缀的性质将条件串接到自己后面，这样就包换了所有情况，求sa即可。\n\n---\n### [BZOJ1032](http://www.lydsy.com/JudgeOnline/problem.php?id=1032) JSOI2007 祖码\n区间DP，标程没有考虑到连续消除的问题，导致数据都错了。\n\n---\n### [BZOJ1034](http://www.lydsy.com/JudgeOnline/problem.php?id=1034) ZJOI2008 泡泡堂\n贪心，对于最好情况，先将对手实力值与ZJ实力值排序，如果ZJ最低的实力值比对手最低的实力值大，那么为了战胜对手，将两者比试的代价最小，如果ZJ最高的实力值比对手最高的实力值大时，那么为了战胜对手，此时只要ZJ取一个比对手该实力值高的元素即可，为了方便，可以取最后一个。当两者均不满足时，则与对手实力值最高的元素比试总不能获胜，为了代价最小，将ZJ实力值最小的元素与其进行比试。\n\n\n\n\n","content":"<h3 id=\"BZOJ1023-SHOI2008-cactus仙人掌图\"><a href=\"#BZOJ1023-SHOI2008-cactus仙人掌图\" class=\"headerlink\" title=\"BZOJ1023 SHOI2008 cactus仙人掌图\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1023\" target=\"_blank\" rel=\"external\">BZOJ1023</a> SHOI2008 cactus仙人掌图</h3><p>题意为求仙人掌图的直径。这题看起来完全没思路，最后看的题解。get了一种Tarjan的用法，先用其求出DFS树，用dp更新树边的直径最大值，考虑将其他非树边以环形dp更新，由于边的权值均为1，所以可以进行单调队列优化。其中利用到了仙人掌的一些性质。</p>\n<hr>\n<h3 id=\"BZOJ1024-SCOI2009-生日快乐\"><a href=\"#BZOJ1024-SCOI2009-生日快乐\" class=\"headerlink\" title=\"BZOJ1024 SCOI2009 生日快乐\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1024\" target=\"_blank\" rel=\"external\">BZOJ1024</a> SCOI2009 生日快乐</h3><p>搜索，考虑切成n块后面积是一样的，那么实际上对于每一个切割后的蛋糕，需要继续处理的操作数的一定的，深搜即可。核心代码如下：</p>\n<pre><code>double work(double x,double y,int k)//x，y为长与宽，k为对于该块蛋糕剩余操作个数。\n{\n    if (k==1)return max(x,y)/min(x,y);\n    double ans=inf;\n    for(int i=1;i&lt;k;++i)\n    ans=min(ans,max(work(x,y/k*i,i),work(x,y/k*(k-i),k-i)));\n    //取min是因为答案要求最小值，取max是因为属于同一块蛋糕。\n    for(int i=1;i&lt;k;++i)\n    ans=min(ans,max(work(x/k*i,y,i),work(x/k*(k-i),y,k-i)));\n    return ans;\n}\n</code></pre><hr>\n<h3 id=\"BZOJ1025-SCOI2009-游戏\"><a href=\"#BZOJ1025-SCOI2009-游戏\" class=\"headerlink\" title=\"BZOJ1025 SCOI2009 游戏\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1025\" target=\"_blank\" rel=\"external\">BZOJ1025</a> SCOI2009 游戏</h3><p>题意为给定$n$个元素，求在$n$的全排列的置换中的周期（即为各个循环节的公倍数），等价于$n$的整数拆分中的最小公倍数数量，直接枚举显然会超时，不妨用dp处理，枚举质因子以及幂即可。</p>\n<hr>\n<h3 id=\"BZOJ1026-SCOI2009-windy数\"><a href=\"#BZOJ1026-SCOI2009-windy数\" class=\"headerlink\" title=\"BZOJ1026 SCOI2009 windy数\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1025\" target=\"_blank\" rel=\"external\">BZOJ1026</a> SCOI2009 windy数</h3><p>数位DP（一般是求在$[L,R]$之间有多少满足条件的数，然而并没有学过，膜的题解），先预处理有$k$位时，最高位为$i$时的<br>答案，通过交集，并集的关系求一下即可。</p>\n<hr>\n<h3 id=\"BZOJ1027-JSOI2007-合金\"><a href=\"#BZOJ1027-JSOI2007-合金\" class=\"headerlink\" title=\"BZOJ1027 JSOI2007 合金\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1027\" target=\"_blank\" rel=\"external\">BZOJ1027</a> JSOI2007 合金</h3><p>构造题，已知$a+b+c=1$，可将第三维浓度去掉，那么目标浓度可由条件浓度转化而来，当且仅当$min(a_{condition})&lt;a_{target}&lt;max(a_{condition})$<br>$min(b_{condition})&lt;b_{target}&lt;max(b_{condition})$<br>那么可以将其转化为二维平面的凸包问题，给定可选点，要求用最少的点使其凸包包含所有目标点。</p>\n<hr>\n<h3 id=\"BZOJ1028-JSOI2007-麻将\"><a href=\"#BZOJ1028-JSOI2007-麻将\" class=\"headerlink\" title=\"BZOJ1028 JSOI2007 麻将\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1028\" target=\"_blank\" rel=\"external\">BZOJ1028</a> JSOI2007 麻将</h3><p>观察$n,m$的范围，可知贪心就能过。</p>\n<hr>\n<h3 id=\"BZOJ1029-JSOI2007-建筑抢修\"><a href=\"#BZOJ1029-JSOI2007-建筑抢修\" class=\"headerlink\" title=\"BZOJ1029 JSOI2007 建筑抢修\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1029\" target=\"_blank\" rel=\"external\">BZOJ1029</a> JSOI2007 建筑抢修</h3><p>还是贪心，涨自信题。</p>\n<hr>\n<h3 id=\"BZOJ1030-JSOI2007-文本生成器\"><a href=\"#BZOJ1030-JSOI2007-文本生成器\" class=\"headerlink\" title=\"BZOJ1030 JSOI2007 文本生成器\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1030\" target=\"_blank\" rel=\"external\">BZOJ1030</a> JSOI2007 文本生成器</h3><p>AC自动机模板题，见<a href=\"https://prostkhala.github.io/2017/03/18/DNA%20Sequence/#more\">DNA Sequence</a>,不过这题$m$范围很小，而子串的长度更大，所以不需要矩阵快速幂（会TLE），直接DP即可。</p>\n<hr>\n<h3 id=\"BZOJ1031-JSOI2007-字符加密\"><a href=\"#BZOJ1031-JSOI2007-字符加密\" class=\"headerlink\" title=\"BZOJ1031 JSOI2007 字符加密\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1031\" target=\"_blank\" rel=\"external\">BZOJ1031</a> JSOI2007 字符加密</h3><p>后缀数组模板题，利用后缀的性质将条件串接到自己后面，这样就包换了所有情况，求sa即可。</p>\n<hr>\n<h3 id=\"BZOJ1032-JSOI2007-祖码\"><a href=\"#BZOJ1032-JSOI2007-祖码\" class=\"headerlink\" title=\"BZOJ1032 JSOI2007 祖码\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1032\" target=\"_blank\" rel=\"external\">BZOJ1032</a> JSOI2007 祖码</h3><p>区间DP，标程没有考虑到连续消除的问题，导致数据都错了。</p>\n<hr>\n<h3 id=\"BZOJ1034-ZJOI2008-泡泡堂\"><a href=\"#BZOJ1034-ZJOI2008-泡泡堂\" class=\"headerlink\" title=\"BZOJ1034 ZJOI2008 泡泡堂\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1034\" target=\"_blank\" rel=\"external\">BZOJ1034</a> ZJOI2008 泡泡堂</h3><p>贪心，对于最好情况，先将对手实力值与ZJ实力值排序，如果ZJ最低的实力值比对手最低的实力值大，那么为了战胜对手，将两者比试的代价最小，如果ZJ最高的实力值比对手最高的实力值大时，那么为了战胜对手，此时只要ZJ取一个比对手该实力值高的元素即可，为了方便，可以取最后一个。当两者均不满足时，则与对手实力值最高的元素比试总不能获胜，为了代价最小，将ZJ实力值最小的元素与其进行比试。</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/05/02/2017年5月 题目总结/","excerpt":"","categories":[{"name":"总结","slug":"总结","permalink":"https://prostkhala.github.io/categories/总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"仙人掌图","slug":"仙人掌图","permalink":"https://prostkhala.github.io/tags/仙人掌图/"},{"name":"Tarjan","slug":"Tarjan","permalink":"https://prostkhala.github.io/tags/Tarjan/"},{"name":"数位动态规划","slug":"数位动态规划","permalink":"https://prostkhala.github.io/tags/数位动态规划/"},{"name":"凸包","slug":"凸包","permalink":"https://prostkhala.github.io/tags/凸包/"}]},{"title":"SDOI2017 数字表格","date":"2017-04-27T03:39:21.000Z","path":"2017/04/27/SDOI2017 数字表格/","text":"SDOI2017 数字表格洛谷3704 题目描述 输入输出格式输入格式：有多组测试数据。 第一行一个数 $T$，表示数据组数。 接下来 $T $行，每行两个数 $n$ 和 $m$ 。 输出格式：输出 $T$ 行，第 $i$ 行的数是第 $i$ 组数据的结果。 输入输出样例输入样例：3 2 3 4 5 6 7 输出样例：1 6 960 数据范围对于 10%的数据，$1≤n,m≤100$； 对于 30% 的数据，$1≤n,m≤1000$ ； 另外存在 30% 的数据，$T≤3$； 对于 100% 的数据，$1≤n,m≤106 1 \\leq n, m \\leq 10 ^ 6 1≤n,m≤10^6$。 题解 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; typedef long long ull; typedef double db;; const int mod = 1000000007; const int N = 1e6+1; ull fi[N],p[N],miu[N],phi[N],tot,d[N],f[N],fp[N][3],ff[N],fs[N],rev[N]; bool vis[N]; int ca1[33],ca2[33]; ull qpow(ull a,ull b) { ull ret=1; if(b&lt;0)b+=mod-1; while(b) { if(b&amp;1)ret=(ret*a)%mod; b&gt;&gt;=1; a=(a*a)%mod; } return ret; } void init() { miu[1]=phi[1]=fs[0]=f[1]=1; for(int i=2;i&lt;N;++i) { f[i]=(f[i-1]+f[i-2])%mod; if(!vis[i])miu[i]=-1,p[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;p[j]*i&lt;N;++j) { vis[i*p[j]]=true; if(i%p[j]==0){miu[i*p[j]]=0;phi[i*p[j]]=phi[i]*p[j];break;} miu[i*p[j]]=-miu[i]; phi[i*p[j]]=phi[i]*(p[j]-1); } } for(int i=1;i&lt;N;++i) fp[i][0]=qpow(f[i],-1),fp[i][1]=1,fp[i][2]=f[i]; for(int i=1;i&lt;N;++i)ff[i]=1; for(int i=1;i&lt;N;++i) for(int j=i;j&lt;N;j+=i) ff[j]=(ull)ff[j]*fp[i][miu[j/i]+1]%mod; for(int i=1;i&lt;N;++i)fs[i]=(ull)fs[i-1]*ff[i]%mod; rev[N-1]=qpow(fs[N-1],-1); for(int i=N-2;i&gt;=0;--i)rev[i]=(ull)rev[i+1]*ff[i+1]%mod; return; } //ull solve(int n,int m) //{ // ull ret=0; // int top=min(n,m); // ull i=1,j; // while(i&lt;=top) // { // j=min(n/(n/i),m/(m/i)); // (ret+=(ull)(miu[j]-miu[i-1])*((n/i)*(m/i))%mod)%=mod; // i=j+1; // } // return ret; //} //ull mobi(ull n,ull m) //{ // if(n&gt;m)swap(n,m); // ull ans=0; // for (int i=1,r;i&lt;=n;i=r+1) // { // r=min(n/(n/i),m/(m/i)); // ans=(ans+sum(n/i)*sum(m/i)%mod*(miu[r]-miu[i-1])%mod)%mod; // } // return ans; //} //ull cheng(ull a,ull b) //{ // ull ret=0; // int tmp1=0,tmp2=0; // memset(ca1,0,sizeof(ca1)); // memset(ca2,0,sizeof(ca2)); // while(a)ca1[++tmp1]=a%10,a/=10; // while(b)ca2[++tmp2]=b%10,b/=10; // int *x=ca1,*y=ca2; // if(tmp2&gt;tmp1)swap(x,y),swap(tmp1,tmp2); // for(int i=1;i&lt;=tmp2;++i)x[i]*=y[i]; // for(int i=1;i&lt;=tmp2;++i) // if(x[i]&gt;10) // { // x[i+1]+=x[i]/10; // x[i]%=10; // } // for(int i=1;i&lt;=tmp1;++i)y[tmp1+1-i]=x[i]; // for(int i=1;i&lt;=tmp1;++i)ret=(ret*10+(y[i]))%mod; // return ret; //} int main() { int T,n,m,k; // freopen(&quot;c.out&quot;,&quot;w&quot;,stdout); init(); scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); ull ans=1; int mn=min(n,m); for(int i=1,r;i&lt;=mn;i=r+1) { r=min(n/(n/i),m/(m/i)); ans=ans*qpow(fs[r]*rev[i-1]%mod,(ull)(n/i)*(m/i)%(mod-1))%mod; } cout&lt;&lt;ans&lt;&lt;endl; } }","raw":"title: SDOI2017 数字表格\ndate: 2017-04-27 11:39:21\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 莫比乌斯反演\n  - 组合数学\n  - 线性筛法\n  - 逆元\n---\n\n# SDOI2017 数字表格\n\n## [洛谷3704](https://www.luogu.org/problem/show?pid=3704) \n---\n## 题目描述\n![](http://i2.muimg.com/567571/b5be40e5aacb8d09.png)\n\n\n\n### 输入输出格式\n#### 输入格式：\n有多组测试数据。\n\n第一行一个数 $T$，表示数据组数。\n\n接下来 $T $行，每行两个数 $n$ 和 $m$ 。\n\n\n#### 输出格式：\n输出 $T$ 行，第 $i$ 行的数是第 $i$ 组数据的结果。\n\n\n### 输入输出样例\n#### 输入样例：\n    3\n\n    2 3\n\n    4 5\n\n    6 7\n\n#### 输出样例：\n    1\n\n    6\n\n    960\n\n### 数据范围\n对于 10%的数据，$1≤n,m≤100$；\n\n对于 30% 的数据，$1≤n,m≤1000$ ；\n\n另外存在 30% 的数据，$T≤3$；\n\n对于 100% 的数据，$1≤n,m≤106 1 \\leq n, m \\leq 10 ^ 6 1≤n,m≤10^6$。\n\n\n---\n## 题解\n![](http://i4.buimg.com/567571/46577fa98c6b973a.png)\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #include<cmath>\n    using namespace std;\n    typedef long long ull;\n    typedef double db;;\n    const int mod = 1000000007;\n    const int N = 1e6+1;\n    ull fi[N],p[N],miu[N],phi[N],tot,d[N],f[N],fp[N][3],ff[N],fs[N],rev[N];\n    bool vis[N];\n    int ca1[33],ca2[33];\n\n    ull qpow(ull a,ull b)\n    {\n        ull ret=1;\n        if(b<0)b+=mod-1;\n        while(b)\n        {\n            if(b&1)ret=(ret*a)%mod;\n            b>>=1;\n            a=(a*a)%mod;\n        }\n        return ret;\n    }\n    void init()\n    {\n        miu[1]=phi[1]=fs[0]=f[1]=1;\n        for(int i=2;i<N;++i)\n        {\n            f[i]=(f[i-1]+f[i-2])%mod;\n            if(!vis[i])miu[i]=-1,p[++tot]=i,phi[i]=i-1;\n            for(int j=1;j<=tot&&p[j]*i<N;++j)\n            {\n                vis[i*p[j]]=true;\n                if(i%p[j]==0){miu[i*p[j]]=0;phi[i*p[j]]=phi[i]*p[j];break;}\n                miu[i*p[j]]=-miu[i];\n                phi[i*p[j]]=phi[i]*(p[j]-1);\n            }\n        }\n\n        for(int i=1;i<N;++i)\n        fp[i][0]=qpow(f[i],-1),fp[i][1]=1,fp[i][2]=f[i];\n\n        for(int i=1;i<N;++i)ff[i]=1;\n\n        for(int i=1;i<N;++i)\n        for(int j=i;j<N;j+=i)\n        ff[j]=(ull)ff[j]*fp[i][miu[j/i]+1]%mod;\n        for(int i=1;i<N;++i)fs[i]=(ull)fs[i-1]*ff[i]%mod;\n\n        rev[N-1]=qpow(fs[N-1],-1);\n\n        for(int i=N-2;i>=0;--i)rev[i]=(ull)rev[i+1]*ff[i+1]%mod;\n        return;\n    }\n    //ull solve(int n,int m)\n    //{\n    //    ull ret=0;\n    //    int top=min(n,m);\n    //    ull i=1,j;\n    //    while(i<=top)\n    //    {\n    //        j=min(n/(n/i),m/(m/i));\n    //        (ret+=(ull)(miu[j]-miu[i-1])*((n/i)*(m/i))%mod)%=mod; \n    //        i=j+1;\n    //    }\n    //    return ret;\n    //}\n    //ull mobi(ull n,ull m)\n    //{\n    //\tif(n>m)swap(n,m);\n    //\tull ans=0;\n    //\tfor (int i=1,r;i<=n;i=r+1)\n    //    {\n    //        r=min(n/(n/i),m/(m/i));\n    //        ans=(ans+sum(n/i)*sum(m/i)%mod*(miu[r]-miu[i-1])%mod)%mod;\n    //    }\n    //\treturn ans;\n    //}\n    //ull cheng(ull a,ull b)\n    //{\n    //\tull ret=0;\n    //\tint tmp1=0,tmp2=0;\n    //\tmemset(ca1,0,sizeof(ca1));\n    //\tmemset(ca2,0,sizeof(ca2));\n    //\twhile(a)ca1[++tmp1]=a%10,a/=10;\n    //\twhile(b)ca2[++tmp2]=b%10,b/=10;\n    //\tint *x=ca1,*y=ca2;\n    //\tif(tmp2>tmp1)swap(x,y),swap(tmp1,tmp2);\n    //\tfor(int i=1;i<=tmp2;++i)x[i]*=y[i];\n    //\tfor(int i=1;i<=tmp2;++i)\n    //\tif(x[i]>10)\n    //\t{\n    //\t\tx[i+1]+=x[i]/10;\n    //\t\tx[i]%=10;\n    //\t}\n    //\tfor(int i=1;i<=tmp1;++i)y[tmp1+1-i]=x[i];\n    //\tfor(int i=1;i<=tmp1;++i)ret=(ret*10+(y[i]))%mod;\n    //\treturn ret;\n    //}\n    int main()\n    {\n        int T,n,m,k;\n    //\tfreopen(\"c.out\",\"w\",stdout);\n        init();\n        scanf(\"%d\",&T);\n        while(T--)\n        {\n            scanf(\"%d%d\",&n,&m);\n            ull ans=1;\n            int mn=min(n,m);\n            for(int i=1,r;i<=mn;i=r+1)\n            {\n                r=min(n/(n/i),m/(m/i));\n                ans=ans*qpow(fs[r]*rev[i-1]%mod,(ull)(n/i)*(m/i)%(mod-1))%mod;\n            }\n            cout<<ans<<endl;\n        }\n    }","content":"<h1 id=\"SDOI2017-数字表格\"><a href=\"#SDOI2017-数字表格\" class=\"headerlink\" title=\"SDOI2017 数字表格\"></a>SDOI2017 数字表格</h1><h2 id=\"洛谷3704\"><a href=\"#洛谷3704\" class=\"headerlink\" title=\"洛谷3704\"></a><a href=\"https://www.luogu.org/problem/show?pid=3704\" target=\"_blank\" rel=\"external\">洛谷3704</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><img src=\"http://i2.muimg.com/567571/b5be40e5aacb8d09.png\" alt=\"\"></p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>有多组测试数据。</p>\n<p>第一行一个数 $T$，表示数据组数。</p>\n<p>接下来 $T $行，每行两个数 $n$ 和 $m$ 。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出 $T$ 行，第 $i$ 行的数是第 $i$ 组数据的结果。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\n\n2 3\n\n4 5\n\n6 7\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>1\n\n6\n\n960\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 10%的数据，$1≤n,m≤100$；</p>\n<p>对于 30% 的数据，$1≤n,m≤1000$ ；</p>\n<p>另外存在 30% 的数据，$T≤3$；</p>\n<p>对于 100% 的数据，$1≤n,m≤106 1 \\leq n, m \\leq 10 ^ 6 1≤n,m≤10^6$。</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p><img src=\"http://i4.buimg.com/567571/46577fa98c6b973a.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\nusing namespace std;\ntypedef long long ull;\ntypedef double db;;\nconst int mod = 1000000007;\nconst int N = 1e6+1;\null fi[N],p[N],miu[N],phi[N],tot,d[N],f[N],fp[N][3],ff[N],fs[N],rev[N];\nbool vis[N];\nint ca1[33],ca2[33];\n\null qpow(ull a,ull b)\n{\n    ull ret=1;\n    if(b&lt;0)b+=mod-1;\n    while(b)\n    {\n        if(b&amp;1)ret=(ret*a)%mod;\n        b&gt;&gt;=1;\n        a=(a*a)%mod;\n    }\n    return ret;\n}\nvoid init()\n{\n    miu[1]=phi[1]=fs[0]=f[1]=1;\n    for(int i=2;i&lt;N;++i)\n    {\n        f[i]=(f[i-1]+f[i-2])%mod;\n        if(!vis[i])miu[i]=-1,p[++tot]=i,phi[i]=i-1;\n        for(int j=1;j&lt;=tot&amp;&amp;p[j]*i&lt;N;++j)\n        {\n            vis[i*p[j]]=true;\n            if(i%p[j]==0){miu[i*p[j]]=0;phi[i*p[j]]=phi[i]*p[j];break;}\n            miu[i*p[j]]=-miu[i];\n            phi[i*p[j]]=phi[i]*(p[j]-1);\n        }\n    }\n\n    for(int i=1;i&lt;N;++i)\n    fp[i][0]=qpow(f[i],-1),fp[i][1]=1,fp[i][2]=f[i];\n\n    for(int i=1;i&lt;N;++i)ff[i]=1;\n\n    for(int i=1;i&lt;N;++i)\n    for(int j=i;j&lt;N;j+=i)\n    ff[j]=(ull)ff[j]*fp[i][miu[j/i]+1]%mod;\n    for(int i=1;i&lt;N;++i)fs[i]=(ull)fs[i-1]*ff[i]%mod;\n\n    rev[N-1]=qpow(fs[N-1],-1);\n\n    for(int i=N-2;i&gt;=0;--i)rev[i]=(ull)rev[i+1]*ff[i+1]%mod;\n    return;\n}\n//ull solve(int n,int m)\n//{\n//    ull ret=0;\n//    int top=min(n,m);\n//    ull i=1,j;\n//    while(i&lt;=top)\n//    {\n//        j=min(n/(n/i),m/(m/i));\n//        (ret+=(ull)(miu[j]-miu[i-1])*((n/i)*(m/i))%mod)%=mod; \n//        i=j+1;\n//    }\n//    return ret;\n//}\n//ull mobi(ull n,ull m)\n//{\n//    if(n&gt;m)swap(n,m);\n//    ull ans=0;\n//    for (int i=1,r;i&lt;=n;i=r+1)\n//    {\n//        r=min(n/(n/i),m/(m/i));\n//        ans=(ans+sum(n/i)*sum(m/i)%mod*(miu[r]-miu[i-1])%mod)%mod;\n//    }\n//    return ans;\n//}\n//ull cheng(ull a,ull b)\n//{\n//    ull ret=0;\n//    int tmp1=0,tmp2=0;\n//    memset(ca1,0,sizeof(ca1));\n//    memset(ca2,0,sizeof(ca2));\n//    while(a)ca1[++tmp1]=a%10,a/=10;\n//    while(b)ca2[++tmp2]=b%10,b/=10;\n//    int *x=ca1,*y=ca2;\n//    if(tmp2&gt;tmp1)swap(x,y),swap(tmp1,tmp2);\n//    for(int i=1;i&lt;=tmp2;++i)x[i]*=y[i];\n//    for(int i=1;i&lt;=tmp2;++i)\n//    if(x[i]&gt;10)\n//    {\n//        x[i+1]+=x[i]/10;\n//        x[i]%=10;\n//    }\n//    for(int i=1;i&lt;=tmp1;++i)y[tmp1+1-i]=x[i];\n//    for(int i=1;i&lt;=tmp1;++i)ret=(ret*10+(y[i]))%mod;\n//    return ret;\n//}\nint main()\n{\n    int T,n,m,k;\n//    freopen(&quot;c.out&quot;,&quot;w&quot;,stdout);\n    init();\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--)\n    {\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        ull ans=1;\n        int mn=min(n,m);\n        for(int i=1,r;i&lt;=mn;i=r+1)\n        {\n            r=min(n/(n/i),m/(m/i));\n            ans=ans*qpow(fs[r]*rev[i-1]%mod,(ull)(n/i)*(m/i)%(mod-1))%mod;\n        }\n        cout&lt;&lt;ans&lt;&lt;endl;\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/27/SDOI2017 数字表格/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://prostkhala.github.io/tags/莫比乌斯反演/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"},{"name":"线性筛法","slug":"线性筛法","permalink":"https://prostkhala.github.io/tags/线性筛法/"},{"name":"逆元","slug":"逆元","permalink":"https://prostkhala.github.io/tags/逆元/"}]},{"title":"2017年4月 题目总结","date":"2017-04-25T04:03:24.000Z","path":"2017/04/25/2017年4月 题目总结/","text":"BZOJ1001 BeiJing2006 狼抓兔子网络流裸题，考虑到边为双向边，建图时应同样将反向边赋值。同时也应加上反向弧优化（当流量为零时直接将点标记为不可达到即可） BZOJ1002 FJOI2007 轮状病毒最简单的方法是打表找规律，进阶一点是动态规划。其实这题跟基尔霍夫矩阵有关，然而还是找规律。（要加上高精度） BZOJ1003 ZJOI2006 物流运输一道DP题，转移方程为$f[i]=min(f[i],f[j]+k+t[j+1][i]*(i-j))$ BZOJ1004 HNOI2008 CardsBurnside引理裸题，题目中给定的限制满足将洗牌看作置换的条件。只要递推加DP求出每种置换下不变方案数即可。考虑到当两张牌在该置换下属于同一循环节时，不变方案要求两者颜色相同，做一下三维背包即可。 BZOJ1005 HNOI2008 明明的烦恼purfer序列裸题，根据确定purfer序列的规则将度数的限制转化为在序列中的限制，求排列总数即可，对于分母需要求逆元，可以上高精度也可以分解质因数。 BZOJ1006 HNOI2008 神奇的国度弦图裸题，见弦图与区间图。 BZOJ1007 HNOI2008 水平可见直线以斜率维护双端队列，当两端元素被覆盖时出队，在将当前直线加入队列，最后剩下的即为答案。 BZOJ1008 HNOI2008 越狱简单的快速幂，稍微推一下即可得到答案为$qpow(m,n)-(qpow(m-1,n-1)*m)$。 BZOJ1009 HNOI2008 GT考试用KMP和AC自动机皆可，KMP需要DP一下，AC自动机上模板就行。 BZOJ1011 HNOI2008 遥远的行星简单的递推，考虑到题目中所说的限制和误差的条件，不妨在$j$大于一个限制时，将求$j$的受力公式化中的分母化为近似的$(A*j)/2$j即可。 BZOJ1012 JSOI2008 最大数各种数据结构的裸题。 BZOJ1013 JSOI2008 球形空间产生器高斯消元，提示中给出了两点间坐标公式，可以将每个给定的点与圆心坐标通过公式建立联系，再消掉公式右项中的半径，即可套用高斯消元算法。 BZOJ4801 BZOJ4月月赛 打牌考验基础的编程能力，每一轮的优先权是解题的关键，不妨将两人有牌权值相同时特殊处理一下，注意思路要清晰，最后注意下$A$的权值与价值不同，优先出牌的人可能故意输掉一局使得分尽可能大。 BZOJ4810 YNOI2017 由乃的玉米田主要考察bitset的运用，但直接套用会明显会超时，需要莫队算法优化时间复杂度。 洛谷3708 洛谷四月月赛 koishi的数学题设$g(x,i)=g (mod i)$，则可以先打表算出$g(1,1)$到$g(n,n)$的值。观察矩阵可知，考虑$f(x-1)$对$f(x)$的贡献，可知两者的区别主要的不同取决于因子的不同，预处理一下即可。 BZOJ1015 JSOI2008 星球大战考察并查集的应用，由于问题可以离线，可以将操作逆处理，将问题转变为熟悉的集合合并问题，再注意一下剪枝即可。 BZOJ1018 SHOI2008 堵塞的交通分块+并查集，思想很简单(分块优化的暴力)，第一次实现这种数据结构，调了好久。正解是线段树维护每一列自身以及与相邻两列的连通性。考虑两点之间可能的联通方式，枚举所有可能的情况，完成所有操作。（比暴力还难写） BZOJ1019 SHOI2008汉诺塔第一眼看题先打表找了个规律，可知，$f[i]$（当前优先级下有$i$层时的答案）与$f[i-1]$线性相关，于是模拟出来前20项，递推出后十项。（正解为DP，严格遵循题目所给的要求（汉诺塔问题均有$f[i]=f[i-1]*k+b$的递推式）） BZOJ1020 SHOI2008 安全的航线（MARK）典型的计算几何，可以二分可以迭代，具体按照莫涛的论文《迭代思想的应用》实现，但是还是TLE了。后来看题解get了求垂足的姿势，复习了一下求点与多边形包含关系的方法。（mark一下，复习时再敲一遍） BZOJ1021 SHOI2008 循环的债务题目可以进一步简化，即已知每个人初始金钱和构成 洛谷3704 SDOI2017 数字表格莫比乌斯反演的常见应用，见SDOI2017 数字表格。 BZOJ1049 HAOI2006 数字序列很像暴力的动规，对于第一问，需要用到补集转化的思想（浅谈补集转化思想在统计问题中的应用），设$f[i]$为前$i$位的最多不变元素，那么$f[i]$能由$f[j]$转化而来当且仅当$a[i]-a[j]&gt;=i-j$,即修改两者之间的$i-j-1$个数使其严格递增，即两者之间只有1个元素不变，那么有$$f[i]=max(f[i],f[j]+1)(a[i]-a[j]&gt;=i-j)$$时间复杂度为$O(n^2)$,无法通过全部数据点，考虑进行优化，观察状态转移方程，易知可以通过减标号的方法转化成LIS问题，即可在$O(nlogn)$的时间内求解。 对于第二问，为了简化问题，可以先设$w(i,j)$为将从$i$到$j$的所有元素进行修改的最小代价，设$g[i]$为前$i$位的最小答案。那么根据第一问有，$$g[i]=min(g[i],g[j]+w(j+1,i))(f[i]=f[j]+1)$$ 对于$w$的求解，可以记录每一个需要修改的元素的下一个和上一个不需要修改元素的位置，模拟即可。 「Codefores286E」 Ladies’ Shop根据题目所给条件， 可知要求的$p$个数一定在给定的$n$个数中。（1） 那么可以根据多项式乘法系数相乘，指数相加的特点，构造生成函数，并求出这$n$个数可以组成的所有情况。已知某个$n$集合中数 $a$ 可以由 $b$ + $c$ + $d$ 生成，那么根据题目中所给条件，可知一定有 $e$ 由$c$ + $d$ 生成，那么可以将 $a$ 看作由 $b$ + $e$ 生成。 根据数学归纳法，易证条件一: $p$个数可以选出一些集合（相同的数可重复选），其和可以组成所有给定的$n$个数。 与以下结论等价： $p$个数可以选出任何两个元素（相同的数可重复选），其和可以组成所有给定的$n$个数。 （2） 那么生成函数的构造就显而易见了。（将幂作为权值，系数作为出现的次数，并将该生成函数与自身相乘，可以通过FFT优化） 对于第三个条件（满足$|p|$的阶最小），可以结合以贪心的策略。如果生成函数中某项系数大于1且在给定集合$|n|$中，则该元素一定可以由另外两个元素组成，那么就不将其加入集合$|p|$中，否则将其加入集合$|p|$中。 至于无解的判断，易知其等价于： 生成函数中某项系数不为零且该元素不在给定集合中。","raw":"title: 2017年4月 题目总结\ndate: 2017-4-25 12:03:24\ncategories:\n  - 总结\ntags:\n  - 高斯消元\n  - 高精度算法\n  - 网络流\n  - 动态规划\n  - Polya定理&Burnside引理\n  - 弦图与区间图\n  - 计算几何\n  - AC自动机\n  - KMP\n  - SPLAY\n  - HASH\n  - purfer序列\n  - BITSET\n  - 莫队算法\n  - 并查集\n  - 分块\n---\n\n### [BZOJ1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001) BeiJing2006 狼抓兔子\n\n网络流裸题，考虑到边为双向边，建图时应同样将反向边赋值。同时也应加上反向弧优化（当流量为零时直接将点标记为不可达到即可）\n\n---\n### [BZOJ1002](http://www.lydsy.com/JudgeOnline/problem.php?id=1002) FJOI2007 轮状病毒\n最简单的方法是打表找规律，进阶一点是动态规划。其实这题跟基尔霍夫矩阵有关，然而还是找规律。（要加上高精度）\n\n---\n### [BZOJ1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003) ZJOI2006 物流运输\n一道DP题，转移方程为$f[i]=min(f[i],f[j]+k+t[j+1][i]*(i-j))$\n\n---\n\n### [BZOJ1004](http://www.lydsy.com/JudgeOnline/problem.php?id=1004) HNOI2008 Cards\nBurnside引理裸题，题目中给定的限制满足将洗牌看作置换的条件。只要递推加DP求出每种置换下不变方案数即可。考虑到当两张牌在该置换下属于同一循环节时，不变方案要求两者颜色相同，做一下三维背包即可。\n\n\n---\n### [BZOJ1005](http://www.lydsy.com/JudgeOnline/problem.php?id=1005) \tHNOI2008 明明的烦恼\npurfer序列裸题，根据确定purfer序列的规则将度数的限制转化为在序列中的限制，求排列总数即可，对于分母需要求逆元，可以上高精度也可以分解质因数。\n\n---\n### [BZOJ1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006) \tHNOI2008 神奇的国度\n弦图裸题，见[弦图与区间图](https://prostkhala.github.io/2017/04/21/%E5%BC%A6%E5%9B%BE%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9B%BE/)。\n\n---\n### [BZOJ1007](http://www.lydsy.com/JudgeOnline/problem.php?id=1007) \tHNOI2008 水平可见直线\n以斜率维护双端队列，当两端元素被覆盖时出队，在将当前直线加入队列，最后剩下的即为答案。\n\n---\n### [BZOJ1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008) \tHNOI2008 越狱\n简单的快速幂，稍微推一下即可得到答案为$qpow(m,n)-(qpow(m-1,n-1)*m)$。\n\n---\n### [BZOJ1009](http://www.lydsy.com/JudgeOnline/problem.php?id=1009) \tHNOI2008 GT考试\n用KMP和AC自动机皆可，KMP需要DP一下，AC自动机上模板就行。\n\n---\n### [BZOJ1011](http://www.lydsy.com/JudgeOnline/problem.php?id=1011) \tHNOI2008 遥远的行星\n简单的递推，考虑到题目中所说的限制和误差的条件，不妨在$j$大于一个限制时，将求$j$的受力公式化中的分母化为近似的$(A*j)/2$j即可。\n\n---\n### [BZOJ1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012) \tJSOI2008 最大数\n各种数据结构的裸题。\n\n---\n### [BZOJ1013](http://www.lydsy.com/JudgeOnline/problem.php?id=1013) \tJSOI2008 球形空间产生器\n高斯消元，提示中给出了两点间坐标公式，可以将每个给定的点与圆心坐标通过公式建立联系，再消掉公式右项中的半径，即可套用高斯消元算法。\n\n---\n### [BZOJ4801](http://www.lydsy.com/JudgeOnline/problem.php?id=4801) \tBZOJ4月月赛 打牌\n考验基础的编程能力，每一轮的优先权是解题的关键，不妨将两人有牌权值相同时特殊处理一下，注意思路要清晰，最后注意下$A$的权值与价值不同，优先出牌的人可能故意输掉一局使得分尽可能大。\n\n---\n### [BZOJ4810](http://www.lydsy.com/JudgeOnline/problem.php?id=4810) \tYNOI2017 由乃的玉米田\n主要考察bitset的运用，但直接套用会明显会超时，需要莫队算法优化时间复杂度。\n\n---\n### [洛谷3708](https://www.luogu.org/problem/show?pid=3708) 洛谷四月月赛 koishi的数学题\n设$g(x,i)=g (mod i)$，则可以先打表算出$g(1,1)$到$g(n,n)$的值。观察矩阵可知，考虑$f(x-1)$对$f(x)$的贡献，可知两者的区别主要的不同取决于因子的不同，预处理一下即可。\n\n---\n### [BZOJ1015](http://www.lydsy.com/JudgeOnline/problem.php?id=1015) JSOI2008 星球大战\n考察并查集的应用，由于问题可以离线，可以将操作逆处理，将问题转变为熟悉的集合合并问题，再注意一下剪枝即可。\n\n\n\n---\n### [BZOJ1018](http://www.lydsy.com/JudgeOnline/problem.php?id=1018) \tSHOI2008 堵塞的交通\n分块+并查集，思想很简单(分块优化的暴力)，第一次实现这种数据结构，调了好久。正解是线段树维护每一列自身以及与相邻两列的连通性。考虑两点之间可能的联通方式，枚举所有可能的情况，完成所有操作。（比暴力还难写）\n\n---\n### [BZOJ1019](http://www.lydsy.com/JudgeOnline/problem.php?id=1019) SHOI2008汉诺塔\n第一眼看题先打表找了个规律，可知，$f[i]$（当前优先级下有$i$层时的答案）与$f[i-1]$线性相关，于是模拟出来前20项，递推出后十项。（正解为DP，严格遵循题目所给的要求（汉诺塔问题均有$f[i]=f[i-1]*k+b$的递推式））\n\n---\n### [BZOJ1020](http://www.lydsy.com/JudgeOnline/problem.php?id=1020) SHOI2008 安全的航线（MARK）\n典型的计算几何，可以二分可以迭代，具体按照莫涛的论文《迭代思想的应用》实现，但是还是TLE了。后来看题解get了求垂足的姿势，复习了一下求点与多边形包含关系的方法。（mark一下，复习时再敲一遍）\n\n---\n### [BZOJ1021](http://www.lydsy.com/JudgeOnline/problem.php?id=1021)  SHOI2008 循环的债务\n题目可以进一步简化，即已知每个人初始金钱和构成\n\n---\n### [洛谷3704](https://www.luogu.org/problem/show?pid=3704)  SDOI2017 数字表格\n莫比乌斯反演的常见应用，见[SDOI2017 数字表格](https://prostkhala.github.io/2017/04/27/SDOI2017%20%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/#more)。\n\n---\n### [BZOJ1049](http://www.lydsy.com/JudgeOnline/problem.php?id=1049) HAOI2006 数字序列\n很像暴力的动规，对于第一问，需要用到补集转化的思想（[浅谈补集转化思想在统计问题中的应用](https://wenku.baidu.com/view/31a907020740be1e650e9aad.html)），设$f[i]$为前$i$位的最多不变元素，那么$f[i]$能由$f[j]$转化而来当且仅当$a[i]-a[j]>=i-j$,即修改两者之间的$i-j-1$个数使其严格递增，即两者之间只有1个元素不变，那么有\n$$f[i]=max(f[i],f[j]+1)(a[i]-a[j]>=i-j)$$\n时间复杂度为$O(n^2)$,无法通过全部数据点，考虑进行优化，观察状态转移方程，易知可以通过减标号的方法转化成LIS问题，即可在$O(nlogn)$的时间内求解。\n\n对于第二问，为了简化问题，可以先设$w(i,j)$为将从$i$到$j$的所有元素进行修改的最小代价，设$g[i]$为前$i$位的最小答案。那么根据第一问有，\n$$g[i]=min(g[i],g[j]+w(j+1,i))(f[i]=f[j]+1)$$\n\n对于$w$的求解，可以记录每一个需要修改的元素的下一个和上一个不需要修改元素的位置，模拟即可。\n\n---\n### 「Codefores286E」 Ladies' Shop \n根据题目所给条件，\n\n可知要求的$p$个数一定在给定的$n$个数中。（1）\n\n那么可以根据多项式乘法系数相乘，指数相加的特点，构造生成函数，并求出这$n$个数可以组成的所有情况。已知某个$n$集合中数 $a$ 可以由 $b$ + $c$ + $d$ 生成，那么根据题目中所给条件，可知一定有 $e$ 由$c$ + $d$ 生成，那么可以将 $a$ 看作由 $b$ + $e$  生成。\n\n根据数学归纳法，易证条件一: \n\n$p$个数可以选出一些集合（相同的数可重复选），其和可以组成所有给定的$n$个数。\n\n 与以下结论等价：\n\n$p$个数可以选出任何两个元素（相同的数可重复选），其和可以组成所有给定的$n$个数。 （2）\n\n那么生成函数的构造就显而易见了。（将幂作为权值，系数作为出现的次数，并将该生成函数与自身相乘，可以通过FFT优化）\n\n\n对于第三个条件（满足$|p|$的阶最小），可以结合以贪心的策略。如果生成函数中某项系数大于1且在给定集合$|n|$中，则该元素一定可以由另外两个元素组成，那么就不将其加入集合$|p|$中，否则将其加入集合$|p|$中。\n\n至于无解的判断，易知其等价于：\n\n生成函数中某项系数不为零且该元素不在给定集合中。\n\n\n","content":"<h3 id=\"BZOJ1001-BeiJing2006-狼抓兔子\"><a href=\"#BZOJ1001-BeiJing2006-狼抓兔子\" class=\"headerlink\" title=\"BZOJ1001 BeiJing2006 狼抓兔子\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1001\" target=\"_blank\" rel=\"external\">BZOJ1001</a> BeiJing2006 狼抓兔子</h3><p>网络流裸题，考虑到边为双向边，建图时应同样将反向边赋值。同时也应加上反向弧优化（当流量为零时直接将点标记为不可达到即可）</p>\n<hr>\n<h3 id=\"BZOJ1002-FJOI2007-轮状病毒\"><a href=\"#BZOJ1002-FJOI2007-轮状病毒\" class=\"headerlink\" title=\"BZOJ1002 FJOI2007 轮状病毒\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1002\" target=\"_blank\" rel=\"external\">BZOJ1002</a> FJOI2007 轮状病毒</h3><p>最简单的方法是打表找规律，进阶一点是动态规划。其实这题跟基尔霍夫矩阵有关，然而还是找规律。（要加上高精度）</p>\n<hr>\n<h3 id=\"BZOJ1003-ZJOI2006-物流运输\"><a href=\"#BZOJ1003-ZJOI2006-物流运输\" class=\"headerlink\" title=\"BZOJ1003 ZJOI2006 物流运输\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1003\" target=\"_blank\" rel=\"external\">BZOJ1003</a> ZJOI2006 物流运输</h3><p>一道DP题，转移方程为$f[i]=min(f[i],f[j]+k+t[j+1][i]*(i-j))$</p>\n<hr>\n<h3 id=\"BZOJ1004-HNOI2008-Cards\"><a href=\"#BZOJ1004-HNOI2008-Cards\" class=\"headerlink\" title=\"BZOJ1004 HNOI2008 Cards\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1004\" target=\"_blank\" rel=\"external\">BZOJ1004</a> HNOI2008 Cards</h3><p>Burnside引理裸题，题目中给定的限制满足将洗牌看作置换的条件。只要递推加DP求出每种置换下不变方案数即可。考虑到当两张牌在该置换下属于同一循环节时，不变方案要求两者颜色相同，做一下三维背包即可。</p>\n<hr>\n<h3 id=\"BZOJ1005-HNOI2008-明明的烦恼\"><a href=\"#BZOJ1005-HNOI2008-明明的烦恼\" class=\"headerlink\" title=\"BZOJ1005     HNOI2008 明明的烦恼\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1005\" target=\"_blank\" rel=\"external\">BZOJ1005</a>     HNOI2008 明明的烦恼</h3><p>purfer序列裸题，根据确定purfer序列的规则将度数的限制转化为在序列中的限制，求排列总数即可，对于分母需要求逆元，可以上高精度也可以分解质因数。</p>\n<hr>\n<h3 id=\"BZOJ1006-HNOI2008-神奇的国度\"><a href=\"#BZOJ1006-HNOI2008-神奇的国度\" class=\"headerlink\" title=\"BZOJ1006     HNOI2008 神奇的国度\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1006\" target=\"_blank\" rel=\"external\">BZOJ1006</a>     HNOI2008 神奇的国度</h3><p>弦图裸题，见<a href=\"https://prostkhala.github.io/2017/04/21/%E5%BC%A6%E5%9B%BE%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9B%BE/\">弦图与区间图</a>。</p>\n<hr>\n<h3 id=\"BZOJ1007-HNOI2008-水平可见直线\"><a href=\"#BZOJ1007-HNOI2008-水平可见直线\" class=\"headerlink\" title=\"BZOJ1007     HNOI2008 水平可见直线\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1007\" target=\"_blank\" rel=\"external\">BZOJ1007</a>     HNOI2008 水平可见直线</h3><p>以斜率维护双端队列，当两端元素被覆盖时出队，在将当前直线加入队列，最后剩下的即为答案。</p>\n<hr>\n<h3 id=\"BZOJ1008-HNOI2008-越狱\"><a href=\"#BZOJ1008-HNOI2008-越狱\" class=\"headerlink\" title=\"BZOJ1008     HNOI2008 越狱\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1008\" target=\"_blank\" rel=\"external\">BZOJ1008</a>     HNOI2008 越狱</h3><p>简单的快速幂，稍微推一下即可得到答案为$qpow(m,n)-(qpow(m-1,n-1)*m)$。</p>\n<hr>\n<h3 id=\"BZOJ1009-HNOI2008-GT考试\"><a href=\"#BZOJ1009-HNOI2008-GT考试\" class=\"headerlink\" title=\"BZOJ1009     HNOI2008 GT考试\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1009\" target=\"_blank\" rel=\"external\">BZOJ1009</a>     HNOI2008 GT考试</h3><p>用KMP和AC自动机皆可，KMP需要DP一下，AC自动机上模板就行。</p>\n<hr>\n<h3 id=\"BZOJ1011-HNOI2008-遥远的行星\"><a href=\"#BZOJ1011-HNOI2008-遥远的行星\" class=\"headerlink\" title=\"BZOJ1011     HNOI2008 遥远的行星\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1011\" target=\"_blank\" rel=\"external\">BZOJ1011</a>     HNOI2008 遥远的行星</h3><p>简单的递推，考虑到题目中所说的限制和误差的条件，不妨在$j$大于一个限制时，将求$j$的受力公式化中的分母化为近似的$(A*j)/2$j即可。</p>\n<hr>\n<h3 id=\"BZOJ1012-JSOI2008-最大数\"><a href=\"#BZOJ1012-JSOI2008-最大数\" class=\"headerlink\" title=\"BZOJ1012     JSOI2008 最大数\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1012\" target=\"_blank\" rel=\"external\">BZOJ1012</a>     JSOI2008 最大数</h3><p>各种数据结构的裸题。</p>\n<hr>\n<h3 id=\"BZOJ1013-JSOI2008-球形空间产生器\"><a href=\"#BZOJ1013-JSOI2008-球形空间产生器\" class=\"headerlink\" title=\"BZOJ1013     JSOI2008 球形空间产生器\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1013\" target=\"_blank\" rel=\"external\">BZOJ1013</a>     JSOI2008 球形空间产生器</h3><p>高斯消元，提示中给出了两点间坐标公式，可以将每个给定的点与圆心坐标通过公式建立联系，再消掉公式右项中的半径，即可套用高斯消元算法。</p>\n<hr>\n<h3 id=\"BZOJ4801-BZOJ4月月赛-打牌\"><a href=\"#BZOJ4801-BZOJ4月月赛-打牌\" class=\"headerlink\" title=\"BZOJ4801     BZOJ4月月赛 打牌\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=4801\" target=\"_blank\" rel=\"external\">BZOJ4801</a>     BZOJ4月月赛 打牌</h3><p>考验基础的编程能力，每一轮的优先权是解题的关键，不妨将两人有牌权值相同时特殊处理一下，注意思路要清晰，最后注意下$A$的权值与价值不同，优先出牌的人可能故意输掉一局使得分尽可能大。</p>\n<hr>\n<h3 id=\"BZOJ4810-YNOI2017-由乃的玉米田\"><a href=\"#BZOJ4810-YNOI2017-由乃的玉米田\" class=\"headerlink\" title=\"BZOJ4810     YNOI2017 由乃的玉米田\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=4810\" target=\"_blank\" rel=\"external\">BZOJ4810</a>     YNOI2017 由乃的玉米田</h3><p>主要考察bitset的运用，但直接套用会明显会超时，需要莫队算法优化时间复杂度。</p>\n<hr>\n<h3 id=\"洛谷3708-洛谷四月月赛-koishi的数学题\"><a href=\"#洛谷3708-洛谷四月月赛-koishi的数学题\" class=\"headerlink\" title=\"洛谷3708 洛谷四月月赛 koishi的数学题\"></a><a href=\"https://www.luogu.org/problem/show?pid=3708\" target=\"_blank\" rel=\"external\">洛谷3708</a> 洛谷四月月赛 koishi的数学题</h3><p>设$g(x,i)=g (mod i)$，则可以先打表算出$g(1,1)$到$g(n,n)$的值。观察矩阵可知，考虑$f(x-1)$对$f(x)$的贡献，可知两者的区别主要的不同取决于因子的不同，预处理一下即可。</p>\n<hr>\n<h3 id=\"BZOJ1015-JSOI2008-星球大战\"><a href=\"#BZOJ1015-JSOI2008-星球大战\" class=\"headerlink\" title=\"BZOJ1015 JSOI2008 星球大战\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1015\" target=\"_blank\" rel=\"external\">BZOJ1015</a> JSOI2008 星球大战</h3><p>考察并查集的应用，由于问题可以离线，可以将操作逆处理，将问题转变为熟悉的集合合并问题，再注意一下剪枝即可。</p>\n<hr>\n<h3 id=\"BZOJ1018-SHOI2008-堵塞的交通\"><a href=\"#BZOJ1018-SHOI2008-堵塞的交通\" class=\"headerlink\" title=\"BZOJ1018     SHOI2008 堵塞的交通\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1018\" target=\"_blank\" rel=\"external\">BZOJ1018</a>     SHOI2008 堵塞的交通</h3><p>分块+并查集，思想很简单(分块优化的暴力)，第一次实现这种数据结构，调了好久。正解是线段树维护每一列自身以及与相邻两列的连通性。考虑两点之间可能的联通方式，枚举所有可能的情况，完成所有操作。（比暴力还难写）</p>\n<hr>\n<h3 id=\"BZOJ1019-SHOI2008汉诺塔\"><a href=\"#BZOJ1019-SHOI2008汉诺塔\" class=\"headerlink\" title=\"BZOJ1019 SHOI2008汉诺塔\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1019\" target=\"_blank\" rel=\"external\">BZOJ1019</a> SHOI2008汉诺塔</h3><p>第一眼看题先打表找了个规律，可知，$f[i]$（当前优先级下有$i$层时的答案）与$f[i-1]$线性相关，于是模拟出来前20项，递推出后十项。（正解为DP，严格遵循题目所给的要求（汉诺塔问题均有$f[i]=f[i-1]*k+b$的递推式））</p>\n<hr>\n<h3 id=\"BZOJ1020-SHOI2008-安全的航线（MARK）\"><a href=\"#BZOJ1020-SHOI2008-安全的航线（MARK）\" class=\"headerlink\" title=\"BZOJ1020 SHOI2008 安全的航线（MARK）\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1020\" target=\"_blank\" rel=\"external\">BZOJ1020</a> SHOI2008 安全的航线（MARK）</h3><p>典型的计算几何，可以二分可以迭代，具体按照莫涛的论文《迭代思想的应用》实现，但是还是TLE了。后来看题解get了求垂足的姿势，复习了一下求点与多边形包含关系的方法。（mark一下，复习时再敲一遍）</p>\n<hr>\n<h3 id=\"BZOJ1021-SHOI2008-循环的债务\"><a href=\"#BZOJ1021-SHOI2008-循环的债务\" class=\"headerlink\" title=\"BZOJ1021  SHOI2008 循环的债务\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1021\" target=\"_blank\" rel=\"external\">BZOJ1021</a>  SHOI2008 循环的债务</h3><p>题目可以进一步简化，即已知每个人初始金钱和构成</p>\n<hr>\n<h3 id=\"洛谷3704-SDOI2017-数字表格\"><a href=\"#洛谷3704-SDOI2017-数字表格\" class=\"headerlink\" title=\"洛谷3704  SDOI2017 数字表格\"></a><a href=\"https://www.luogu.org/problem/show?pid=3704\" target=\"_blank\" rel=\"external\">洛谷3704</a>  SDOI2017 数字表格</h3><p>莫比乌斯反演的常见应用，见<a href=\"https://prostkhala.github.io/2017/04/27/SDOI2017%20%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/#more\">SDOI2017 数字表格</a>。</p>\n<hr>\n<h3 id=\"BZOJ1049-HAOI2006-数字序列\"><a href=\"#BZOJ1049-HAOI2006-数字序列\" class=\"headerlink\" title=\"BZOJ1049 HAOI2006 数字序列\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1049\" target=\"_blank\" rel=\"external\">BZOJ1049</a> HAOI2006 数字序列</h3><p>很像暴力的动规，对于第一问，需要用到补集转化的思想（<a href=\"https://wenku.baidu.com/view/31a907020740be1e650e9aad.html\" target=\"_blank\" rel=\"external\">浅谈补集转化思想在统计问题中的应用</a>），设$f[i]$为前$i$位的最多不变元素，那么$f[i]$能由$f[j]$转化而来当且仅当$a[i]-a[j]&gt;=i-j$,即修改两者之间的$i-j-1$个数使其严格递增，即两者之间只有1个元素不变，那么有<br>$$f[i]=max(f[i],f[j]+1)(a[i]-a[j]&gt;=i-j)$$<br>时间复杂度为$O(n^2)$,无法通过全部数据点，考虑进行优化，观察状态转移方程，易知可以通过减标号的方法转化成LIS问题，即可在$O(nlogn)$的时间内求解。</p>\n<p>对于第二问，为了简化问题，可以先设$w(i,j)$为将从$i$到$j$的所有元素进行修改的最小代价，设$g[i]$为前$i$位的最小答案。那么根据第一问有，<br>$$g[i]=min(g[i],g[j]+w(j+1,i))(f[i]=f[j]+1)$$</p>\n<p>对于$w$的求解，可以记录每一个需要修改的元素的下一个和上一个不需要修改元素的位置，模拟即可。</p>\n<hr>\n<h3 id=\"「Codefores286E」-Ladies’-Shop\"><a href=\"#「Codefores286E」-Ladies’-Shop\" class=\"headerlink\" title=\"「Codefores286E」 Ladies’ Shop\"></a>「Codefores286E」 Ladies’ Shop</h3><p>根据题目所给条件，</p>\n<p>可知要求的$p$个数一定在给定的$n$个数中。（1）</p>\n<p>那么可以根据多项式乘法系数相乘，指数相加的特点，构造生成函数，并求出这$n$个数可以组成的所有情况。已知某个$n$集合中数 $a$ 可以由 $b$ + $c$ + $d$ 生成，那么根据题目中所给条件，可知一定有 $e$ 由$c$ + $d$ 生成，那么可以将 $a$ 看作由 $b$ + $e$  生成。</p>\n<p>根据数学归纳法，易证条件一: </p>\n<p>$p$个数可以选出一些集合（相同的数可重复选），其和可以组成所有给定的$n$个数。</p>\n<p> 与以下结论等价：</p>\n<p>$p$个数可以选出任何两个元素（相同的数可重复选），其和可以组成所有给定的$n$个数。 （2）</p>\n<p>那么生成函数的构造就显而易见了。（将幂作为权值，系数作为出现的次数，并将该生成函数与自身相乘，可以通过FFT优化）</p>\n<p>对于第三个条件（满足$|p|$的阶最小），可以结合以贪心的策略。如果生成函数中某项系数大于1且在给定集合$|n|$中，则该元素一定可以由另外两个元素组成，那么就不将其加入集合$|p|$中，否则将其加入集合$|p|$中。</p>\n<p>至于无解的判断，易知其等价于：</p>\n<p>生成函数中某项系数不为零且该元素不在给定集合中。</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/25/2017年4月 题目总结/","excerpt":"","categories":[{"name":"总结","slug":"总结","permalink":"https://prostkhala.github.io/categories/总结/"}],"tags":[{"name":"高斯消元","slug":"高斯消元","permalink":"https://prostkhala.github.io/tags/高斯消元/"},{"name":"高精度算法","slug":"高精度算法","permalink":"https://prostkhala.github.io/tags/高精度算法/"},{"name":"网络流","slug":"网络流","permalink":"https://prostkhala.github.io/tags/网络流/"},{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"Polya定理&Burnside引理","slug":"Polya定理-Burnside引理","permalink":"https://prostkhala.github.io/tags/Polya定理-Burnside引理/"},{"name":"弦图与区间图","slug":"弦图与区间图","permalink":"https://prostkhala.github.io/tags/弦图与区间图/"},{"name":"计算几何","slug":"计算几何","permalink":"https://prostkhala.github.io/tags/计算几何/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://prostkhala.github.io/tags/AC自动机/"},{"name":"KMP","slug":"KMP","permalink":"https://prostkhala.github.io/tags/KMP/"},{"name":"SPLAY","slug":"SPLAY","permalink":"https://prostkhala.github.io/tags/SPLAY/"},{"name":"HASH","slug":"HASH","permalink":"https://prostkhala.github.io/tags/HASH/"},{"name":"purfer序列","slug":"purfer序列","permalink":"https://prostkhala.github.io/tags/purfer序列/"},{"name":"BITSET","slug":"BITSET","permalink":"https://prostkhala.github.io/tags/BITSET/"},{"name":"莫队算法","slug":"莫队算法","permalink":"https://prostkhala.github.io/tags/莫队算法/"},{"name":"并查集","slug":"并查集","permalink":"https://prostkhala.github.io/tags/并查集/"},{"name":"分块","slug":"分块","permalink":"https://prostkhala.github.io/tags/分块/"}]},{"title":"弦图与区间图","date":"2017-04-21T02:33:21.000Z","path":"2017/04/21/弦图与区间图/","text":"论文 弦图与区间图-陈丹琦 定义团：图G的一个子图$G′=(V′,E′)$，$G′$为关于$V′$的完全图。 极大团：一个团是极大团当它不是其它团的子集。 最大团：点数最多的团。 弦：连接环中不相邻的两个点的边。 弦图：一个无向图称为弦图当且仅当图中任意长度大于3的环都至少有一个弦。 单纯点：设N(v)表示与点v相邻的点集。一个点称为单纯点当{v} + N(v)的诱导子图为一个团。 完美消除序列：这是一个序列${v_i}$，它满足$v_i$在${v_{1…n}}$的诱导子图中为单纯点。 弦图的判定：存在完美消除序列的图为弦图。 最小色数：用最少的颜色给点染色使相邻点颜色不同，$χ(G)$为其色数。 最大独立集：最大的一个点集使任意两个点不相邻，$α(G)$为其点数。 最小团覆盖：用最少个数的团覆盖所有的点，$κ(G)$为其团数。 求解完美消除序列：可通过最大势算法求解完美消除序列，维护每个点的势（初始化为零），每次将势最大的点从图中删除，并加入到完美消除序列中，然后将所有与其相连的点的势加一，直到图为空为止。时间复杂度为$O(n^2+m)$,可以用桶优化到$O(n+m)$（并不会）(但是可以用堆优化)。 最小色数的求解：简单的贪心策略，遍历完美消除队列，将当前点染为可行的最小编号颜色，最大的编号即为答案。 最大独立集的求解：仍然是贪心，遍历完美消除队列，如果当前点的所有相邻的点不在独立集中，则将该点加入独立集。 最小团覆盖的求解：最小团覆盖数=最大独立集数（以上一切都不会证） HNOI2008 神奇的国度BZOJ1006 COGS1830 题目描述K国是一个热衷三角形的国度,连人的交往也只喜欢三角原则.他们认为三角关系:即AB相互认识,BC相互认识,CA相互认识,是简洁高效的.为了巩固三角关系,K国禁止四边关系,五边关系等等的存在.所谓N边关系,是指N个人 A1A2…An之间仅存在N对认识关系:(A1A2)(A2A3)…(AnA1),而没有其它认识关系.比如四边关系指ABCD四个人 AB,BC,CD,DA相互认识,而AC,BD不认识.全民比赛时,为了防止做弊，规定任意一对相互认识的人不得在一队，国王相知道，最少可以分多少支队。 输入输出格式输入格式：第一行两个整数N，M。表示有N个人，M对认识关系. 接下来M行每行输入一对朋友关系 。 输出格式：输出一个整数，最少可以分多少队 。 输入输出样例输入样例：4 5 1 2 1 4 2 4 2 3 3 4 输出样例：3 (1,3)(2)(4)为一种可行方案 数据范围$1&lt;=N&lt;=10000,1&lt;=M&lt;=1000000$ 题解根据题目所给条件可知，任何点数大于三的环都存在弦，可知该图为弦图，直接求解最小染色数即可。（该题数据范围较小，不需要桶优化） CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; const int N =1e5+1; const int inf = 0x7fffffff; struct nd{int ne,to;}e[20*N]; int head[N],cnt,tot,vis[N],p[N],q[N],n,m,ans,c[N]; bool use[N]; void in(int x,int y) { e[++cnt].ne=head[x]; e[cnt].to=y; head[x]=cnt; return; } int main() { // freopen(&quot;bzoj_1006.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1006.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x,y;i&lt;=m;++i)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x); int x=1; while(tot!=n) { for(int i=1;i&lt;=n;++i)if(p[i]&gt;p[x]&amp;&amp;!vis[i])x=i; vis[x]=1;q[++tot]=x; for(int i=head[x];i;i=e[i].ne)p[e[i].to]++; x=inf; } for(int t=1;t&lt;=n;++t) { int x=q[t]; for(int i=1;i&lt;=ans;++i)use[i]=0; for(int i=head[x];i;i=e[i].ne)use[c[e[i].to]]=true; int now=1; while(use[now])now++; c[x]=now; if(now&gt;ans)ans=now; } printf(&quot;%d&quot;,ans); }","raw":"title: 弦图与区间图\ndate: 2017-04-21 10:33:21\ncategories:\n  - 图论\n  - 弦图与区间图\ntags:\n  - 图论\n  - 弦图与区间图\n---\n\n# 论文\n [弦图与区间图-陈丹琦](https://wenku.baidu.com/view/6f9f2223dd36a32d73758126.html)\n\n---\n\n# 定义\n#### 团：\n图G的一个子图$G′=(V′,E′)$，$G′$为关于$V′$的完全图。\n\n#### 极大团：\n一个团是极大团当它不是其它团的子集。\n\n#### 最大团：\n点数最多的团。\n\n#### 弦：\n连接环中不相邻的两个点的边。\n\n#### 弦图：\n一个无向图称为弦图当且仅当图中任意长度大于3的环都至少有一个弦。\n\n#### 单纯点：\n设N(v)表示与点v相邻的点集。一个点称为单纯点当{v} + N(v)的诱导子图为一个团。\n\n#### 完美消除序列：\n这是一个序列${v_i}$，它满足$v_i$在${v_{1...n}}$的诱导子图中为单纯点。\n\n#### 弦图的判定：\n存在完美消除序列的图为弦图。\n\n#### 最小色数：\n用最少的颜色给点染色使相邻点颜色不同，$χ(G)$为其色数。\n\n#### 最大独立集：\n最大的一个点集使任意两个点不相邻，$α(G)$为其点数。\n\n#### 最小团覆盖：\n用最少个数的团覆盖所有的点，$κ(G)$为其团数。\n\n---\n\n# 求解\n\n#### 完美消除序列：\n可通过最大势算法求解完美消除序列，维护每个点的势（初始化为零），每次将势最大的点从图中删除，并加入到完美消除序列中，然后将所有与其相连的点的势加一，直到图为空为止。时间复杂度为$O(n^2+m)$,可以用桶优化到$O(n+m)$（并不会）(但是可以用堆优化)。\n\n#### 最小色数的求解：\n简单的贪心策略，遍历完美消除队列，将当前点染为可行的最小编号颜色，最大的编号即为答案。\n\n#### 最大独立集的求解：\n仍然是贪心，遍历完美消除队列，如果当前点的所有相邻的点不在独立集中，则将该点加入独立集。\n\n#### 最小团覆盖的求解：\n##### 最小团覆盖数=最大独立集数\n\n（以上一切都不会证）\n\n---\n# HNOI2008 神奇的国度\n## [BZOJ1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006) [COGS1830](http://cogs.pro/cogs/problem/problem.php?pid=1830)\n\n---\n## 题目描述\n\nK国是一个热衷三角形的国度,连人的交往也只喜欢三角原则.他们认为三角关系:即AB相互认识,BC相互认识,CA相互认识,是简洁高效的.为了巩固三角关系,K国禁止四边关系,五边关系等等的存在.所谓N边关系,是指N个人 A1A2...An之间仅存在N对认识关系:(A1A2)(A2A3)...(AnA1),而没有其它认识关系.比如四边关系指ABCD四个人 AB,BC,CD,DA相互认识,而AC,BD不认识.全民比赛时,为了防止做弊，规定任意一对相互认识的人不得在一队，国王相知道，最少可以分多少支队。 \n\n### 输入输出格式\n#### 输入格式：\n第一行两个整数N，M。表示有N个人，M对认识关系. 接下来M行每行输入一对朋友关系 。\n\n#### 输出格式：\n输出一个整数，最少可以分多少队 。\n\n\n### 输入输出样例\n#### 输入样例：\n\n\t4 5\n    1 2\n    1 4\n    2 4\n    2 3\n    3 4\n\n#### 输出样例：\n    3\n    (1,3)(2)(4)为一种可行方案 \n\n### 数据范围\n$1<=N<=10000,1<=M<=1000000$\n\n---\n\n## 题解\n\n根据题目所给条件可知，任何点数大于三的环都存在弦，可知该图为弦图，直接求解最小染色数即可。（该题数据范围较小，不需要桶优化）\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    using namespace std;\n    const int N =1e5+1;\n    const int inf = 0x7fffffff;\n    struct nd{int ne,to;}e[20*N];\n    int head[N],cnt,tot,vis[N],p[N],q[N],n,m,ans,c[N];\n    bool use[N];\n    void in(int x,int y)\n    {\n        e[++cnt].ne=head[x];\n        e[cnt].to=y;\n        head[x]=cnt;\n        return;\n    }\n    int main()\n    {\n    //\tfreopen(\"bzoj_1006.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1006.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1,x,y;i<=m;++i)scanf(\"%d%d\",&x,&y),in(x,y),in(y,x);\n        int x=1;\n        while(tot!=n)\n        {\n            for(int i=1;i<=n;++i)if(p[i]>p[x]&&!vis[i])x=i;\n            vis[x]=1;q[++tot]=x;\n            for(int i=head[x];i;i=e[i].ne)p[e[i].to]++;\n            x=inf;\n        }\n        for(int t=1;t<=n;++t)\n        {\n            int x=q[t];\n            for(int i=1;i<=ans;++i)use[i]=0;\n            for(int i=head[x];i;i=e[i].ne)use[c[e[i].to]]=true;\n            int now=1;\n            while(use[now])now++;\n            c[x]=now;\n            if(now>ans)ans=now;\n        }\n        printf(\"%d\",ans);\n    }","content":"<h1 id=\"论文\"><a href=\"#论文\" class=\"headerlink\" title=\"论文\"></a>论文</h1><p> <a href=\"https://wenku.baidu.com/view/6f9f2223dd36a32d73758126.html\" target=\"_blank\" rel=\"external\">弦图与区间图-陈丹琦</a></p>\n<hr>\n<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><h4 id=\"团：\"><a href=\"#团：\" class=\"headerlink\" title=\"团：\"></a>团：</h4><p>图G的一个子图$G′=(V′,E′)$，$G′$为关于$V′$的完全图。</p>\n<h4 id=\"极大团：\"><a href=\"#极大团：\" class=\"headerlink\" title=\"极大团：\"></a>极大团：</h4><p>一个团是极大团当它不是其它团的子集。</p>\n<h4 id=\"最大团：\"><a href=\"#最大团：\" class=\"headerlink\" title=\"最大团：\"></a>最大团：</h4><p>点数最多的团。</p>\n<h4 id=\"弦：\"><a href=\"#弦：\" class=\"headerlink\" title=\"弦：\"></a>弦：</h4><p>连接环中不相邻的两个点的边。</p>\n<h4 id=\"弦图：\"><a href=\"#弦图：\" class=\"headerlink\" title=\"弦图：\"></a>弦图：</h4><p>一个无向图称为弦图当且仅当图中任意长度大于3的环都至少有一个弦。</p>\n<h4 id=\"单纯点：\"><a href=\"#单纯点：\" class=\"headerlink\" title=\"单纯点：\"></a>单纯点：</h4><p>设N(v)表示与点v相邻的点集。一个点称为单纯点当{v} + N(v)的诱导子图为一个团。</p>\n<h4 id=\"完美消除序列：\"><a href=\"#完美消除序列：\" class=\"headerlink\" title=\"完美消除序列：\"></a>完美消除序列：</h4><p>这是一个序列${v_i}$，它满足$v_i$在${v_{1…n}}$的诱导子图中为单纯点。</p>\n<h4 id=\"弦图的判定：\"><a href=\"#弦图的判定：\" class=\"headerlink\" title=\"弦图的判定：\"></a>弦图的判定：</h4><p>存在完美消除序列的图为弦图。</p>\n<h4 id=\"最小色数：\"><a href=\"#最小色数：\" class=\"headerlink\" title=\"最小色数：\"></a>最小色数：</h4><p>用最少的颜色给点染色使相邻点颜色不同，$χ(G)$为其色数。</p>\n<h4 id=\"最大独立集：\"><a href=\"#最大独立集：\" class=\"headerlink\" title=\"最大独立集：\"></a>最大独立集：</h4><p>最大的一个点集使任意两个点不相邻，$α(G)$为其点数。</p>\n<h4 id=\"最小团覆盖：\"><a href=\"#最小团覆盖：\" class=\"headerlink\" title=\"最小团覆盖：\"></a>最小团覆盖：</h4><p>用最少个数的团覆盖所有的点，$κ(G)$为其团数。</p>\n<hr>\n<h1 id=\"求解\"><a href=\"#求解\" class=\"headerlink\" title=\"求解\"></a>求解</h1><h4 id=\"完美消除序列：-1\"><a href=\"#完美消除序列：-1\" class=\"headerlink\" title=\"完美消除序列：\"></a>完美消除序列：</h4><p>可通过最大势算法求解完美消除序列，维护每个点的势（初始化为零），每次将势最大的点从图中删除，并加入到完美消除序列中，然后将所有与其相连的点的势加一，直到图为空为止。时间复杂度为$O(n^2+m)$,可以用桶优化到$O(n+m)$（并不会）(但是可以用堆优化)。</p>\n<h4 id=\"最小色数的求解：\"><a href=\"#最小色数的求解：\" class=\"headerlink\" title=\"最小色数的求解：\"></a>最小色数的求解：</h4><p>简单的贪心策略，遍历完美消除队列，将当前点染为可行的最小编号颜色，最大的编号即为答案。</p>\n<h4 id=\"最大独立集的求解：\"><a href=\"#最大独立集的求解：\" class=\"headerlink\" title=\"最大独立集的求解：\"></a>最大独立集的求解：</h4><p>仍然是贪心，遍历完美消除队列，如果当前点的所有相邻的点不在独立集中，则将该点加入独立集。</p>\n<h4 id=\"最小团覆盖的求解：\"><a href=\"#最小团覆盖的求解：\" class=\"headerlink\" title=\"最小团覆盖的求解：\"></a>最小团覆盖的求解：</h4><h5 id=\"最小团覆盖数-最大独立集数\"><a href=\"#最小团覆盖数-最大独立集数\" class=\"headerlink\" title=\"最小团覆盖数=最大独立集数\"></a>最小团覆盖数=最大独立集数</h5><p>（以上一切都不会证）</p>\n<hr>\n<h1 id=\"HNOI2008-神奇的国度\"><a href=\"#HNOI2008-神奇的国度\" class=\"headerlink\" title=\"HNOI2008 神奇的国度\"></a>HNOI2008 神奇的国度</h1><h2 id=\"BZOJ1006-COGS1830\"><a href=\"#BZOJ1006-COGS1830\" class=\"headerlink\" title=\"BZOJ1006 COGS1830\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1006\" target=\"_blank\" rel=\"external\">BZOJ1006</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1830\" target=\"_blank\" rel=\"external\">COGS1830</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>K国是一个热衷三角形的国度,连人的交往也只喜欢三角原则.他们认为三角关系:即AB相互认识,BC相互认识,CA相互认识,是简洁高效的.为了巩固三角关系,K国禁止四边关系,五边关系等等的存在.所谓N边关系,是指N个人 A1A2…An之间仅存在N对认识关系:(A1A2)(A2A3)…(AnA1),而没有其它认识关系.比如四边关系指ABCD四个人 AB,BC,CD,DA相互认识,而AC,BD不认识.全民比赛时,为了防止做弊，规定任意一对相互认识的人不得在一队，国王相知道，最少可以分多少支队。 </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行两个整数N，M。表示有N个人，M对认识关系. 接下来M行每行输入一对朋友关系 。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出一个整数，最少可以分多少队 。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>4 5\n1 2\n1 4\n2 4\n2 3\n3 4\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>3\n(1,3)(2)(4)为一种可行方案 \n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>$1&lt;=N&lt;=10000,1&lt;=M&lt;=1000000$</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>根据题目所给条件可知，任何点数大于三的环都存在弦，可知该图为弦图，直接求解最小染色数即可。（该题数据范围较小，不需要桶优化）</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nconst int N =1e5+1;\nconst int inf = 0x7fffffff;\nstruct nd{int ne,to;}e[20*N];\nint head[N],cnt,tot,vis[N],p[N],q[N],n,m,ans,c[N];\nbool use[N];\nvoid in(int x,int y)\n{\n    e[++cnt].ne=head[x];\n    e[cnt].to=y;\n    head[x]=cnt;\n    return;\n}\nint main()\n{\n//    freopen(&quot;bzoj_1006.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;bzoj_1006.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1,x,y;i&lt;=m;++i)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x);\n    int x=1;\n    while(tot!=n)\n    {\n        for(int i=1;i&lt;=n;++i)if(p[i]&gt;p[x]&amp;&amp;!vis[i])x=i;\n        vis[x]=1;q[++tot]=x;\n        for(int i=head[x];i;i=e[i].ne)p[e[i].to]++;\n        x=inf;\n    }\n    for(int t=1;t&lt;=n;++t)\n    {\n        int x=q[t];\n        for(int i=1;i&lt;=ans;++i)use[i]=0;\n        for(int i=head[x];i;i=e[i].ne)use[c[e[i].to]]=true;\n        int now=1;\n        while(use[now])now++;\n        c[x]=now;\n        if(now&gt;ans)ans=now;\n    }\n    printf(&quot;%d&quot;,ans);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/21/弦图与区间图/","excerpt":"","categories":[{"name":"图论","slug":"图论","permalink":"https://prostkhala.github.io/categories/图论/"},{"name":"弦图与区间图","slug":"图论/弦图与区间图","permalink":"https://prostkhala.github.io/categories/图论/弦图与区间图/"}],"tags":[{"name":"弦图与区间图","slug":"弦图与区间图","permalink":"https://prostkhala.github.io/tags/弦图与区间图/"},{"name":"图论","slug":"图论","permalink":"https://prostkhala.github.io/tags/图论/"}]},{"title":"组合数学总结","date":"2017-04-10T13:50:08.802Z","path":"2017/04/10/组合数学总结/","text":"组合数学总结 基本原理加法原理做一件事情，完成它有$N$类方式，第一类方式有$M_1$种方法，第二类方式有$M_2$种方法，……，第$N$类方式有$M_N$种方法，那么完成这件事情共有$M1+M2+……+M_N$种方法。 乘法原理做一件事，完成它需要分成$n$个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，……，做第n步有$m_n$种不同的方法。那么完成这件事共有$m_1×m_2×m_3×…×m_n$种不同的方法。 排列数从$n$个不同元素中任取$r（r≦n）$个元素排成一列（考虑元素先后出现次序）称此为一个排列，此种排列的总数即为排列数，即叫做从$n$个不同元素中取出r个元素的排列数，记为$A(n,r)$。 对于$A(n,r)$，第一个元素有$n$种取法，第二个元素有$n-1$种取法，……，第$r$个元素有$n-r+1$中取法，则根据乘法原理可得。 $A(n,r)=\\frac {n!} {(n-r)!}$ 组合数从$n$个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的组合数，记为$C(n，m)$。 根据定义，可知组合数与排列数的不同便是组合数对顺序没有要求。对组合数来说${1,2,3}$与${1,3,2}$是一种组合，但对排列数则不是。那么在组合数中重复计算的次数即为$r$的全排列，即$r!$， 则有 $C(n,r)=\\frac {A(n,r)} {r!}$， 即 $C(n,r)=\\frac {n!} {r!(n-r)!}$ 常见定理与组合论证1.$C(n,r)=C(n,n-r)$将其表示为一个长度为$n$的二进制串，则组合数为有$r$位为$1$的串的个数，易知其与有$n-r$位为$0$的串的个数等价。 2.$C(n,r)=C(n-1,r-1)+C(n-1,r)$将其表示为一个长度为$n$的二进制串，利用动态规划的思想，可设$C(n-1,r-1)$表示长度为$n-1$的串且在末尾新加入一个$1$的方案数，$C(n-1,r)$表示长度为$n-1$的串且在末尾新加入一个$0$，易证该递推式的正确性。（初始化为$C(i,i)=0$） 3.$2^n=\\sum_k C(n,k)$$2^n$为长度为$n$的二进制串的总方案数，根据加法原理，易知其等价于长度为$n$的二进制串且有$0,1,….n$个$1$的方案数和。 4.$(a+b)^n=\\sum_kC(n,k)a^kb^{b-k}$这个定理同样可以直接通过二项式定理求证。 5.$C(n+m,r)=\\sum_kC(n,k)*C(m,r-k)$左项可以表示为一个长度为$a+b$的二进制串，右项则可以表示为一个长度为$a$的二进制串拼上一个长度为$b$的二进制串，此处可以转化为定理$3$,再结合乘法原理即可得证。 6.$C(n,r)=\\frac n r(n-1,r-1)$结合定理一，可以通过简单的推导得到该定理。 7.$C(n,m)C(m,r)=C(n,r)C(n-r,m-r)$可以将左式表示为在$n$个学生中选出$m$个组长，再在$m$个组长中选出$r$班干部，则右式可以表示为在$n$个学生中选$r$个班干部，再在剩余的学生$n-r$中选出$m-r$个不是班干部的组长，易知两者等价。 可重复组合数从$n$个不同元素中，任取$m(m≤n)$个元素并成一组（可以重复选择），叫做从$n$个不同元素中取出$m$个元素的一个可重复组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的可重复组合数。 可重复组合即为$C(n+m-1,m)$。 对于此结论的证明可以逆向来看，$n$中选$m$个元素即为将$m$个球放在$n$个盒子内的方案数，每个盒子中允许放$0$到$m$个球。对于这$m$个球来说，即为$n-1$个断点将其分为了$n$部分。 不妨将断点用二进制串表示为0，球表示为1，那么在$3$个元素中选$5$个元素的一种方案即可表示为 $ 1-1-1-0-1-0-1 $ 易观察到可重复组合数等于在$n+m-1$个元素中选取$m$个$1$的方案数 即为 $C(n+m-1,m)$ 可重复组合数同样可以解决如下的问题： 已知 $x_1+x_2+x_3+……+x_n=m(x_i&gt;=0)$ 求方程的解数。 此处可以看出答案即为$C(n+m-1,m)$，论证方法同上，该问题同样有很多变式，如改变$x_i$的取值范围等，同样可以通过如上方式得解，此处不再赘述。 斯特林数斯特林数分为第一类斯特林数和第二类斯特林数，其中第一类斯特林数为将$n$个物体排成$m$个非空循环排列的方案数，记为$s(n,m)$，第二类斯特林数为将$n$个物体划分到$m$个集合的方案数，记为$S(n,m)$。 第一类斯特林数$s(n,m)$的递推公式： $s(n,m)=(n-1)*s(n-1,m)+s(n-1,m-1) (1&lt;=m&lt;=n-1)$ 边界条件： $s(n,0)=0 (n&gt;=1)$ $s(n,n)=1(n&gt;=0)$ 递推关系的说明： 考虑第$n$个物品，$n$可以单独构成一个非空循环排列，这样前$n-1$种物品构成$m-1$个非空循环排列，方法数为$s(n-1,m-1)$。 也可以前$n-1$种物品构成$m$个非空循环排列，而第$n$个物品插入第$i$个物品的左边，这有$(n-1)×s(n-1,m)$种方法。 第二类斯特林数S(n,m)的递推公式是： $S(n,m)=m×S(n-1,m)+S(n-1,m-1) (1&lt;=m&lt;=n-1)$ 边界条件： $s(n,0)=0 (n&gt;=1)$ $s(n,n)=1(n&gt;=0)$ 递推关系的说明： 考虑第$n$个物品，$n$可以单独构成一个非空集合，此时前$n-1$个物品构成$m-1$个非空的不可辨别的集合，方法数为$S(n-1,m-1)$； 也可以前$n-1$种物品构成$m$个非空的不可辨别的集合，第$n$个物品放入任意一个中，这样有$m×S(n-1,m)$种方法。 第一类斯特林数和第二类斯特林数有相同的初始条件，但递推关系不同，两者在计数问题中均有着广泛的运用。 卡特兰数一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列? 该答案的解即为卡特兰数。实际上，卡特兰数也同样可以表示为有n个节点的无标号树的个数，汉诺塔问题的解，括号表达式的方案数,凸多边形的三角划分数等等，在组合数学中有着广泛的应用。 令$h(0)=1$,$h(1)=1$，则卡特兰数数满足递推式： $h(n)= h(0)×h(n-1)+h(1)×h(n-2) + … + h(n-1)×h(0) (n&gt;=2)$ 亦或 $h(n)=h(n-1)×(4×n-2)/(n+1)$ 同样可以用组合数表示 $h(n)=\\frac {C(2n,n)} {n+1}$ 或者 $h(n)=C(2n,n)-C(2n,n-1)$ 证明可以将出栈入栈的操作集合，看作一个长度为$2n$的二进制串，$0$代表入栈操作，$1$代表出栈操作，则该字符串有两个限制：0和1的个数相同（即对应每个元素只能入栈出栈一次），对于所有前缀，0的个数要大于等于1的个数（对应栈为空时不能继续出栈）。 先求出只满足第一个限制的方案数，易知其为$C(2n,n)$。 再考虑第二个限制需要排除的方案，易知其前缀必有一处$1$的个数大于$0$的个数，可设此处有$k$个$0$，$k+1$个$1$，剩下的串中有$n-k$个$0$，$n-k-1$个$1$，将剩下的串按位取反，则得到的新串中共有$n-1$个$0$，$n+1$个$1$，这样的串共有$C(2n,n-1)$。 则有 $h(n)=C(2n,n)-C(2n,n-1)$ 以上的组合论证均涉及模型的转化，实际上，模型的建立在组合论证中具有重要的作用，模型需要满足尽可能简化问题，确保与原问题等价等条件，才能优美地求解。 容斥原理在计数时，为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。 易知 则通项公式表示为 错排公式错排是给定原顺序（一般为有序数列），求每个元素都不在原位置的排列方案数。递推式为： $D(n) = (n-1)[ D(n-2) + D(n-1)]$ 初始条件为： $D(1) = 0 $ $ D(2) = 1$ 题目总结：","raw":"title: 组合数学总结\ndate: 2017-m-d h:min:s\ncategories:\n  - 数论\ntags:\n  - 组合数学\n  - 逆元\n  - Polya定理&Burnside引理\n  - 群论\n  - 数论\n  - 容斥原理\n  - no yet\n---\n\n# 组合数学总结\n---\n## 基本原理\n### 加法原理\n做一件事情，完成它有$N$类方式，第一类方式有$M_1$种方法，第二类方式有$M_2$种方法，……，第$N$类方式有$M_N$种方法，那么完成这件事情共有$M1+M2+……+M_N$种方法。\n### 乘法原理\n做一件事，完成它需要分成$n$个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，……，做第n步有$m_n$种不同的方法。那么完成这件事共有$m_1×m_2×m_3×…×m_n$种不同的方法。\n\n---\n## 排列数\n从$n$个不同元素中任取$r（r≦n）$个元素排成一列（考虑元素先后出现次序）称此为一个排列，此种排列的总数即为排列数，即叫做从$n$个不同元素中取出r个元素的排列数，记为$A(n,r)$。\n\n对于$A(n,r)$，第一个元素有$n$种取法，第二个元素有$n-1$种取法，……，第$r$个元素有$n-r+1$中取法，则根据乘法原理可得。\n\n$A(n,r)=\\frac {n!} {(n-r)!}$\n\n---\n## 组合数\n从$n$个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的组合数，记为$C(n，m)$。\n\n根据定义，可知组合数与排列数的不同便是组合数对顺序没有要求。对组合数来说${1,2,3}$与${1,3,2}$是一种组合，但对排列数则不是。那么在组合数中重复计算的次数即为$r$的全排列，即$r!$，\n\n则有\n\n$C(n,r)=\\frac {A(n,r)} {r!}$，\n\n即\n\n$C(n,r)=\\frac {n!} {r!(n-r)!}$\n\n### 常见定理与组合论证\n\n#### 1.$C(n,r)=C(n,n-r)$\n将其表示为一个长度为$n$的二进制串，则组合数为有$r$位为$1$的串的个数，易知其与有$n-r$位为$0$的串的个数等价。\n#### 2.$C(n,r)=C(n-1,r-1)+C(n-1,r)$\n将其表示为一个长度为$n$的二进制串，利用动态规划的思想，可设$C(n-1,r-1)$表示长度为$n-1$的串且在末尾新加入一个$1$的方案数，$C(n-1,r)$表示长度为$n-1$的串且在末尾新加入一个$0$，易证该递推式的正确性。（初始化为$C(i,i)=0$）\n#### 3.$2^n=\\sum_k C(n,k)$\n$2^n$为长度为$n$的二进制串的总方案数，根据加法原理，易知其等价于长度为$n$的二进制串且有$0,1,....n$个$1$的方案数和。\n#### 4.$(a+b)^n=\\sum_kC(n,k)a^kb^{b-k}$\n这个定理同样可以直接通过二项式定理求证。\n\n#### 5.$C(n+m,r)=\\sum_kC(n,k)*C(m,r-k)$\n左项可以表示为一个长度为$a+b$的二进制串，右项则可以表示为一个长度为$a$的二进制串拼上一个长度为$b$的二进制串，此处可以转化为定理$3$,再结合乘法原理即可得证。\n#### 6.$C(n,r)=\\frac n r(n-1,r-1)$\n结合定理一，可以通过简单的推导得到该定理。\n#### 7.$C(n,m)C(m,r)=C(n,r)C(n-r,m-r)$\n可以将左式表示为在$n$个学生中选出$m$个组长，再在$m$个组长中选出$r$班干部，则右式可以表示为在$n$个学生中选$r$个班干部，再在剩余的学生$n-r$中选出$m-r$个不是班干部的组长，易知两者等价。\n\n---\n## 可重复组合数\n从$n$个不同元素中，任取$m(m≤n)$个元素并成一组（可以重复选择），叫做从$n$个不同元素中取出$m$个元素的一个可重复组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的可重复组合数。\n\n可重复组合即为$C(n+m-1,m)$。\n\n对于此结论的证明可以逆向来看，$n$中选$m$个元素即为将$m$个球放在$n$个盒子内的方案数，每个盒子中允许放$0$到$m$个球。对于这$m$个球来说，即为$n-1$个断点将其分为了$n$部分。\n\n不妨将断点用二进制串表示为0，球表示为1，那么在$3$个元素中选$5$个元素的一种方案即可表示为\n\n$ 1-1-1-0-1-0-1 $\n\n易观察到可重复组合数等于在$n+m-1$个元素中选取$m$个$1$的方案数\n\n即为\n\n$C(n+m-1,m)$\n\n可重复组合数同样可以解决如下的问题：\n\n已知\n\n$x_1+x_2+x_3+……+x_n=m(x_i>=0)$\n\n求方程的解数。\n\n此处可以看出答案即为$C(n+m-1,m)$，论证方法同上，该问题同样有很多变式，如改变$x_i$的取值范围等，同样可以通过如上方式得解，此处不再赘述。\n\n---\n## 斯特林数\n斯特林数分为第一类斯特林数和第二类斯特林数，其中第一类斯特林数为将$n$个物体排成$m$个非空循环排列的方案数，记为$s(n,m)$，第二类斯特林数为将$n$个物体划分到$m$个集合的方案数，记为$S(n,m)$。\n### 第一类斯特林数\n$s(n,m)$的递推公式：\n\n$s(n,m)=(n-1)*s(n-1,m)+s(n-1,m-1) (1<=m<=n-1)$\n\n边界条件：\n\n$s(n,0)=0 (n>=1)$ $s(n,n)=1(n>=0)$\n\n\n递推关系的说明：\n\n考虑第$n$个物品，$n$可以单独构成一个非空循环排列，这样前$n-1$种物品构成$m-1$个非空循环排列，方法数为$s(n-1,m-1)$。\n\n也可以前$n-1$种物品构成$m$个非空循环排列，而第$n$个物品插入第$i$个物品的左边，这有$(n-1)×s(n-1,m)$种方法。\n\n \n\n \n\n### 第二类斯特林数\n\nS(n,m)的递推公式是：\n\n$S(n,m)=m×S(n-1,m)+S(n-1,m-1) (1<=m<=n-1)$\n\n边界条件：\n\n$s(n,0)=0 (n>=1)$ $s(n,n)=1(n>=0)$\n\n递推关系的说明：\n\n考虑第$n$个物品，$n$可以单独构成一个非空集合，此时前$n-1$个物品构成$m-1$个非空的不可辨别的集合，方法数为$S(n-1,m-1)$；\n\n也可以前$n-1$种物品构成$m$个非空的不可辨别的集合，第$n$个物品放入任意一个中，这样有$m×S(n-1,m)$种方法。\n\n第一类斯特林数和第二类斯特林数有相同的初始条件，但递推关系不同，两者在计数问题中均有着广泛的运用。\n\n\n---\n## 卡特兰数\n一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?\n\n该答案的解即为卡特兰数。实际上，卡特兰数也同样可以表示为有n个节点的无标号树的个数，汉诺塔问题的解，括号表达式的方案数,凸多边形的三角划分数等等，在组合数学中有着广泛的应用。\n\n令$h(0)=1$,$h(1)=1$，则卡特兰数数满足递推式：\n\n$h(n)= h(0)×h(n-1)+h(1)×h(n-2) + ... + h(n-1)×h(0) (n>=2)$\n\n亦或\n\n$h(n)=h(n-1)×(4×n-2)/(n+1)$\n\n同样可以用组合数表示\n\n$h(n)=\\frac {C(2n,n)} {n+1}$\n\n或者\n\n$h(n)=C(2n,n)-C(2n,n-1)$\n\n证明可以将出栈入栈的操作集合，看作一个长度为$2n$的二进制串，$0$代表入栈操作，$1$代表出栈操作，则该字符串有两个限制：0和1的个数相同（即对应每个元素只能入栈出栈一次），对于所有前缀，0的个数要大于等于1的个数（对应栈为空时不能继续出栈）。\n\n先求出只满足第一个限制的方案数，易知其为$C(2n,n)$。\n\n再考虑第二个限制需要排除的方案，易知其前缀必有一处$1$的个数大于$0$的个数，可设此处有$k$个$0$，$k+1$个$1$，剩下的串中有$n-k$个$0$，$n-k-1$个$1$，将剩下的串按位取反，则得到的新串中共有$n-1$个$0$，$n+1$个$1$，这样的串共有$C(2n,n-1)$。\n\n则有\n\n$h(n)=C(2n,n)-C(2n,n-1)$\n\n以上的组合论证均涉及模型的转化，实际上，模型的建立在组合论证中具有重要的作用，模型需要满足尽可能简化问题，确保与原问题等价等条件，才能优美地求解。\n\n---\n## 容斥原理\n在计数时，为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。\n\n易知\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/05f67b2ce4414f2a1f96e4210a86d71028aa53b6)\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/0b8e7c1631ec013eed94feb5aa406a573caa3559)\n\n则通项公式表示为\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/a7589a99f7137c74fd85940231971082679f12c3)\n\n---\n## 错排公式\n错排是给定原顺序（一般为有序数列），求每个元素都不在原位置的排列方案数。\n递推式为：\n\n$D(n) = (n-1)[ D(n-2) + D(n-1)]$\n\n初始条件为：\n\n$D(1) = 0 $\n\n$ D(2) = 1$\n\n---\n题目总结：\n","content":"<h1 id=\"组合数学总结\"><a href=\"#组合数学总结\" class=\"headerlink\" title=\"组合数学总结\"></a>组合数学总结</h1><hr>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><h3 id=\"加法原理\"><a href=\"#加法原理\" class=\"headerlink\" title=\"加法原理\"></a>加法原理</h3><p>做一件事情，完成它有$N$类方式，第一类方式有$M_1$种方法，第二类方式有$M_2$种方法，……，第$N$类方式有$M_N$种方法，那么完成这件事情共有$M1+M2+……+M_N$种方法。</p>\n<h3 id=\"乘法原理\"><a href=\"#乘法原理\" class=\"headerlink\" title=\"乘法原理\"></a>乘法原理</h3><p>做一件事，完成它需要分成$n$个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，……，做第n步有$m_n$种不同的方法。那么完成这件事共有$m_1×m_2×m_3×…×m_n$种不同的方法。</p>\n<hr>\n<h2 id=\"排列数\"><a href=\"#排列数\" class=\"headerlink\" title=\"排列数\"></a>排列数</h2><p>从$n$个不同元素中任取$r（r≦n）$个元素排成一列（考虑元素先后出现次序）称此为一个排列，此种排列的总数即为排列数，即叫做从$n$个不同元素中取出r个元素的排列数，记为$A(n,r)$。</p>\n<p>对于$A(n,r)$，第一个元素有$n$种取法，第二个元素有$n-1$种取法，……，第$r$个元素有$n-r+1$中取法，则根据乘法原理可得。</p>\n<p>$A(n,r)=\\frac {n!} {(n-r)!}$</p>\n<hr>\n<h2 id=\"组合数\"><a href=\"#组合数\" class=\"headerlink\" title=\"组合数\"></a>组合数</h2><p>从$n$个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的组合数，记为$C(n，m)$。</p>\n<p>根据定义，可知组合数与排列数的不同便是组合数对顺序没有要求。对组合数来说${1,2,3}$与${1,3,2}$是一种组合，但对排列数则不是。那么在组合数中重复计算的次数即为$r$的全排列，即$r!$，</p>\n<p>则有</p>\n<p>$C(n,r)=\\frac {A(n,r)} {r!}$，</p>\n<p>即</p>\n<p>$C(n,r)=\\frac {n!} {r!(n-r)!}$</p>\n<h3 id=\"常见定理与组合论证\"><a href=\"#常见定理与组合论证\" class=\"headerlink\" title=\"常见定理与组合论证\"></a>常见定理与组合论证</h3><h4 id=\"1-C-n-r-C-n-n-r\"><a href=\"#1-C-n-r-C-n-n-r\" class=\"headerlink\" title=\"1.$C(n,r)=C(n,n-r)$\"></a>1.$C(n,r)=C(n,n-r)$</h4><p>将其表示为一个长度为$n$的二进制串，则组合数为有$r$位为$1$的串的个数，易知其与有$n-r$位为$0$的串的个数等价。</p>\n<h4 id=\"2-C-n-r-C-n-1-r-1-C-n-1-r\"><a href=\"#2-C-n-r-C-n-1-r-1-C-n-1-r\" class=\"headerlink\" title=\"2.$C(n,r)=C(n-1,r-1)+C(n-1,r)$\"></a>2.$C(n,r)=C(n-1,r-1)+C(n-1,r)$</h4><p>将其表示为一个长度为$n$的二进制串，利用动态规划的思想，可设$C(n-1,r-1)$表示长度为$n-1$的串且在末尾新加入一个$1$的方案数，$C(n-1,r)$表示长度为$n-1$的串且在末尾新加入一个$0$，易证该递推式的正确性。（初始化为$C(i,i)=0$）</p>\n<h4 id=\"3-2-n-sum-k-C-n-k\"><a href=\"#3-2-n-sum-k-C-n-k\" class=\"headerlink\" title=\"3.$2^n=\\sum_k C(n,k)$\"></a>3.$2^n=\\sum_k C(n,k)$</h4><p>$2^n$为长度为$n$的二进制串的总方案数，根据加法原理，易知其等价于长度为$n$的二进制串且有$0,1,….n$个$1$的方案数和。</p>\n<h4 id=\"4-a-b-n-sum-kC-n-k-a-kb-b-k\"><a href=\"#4-a-b-n-sum-kC-n-k-a-kb-b-k\" class=\"headerlink\" title=\"4.$(a+b)^n=\\sum_kC(n,k)a^kb^{b-k}$\"></a>4.$(a+b)^n=\\sum_kC(n,k)a^kb^{b-k}$</h4><p>这个定理同样可以直接通过二项式定理求证。</p>\n<h4 id=\"5-C-n-m-r-sum-kC-n-k-C-m-r-k\"><a href=\"#5-C-n-m-r-sum-kC-n-k-C-m-r-k\" class=\"headerlink\" title=\"5.$C(n+m,r)=\\sum_kC(n,k)*C(m,r-k)$\"></a>5.$C(n+m,r)=\\sum_kC(n,k)*C(m,r-k)$</h4><p>左项可以表示为一个长度为$a+b$的二进制串，右项则可以表示为一个长度为$a$的二进制串拼上一个长度为$b$的二进制串，此处可以转化为定理$3$,再结合乘法原理即可得证。</p>\n<h4 id=\"6-C-n-r-frac-n-r-n-1-r-1\"><a href=\"#6-C-n-r-frac-n-r-n-1-r-1\" class=\"headerlink\" title=\"6.$C(n,r)=\\frac n r(n-1,r-1)$\"></a>6.$C(n,r)=\\frac n r(n-1,r-1)$</h4><p>结合定理一，可以通过简单的推导得到该定理。</p>\n<h4 id=\"7-C-n-m-C-m-r-C-n-r-C-n-r-m-r\"><a href=\"#7-C-n-m-C-m-r-C-n-r-C-n-r-m-r\" class=\"headerlink\" title=\"7.$C(n,m)C(m,r)=C(n,r)C(n-r,m-r)$\"></a>7.$C(n,m)C(m,r)=C(n,r)C(n-r,m-r)$</h4><p>可以将左式表示为在$n$个学生中选出$m$个组长，再在$m$个组长中选出$r$班干部，则右式可以表示为在$n$个学生中选$r$个班干部，再在剩余的学生$n-r$中选出$m-r$个不是班干部的组长，易知两者等价。</p>\n<hr>\n<h2 id=\"可重复组合数\"><a href=\"#可重复组合数\" class=\"headerlink\" title=\"可重复组合数\"></a>可重复组合数</h2><p>从$n$个不同元素中，任取$m(m≤n)$个元素并成一组（可以重复选择），叫做从$n$个不同元素中取出$m$个元素的一个可重复组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做从$n$个不同元素中取出$m$个元素的可重复组合数。</p>\n<p>可重复组合即为$C(n+m-1,m)$。</p>\n<p>对于此结论的证明可以逆向来看，$n$中选$m$个元素即为将$m$个球放在$n$个盒子内的方案数，每个盒子中允许放$0$到$m$个球。对于这$m$个球来说，即为$n-1$个断点将其分为了$n$部分。</p>\n<p>不妨将断点用二进制串表示为0，球表示为1，那么在$3$个元素中选$5$个元素的一种方案即可表示为</p>\n<p>$ 1-1-1-0-1-0-1 $</p>\n<p>易观察到可重复组合数等于在$n+m-1$个元素中选取$m$个$1$的方案数</p>\n<p>即为</p>\n<p>$C(n+m-1,m)$</p>\n<p>可重复组合数同样可以解决如下的问题：</p>\n<p>已知</p>\n<p>$x_1+x_2+x_3+……+x_n=m(x_i&gt;=0)$</p>\n<p>求方程的解数。</p>\n<p>此处可以看出答案即为$C(n+m-1,m)$，论证方法同上，该问题同样有很多变式，如改变$x_i$的取值范围等，同样可以通过如上方式得解，此处不再赘述。</p>\n<hr>\n<h2 id=\"斯特林数\"><a href=\"#斯特林数\" class=\"headerlink\" title=\"斯特林数\"></a>斯特林数</h2><p>斯特林数分为第一类斯特林数和第二类斯特林数，其中第一类斯特林数为将$n$个物体排成$m$个非空循环排列的方案数，记为$s(n,m)$，第二类斯特林数为将$n$个物体划分到$m$个集合的方案数，记为$S(n,m)$。</p>\n<h3 id=\"第一类斯特林数\"><a href=\"#第一类斯特林数\" class=\"headerlink\" title=\"第一类斯特林数\"></a>第一类斯特林数</h3><p>$s(n,m)$的递推公式：</p>\n<p>$s(n,m)=(n-1)*s(n-1,m)+s(n-1,m-1) (1&lt;=m&lt;=n-1)$</p>\n<p>边界条件：</p>\n<p>$s(n,0)=0 (n&gt;=1)$ $s(n,n)=1(n&gt;=0)$</p>\n<p>递推关系的说明：</p>\n<p>考虑第$n$个物品，$n$可以单独构成一个非空循环排列，这样前$n-1$种物品构成$m-1$个非空循环排列，方法数为$s(n-1,m-1)$。</p>\n<p>也可以前$n-1$种物品构成$m$个非空循环排列，而第$n$个物品插入第$i$个物品的左边，这有$(n-1)×s(n-1,m)$种方法。</p>\n<h3 id=\"第二类斯特林数\"><a href=\"#第二类斯特林数\" class=\"headerlink\" title=\"第二类斯特林数\"></a>第二类斯特林数</h3><p>S(n,m)的递推公式是：</p>\n<p>$S(n,m)=m×S(n-1,m)+S(n-1,m-1) (1&lt;=m&lt;=n-1)$</p>\n<p>边界条件：</p>\n<p>$s(n,0)=0 (n&gt;=1)$ $s(n,n)=1(n&gt;=0)$</p>\n<p>递推关系的说明：</p>\n<p>考虑第$n$个物品，$n$可以单独构成一个非空集合，此时前$n-1$个物品构成$m-1$个非空的不可辨别的集合，方法数为$S(n-1,m-1)$；</p>\n<p>也可以前$n-1$种物品构成$m$个非空的不可辨别的集合，第$n$个物品放入任意一个中，这样有$m×S(n-1,m)$种方法。</p>\n<p>第一类斯特林数和第二类斯特林数有相同的初始条件，但递推关系不同，两者在计数问题中均有着广泛的运用。</p>\n<hr>\n<h2 id=\"卡特兰数\"><a href=\"#卡特兰数\" class=\"headerlink\" title=\"卡特兰数\"></a>卡特兰数</h2><p>一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?</p>\n<p>该答案的解即为卡特兰数。实际上，卡特兰数也同样可以表示为有n个节点的无标号树的个数，汉诺塔问题的解，括号表达式的方案数,凸多边形的三角划分数等等，在组合数学中有着广泛的应用。</p>\n<p>令$h(0)=1$,$h(1)=1$，则卡特兰数数满足递推式：</p>\n<p>$h(n)= h(0)×h(n-1)+h(1)×h(n-2) + … + h(n-1)×h(0) (n&gt;=2)$</p>\n<p>亦或</p>\n<p>$h(n)=h(n-1)×(4×n-2)/(n+1)$</p>\n<p>同样可以用组合数表示</p>\n<p>$h(n)=\\frac {C(2n,n)} {n+1}$</p>\n<p>或者</p>\n<p>$h(n)=C(2n,n)-C(2n,n-1)$</p>\n<p>证明可以将出栈入栈的操作集合，看作一个长度为$2n$的二进制串，$0$代表入栈操作，$1$代表出栈操作，则该字符串有两个限制：0和1的个数相同（即对应每个元素只能入栈出栈一次），对于所有前缀，0的个数要大于等于1的个数（对应栈为空时不能继续出栈）。</p>\n<p>先求出只满足第一个限制的方案数，易知其为$C(2n,n)$。</p>\n<p>再考虑第二个限制需要排除的方案，易知其前缀必有一处$1$的个数大于$0$的个数，可设此处有$k$个$0$，$k+1$个$1$，剩下的串中有$n-k$个$0$，$n-k-1$个$1$，将剩下的串按位取反，则得到的新串中共有$n-1$个$0$，$n+1$个$1$，这样的串共有$C(2n,n-1)$。</p>\n<p>则有</p>\n<p>$h(n)=C(2n,n)-C(2n,n-1)$</p>\n<p>以上的组合论证均涉及模型的转化，实际上，模型的建立在组合论证中具有重要的作用，模型需要满足尽可能简化问题，确保与原问题等价等条件，才能优美地求解。</p>\n<hr>\n<h2 id=\"容斥原理\"><a href=\"#容斥原理\" class=\"headerlink\" title=\"容斥原理\"></a>容斥原理</h2><p>在计数时，为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。</p>\n<p>易知</p>\n<p><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/05f67b2ce4414f2a1f96e4210a86d71028aa53b6\" alt=\"\"></p>\n<p><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/0b8e7c1631ec013eed94feb5aa406a573caa3559\" alt=\"\"></p>\n<p>则通项公式表示为</p>\n<p><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a7589a99f7137c74fd85940231971082679f12c3\" alt=\"\"></p>\n<hr>\n<h2 id=\"错排公式\"><a href=\"#错排公式\" class=\"headerlink\" title=\"错排公式\"></a>错排公式</h2><p>错排是给定原顺序（一般为有序数列），求每个元素都不在原位置的排列方案数。<br>递推式为：</p>\n<p>$D(n) = (n-1)[ D(n-2) + D(n-1)]$</p>\n<p>初始条件为：</p>\n<p>$D(1) = 0 $</p>\n<p>$ D(2) = 1$</p>\n<hr>\n<p>题目总结：</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/10/组合数学总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"Polya定理&Burnside引理","slug":"Polya定理-Burnside引理","permalink":"https://prostkhala.github.io/tags/Polya定理-Burnside引理/"},{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"},{"name":"逆元","slug":"逆元","permalink":"https://prostkhala.github.io/tags/逆元/"},{"name":"群论","slug":"群论","permalink":"https://prostkhala.github.io/tags/群论/"},{"name":"no yet","slug":"no-yet","permalink":"https://prostkhala.github.io/tags/no-yet/"},{"name":"容斥原理","slug":"容斥原理","permalink":"https://prostkhala.github.io/tags/容斥原理/"}]},{"title":"Transposing Is Even More Fun","date":"2017-04-09T10:58:42.000Z","path":"2017/04/09/Transposing is Even More Fun/","text":"Transposing is Even More FunCOGS1608 题目描述给你一个$2^a*2^b$的矩阵，在内存中的存放方式是先存第一行的，再存第二行的……每行也是从左到右存放。现在你想把它变成它的转置矩阵（也是一样的储存方式），但是只能用交换操作（即交换两个储存单元的内容），至少需要交换多少步？ 输入输出格式输入格式： 第1行数数据组数$c(1&lt;=c&lt;=400000)$. 接下来有c行，每行一组测试数据：两个整数$a,b(0&lt;=a+b&lt;=1000000)$。 输出格式：对每组数据输出一个整数，即转置矩阵需要的最少交换次数。因为这个次数可能很大，你只需要输出它模$1000003$的值（没错，这是个素数）。 输入输出样例输入样例：3 1 1 2 2 5 7 输出样例：1 6 3744 题解该题所求的是最小步数不是计数，但仍可以通过polya定理求解。将矩阵表示成在内存中的存储方式，并将转置考虑为一种置换。以$2^1 * 2^2$为例，则置换为 0 1 2 3 4 5 6 7 到 0 2 4 6 1 3 5 7 表示为 / 0 1 2 3 4 5 6 7 \\ \\ 0 2 4 6 1 3 5 7 / 亦或 （1）（1 2 4）（3 6 5）（7） 考虑在任意一个循环节中，需要交换的次数即为 （ 循环节的长度 - 1 ） 次，且已知所有循环节长度为矩阵中元素的总个数（即为$2^{a+b}$个），则有 $Ans=2^{a+b}-循环节个数$ 现在的问题就转换成了求解循环节的个数，已知$c(1&lt;=c&lt;=400000)$且$(0&lt;=a+b&lt;=1000000)$，则循环节的个数显然不能通过暴力求解。考虑这种置换对应矩阵中的转置，有一定的规律可循，不妨将元素转换为二进制进行观察。则置换为 000 - 000 001 - 010 010 - 100 011 - 110 100 - 001 101 - 011 110 - 101 111 - 111 不难发现该转置操作中所有元素的二进制数皆循环右移了$a$位（也可以说循环左移了b位），我们也可以稍微推算一下，对于矩阵元素$（i，j）$来说，转置使其变为了$（j，i）$，将其表示为队列，则从第 $(i-1)2^a+j$ 位转置为第 $(j-1)2^b+i$ 位，即对应二进制的循环右移。那么可以将问题转化为一个polya定理的经典问题，即项链染色问题。将二进制的表示看为一种染色方案，长度为a+b，颜色为 0,1 两种，循环右移左移即对应项链的旋转。 以a=2，b=4为例。 则项链为 a1 / \\ a6 a2 | | a5 a3 \\ / a4 但该题的置换群$G=${$不动，循环右移a位 $ } $ $，显然与原问题不同，那么不妨将项链压缩一下，根据前面的推理，可知循环右移$a$位与左移$b$位是一种操作，那么不妨将$gcd(a，b)$个点压为一个点。则例图转化为 a1,2 / \\ a5,6 -- a3,4 此时对于任意一个点有2^gcd(a,b)中染色方案。 则 $Ans=2^{a+b}-(\\sum_{d|n}k^{d}\\varphi(n/d))/n$ 原式中 $n=(a+b)/gcd(a,b),k=2^{gcd(a,b)}$ 由于原式需要取模，则需要求n的逆元，已知$a+b&lt;=1e6$,模数为$1e6+3$（为质数），易知两者互质，则可通过费马小定理求逆。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; const int N = 1e6+1; const int mod = 1000003; typedef long long ll; int a,b; bool vis[N]; int p[N],phi[N],tot,pow2[N]; int gcd(int a,int b){return b?gcd(b,a%b):a;} void get(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } void put(int x) { int num = 0; char c[15]; while(x) c[++num] = (x%10)+48, x /= 10; while(num) putchar(c[num--]); putchar(&#39;\\n&#39;); } int qpow(int a,int b) { int ans=1; while(b) { if(b&amp;1)ans=((ll)ans*a)%mod; b&gt;&gt;=1; a=((ll)a*a)%mod; } return ans; } int getprime() { phi[1]=1; for(int i=2;i&lt;=N-1;++i) { if(!vis[i])p[++tot]=i,phi[i]=(i-1)%mod; for(int t=1;t&lt;=tot&amp;&amp;i*p[t]&lt;=N-1;++t) { vis[i*p[t]]=1; if(i%p[t]==0){phi[i*p[t]]=((ll)phi[i]*p[t])%mod;break;} phi[i*p[t]]=((ll)phi[i]*(p[t]-1))%mod; } } pow2[0]=1; for(int i=1;i&lt;=N-1;++i)pow2[i]=(pow2[i-1]&lt;&lt;1)%mod; } int main() { // freopen(&quot;transp2.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;transp2.out&quot;,&quot;w&quot;,stdout); int T; getprime(); scanf(&quot;%d&quot;,&amp;T); while(T--) { get(a);get(b); int lin=0; int gcdab=gcd(a,b); int n=(a+b)/gcdab; int inv; inv=qpow(n,mod-2); for(int d=1;d&lt;=n;++d) { if(n%d==0) { (lin+=(pow2[gcdab*d]*phi[n/d]))%=mod; } } put(((ll)pow2[a+b]-lin*inv%mod+mod)%mod); } }","raw":"title: Transposing is Even More Fun\ndate: 2017-04-09 18:58:42\ncategories:\n  - 群论\ntags:\n  - 组合数学\n  - 扩展欧几里得\n  - 数论\n  - 欧拉函数\n  - Polya定理&Burnside引理\n  - 费马小定理\n  - 逆元\n---\n\n# Transposing is Even More Fun\n\n## [COGS1608](http://cogs.pro/cogs/problem/problem.php?pid=1608)\n\n---\n## 题目描述\n给你一个$2^a*2^b$的矩阵，在内存中的存放方式是先存第一行的，再存第二行的……每行也是从左到右存放。现在你想把它变成它的转置矩阵（也是一样的储存方式），但是只能用交换操作（即交换两个储存单元的内容），至少需要交换多少步？ \n### 输入输出格式\n#### 输入格式：\n 第1行数数据组数$c(1<=c<=400000)$.\n\n接下来有c行，每行一组测试数据：两个整数$a,b(0<=a+b<=1000000)$。 \n\n#### 输出格式：\n对每组数据输出一个整数，即转置矩阵需要的最少交换次数。因为这个次数可能很大，你只需要输出它模$1000003$的值（没错，这是个素数）。 \n\n\n### 输入输出样例\n#### 输入样例：\n    3\n\n    1 1\n\n    2 2\n\n    5 7 \n\n#### 输出样例：\n   \n    1\n\n    6\n\n    3744\n---\n\n## 题解\n\n该题所求的是最小步数不是计数，但仍可以通过polya定理求解。将矩阵表示成在内存中的存储方式，并将转置考虑为一种置换。\n以$2^1 * 2^2$为例，则置换为\n\t\n    0  1  \n    2  3 \n    4  5\n\t6  7\n到\n\n\t0  2  4  6\n    1  3  5  7\n表示为\n\n\t/ 0 1 2 3 4 5 6 7 \\\n    \\ 0 2 4 6 1 3 5 7 /\n亦或\n\t\n    （1）（1 2 4）（3 6 5）（7）    \n考虑在任意一个循环节中，需要交换的次数即为 （ 循环节的长度 - 1 ） 次，且已知所有循环节长度为矩阵中元素的总个数（即为$2^{a+b}$个），则有\n\n$Ans=2^{a+b}-循环节个数$\n\n现在的问题就转换成了求解循环节的个数，已知$c(1<=c<=400000)$且$(0<=a+b<=1000000)$，则循环节的个数显然不能通过暴力求解。考虑这种置换对应矩阵中的转置，有一定的规律可循，不妨将元素转换为二进制进行观察。\n则置换为\n\t\n    000 - 000\n    001 - 010\n    010 - 100\n    011 - 110\n    100 - 001\n    101 - 011\n    110 - 101\n    111 - 111\n不难发现该转置操作中所有元素的二进制数皆循环右移了$a$位（也可以说循环左移了b位），我们也可以稍微推算一下，对于矩阵元素$（i，j）$来说，转置使其变为了$（j，i）$，将其表示为队列，则从第 $(i-1)*2^a+j$ 位转置为第 $(j-1)*2^b+i$ 位，即对应二进制的循环右移。那么可以将问题转化为一个polya定理的经典问题，即项链染色问题。将二进制的表示看为一种染色方案，长度为a+b，颜色为 0,1 两种，循环右移左移即对应项链的旋转。\n\n\t以a=2，b=4为例。\n    \n    则项链为\n    \n\t      a1\n         /  \\\n        a6   a2\n        |    |\n        a5   a3\n         \\  /\n          a4   \n\n但该题的置换群$G=${$不动，循环右移a位 $ } $ $，显然与原问题不同，那么不妨将项链压缩一下，根据前面的推理，可知循环右移$a$位与左移$b$位是一种操作，那么不妨将$gcd(a，b)$个点压为一个点。则例图转化为\n\n\t\t a1,2\n         /  \\\n     a5,6 -- a3,4\n     此时对于任意一个点有2^gcd(a,b)中染色方案。\n     \n     \n     \n![](http://i4.buimg.com/567571/dab5972c63da0312.png)\n\n\n\n则\n\n$Ans=2^{a+b}-(\\sum_{d|n}k^{d}\\varphi(n/d))/n$\n\n原式中\n\n$n=(a+b)/gcd(a,b),k=2^{gcd(a,b)}$\n\n由于原式需要取模，则需要求n的逆元，已知$a+b<=1e6$,模数为$1e6+3$（为质数），易知两者互质，则可通过费马小定理求逆。\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<algorithm>\n    #include<cmath>\n    using namespace std;\n    const int N = 1e6+1;\n    const int mod = 1000003;\n    typedef long long ll;\n    int a,b;\n    bool vis[N];\n    int p[N],phi[N],tot,pow2[N];\n    int gcd(int a,int b){return b?gcd(b,a%b):a;}\n    void get(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    void put(int x)\n    {  \n        int num = 0; char c[15];\n        while(x) c[++num] = (x%10)+48, x /= 10;\n        while(num) putchar(c[num--]);\n        putchar('\\n'); \n    }\n    int qpow(int a,int b)\n    {\n        int ans=1;\n        while(b)\n        {\n            if(b&1)ans=((ll)ans*a)%mod;\n            b>>=1;\n            a=((ll)a*a)%mod;\n        }\n        return ans;\n    }\n    int getprime()\n    {\n        phi[1]=1;\n        for(int i=2;i<=N-1;++i)\n        {\n            if(!vis[i])p[++tot]=i,phi[i]=(i-1)%mod;\n            for(int t=1;t<=tot&&i*p[t]<=N-1;++t)\n            {\n                vis[i*p[t]]=1;\n                if(i%p[t]==0){phi[i*p[t]]=((ll)phi[i]*p[t])%mod;break;}\n                phi[i*p[t]]=((ll)phi[i]*(p[t]-1))%mod;\n            }\n        }\n        pow2[0]=1;\n        for(int i=1;i<=N-1;++i)pow2[i]=(pow2[i-1]<<1)%mod;\n    }\n\n    int main()\n    {\n    //\tfreopen(\"transp2.in\",\"r\",stdin);\n    //\tfreopen(\"transp2.out\",\"w\",stdout);\n        int T;\n        getprime();\n        scanf(\"%d\",&T);\n        while(T--)\n        {\n            get(a);get(b);\n            int lin=0;\n            int gcdab=gcd(a,b);\n            int n=(a+b)/gcdab;\n            int inv;\n            inv=qpow(n,mod-2);\n            for(int d=1;d<=n;++d)\n            {\n                if(n%d==0)\n                {\n                    (lin+=(pow2[gcdab*d]*phi[n/d]))%=mod;\n                }\n            }\n            put(((ll)pow2[a+b]-lin*inv%mod+mod)%mod);\n        }\n    }","content":"<h1 id=\"Transposing-is-Even-More-Fun\"><a href=\"#Transposing-is-Even-More-Fun\" class=\"headerlink\" title=\"Transposing is Even More Fun\"></a>Transposing is Even More Fun</h1><h2 id=\"COGS1608\"><a href=\"#COGS1608\" class=\"headerlink\" title=\"COGS1608\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1608\" target=\"_blank\" rel=\"external\">COGS1608</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给你一个$2^a*2^b$的矩阵，在内存中的存放方式是先存第一行的，再存第二行的……每行也是从左到右存放。现在你想把它变成它的转置矩阵（也是一样的储存方式），但是只能用交换操作（即交换两个储存单元的内容），至少需要交换多少步？ </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p> 第1行数数据组数$c(1&lt;=c&lt;=400000)$.</p>\n<p>接下来有c行，每行一组测试数据：两个整数$a,b(0&lt;=a+b&lt;=1000000)$。 </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对每组数据输出一个整数，即转置矩阵需要的最少交换次数。因为这个次数可能很大，你只需要输出它模$1000003$的值（没错，这是个素数）。 </p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\n\n1 1\n\n2 2\n\n5 7 \n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>1\n\n6\n\n3744\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>该题所求的是最小步数不是计数，但仍可以通过polya定理求解。将矩阵表示成在内存中的存储方式，并将转置考虑为一种置换。<br>以$2^1 * 2^2$为例，则置换为</p>\n<pre><code>0  1  \n2  3 \n4  5\n6  7\n</code></pre><p>到</p>\n<pre><code>0  2  4  6\n1  3  5  7\n</code></pre><p>表示为</p>\n<pre><code>/ 0 1 2 3 4 5 6 7 \\\n\\ 0 2 4 6 1 3 5 7 /\n</code></pre><p>亦或</p>\n<pre><code>（1）（1 2 4）（3 6 5）（7）    \n</code></pre><p>考虑在任意一个循环节中，需要交换的次数即为 （ 循环节的长度 - 1 ） 次，且已知所有循环节长度为矩阵中元素的总个数（即为$2^{a+b}$个），则有</p>\n<p>$Ans=2^{a+b}-循环节个数$</p>\n<p>现在的问题就转换成了求解循环节的个数，已知$c(1&lt;=c&lt;=400000)$且$(0&lt;=a+b&lt;=1000000)$，则循环节的个数显然不能通过暴力求解。考虑这种置换对应矩阵中的转置，有一定的规律可循，不妨将元素转换为二进制进行观察。<br>则置换为</p>\n<pre><code>000 - 000\n001 - 010\n010 - 100\n011 - 110\n100 - 001\n101 - 011\n110 - 101\n111 - 111\n</code></pre><p>不难发现该转置操作中所有元素的二进制数皆循环右移了$a$位（也可以说循环左移了b位），我们也可以稍微推算一下，对于矩阵元素$（i，j）$来说，转置使其变为了$（j，i）$，将其表示为队列，则从第 $(i-1)<em>2^a+j$ 位转置为第 $(j-1)</em>2^b+i$ 位，即对应二进制的循环右移。那么可以将问题转化为一个polya定理的经典问题，即项链染色问题。将二进制的表示看为一种染色方案，长度为a+b，颜色为 0,1 两种，循环右移左移即对应项链的旋转。</p>\n<pre><code>以a=2，b=4为例。\n\n则项链为\n\n      a1\n     /  \\\n    a6   a2\n    |    |\n    a5   a3\n     \\  /\n      a4   \n</code></pre><p>但该题的置换群$G=${$不动，循环右移a位 $ } $ $，显然与原问题不同，那么不妨将项链压缩一下，根据前面的推理，可知循环右移$a$位与左移$b$位是一种操作，那么不妨将$gcd(a，b)$个点压为一个点。则例图转化为</p>\n<pre><code>     a1,2\n     /  \\\n a5,6 -- a3,4\n 此时对于任意一个点有2^gcd(a,b)中染色方案。\n</code></pre><p><img src=\"http://i4.buimg.com/567571/dab5972c63da0312.png\" alt=\"\"></p>\n<p>则</p>\n<p>$Ans=2^{a+b}-(\\sum_{d|n}k^{d}\\varphi(n/d))/n$</p>\n<p>原式中</p>\n<p>$n=(a+b)/gcd(a,b),k=2^{gcd(a,b)}$</p>\n<p>由于原式需要取模，则需要求n的逆元，已知$a+b&lt;=1e6$,模数为$1e6+3$（为质数），易知两者互质，则可通过费马小定理求逆。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nconst int N = 1e6+1;\nconst int mod = 1000003;\ntypedef long long ll;\nint a,b;\nbool vis[N];\nint p[N],phi[N],tot,pow2[N];\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nvoid get(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nvoid put(int x)\n{  \n    int num = 0; char c[15];\n    while(x) c[++num] = (x%10)+48, x /= 10;\n    while(num) putchar(c[num--]);\n    putchar(&#39;\\n&#39;); \n}\nint qpow(int a,int b)\n{\n    int ans=1;\n    while(b)\n    {\n        if(b&amp;1)ans=((ll)ans*a)%mod;\n        b&gt;&gt;=1;\n        a=((ll)a*a)%mod;\n    }\n    return ans;\n}\nint getprime()\n{\n    phi[1]=1;\n    for(int i=2;i&lt;=N-1;++i)\n    {\n        if(!vis[i])p[++tot]=i,phi[i]=(i-1)%mod;\n        for(int t=1;t&lt;=tot&amp;&amp;i*p[t]&lt;=N-1;++t)\n        {\n            vis[i*p[t]]=1;\n            if(i%p[t]==0){phi[i*p[t]]=((ll)phi[i]*p[t])%mod;break;}\n            phi[i*p[t]]=((ll)phi[i]*(p[t]-1))%mod;\n        }\n    }\n    pow2[0]=1;\n    for(int i=1;i&lt;=N-1;++i)pow2[i]=(pow2[i-1]&lt;&lt;1)%mod;\n}\n\nint main()\n{\n//    freopen(&quot;transp2.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;transp2.out&quot;,&quot;w&quot;,stdout);\n    int T;\n    getprime();\n    scanf(&quot;%d&quot;,&amp;T);\n    while(T--)\n    {\n        get(a);get(b);\n        int lin=0;\n        int gcdab=gcd(a,b);\n        int n=(a+b)/gcdab;\n        int inv;\n        inv=qpow(n,mod-2);\n        for(int d=1;d&lt;=n;++d)\n        {\n            if(n%d==0)\n            {\n                (lin+=(pow2[gcdab*d]*phi[n/d]))%=mod;\n            }\n        }\n        put(((ll)pow2[a+b]-lin*inv%mod+mod)%mod);\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/09/Transposing is Even More Fun/","excerpt":"","categories":[{"name":"群论","slug":"群论","permalink":"https://prostkhala.github.io/categories/群论/"}],"tags":[{"name":"Polya定理&Burnside引理","slug":"Polya定理-Burnside引理","permalink":"https://prostkhala.github.io/tags/Polya定理-Burnside引理/"},{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"},{"name":"逆元","slug":"逆元","permalink":"https://prostkhala.github.io/tags/逆元/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://prostkhala.github.io/tags/扩展欧几里得/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://prostkhala.github.io/tags/欧拉函数/"},{"name":"费马小定理","slug":"费马小定理","permalink":"https://prostkhala.github.io/tags/费马小定理/"}]},{"title":"JSOI2006 同构","date":"2017-04-08T03:02:12.000Z","path":"2017/04/08/同构/","text":"JSOI2006 同构COGS1609 SGU282 题目描述 我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。 给你$N$,$M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 输入输出格式输入格式：输入一行三个整数$N,M,P(1&lt;=N&lt;=53,1&lt;=M&lt;=1000,P$是素数且$P&lt;=10^6)$。 输出格式：输出一行一个正整数，即互不同构的染色图数量模P的值。 输入输出样例输入样例：sample 1: 1 1 2 sample 2: 3 2 97 sample 3: 3 4 97 输出样例：sample 1: 1 sample 2: 4 sample 3: 20 题解对于本题来说，存在的置换共有 $n!$ 种（即n个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对n进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$ 以内。 关于取模的问题，已知p是质数（p&gt;53???），易证两者互质，则可通过费马小定理求逆。 CODE#include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int N = 1e4+1; ll num[N],cnt[N],res,fac[N],n,m,p,ans; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} ll qpow(ll a,ll b) { ll ans=1; while(b) { if(b&amp;1)ans=(ans*a)%p; b&gt;&gt;=1;a=(a*a)%p; } return ans; } int dfs(ll now,ll maxl) { if(maxl==0) { ll a=1,b=0; for(int i=0;i&lt;res;i++) { a=a*qpow(num[i],cnt[i])%p*fac[cnt[i]]%p; b+=cnt[i]*(cnt[i]-1)/2*num[i]+num[i]/2*cnt[i]; for(ll j=i+1;j&lt;res;j++)b+=cnt[i]*cnt[j]*gcd(num[i],num[j]); } a=qpow(a,p-2)*fac[n]%p; ans=(ans+a*qpow(m,b)%p)%p; } if(now&gt;maxl)return 0; dfs(now+1,maxl); for(int i=1;i*now&lt;=maxl;i++) { num[res]=now,cnt[res++]=i; dfs(now+1,maxl-i*now); res--; } } int main() { // freopen(&quot;isomorphism.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;isomorphism.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;p); fac[0]=1;for(int i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%p; dfs(1,n); ans=ans*qpow(fac[n],p-2)%p; printf(&quot;%lld\\n&quot;,ans); }","raw":"title: JSOI2006 同构\ndate: 2017-04-08 11:02:12\ncategories:\n  - 群论\ntags:\n  - 群论\n  - 组合数学\n  - Polya定理&Burnside引理\n---\n\n# JSOI2006 同构\n\n## [COGS1609](http://cogs.pro/cogs/problem/problem.php?pid=1609)  [SGU282](http://acm.sgu.ru/problem.php?problem=282)\n\n---\n## 题目描述\n 我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。\n\n给你$N$,$M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 \n### 输入输出格式\n#### 输入格式：\n输入一行三个整数$N,M,P(1<=N<=53,1<=M<=1000,P$是素数且$P<=10^6)$。 \n\n#### 输出格式：\n\n输出一行一个正整数，即互不同构的染色图数量模P的值。 \n\n### 输入输出样例\n#### 输入样例：\n    sample 1:\n\n    1 1 2\n\n\n    sample 2:\n\n    3 2 97\n\n\n    sample 3:\n\n    3 4 97 \n\n#### 输出样例：\n    sample 1:\n\n    1\n\n\n    sample 2:\n\n    4\n\n\n    sample 3:\n\n    20 \n---\n\n## 题解\n对于本题来说，存在的置换共有 $n!$ 种（即n个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对n进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$ 以内。\n\n![](http://i4.buimg.com/567571/baa6be1cf522dc1d.png)\n\n关于取模的问题，已知p是质数（p>53???），易证两者互质，则可通过费马小定理求逆。\n\n\n---\n### CODE\n\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    typedef long long ll;\n    const int N = 1e4+1;\n    ll num[N],cnt[N],res,fac[N],n,m,p,ans;\n    ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} \n    ll qpow(ll a,ll b)\n    {\n        ll ans=1;\n        while(b)\n        {\n            if(b&1)ans=(ans*a)%p;\n            b>>=1;a=(a*a)%p;\n        }\n        return ans;\n    }\n    int dfs(ll now,ll maxl)\n    {\n        if(maxl==0)\n        {\n            ll a=1,b=0;\n            for(int i=0;i<res;i++)\n            {\n                a=a*qpow(num[i],cnt[i])%p*fac[cnt[i]]%p;\n                b+=cnt[i]*(cnt[i]-1)/2*num[i]+num[i]/2*cnt[i];\n                for(ll j=i+1;j<res;j++)b+=cnt[i]*cnt[j]*gcd(num[i],num[j]);\n            }\n            a=qpow(a,p-2)*fac[n]%p;\n            ans=(ans+a*qpow(m,b)%p)%p;\n        }\n        if(now>maxl)return 0;\n        dfs(now+1,maxl);\n        for(int i=1;i*now<=maxl;i++)\n        {\n            num[res]=now,cnt[res++]=i;\n            dfs(now+1,maxl-i*now);\n            res--;\n        }\n    }\n    int main()\n    {\t\n    //\tfreopen(\"isomorphism.in\",\"r\",stdin);\n    //\tfreopen(\"isomorphism.out\",\"w\",stdout);\n        scanf(\"%lld%lld%lld\",&n,&m,&p);\n        fac[0]=1;for(int i=1;i<N;i++)fac[i]=fac[i-1]*i%p;\n        dfs(1,n);\n        ans=ans*qpow(fac[n],p-2)%p;\n        printf(\"%lld\\n\",ans);\n    }","content":"<h1 id=\"JSOI2006-同构\"><a href=\"#JSOI2006-同构\" class=\"headerlink\" title=\"JSOI2006 同构\"></a>JSOI2006 同构</h1><h2 id=\"COGS1609-SGU282\"><a href=\"#COGS1609-SGU282\" class=\"headerlink\" title=\"COGS1609  SGU282\"></a><a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1609\" target=\"_blank\" rel=\"external\">COGS1609</a>  <a href=\"http://acm.sgu.ru/problem.php?problem=282\" target=\"_blank\" rel=\"external\">SGU282</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p> 我们把使得每对顶点都被恰好一条边连接，且被$M$种不同颜色之一染色的无向图叫做染色图。如果可以把某张染色图的顶点重新编号使得它和另一张染色图完全相同（即每条对应边的颜色都相同），我们就说这两张染色图是同构的。</p>\n<p>给你$N$,$M$和素数$P$。你需要找到有$N$个顶点的两两互不同构的染色图数量。输出这个数模$P$的值。 </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入一行三个整数$N,M,P(1&lt;=N&lt;=53,1&lt;=M&lt;=1000,P$是素数且$P&lt;=10^6)$。 </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出一行一个正整数，即互不同构的染色图数量模P的值。 </p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>sample 1:\n\n1 1 2\n\n\nsample 2:\n\n3 2 97\n\n\nsample 3:\n\n3 4 97 \n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>sample 1:\n\n1\n\n\nsample 2:\n\n4\n\n\nsample 3:\n\n20 \n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>对于本题来说，存在的置换共有 $n!$ 种（即n个数的全排列），无法直接枚举，不妨考虑每种置换表示成循环后共有几种本质不同的置换，实际上就是对n进行整数拆分的方案数，那么需要枚举的置换便由 $n!$ 降到了 $10^6$ 以内。</p>\n<p><img src=\"http://i4.buimg.com/567571/baa6be1cf522dc1d.png\" alt=\"\"></p>\n<p>关于取模的问题，已知p是质数（p&gt;53???），易证两者互质，则可通过费马小定理求逆。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e4+1;\nll num[N],cnt[N],res,fac[N],n,m,p,ans;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;} \nll qpow(ll a,ll b)\n{\n    ll ans=1;\n    while(b)\n    {\n        if(b&amp;1)ans=(ans*a)%p;\n        b&gt;&gt;=1;a=(a*a)%p;\n    }\n    return ans;\n}\nint dfs(ll now,ll maxl)\n{\n    if(maxl==0)\n    {\n        ll a=1,b=0;\n        for(int i=0;i&lt;res;i++)\n        {\n            a=a*qpow(num[i],cnt[i])%p*fac[cnt[i]]%p;\n            b+=cnt[i]*(cnt[i]-1)/2*num[i]+num[i]/2*cnt[i];\n            for(ll j=i+1;j&lt;res;j++)b+=cnt[i]*cnt[j]*gcd(num[i],num[j]);\n        }\n        a=qpow(a,p-2)*fac[n]%p;\n        ans=(ans+a*qpow(m,b)%p)%p;\n    }\n    if(now&gt;maxl)return 0;\n    dfs(now+1,maxl);\n    for(int i=1;i*now&lt;=maxl;i++)\n    {\n        num[res]=now,cnt[res++]=i;\n        dfs(now+1,maxl-i*now);\n        res--;\n    }\n}\nint main()\n{    \n//    freopen(&quot;isomorphism.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;isomorphism.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;p);\n    fac[0]=1;for(int i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%p;\n    dfs(1,n);\n    ans=ans*qpow(fac[n],p-2)%p;\n    printf(&quot;%lld\\n&quot;,ans);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/04/08/同构/","excerpt":"","categories":[{"name":"群论","slug":"群论","permalink":"https://prostkhala.github.io/categories/群论/"}],"tags":[{"name":"Polya定理&Burnside引理","slug":"Polya定理-Burnside引理","permalink":"https://prostkhala.github.io/tags/Polya定理-Burnside引理/"},{"name":"组合数学","slug":"组合数学","permalink":"https://prostkhala.github.io/tags/组合数学/"},{"name":"群论","slug":"群论","permalink":"https://prostkhala.github.io/tags/群论/"}]},{"title":"裴蜀定理总结","date":"2017-03-28T09:42:15.000Z","path":"2017/03/28/裴蜀定理总结/","text":"裴蜀定理已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b) | d$。特别的，一定存在整数$x,y$使得$ax+by=gcd(a,b)$成立。 例题（待补充）","raw":"title: 裴蜀定理总结\ndate: 2017-03-28 17:42:15\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 扩展欧几里得\n  - 裴蜀定理\n  - no yet\n---\n\n# 裴蜀定理\n\n已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b) | d$。特别的，一定存在整数$x,y$使得\n$ax+by=gcd(a,b)$成立。\n\n\n## 例题\n（待补充）","content":"<h1 id=\"裴蜀定理\"><a href=\"#裴蜀定理\" class=\"headerlink\" title=\"裴蜀定理\"></a>裴蜀定理</h1><p>已知$a,b,x,y,d$均为整数，则$ax+by=d$成立当且仅当$gcd(a,b) | d$。特别的，一定存在整数$x,y$使得<br>$ax+by=gcd(a,b)$成立。</p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p>（待补充）</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/28/裴蜀定理总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://prostkhala.github.io/tags/扩展欧几里得/"},{"name":"裴蜀定理","slug":"裴蜀定理","permalink":"https://prostkhala.github.io/tags/裴蜀定理/"},{"name":"no yet","slug":"no-yet","permalink":"https://prostkhala.github.io/tags/no-yet/"}]},{"title":"欧拉函数总结","date":"2017-03-28T02:33:17.000Z","path":"2017/03/28/欧拉函数总结/","text":"欧拉函数的定义 $\\varphi(n)$ 定义为1到n中与n互质的数的个数。 欧拉函数的求解1 . 通项公式 $ \\varphi(n)=n(1-1/p_1)(1-1/p_2)…(1-1/p_{tot}) $ (其中p为n的质因子，tot为质因子个数) int euler_phi(int n) { int m=(int)sqrt(n); int ans=n; for(int i=2;i&lt;=m;i++) { if(n%i==0) { ans=ans/i*(i-1);//ans*=(1-inv[i])？？； while(n%i==0) n/=i;//与分解质因数相结合 } } if(n&gt;1) ans=ans/n*(n-1); return ans; } 2 . 线性筛法逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前n项欧拉函数。 int prime[2*sqrt(N)+1],phi[N]; bool vis[N]; int tot; int getprime() { for(int i=2;i&lt;=N;++i) { if(!vis[i]) { prime[++tot]=i; phi[i]=i-1; } for(int t=1;t&lt;=tot&amp;&amp;prime[t]*i&lt;=N;++t) { vis[i*prime[t]]=true; if(i%prime[t]==0){phi[i*prime[t]]=phi[i]*prime[t];break;} phi[i*prime[t]]=phi[i]*(prime[t]-1); } } } 相关习题T1已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$ 证明设$T=lcm(1,2,…,p-1)$ 则有 $\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$ 此时只需证明 $T/1+T/2+…+T/(p-1)≡0(modp)$ 根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为 $1+2+…+(p-1)≡0(modp)$ $p*(p-1)≡0(modp)$ 得证。 T1 SDOI2008 沙拉公主的困惑题目描述大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。 输入输出格式输入格式第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n 输出格式共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值 输入输出样例输入样例1 11 4 2 输出样例1 数据范围对于100%的数据，1 &lt; = N , M &lt; = 10000000 题解题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$ 对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。 CODE#include&lt;cstdio&gt; #include&lt;iostream&gt; const int M = 1e6+1; using namespace std; bool vis[M+100]; long long prime[500500],ans[M+100],fac[M+100],rev[M+100]; int n,m,p,T,tot; int main() { scanf(&quot;%d%d&quot;,&amp;T,&amp;p); for(int i=2;i&lt;=M;i++) { if(!vis[i])prime[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++) { vis[prime[j]*i]=1; if(i%prime[j]==0) break; } } fac[1]=1; for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p; rev[1]=1; for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p; ans[1]=1; for(int i=2;i&lt;=M;i++) { if(!vis[i]) ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p; else ans[i]=ans[i-1]; } while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p); } }","raw":"title: 欧拉函数总结\ndate: 2017-03-28 10:33:17\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 线性筛法\n  - 欧拉函数\n---\n\n# 欧拉函数的定义\n $\\varphi(n)$ 定义为1到n中与n互质的数的个数。\n\n---\n# 欧拉函数的求解\n## 1 . 通项公式\n\n $ \\varphi(n)=n(1-1/p_1)(1-1/p_2)...(1-1/p_{tot}) $ (其中p为n的质因子，tot为质因子个数)\n\n    int euler_phi(int n)\n    {\n        int m=(int)sqrt(n);\n        int ans=n;\n        for(int i=2;i<=m;i++)\n        {\n            if(n%i==0)\n            {\n                ans=ans/i*(i-1);//ans*=(1-inv[i])？？；\n                while(n%i==0) n/=i;//与分解质因数相结合\n            }\n        }\n        if(n>1) ans=ans/n*(n-1);\n        return ans;\n    }\n## 2 . 线性筛法\n逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前n项欧拉函数。\n\n    int prime[2*sqrt(N)+1],phi[N];\n\n    bool vis[N];\n\n    int tot;\n    int getprime()\n    {\n        for(int i=2;i<=N;++i)\n        {\n            if(!vis[i])\n            {\n                prime[++tot]=i;\n                phi[i]=i-1;\n            }\n            for(int t=1;t<=tot&&prime[t]*i<=N;++t)\n            {\n                vis[i*prime[t]]=true;\n                if(i%prime[t]==0){phi[i*prime[t]]=phi[i]*prime[t];break;}\n                phi[i*prime[t]]=phi[i]*(prime[t]-1);\n            }\n        }\n    }\n---\n# 相关习题\n\n## T1\n已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$\n\n### 证明\n\n设$T=lcm(1,2,...,p-1)$\n\n则有\n\n$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+...+T/(p-1))/T$\n\n此时只需证明\n\n$T/1+T/2+...+T/(p-1)≡0(modp)$\n\n根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为\n\n$1+2+...+(p-1)≡0(modp)$\n\n$p*(p-1)≡0(modp)$\n\n得证。\n\n---\n## T1 SDOI2008 沙拉公主的困惑\n\n### 题目描述\n大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。\n### 输入输出格式\n#### 输入格式\n第一行为两个整数T，R。R<=10^9+10，T<=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m<=n\n#### 输出格式\n共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值\n### 输入输出样例\n#### 输入样例\n    1 11\n    4 2\n#### 输出样例\n\t1\n### 数据范围\n对于100%的数据，1 < = N , M < = 10000000\n\n---\n### 题解\n题意明确$n>=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$\n\n对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。\n\n---\n### CODE\n    #include<cstdio>\n    #include<iostream>\n    const int M = 1e6+1;\n    using namespace std;\n    bool vis[M+100];\n    long long prime[500500],ans[M+100],fac[M+100],rev[M+100];\n    int n,m,p,T,tot;\n    int main()\n    {\n        scanf(\"%d%d\",&T,&p);\n\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])prime[++tot]=i;\n            for(int j=1;j<=tot&&prime[j]*i<=M;j++)\n            {\n                vis[prime[j]*i]=1;\n                if(i%prime[j]==0)\n                    break;\n            }\n        }\n        fac[1]=1;\n        for(int i=2;i<=M;i++)fac[i]=fac[i-1]*i%p;\n        rev[1]=1;\n        for(int i=2;i<=M&&i<p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n        ans[1]=1;\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])\tans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n            else\t\t\t\tans[i]=ans[i-1];\n        }\n        while(T--)\n        {\n            scanf(\"%d%d\",&n,&m);\n            printf(\"%d\\n\",fac[n]*ans[m]%p);\n        }\n    }\n\n\n\n","content":"<h1 id=\"欧拉函数的定义\"><a href=\"#欧拉函数的定义\" class=\"headerlink\" title=\"欧拉函数的定义\"></a>欧拉函数的定义</h1><p> $\\varphi(n)$ 定义为1到n中与n互质的数的个数。</p>\n<hr>\n<h1 id=\"欧拉函数的求解\"><a href=\"#欧拉函数的求解\" class=\"headerlink\" title=\"欧拉函数的求解\"></a>欧拉函数的求解</h1><h2 id=\"1-通项公式\"><a href=\"#1-通项公式\" class=\"headerlink\" title=\"1 . 通项公式\"></a>1 . 通项公式</h2><p> $ \\varphi(n)=n(1-1/p_1)(1-1/p_2)…(1-1/p_{tot}) $ (其中p为n的质因子，tot为质因子个数)</p>\n<pre><code>int euler_phi(int n)\n{\n    int m=(int)sqrt(n);\n    int ans=n;\n    for(int i=2;i&lt;=m;i++)\n    {\n        if(n%i==0)\n        {\n            ans=ans/i*(i-1);//ans*=(1-inv[i])？？；\n            while(n%i==0) n/=i;//与分解质因数相结合\n        }\n    }\n    if(n&gt;1) ans=ans/n*(n-1);\n    return ans;\n}\n</code></pre><h2 id=\"2-线性筛法\"><a href=\"#2-线性筛法\" class=\"headerlink\" title=\"2 . 线性筛法\"></a>2 . 线性筛法</h2><p>逆元一般通过线性筛法求解，该方法的时间复杂度为$O(n)$，可以预处理出前n项欧拉函数。</p>\n<pre><code>int prime[2*sqrt(N)+1],phi[N];\n\nbool vis[N];\n\nint tot;\nint getprime()\n{\n    for(int i=2;i&lt;=N;++i)\n    {\n        if(!vis[i])\n        {\n            prime[++tot]=i;\n            phi[i]=i-1;\n        }\n        for(int t=1;t&lt;=tot&amp;&amp;prime[t]*i&lt;=N;++t)\n        {\n            vis[i*prime[t]]=true;\n            if(i%prime[t]==0){phi[i*prime[t]]=phi[i]*prime[t];break;}\n            phi[i*prime[t]]=phi[i]*(prime[t]-1);\n        }\n    }\n}\n</code></pre><hr>\n<h1 id=\"相关习题\"><a href=\"#相关习题\" class=\"headerlink\" title=\"相关习题\"></a>相关习题</h1><h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a>T1</h2><p>已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$</p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>设$T=lcm(1,2,…,p-1)$</p>\n<p>则有</p>\n<p>$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$</p>\n<p>此时只需证明</p>\n<p>$T/1+T/2+…+T/(p-1)≡0(modp)$</p>\n<p>根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为</p>\n<p>$1+2+…+(p-1)≡0(modp)$</p>\n<p>$p*(p-1)≡0(modp)$</p>\n<p>得证。</p>\n<hr>\n<h2 id=\"T1-SDOI2008-沙拉公主的困惑\"><a href=\"#T1-SDOI2008-沙拉公主的困惑\" class=\"headerlink\" title=\"T1 SDOI2008 沙拉公主的困惑\"></a>T1 SDOI2008 沙拉公主的困惑</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h4><pre><code>1 11\n4 2\n</code></pre><h4 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h4><pre><code>1\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于100%的数据，1 &lt; = N , M &lt; = 10000000</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$</p>\n<p>对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\nconst int M = 1e6+1;\nusing namespace std;\nbool vis[M+100];\nlong long prime[500500],ans[M+100],fac[M+100],rev[M+100];\nint n,m,p,T,tot;\nint main()\n{\n    scanf(&quot;%d%d&quot;,&amp;T,&amp;p);\n\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])prime[++tot]=i;\n        for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++)\n        {\n            vis[prime[j]*i]=1;\n            if(i%prime[j]==0)\n                break;\n        }\n    }\n    fac[1]=1;\n    for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p;\n    rev[1]=1;\n    for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n    ans[1]=1;\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])    ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n        else                ans[i]=ans[i-1];\n    }\n    while(T--)\n    {\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p);\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/28/欧拉函数总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"线性筛法","slug":"线性筛法","permalink":"https://prostkhala.github.io/tags/线性筛法/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://prostkhala.github.io/tags/欧拉函数/"}]},{"title":"乘法逆元总结","date":"2017-03-28T02:33:17.000Z","path":"2017/03/28/乘法逆元总结/","text":"乘法逆元的定义若$ax≡1 (mod p)$, 则称a关于模p的乘法逆元为x。也可表示为$ax≡1(mod p)$。 当a与p互质时，a关于模p的乘法逆元有解。如果不互质，则无解。如果p为质数，则从1到p-1的任意数都与p互质，即在1到p-1之间都恰好有一个关于模p的乘法逆元。且1到p-1中的所有数的逆元对应1到p-1中的所有数，既是单射也是满射。 逆元的求解1 . 扩展欧几里得算法逆元一般通过EXGCD求解，该方法的时间复杂度为$O(logn)$。 int x, y;//NOIP 同余方程 int extgcd(int a, int b, int &amp;x, int &amp;y) { if (b == 0) { x = 1; y = 0; return a; } int gcd = exgcd(b, a % b, x, y); int tmp = x; x = y; y = tmp - (a/b) * y; return gcd; } //inv[n]=(x%p+x)%p; 2 . 费马小定理当$n$为质数时，同样可以通过费马小定理求解。已知$n^{p-1}≡ 1(mod p)$(费马小定理) 那么$inv[n]=n^{p-2} (mod p)$。该方法的时间复杂度为$O(logn)$（快速幂）。 3 . 线性求前$n$项的逆元 4 . 利用阶乘递推求前$n$项的逆元该方法较简单易懂，理论复杂度是方法3的3倍。据说在某些奇怪的时刻会跑的比上面快。(因为数组的连续访问) //fac为阶乘，rev为阶乘的逆元。 fac[0]=fac[1]=1; for(int i=2;i&lt;=N;i++)fac[i]=fac[i-1]*i%mod; rev[N]=mod_pow(fac[N],mod-2);//mod_pow为带取模的快速幂 for(int i=N-1;i&gt;=0;i--)rev[i]=rev[i+1]*(i+1)%mod; 相关习题T1已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$ 证明设$T=lcm(1,2,…,p-1)$ 则有 $\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$ 此时只需证明 $T/1+T/2+…+T/(p-1)≡0(modp)$ 根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为 $1+2+…+(p-1)≡0(modp)$ $p*(p-1)≡0(modp)$ 得证。 T2 SDOI2008 沙拉公主的困惑题目描述大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。 输入输出格式输入格式第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n 输出格式共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值 输入输出样例输入样例1 11 4 2 输出样例1 数据范围对于100%的数据，1 &lt; = N , M &lt; = 10000000 题解题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$ 对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。 CODE#include&lt;cstdio&gt; #include&lt;iostream&gt; const int M = 1e6+1; using namespace std; bool vis[M+100]; long long prime[500500],ans[M+100],fac[M+100],rev[M+100]; int n,m,p,T,tot; int main() { scanf(&quot;%d%d&quot;,&amp;T,&amp;p); for(int i=2;i&lt;=M;i++) { if(!vis[i])prime[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++) { vis[prime[j]*i]=1; if(i%prime[j]==0) break; } } fac[1]=1; for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p; rev[1]=1; for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p; ans[1]=1; for(int i=2;i&lt;=M;i++) { if(!vis[i]) ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p; else ans[i]=ans[i-1]; } while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p); } }","raw":"title: 乘法逆元总结\ndate: 2017-03-28 10:33:17\ncategories:\n  - 数论\ntags:\n  - 数论\n  - 逆元\n  - 线性筛法\n  - 扩展欧几里得\n  - 欧拉函数\n  - 费马小定理\n---\n\n# 乘法逆元的定义\n若$ax≡1 (mod p)$, 则称a关于模p的乘法逆元为x。也可表示为$ax≡1(mod p)$。\n\n当a与p互质时，a关于模p的乘法逆元有解。如果不互质，则无解。如果p为质数，则从1到p-1的任意数都与p互质，即在1到p-1之间都恰好有一个关于模p的乘法逆元。且1到p-1中的所有数的逆元对应1到p-1中的所有数，既是单射也是满射。\n\n---\n# 逆元的求解\n## 1 . 扩展欧几里得算法\n逆元一般通过EXGCD求解，该方法的时间复杂度为$O(logn)$。\n\n    int x, y;//NOIP 同余方程    \n    int extgcd(int a, int b, int &x, int &y)    \n    {    \n        if (b == 0)\n        {    \n            x = 1;    \n            y = 0;    \n            return a;    \n        }    \n        int gcd = exgcd(b, a % b, x, y);    \n        int tmp = x;    \n        x = y;    \n        y = tmp - (a/b) * y;    \n        return gcd;    \n    }    //inv[n]=(x%p+x)%p;\n ---\n## 2 . 费马小定理\n当$n$为质数时，同样可以通过费马小定理求解。\n已知$n^{p-1}≡ 1(mod p)$(费马小定理)\n 那么$inv[n]=n^{p-2} (mod p)$。该方法的时间复杂度为$O(logn)$（快速幂）。\n \n ---\n ## 3 . 线性求前$n$项的逆元\n![](http://i2.muimg.com/567571/a0936082ab04d10e.png)\n\n---\n## 4 . 利用阶乘递推求前$n$项的逆元\n该方法较简单易懂，理论复杂度是方法3的3倍。据说在某些奇怪的时刻会跑的比上面快。(因为数组的连续访问)\n\n\t//fac为阶乘，rev为阶乘的逆元。\n    fac[0]=fac[1]=1;\n\n    for(int i=2;i<=N;i++)fac[i]=fac[i-1]*i%mod;\n\n    rev[N]=mod_pow(fac[N],mod-2);//mod_pow为带取模的快速幂\n\n    for(int i=N-1;i>=0;i--)rev[i]=rev[i+1]*(i+1)%mod;\n\n---\n# 相关习题\n\n## T1\n已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$\n\n### 证明\n\n设$T=lcm(1,2,...,p-1)$\n\n则有\n\n$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+...+T/(p-1))/T$\n\n此时只需证明\n\n$T/1+T/2+...+T/(p-1)≡0(modp)$\n\n根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为\n\n$1+2+...+(p-1)≡0(modp)$\n\n$p*(p-1)≡0(modp)$\n\n得证。\n\n---\n## T2 SDOI2008 沙拉公主的困惑\n\n### 题目描述\n大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。\n### 输入输出格式\n#### 输入格式\n第一行为两个整数T，R。R<=10^9+10，T<=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m<=n\n#### 输出格式\n共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值\n### 输入输出样例\n#### 输入样例\n    1 11\n    4 2\n#### 输出样例\n\t1\n### 数据范围\n对于100%的数据，1 < = N , M < = 10000000\n\n---\n### 题解\n题意明确$n>=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$\n\n对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。\n\n---\n### CODE\n    #include<cstdio>\n    #include<iostream>\n    const int M = 1e6+1;\n    using namespace std;\n    bool vis[M+100];\n    long long prime[500500],ans[M+100],fac[M+100],rev[M+100];\n    int n,m,p,T,tot;\n    int main()\n    {\n        scanf(\"%d%d\",&T,&p);\n\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])prime[++tot]=i;\n            for(int j=1;j<=tot&&prime[j]*i<=M;j++)\n            {\n                vis[prime[j]*i]=1;\n                if(i%prime[j]==0)\n                    break;\n            }\n        }\n        fac[1]=1;\n        for(int i=2;i<=M;i++)fac[i]=fac[i-1]*i%p;\n        rev[1]=1;\n        for(int i=2;i<=M&&i<p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n        ans[1]=1;\n        for(int i=2;i<=M;i++)\n        {\n            if(!vis[i])\tans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n            else\t\t\t\tans[i]=ans[i-1];\n        }\n        while(T--)\n        {\n            scanf(\"%d%d\",&n,&m);\n            printf(\"%d\\n\",fac[n]*ans[m]%p);\n        }\n    }\n","content":"<h1 id=\"乘法逆元的定义\"><a href=\"#乘法逆元的定义\" class=\"headerlink\" title=\"乘法逆元的定义\"></a>乘法逆元的定义</h1><p>若$ax≡1 (mod p)$, 则称a关于模p的乘法逆元为x。也可表示为$ax≡1(mod p)$。</p>\n<p>当a与p互质时，a关于模p的乘法逆元有解。如果不互质，则无解。如果p为质数，则从1到p-1的任意数都与p互质，即在1到p-1之间都恰好有一个关于模p的乘法逆元。且1到p-1中的所有数的逆元对应1到p-1中的所有数，既是单射也是满射。</p>\n<hr>\n<h1 id=\"逆元的求解\"><a href=\"#逆元的求解\" class=\"headerlink\" title=\"逆元的求解\"></a>逆元的求解</h1><h2 id=\"1-扩展欧几里得算法\"><a href=\"#1-扩展欧几里得算法\" class=\"headerlink\" title=\"1 . 扩展欧几里得算法\"></a>1 . 扩展欧几里得算法</h2><p>逆元一般通过EXGCD求解，该方法的时间复杂度为$O(logn)$。</p>\n<pre><code>int x, y;//NOIP 同余方程    \nint extgcd(int a, int b, int &amp;x, int &amp;y)    \n{    \n    if (b == 0)\n    {    \n        x = 1;    \n        y = 0;    \n        return a;    \n    }    \n    int gcd = exgcd(b, a % b, x, y);    \n    int tmp = x;    \n    x = y;    \n    y = tmp - (a/b) * y;    \n    return gcd;    \n}    //inv[n]=(x%p+x)%p;\n</code></pre><hr>\n<h2 id=\"2-费马小定理\"><a href=\"#2-费马小定理\" class=\"headerlink\" title=\"2 . 费马小定理\"></a>2 . 费马小定理</h2><p>当$n$为质数时，同样可以通过费马小定理求解。<br>已知$n^{p-1}≡ 1(mod p)$(费马小定理)<br> 那么$inv[n]=n^{p-2} (mod p)$。该方法的时间复杂度为$O(logn)$（快速幂）。</p>\n<hr>\n<h2 id=\"3-线性求前-n-项的逆元\"><a href=\"#3-线性求前-n-项的逆元\" class=\"headerlink\" title=\"3 . 线性求前$n$项的逆元\"></a>3 . 线性求前$n$项的逆元</h2><p><img src=\"http://i2.muimg.com/567571/a0936082ab04d10e.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"4-利用阶乘递推求前-n-项的逆元\"><a href=\"#4-利用阶乘递推求前-n-项的逆元\" class=\"headerlink\" title=\"4 . 利用阶乘递推求前$n$项的逆元\"></a>4 . 利用阶乘递推求前$n$项的逆元</h2><p>该方法较简单易懂，理论复杂度是方法3的3倍。据说在某些奇怪的时刻会跑的比上面快。(因为数组的连续访问)</p>\n<pre><code>//fac为阶乘，rev为阶乘的逆元。\nfac[0]=fac[1]=1;\n\nfor(int i=2;i&lt;=N;i++)fac[i]=fac[i-1]*i%mod;\n\nrev[N]=mod_pow(fac[N],mod-2);//mod_pow为带取模的快速幂\n\nfor(int i=N-1;i&gt;=0;i--)rev[i]=rev[i+1]*(i+1)%mod;\n</code></pre><hr>\n<h1 id=\"相关习题\"><a href=\"#相关习题\" class=\"headerlink\" title=\"相关习题\"></a>相关习题</h1><h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a>T1</h2><p>已知 $\\sum_{i=1}^{p-1}{1/i}$ $=A/B$,其中$p$为奇质数，求证$A≡0(modp)$</p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>设$T=lcm(1,2,…,p-1)$</p>\n<p>则有</p>\n<p>$\\sum_{i=1}^{p-1}{1/i}$ $= (T/1+T/2+…+T/(p-1))/T$</p>\n<p>此时只需证明</p>\n<p>$T/1+T/2+…+T/(p-1)≡0(modp)$</p>\n<p>根据性质（见上）我们可以知道，1到p-1中所有数的逆元对应1到p-1中的所有数，则原式可以化简为</p>\n<p>$1+2+…+(p-1)≡0(modp)$</p>\n<p>$p*(p-1)≡0(modp)$</p>\n<p>得证。</p>\n<hr>\n<h2 id=\"T2-SDOI2008-沙拉公主的困惑\"><a href=\"#T2-SDOI2008-沙拉公主的困惑\" class=\"headerlink\" title=\"T2 SDOI2008 沙拉公主的困惑\"></a>T2 SDOI2008 沙拉公主的困惑</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为1到N的阶乘，但是，政府只发行编号与M!互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于可能张数非常大，你只需计算出对R取模后的答案即可。R是一个质数。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第一行为两个整数T，R。R&lt;=10^9+10，T&lt;=10000，表示该组中测试数据数目，R为模 后面T行，每行一对整数N，M，见题目描述 m&lt;=n</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>共T行，对于每一对N，M，输出1至N！中与M！素质的数的数量对R取模后的值</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a>输入样例</h4><pre><code>1 11\n4 2\n</code></pre><h4 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a>输出样例</h4><pre><code>1\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于100%的数据，1 &lt; = N , M &lt; = 10000000</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>题意明确$n&gt;=m$,且易知$m!|n!$那么只需要算出$\\varphi(m!)$即可，根据欧几里得算法可知最后的答案即为$\\varphi(m!)*n!/m!(modp)$</p>\n<p>对于$\\varphi(m!)$来说，m!的值过大，只能利用通项公式来求解，易知m!的所有质因数即为1到m中所有的质数，由于通项公式中涉及模运算下的除法，所以应先处理一下逆元。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\nconst int M = 1e6+1;\nusing namespace std;\nbool vis[M+100];\nlong long prime[500500],ans[M+100],fac[M+100],rev[M+100];\nint n,m,p,T,tot;\nint main()\n{\n    scanf(&quot;%d%d&quot;,&amp;T,&amp;p);\n\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])prime[++tot]=i;\n        for(int j=1;j&lt;=tot&amp;&amp;prime[j]*i&lt;=M;j++)\n        {\n            vis[prime[j]*i]=1;\n            if(i%prime[j]==0)\n                break;\n        }\n    }\n    fac[1]=1;\n    for(int i=2;i&lt;=M;i++)fac[i]=fac[i-1]*i%p;\n    rev[1]=1;\n    for(int i=2;i&lt;=M&amp;&amp;i&lt;p;i++)rev[i]=(p-p/i)*rev[p%i]%p;\n    ans[1]=1;\n    for(int i=2;i&lt;=M;i++)\n    {\n        if(!vis[i])    ans[i]=ans[i-1]*(i-1)%p*rev[i%p]%p;\n        else                ans[i]=ans[i-1];\n    }\n    while(T--)\n    {\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n        printf(&quot;%d\\n&quot;,fac[n]*ans[m]%p);\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/28/乘法逆元总结/","excerpt":"","categories":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://prostkhala.github.io/tags/数论/"},{"name":"线性筛法","slug":"线性筛法","permalink":"https://prostkhala.github.io/tags/线性筛法/"},{"name":"逆元","slug":"逆元","permalink":"https://prostkhala.github.io/tags/逆元/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://prostkhala.github.io/tags/扩展欧几里得/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://prostkhala.github.io/tags/欧拉函数/"},{"name":"费马小定理","slug":"费马小定理","permalink":"https://prostkhala.github.io/tags/费马小定理/"}]},{"title":"NOI2005 维修数列","date":"2017-03-21T14:13:15.000Z","path":"2017/03/21/NOI2005维修数列/","text":"NOI2005 维护数列洛谷2042 COGS339 题目描述 请写一个程序，要求维护一个数列，支持以下 6 种操作：（请注意，格式栏 中的下划线‘ _ ’表示实际输入文件中的空格） 操作编号 输入文件中的格式 说明 1. 插入 INSERT_posi_tot_c1_c2_..._ctot 在当前数列的第 posi 个数字后插入 tot个数字：c1, c2, …, ctot；若在数列首插入，则 posi 为 0 2. 删除 DELETE_posi_tot 从当前数列的第 posi 个数字开始连续删除 tot 个数字 3. 修改 MAKE-SAME_posi_tot_c 将当前数列的第 posi 个数字开始的连续 tot 个数字统一修改为 c 4. 翻转 REVERSE_posi_tot 取出从当前数列的第 posi 个数字开始的 tot 个数字，翻转后放入原来的位置 5. 求和 GET-SUM_posi_tot 计算从当前数列开始的第 posi 个数字开始的 tot 个数字的和并输出 6. 求和最大的子列 MAX-SUM 求出当前数列中和最大的一段子列，并输出最大和 输入输出格式输入格式： 输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M表示要进行的操作数目。 第 2 行包含 N 个数字，描述初始时的数列。 以下 M 行，每行一条命令，格式参见问题描述中的表格。 输出格式：对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结果，每个答案（数字）占一行。 输入输出样例输入样例：9 8 2 -6 3 5 1 -5 -3 6 3 GET-SUM 5 4 MAX-SUM INSERT 8 3 -5 7 2 DELETE 12 1 MAKE-SAME 3 3 2 REVERSE 3 6 GET-SUM 5 4 MAX-SUM 输出样例：-1 10 1 10 数据范围你可以认为在任何时刻，数列中至少有 1 个数。 输入数据一定是正确的，即指定位置的数在数列中一定存在。 50%的数据中，任何时刻数列中最多含有 30 000 个数； 100%的数据中，任何时刻数列中最多含有 500 000 个数。 100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。 100%的数据中，M ≤20 000，插入的数字总数不超过 4 000 000 个，输入文件大小不超过 20MBytes。 题解对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立二分搜索树，而不应直接插入，否则会导致时间复杂度过高，同时操作后也要注意更新信息。 对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。 对于求和操作，具体实现与线段树相同。 对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。 （一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入4e6个元素，但同时也说明队列中最多只有5e5个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用。） CODE V1（暴力）#include&lt;iostream&gt; #include&lt;cstdio&gt; const int N = 4e6+5; const int inf = 0x7fffffff; using namespace std; int tot,root,rev[N],size[N],w[N],fa[N],son[N][2],id[N]; void update(int x) { size[x]=size[son[x][0]]+size[son[x][1]]+1; } void pushdown(int x) { if(rev[x]) { swap(son[x][0],son[x][1]); rev[son[x][0]]^=1; rev[son[x][1]]^=1; rev[x]=0; } return; } void zg(int x) { pushdown(fa[x]),pushdown(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(z) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; update(y);update(x); } void splay(int x,int f) { while(fa[x]!=f) { int y=fa[x],z=fa[y]; if(z!=f) { if(son[z][0]==y^son[y][0]==x) zg(x); else zg(y); } zg(x); } if(!f) root=x; } void insert(int &amp;x,int v,int f) { if(!x) { x=++tot; son[x][0]=son[x][1]=0; size[x]=1; w[x]=v;fa[x]=f; splay(x,0); return; } insert(son[x][v&gt;w[x]],v,x); update(x); } int get(int v) { int x=root; while(x&amp;&amp;v!=w[x]) x=son[x][v&gt;w[x]]; return x; } int find(int k,int rank) { pushdown(k); int l=son[k][0],r=son[k][1]; if(size[l]+1==rank)return k; else if(size[l]&gt;=rank)return find(l,rank); else return find(r,rank-size[l]-1); } int a[N]; char op[19]; int sum1,ans1,max1; int inorder(int x) { pushdown(x); if(son[x][0])inorder(son[x][0]); if(w[x]!=inf&amp;&amp;w[x]!=-inf)printf(&quot;%d &quot;,a[w[x]]); if(son[x][1])inorder(son[x][1]); } int inordermax(int x) { pushdown(x); if(son[x][0])inordermax(son[x][0]); if(w[x]!=inf&amp;&amp;w[x]!=-inf) { max1=max(max1,a[w[x]]); sum1+=a[w[x]]*num[x]; if(sum1&gt;0)ans1=max(ans1,sum1); else sum1=0; } if(son[x][1])inordermax(son[x][1]); } int main() { // freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout); int n,m,tmp; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); insert(root,-inf,0);insert(root,inf,0); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i); for(int i=1;i&lt;=n;++i)insert(root,i,0); tmp=n; for(int i=1,pos,tt,x;i&lt;=m;++i) { scanf(&quot;%s&quot;,op); if(op[0]==&#39;I&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int now=find(root,pos+1),ne=find(root,pos+2); update(now),update(ne); splay(now,0);splay(ne,root); for(int i=1;i&lt;=tt;++i)scanf(&quot;%d&quot;,&amp;a[++tmp]),insert(son[ne][0],tmp,ne); update(root),update(son[root][1]); } if(op[0]==&#39;D&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int now=find(root,pos),ne=find(root,pos+tt+1); splay(now,0);splay(ne,root); fa[son[ne][0]]=0; son[ne][0]=0; update(ne);update(now); } if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;) { scanf(&quot;%d%d%d&quot;,&amp;pos,&amp;tt,&amp;x); for(int t=pos+1;t&lt;=pos+tt;++t) a[w[find(root,t)]]=x; } if(op[0]==&#39;R&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int now=find(root,pos),ne=find(root,pos+tt+1); update(now),update(ne); splay(now,0);splay(ne,root); int s=son[ne][0]; rev[s]^=1; } if(op[0]==&#39;G&#39;) { scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt); int sum=0; for(int t=1;t&lt;=tt;++t) sum+=a[find(root,pos+t)-2]; printf(&quot;%d\\n&quot;,sum); } if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;) { sum1=ans1=0;max1=-0x7fffffff; inordermax(root); printf(&quot;%d\\n&quot;,ans1==0?max1:ans1); } } // inorder(root); } CODE V2#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; const int inf = 1e9; const int N = 1e6+1; inline int read() { int x=0,f=1;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} return x*f; } int n,m,root,cnt; int sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][2];; bool tag[N],rev[N]; queue&lt;int&gt;q; void pushdown(int x) { int sonl=son[x][0],sonr=son[x][1]; if(tag[x]) { if(sonl)tag[sonl]=true,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl]; if(sonr)tag[sonr]=true,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr]; if(v[x]&gt;=0) { if(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl]; if(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr]; } else { if(sonl)lx[sonl]=rx[sonl]=0,mx[sonl]=v[x]; if(sonr)lx[sonr]=rx[sonr]=0,mx[sonr]=v[x]; } rev[x]=tag[x]=0; } if(rev[x]) { rev[x]^=1;rev[sonl]^=1;rev[sonr]^=1; swap(lx[sonl],rx[sonl]);swap(lx[sonr],rx[sonr]); swap(son[sonl][0],son[sonl][1]);swap(son[sonr][0],son[sonr][1]); } } int inorder(int x) { pushdown(x); if(son[x][0])inorder(son[x][0]); if(v[x]!=inf&amp;&amp;v[x]!=-inf)printf(&quot;%d &quot;,v[x]); if(son[x][1])inorder(son[x][1]); } void update(int x) { int sonl=son[x][0],sonr=son[x][1]; sum[x]=sum[sonl]+sum[sonr]+v[x]; size[x]=size[sonl]+size[sonr]+1; mx[x]=max(mx[sonl],mx[sonr]); mx[x]=max(mx[x],rx[sonl]+v[x]+lx[sonr]); lx[x]=max(lx[sonl],sum[sonl]+v[x]+lx[sonr]); rx[x]=max(rx[sonr],sum[sonr]+v[x]+rx[sonl]); } void rotate(int x,int &amp;k) { int y=fa[x],z=fa[y],l,r; l=(son[y][1]==x);r=l^1; if(y==k)k=x; else son[z][son[z][1]==y]=x; fa[son[x][r]]=y;fa[y]=x;fa[x]=z; son[y][l]=son[x][r];son[x][r]=y; update(y);update(x); } void splay(int x,int &amp;k) { while(x!=k) { int y=fa[x],z=fa[y]; if(y!=k) { if(son[y][0]==x^son[z][0]==y)rotate(x,k); else rotate(y,k); } rotate(x,k); } } int find(int x,int rk) { pushdown(x); int l=son[x][0],r=son[x][1]; if(size[l]+1==rk)return x; if(size[l]&gt;=rk)return find(l,rk); return find(r,rk-size[l]-1); } void rec(int x) { if(!x)return; int l=son[x][0],r=son[x][1]; rec(l);rec(r);q.push(x); fa[x]=son[x][0]=son[x][1]=0; tag[x]=rev[x]=0; } int split(int k,int tt) { int x=find(root,k),y=find(root,k+tt+1); splay(x,root);splay(y,son[x][1]); return son[y][0]; } void modify(int k,int tt,int val) { int x=split(k,tt),y=fa[x]; v[x]=val;tag[x]=1;sum[x]=size[x]*val; if(val&gt;=0)lx[x]=rx[x]=mx[x]=sum[x]; else lx[x]=rx[x]=0,mx[x]=val; update(y);update(fa[y]); } void rever(int k,int tt) { int x=split(k,tt),y=fa[x]; if(!tag[x]) { rev[x]^=1; swap(son[x][0],son[x][1]); swap(lx[x],rx[x]); update(y);update(fa[y]); } } void delet(int k,int tt) { int x=split(k,tt),y=fa[x]; rec(x);son[y][0]=0; update(y);update(fa[y]); } void build(int l,int r,int s) { if(l&gt;r)return; int mid=(l+r)&gt;&gt;1,now=id[mid],last=id[s]; if(l==r) { sum[now]=a[l];size[now]=1; tag[now]=rev[now]=0; if(a[l]&gt;=0)lx[now]=rx[now]=mx[now]=a[l]; else lx[now]=rx[now]=0,mx[now]=a[l]; } else build(l,mid-1,mid),build(mid+1,r,mid); v[now]=a[mid];fa[now]=last;update(now); son[last][mid&gt;=s]=now; } void insert(int k,int tt) { for(int i=1;i&lt;=tt;i++)a[i]=read(); for(int i=1;i&lt;=tt;i++) if(!q.empty())id[i]=q.front(),q.pop(); else id[i]=++cnt; build(1,tt,0);int z=id[(1+tt)&gt;&gt;1]; int x=find(root,k+1),y=find(root,k+2); splay(x,root);splay(y,son[x][1]); fa[z]=y;son[y][0]=z; update(y);update(x); } int main() { // freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); mx[0]=a[1]=a[n+2]=-inf; for(int i=2;i&lt;=n+1;i++)a[i]=read(); for(int i=1;i&lt;=n+2;i++)id[i]=i; build(1,n+2,0); root=(n+3)&gt;&gt;1;cnt=n+2; int k,tt,val; char op[19]; for(int i=1;i&lt;=m;++i) { scanf(&quot;%s&quot;,op); if(op[0]==&#39;I&#39;)k=read(),tt=read(),insert(k,tt); if(op[0]==&#39;D&#39;)k=read(),tt=read(),delet(k,tt); if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;)printf(&quot;%d\\n&quot;,mx[root]); if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;)k=read(),tt=read(),val=read(),modify(k,tt,val); if(op[0]==&#39;R&#39;)k=read(),tt=read(),rever(k,tt); if(op[0]==&#39;G&#39;){k=read(),tt=read();printf(&quot;%d\\n&quot;,sum[split(k,tt)]);} } // inorder(root); }","raw":"title: NOI2005 维修数列\ndate: 2017-03-21 22:13:15\ncategories:\n  - 数据结构\n  - 平衡树\n  - SPLAY\ntags:\n  - SPLAY\n---\n\n# NOI2005 维护数列\n\n## [洛谷2042](https://www.luogu.org/problem/show?pid=2042) [COGS339](http://cogs.pro/cogs/problem/problem.php?pid=339)\n\n---\n## 题目描述\n 请写一个程序，要求维护一个数列，支持以下 6 种操作：（请注意，格式栏 中的下划线‘ _ ’表示实际输入文件中的空格）\n\n    操作编号\t输入文件中的格式\t说明\n\n\n    1.  插入\tINSERT_posi_tot_c1_c2_..._ctot\n\t在当前数列的第 posi 个数字后插入 tot个数字：c1, c2, …, ctot；若在数列首插入，则 posi 为 0\n\n    2.  删除\tDELETE_posi_tot\n    从当前数列的第 posi 个数字开始连续删除 tot 个数字\n\n    3.  修改\tMAKE-SAME_posi_tot_c\n\t 将当前数列的第 posi 个数字开始的连续 tot 个数字统一修改为 c\n\n    4.  翻转\tREVERSE_posi_tot\n \t取出从当前数列的第 posi 个数字开始的 tot 个数字，翻转后放入原来的位置\n    \n    5.  求和\tGET-SUM_posi_tot\n\t计算从当前数列开始的第 posi 个数字开始的 tot 个数字的和并输出\n\n    6.  求和最大的子列\tMAX-SUM\n\t求出当前数列中和最大的一段子列，并输出最大和 \n### 输入输出格式\n#### 输入格式：\n 输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M表示要进行的操作数目。\n\n第 2 行包含 N 个数字，描述初始时的数列。\n\n以下 M 行，每行一条命令，格式参见问题描述中的表格。 \n\n\n#### 输出格式：\n\n对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结果，每个答案（数字）占一行。 \n\n### 输入输出样例\n#### 输入样例：\n    9 8\n    2 -6 3 5 1 -5 -3 6 3\n    GET-SUM 5 4\n    MAX-SUM INSERT 8 3 -5 7 2\n    DELETE 12 1\n    MAKE-SAME 3 3 2\n    REVERSE 3 6\n    GET-SUM 5 4\n    MAX-SUM\n    \n\n#### 输出样例：\n    -1\n    10\n    1\n    10\n    \n\n### 数据范围\n\n你可以认为在任何时刻，数列中至少有 1 个数。\n\n输入数据一定是正确的，即指定位置的数在数列中一定存在。\n\n50%的数据中，任何时刻数列中最多含有 30 000 个数；\n\n100%的数据中，任何时刻数列中最多含有 500 000 个数。\n\n100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。\n\n100%的数据中，M ≤20 000，插入的数字总数不超过 4 000 000 个，输入文件大小不超过 20MBytes。\n\n---\n\n## 题解\n对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立二分搜索树，而不应直接插入，否则会导致时间复杂度过高，同时操作后也要注意更新信息。\n\n对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。\n\n对于求和操作，具体实现与线段树相同。\n\n对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。\n\n（一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入4e6个元素，但同时也说明队列中最多只有5e5个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用。）\n\n---\n### CODE V1（暴力）\n    #include<iostream>\n    #include<cstdio>\n    const int N = 4e6+5;\n    const int inf = 0x7fffffff;\n    using namespace std;\n    int tot,root,rev[N],size[N],w[N],fa[N],son[N][2],id[N];\n    void update(int x)\n    {\n        size[x]=size[son[x][0]]+size[son[x][1]]+1;\n    }\n    void pushdown(int x)\n    {\n        if(rev[x])\n        {\n            swap(son[x][0],son[x][1]);\n            rev[son[x][0]]^=1;\n            rev[son[x][1]]^=1;\n            rev[x]=0;\n        }\n        return;\n    }\n    void zg(int x)\n    {\n        pushdown(fa[x]),pushdown(x);\n        int y=fa[x],z=fa[y],t=(son[y][0]==x);\n        if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n        son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n        son[x][t]=y;fa[y]=x;\n        update(y);update(x);\n    }\n    void splay(int x,int f)\n    {\n        while(fa[x]!=f)\n        {\n            int y=fa[x],z=fa[y];\n            if(z!=f)\n            {\n                if(son[z][0]==y^son[y][0]==x) zg(x);\n                else zg(y);\n            } \n            zg(x);\t\n        }\n        if(!f) root=x;\n    }\n    void insert(int &x,int v,int f)\n    {\n        if(!x)\n        {\n            x=++tot;\n            son[x][0]=son[x][1]=0;\n            size[x]=1;\n            w[x]=v;fa[x]=f;\n            splay(x,0);\n            return;\n        }\n        insert(son[x][v>w[x]],v,x);\n        update(x);\n    }\n    int get(int v)\n    {\n        int x=root;\n        while(x&&v!=w[x]) x=son[x][v>w[x]];\n        return x;\n    }\n    int find(int k,int rank)\n    {\n        pushdown(k);\n        int l=son[k][0],r=son[k][1];\n        if(size[l]+1==rank)return k;\n        else if(size[l]>=rank)return find(l,rank);\n        else return find(r,rank-size[l]-1);\n    }\n    int a[N];\n    char op[19];\n    int sum1,ans1,max1;\n    int inorder(int x)\n    {\n        pushdown(x);\n        if(son[x][0])inorder(son[x][0]);\n        if(w[x]!=inf&&w[x]!=-inf)printf(\"%d \",a[w[x]]);\n        if(son[x][1])inorder(son[x][1]);\n    }\n    int inordermax(int x)\n    {\n        pushdown(x);\n        if(son[x][0])inordermax(son[x][0]);\n        if(w[x]!=inf&&w[x]!=-inf)\n        {\n            max1=max(max1,a[w[x]]);\n            sum1+=a[w[x]]*num[x];\n            if(sum1>0)ans1=max(ans1,sum1);\n            else\tsum1=0;\n        }\n        if(son[x][1])inordermax(son[x][1]);\n    }\n\n    int main()\n    {\n    //\tfreopen(\"seq2005.in\",\"r\",stdin);\n    //\tfreopen(\"seq2005.out\",\"w\",stdout);\n        int n,m,tmp;\n        scanf(\"%d%d\",&n,&m);\n        insert(root,-inf,0);insert(root,inf,0);\n        for(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n        for(int i=1;i<=n;++i)insert(root,i,0);\n        tmp=n;\n        for(int i=1,pos,tt,x;i<=m;++i)\n        {\n            scanf(\"%s\",op);\n            if(op[0]=='I')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int now=find(root,pos+1),ne=find(root,pos+2);\n                update(now),update(ne);\n                splay(now,0);splay(ne,root);\n                for(int i=1;i<=tt;++i)scanf(\"%d\",&a[++tmp]),insert(son[ne][0],tmp,ne);\n                update(root),update(son[root][1]);\n            }\n            if(op[0]=='D')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int now=find(root,pos),ne=find(root,pos+tt+1);\n                splay(now,0);splay(ne,root);\n                fa[son[ne][0]]=0;\n                son[ne][0]=0;\n                update(ne);update(now);\n            }\n            if(op[0]=='M'&&op[2]=='K')\n            {\n                scanf(\"%d%d%d\",&pos,&tt,&x);\n                for(int t=pos+1;t<=pos+tt;++t)\n                a[w[find(root,t)]]=x;\n            }\n            if(op[0]=='R')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int now=find(root,pos),ne=find(root,pos+tt+1);\n                update(now),update(ne);\n                splay(now,0);splay(ne,root);\n                int s=son[ne][0];\n                rev[s]^=1;\n            }\n            if(op[0]=='G')\n            {\n                scanf(\"%d%d\",&pos,&tt);\n                int sum=0;\n                for(int t=1;t<=tt;++t)\n                sum+=a[find(root,pos+t)-2];\n                printf(\"%d\\n\",sum);\n            }\n            if(op[0]=='M'&&op[2]=='X')\n            {\n                sum1=ans1=0;max1=-0x7fffffff;\n                inordermax(root);\n                printf(\"%d\\n\",ans1==0?max1:ans1);\n            }\n        }\n        //\tinorder(root);\n    }\n    \n    \n ---\n ### CODE V2\n \n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #include<queue>\n    using namespace std;\n    const int inf = 1e9;\n    const int N = 1e6+1;\n    inline int read()\n    {\n        int x=0,f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n        return x*f;\n    }\n    int n,m,root,cnt;\n    int sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][2];;\n    bool tag[N],rev[N];\n    queue<int>q;\n    void pushdown(int x)\n    {\n        int sonl=son[x][0],sonr=son[x][1];\n        if(tag[x])\n        {\n\n            if(sonl)tag[sonl]=true,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl];\n            if(sonr)tag[sonr]=true,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr];\n            if(v[x]>=0)\n            {\n                if(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl];\n                if(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr];\n            }\n            else \n            {\n                if(sonl)lx[sonl]=rx[sonl]=0,mx[sonl]=v[x];\n                if(sonr)lx[sonr]=rx[sonr]=0,mx[sonr]=v[x];\n            }\n            rev[x]=tag[x]=0;\n        }\n        if(rev[x])\n        {\n            rev[x]^=1;rev[sonl]^=1;rev[sonr]^=1;\n            swap(lx[sonl],rx[sonl]);swap(lx[sonr],rx[sonr]);\n            swap(son[sonl][0],son[sonl][1]);swap(son[sonr][0],son[sonr][1]);\n        }\n    }\n    int inorder(int x)\n    {\n        pushdown(x);\n        if(son[x][0])inorder(son[x][0]);\n        if(v[x]!=inf&&v[x]!=-inf)printf(\"%d \",v[x]);\n        if(son[x][1])inorder(son[x][1]);\n    }\n    void update(int x)\n    {\n        int sonl=son[x][0],sonr=son[x][1];\n        sum[x]=sum[sonl]+sum[sonr]+v[x];\n        size[x]=size[sonl]+size[sonr]+1;\n        mx[x]=max(mx[sonl],mx[sonr]);\n        mx[x]=max(mx[x],rx[sonl]+v[x]+lx[sonr]);\n        lx[x]=max(lx[sonl],sum[sonl]+v[x]+lx[sonr]);\n        rx[x]=max(rx[sonr],sum[sonr]+v[x]+rx[sonl]);\n    }\n\n    void rotate(int x,int &k)\n    {\n        int y=fa[x],z=fa[y],l,r;\n        l=(son[y][1]==x);r=l^1;\n        if(y==k)k=x;\n        else son[z][son[z][1]==y]=x;\n        fa[son[x][r]]=y;fa[y]=x;fa[x]=z;\n        son[y][l]=son[x][r];son[x][r]=y;\n        update(y);update(x);\n    }\n    void splay(int x,int &k)\n    {\n        while(x!=k)\n        {\n            int y=fa[x],z=fa[y];\n            if(y!=k)\n            {\n                if(son[y][0]==x^son[z][0]==y)rotate(x,k);\n                else rotate(y,k);\n            }\n            rotate(x,k);\n        }\n    }\n    int find(int x,int rk)\n    {\n        pushdown(x);\n        int l=son[x][0],r=son[x][1];\n        if(size[l]+1==rk)return x;\n        if(size[l]>=rk)return find(l,rk);\n        return find(r,rk-size[l]-1);\n    }\n    void rec(int x)\n    {\n        if(!x)return;\n        int l=son[x][0],r=son[x][1];\n        rec(l);rec(r);q.push(x);\n        fa[x]=son[x][0]=son[x][1]=0;\n        tag[x]=rev[x]=0;\n    }\n    int split(int k,int tt)\n    {\n        int x=find(root,k),y=find(root,k+tt+1);\n        splay(x,root);splay(y,son[x][1]);\n        return son[y][0];\n    }\n    void modify(int k,int tt,int val)\n    {\n        int x=split(k,tt),y=fa[x];\n        v[x]=val;tag[x]=1;sum[x]=size[x]*val;\n        if(val>=0)lx[x]=rx[x]=mx[x]=sum[x];\n        else lx[x]=rx[x]=0,mx[x]=val;\n        update(y);update(fa[y]);\n    }\n    void rever(int k,int tt)\n    {\n        int x=split(k,tt),y=fa[x];\n        if(!tag[x])\n        {\n            rev[x]^=1;\n            swap(son[x][0],son[x][1]);\n            swap(lx[x],rx[x]);\n            update(y);update(fa[y]);\n        }\n    }\n    void delet(int k,int tt)\n    {\n        int x=split(k,tt),y=fa[x];\n        rec(x);son[y][0]=0;\n        update(y);update(fa[y]);\n    }\n    void build(int l,int r,int s)\n    {\n        if(l>r)return;\n        int mid=(l+r)>>1,now=id[mid],last=id[s];\n        if(l==r)\n        {\n            sum[now]=a[l];size[now]=1;\n            tag[now]=rev[now]=0;\n            if(a[l]>=0)lx[now]=rx[now]=mx[now]=a[l];\n            else lx[now]=rx[now]=0,mx[now]=a[l];\n        }\n        else build(l,mid-1,mid),build(mid+1,r,mid);\n        v[now]=a[mid];fa[now]=last;update(now);\n        son[last][mid>=s]=now;\n       }\n    void insert(int k,int tt)\n    {\n        for(int i=1;i<=tt;i++)a[i]=read();\n        for(int i=1;i<=tt;i++)\n        if(!q.empty())id[i]=q.front(),q.pop();\n        else id[i]=++cnt;\n        build(1,tt,0);int z=id[(1+tt)>>1];\n        int x=find(root,k+1),y=find(root,k+2);\n        splay(x,root);splay(y,son[x][1]);\n        fa[z]=y;son[y][0]=z;\n        update(y);update(x);\n    }\n    int main()\n    {\n    //\tfreopen(\"seq2005.in\",\"r\",stdin);\n    //\tfreopen(\"seq2005.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        mx[0]=a[1]=a[n+2]=-inf;\n        for(int i=2;i<=n+1;i++)a[i]=read();\n        for(int i=1;i<=n+2;i++)id[i]=i;\n        build(1,n+2,0);\n        root=(n+3)>>1;cnt=n+2;\n        int k,tt,val;\n        char op[19];\n        for(int i=1;i<=m;++i)\n        {\n            scanf(\"%s\",op);\n            if(op[0]=='I')k=read(),tt=read(),insert(k,tt);\n            if(op[0]=='D')k=read(),tt=read(),delet(k,tt);\n            if(op[0]=='M'&&op[2]=='X')printf(\"%d\\n\",mx[root]);\n            if(op[0]=='M'&&op[2]=='K')k=read(),tt=read(),val=read(),modify(k,tt,val);\n            if(op[0]=='R')k=read(),tt=read(),rever(k,tt);\n            if(op[0]=='G'){k=read(),tt=read();printf(\"%d\\n\",sum[split(k,tt)]);}\n        }\n    //\t\tinorder(root);\n    }\n\n \n","content":"<h1 id=\"NOI2005-维护数列\"><a href=\"#NOI2005-维护数列\" class=\"headerlink\" title=\"NOI2005 维护数列\"></a>NOI2005 维护数列</h1><h2 id=\"洛谷2042-COGS339\"><a href=\"#洛谷2042-COGS339\" class=\"headerlink\" title=\"洛谷2042 COGS339\"></a><a href=\"https://www.luogu.org/problem/show?pid=2042\" target=\"_blank\" rel=\"external\">洛谷2042</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=339\" target=\"_blank\" rel=\"external\">COGS339</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p> 请写一个程序，要求维护一个数列，支持以下 6 种操作：（请注意，格式栏 中的下划线‘ _ ’表示实际输入文件中的空格）</p>\n<pre><code>操作编号    输入文件中的格式    说明\n\n\n1.  插入    INSERT_posi_tot_c1_c2_..._ctot\n在当前数列的第 posi 个数字后插入 tot个数字：c1, c2, …, ctot；若在数列首插入，则 posi 为 0\n\n2.  删除    DELETE_posi_tot\n从当前数列的第 posi 个数字开始连续删除 tot 个数字\n\n3.  修改    MAKE-SAME_posi_tot_c\n 将当前数列的第 posi 个数字开始的连续 tot 个数字统一修改为 c\n\n4.  翻转    REVERSE_posi_tot\n 取出从当前数列的第 posi 个数字开始的 tot 个数字，翻转后放入原来的位置\n\n5.  求和    GET-SUM_posi_tot\n计算从当前数列开始的第 posi 个数字开始的 tot 个数字的和并输出\n\n6.  求和最大的子列    MAX-SUM\n求出当前数列中和最大的一段子列，并输出最大和 \n</code></pre><h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p> 输入文件的第 1 行包含两个数 N 和 M，N 表示初始时数列中数的个数，M表示要进行的操作数目。</p>\n<p>第 2 行包含 N 个数字，描述初始时的数列。</p>\n<p>以下 M 行，每行一条命令，格式参见问题描述中的表格。 </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于输入数据中的 GET-SUM 和 MAX-SUM 操作，向输出文件依次打印结果，每个答案（数字）占一行。 </p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>9 8\n2 -6 3 5 1 -5 -3 6 3\nGET-SUM 5 4\nMAX-SUM INSERT 8 3 -5 7 2\nDELETE 12 1\nMAKE-SAME 3 3 2\nREVERSE 3 6\nGET-SUM 5 4\nMAX-SUM\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>-1\n10\n1\n10\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>你可以认为在任何时刻，数列中至少有 1 个数。</p>\n<p>输入数据一定是正确的，即指定位置的数在数列中一定存在。</p>\n<p>50%的数据中，任何时刻数列中最多含有 30 000 个数；</p>\n<p>100%的数据中，任何时刻数列中最多含有 500 000 个数。</p>\n<p>100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。</p>\n<p>100%的数据中，M ≤20 000，插入的数字总数不超过 4 000 000 个，输入文件大小不超过 20MBytes。</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>对于删除操作和插入操作，应将删除区间左边一位的端点旋转到根，再将区间右边一位的端点旋转到根的右儿子（对于插入操作则为将插入位置前一位旋转到根，后一位旋转到其右儿子），需要注意的是，插入元素时应按顺序建立二分搜索树，而不应直接插入，否则会导致时间复杂度过高，同时操作后也要注意更新信息。</p>\n<p>对于修改操作和反转操作，可以借鉴线段树的懒人标记，在进行形如删除操作的旋转后，将操作区间打上标记，将深度最浅的节点进行操作，然后在待该子树变动时再下传标记。</p>\n<p>对于求和操作，具体实现与线段树相同。</p>\n<p>对于求最大子串和的操作，可以其具体实现与动规相同，只是在其他操作中实时更新，这样便可以做到$O(1)$查询。</p>\n<p>（一开始写了个几近暴力的实现，后两个操作都是遍历一遍后才能得到答案。数据范围中虽然说明最多会插入4e6个元素，但同时也说明队列中最多只有5e5个元素，对此可以进行空间上的优化，将被删除元素的下标标记下来，添加时重新使用。）</p>\n<hr>\n<h3 id=\"CODE-V1（暴力）\"><a href=\"#CODE-V1（暴力）\" class=\"headerlink\" title=\"CODE V1（暴力）\"></a>CODE V1（暴力）</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nconst int N = 4e6+5;\nconst int inf = 0x7fffffff;\nusing namespace std;\nint tot,root,rev[N],size[N],w[N],fa[N],son[N][2],id[N];\nvoid update(int x)\n{\n    size[x]=size[son[x][0]]+size[son[x][1]]+1;\n}\nvoid pushdown(int x)\n{\n    if(rev[x])\n    {\n        swap(son[x][0],son[x][1]);\n        rev[son[x][0]]^=1;\n        rev[son[x][1]]^=1;\n        rev[x]=0;\n    }\n    return;\n}\nvoid zg(int x)\n{\n    pushdown(fa[x]),pushdown(x);\n    int y=fa[x],z=fa[y],t=(son[y][0]==x);\n    if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n    son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n    son[x][t]=y;fa[y]=x;\n    update(y);update(x);\n}\nvoid splay(int x,int f)\n{\n    while(fa[x]!=f)\n    {\n        int y=fa[x],z=fa[y];\n        if(z!=f)\n        {\n            if(son[z][0]==y^son[y][0]==x) zg(x);\n            else zg(y);\n        } \n        zg(x);    \n    }\n    if(!f) root=x;\n}\nvoid insert(int &amp;x,int v,int f)\n{\n    if(!x)\n    {\n        x=++tot;\n        son[x][0]=son[x][1]=0;\n        size[x]=1;\n        w[x]=v;fa[x]=f;\n        splay(x,0);\n        return;\n    }\n    insert(son[x][v&gt;w[x]],v,x);\n    update(x);\n}\nint get(int v)\n{\n    int x=root;\n    while(x&amp;&amp;v!=w[x]) x=son[x][v&gt;w[x]];\n    return x;\n}\nint find(int k,int rank)\n{\n    pushdown(k);\n    int l=son[k][0],r=son[k][1];\n    if(size[l]+1==rank)return k;\n    else if(size[l]&gt;=rank)return find(l,rank);\n    else return find(r,rank-size[l]-1);\n}\nint a[N];\nchar op[19];\nint sum1,ans1,max1;\nint inorder(int x)\n{\n    pushdown(x);\n    if(son[x][0])inorder(son[x][0]);\n    if(w[x]!=inf&amp;&amp;w[x]!=-inf)printf(&quot;%d &quot;,a[w[x]]);\n    if(son[x][1])inorder(son[x][1]);\n}\nint inordermax(int x)\n{\n    pushdown(x);\n    if(son[x][0])inordermax(son[x][0]);\n    if(w[x]!=inf&amp;&amp;w[x]!=-inf)\n    {\n        max1=max(max1,a[w[x]]);\n        sum1+=a[w[x]]*num[x];\n        if(sum1&gt;0)ans1=max(ans1,sum1);\n        else    sum1=0;\n    }\n    if(son[x][1])inordermax(son[x][1]);\n}\n\nint main()\n{\n//    freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout);\n    int n,m,tmp;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    insert(root,-inf,0);insert(root,inf,0);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i);\n    for(int i=1;i&lt;=n;++i)insert(root,i,0);\n    tmp=n;\n    for(int i=1,pos,tt,x;i&lt;=m;++i)\n    {\n        scanf(&quot;%s&quot;,op);\n        if(op[0]==&#39;I&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int now=find(root,pos+1),ne=find(root,pos+2);\n            update(now),update(ne);\n            splay(now,0);splay(ne,root);\n            for(int i=1;i&lt;=tt;++i)scanf(&quot;%d&quot;,&amp;a[++tmp]),insert(son[ne][0],tmp,ne);\n            update(root),update(son[root][1]);\n        }\n        if(op[0]==&#39;D&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int now=find(root,pos),ne=find(root,pos+tt+1);\n            splay(now,0);splay(ne,root);\n            fa[son[ne][0]]=0;\n            son[ne][0]=0;\n            update(ne);update(now);\n        }\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;)\n        {\n            scanf(&quot;%d%d%d&quot;,&amp;pos,&amp;tt,&amp;x);\n            for(int t=pos+1;t&lt;=pos+tt;++t)\n            a[w[find(root,t)]]=x;\n        }\n        if(op[0]==&#39;R&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int now=find(root,pos),ne=find(root,pos+tt+1);\n            update(now),update(ne);\n            splay(now,0);splay(ne,root);\n            int s=son[ne][0];\n            rev[s]^=1;\n        }\n        if(op[0]==&#39;G&#39;)\n        {\n            scanf(&quot;%d%d&quot;,&amp;pos,&amp;tt);\n            int sum=0;\n            for(int t=1;t&lt;=tt;++t)\n            sum+=a[find(root,pos+t)-2];\n            printf(&quot;%d\\n&quot;,sum);\n        }\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;)\n        {\n            sum1=ans1=0;max1=-0x7fffffff;\n            inordermax(root);\n            printf(&quot;%d\\n&quot;,ans1==0?max1:ans1);\n        }\n    }\n    //    inorder(root);\n}\n</code></pre><hr>\n<h3 id=\"CODE-V2\"><a href=\"#CODE-V2\" class=\"headerlink\" title=\"CODE V2\"></a>CODE V2</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int inf = 1e9;\nconst int N = 1e6+1;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n    return x*f;\n}\nint n,m,root,cnt;\nint sum[N],size[N],v[N],mx[N],lx[N],rx[N],a[N],id[N],fa[N],son[N][2];;\nbool tag[N],rev[N];\nqueue&lt;int&gt;q;\nvoid pushdown(int x)\n{\n    int sonl=son[x][0],sonr=son[x][1];\n    if(tag[x])\n    {\n\n        if(sonl)tag[sonl]=true,v[sonl]=v[x],sum[sonl]=v[x]*size[sonl];\n        if(sonr)tag[sonr]=true,v[sonr]=v[x],sum[sonr]=v[x]*size[sonr];\n        if(v[x]&gt;=0)\n        {\n            if(sonl)lx[sonl]=rx[sonl]=mx[sonl]=sum[sonl];\n            if(sonr)lx[sonr]=rx[sonr]=mx[sonr]=sum[sonr];\n        }\n        else \n        {\n            if(sonl)lx[sonl]=rx[sonl]=0,mx[sonl]=v[x];\n            if(sonr)lx[sonr]=rx[sonr]=0,mx[sonr]=v[x];\n        }\n        rev[x]=tag[x]=0;\n    }\n    if(rev[x])\n    {\n        rev[x]^=1;rev[sonl]^=1;rev[sonr]^=1;\n        swap(lx[sonl],rx[sonl]);swap(lx[sonr],rx[sonr]);\n        swap(son[sonl][0],son[sonl][1]);swap(son[sonr][0],son[sonr][1]);\n    }\n}\nint inorder(int x)\n{\n    pushdown(x);\n    if(son[x][0])inorder(son[x][0]);\n    if(v[x]!=inf&amp;&amp;v[x]!=-inf)printf(&quot;%d &quot;,v[x]);\n    if(son[x][1])inorder(son[x][1]);\n}\nvoid update(int x)\n{\n    int sonl=son[x][0],sonr=son[x][1];\n    sum[x]=sum[sonl]+sum[sonr]+v[x];\n    size[x]=size[sonl]+size[sonr]+1;\n    mx[x]=max(mx[sonl],mx[sonr]);\n    mx[x]=max(mx[x],rx[sonl]+v[x]+lx[sonr]);\n    lx[x]=max(lx[sonl],sum[sonl]+v[x]+lx[sonr]);\n    rx[x]=max(rx[sonr],sum[sonr]+v[x]+rx[sonl]);\n}\n\nvoid rotate(int x,int &amp;k)\n{\n    int y=fa[x],z=fa[y],l,r;\n    l=(son[y][1]==x);r=l^1;\n    if(y==k)k=x;\n    else son[z][son[z][1]==y]=x;\n    fa[son[x][r]]=y;fa[y]=x;fa[x]=z;\n    son[y][l]=son[x][r];son[x][r]=y;\n    update(y);update(x);\n}\nvoid splay(int x,int &amp;k)\n{\n    while(x!=k)\n    {\n        int y=fa[x],z=fa[y];\n        if(y!=k)\n        {\n            if(son[y][0]==x^son[z][0]==y)rotate(x,k);\n            else rotate(y,k);\n        }\n        rotate(x,k);\n    }\n}\nint find(int x,int rk)\n{\n    pushdown(x);\n    int l=son[x][0],r=son[x][1];\n    if(size[l]+1==rk)return x;\n    if(size[l]&gt;=rk)return find(l,rk);\n    return find(r,rk-size[l]-1);\n}\nvoid rec(int x)\n{\n    if(!x)return;\n    int l=son[x][0],r=son[x][1];\n    rec(l);rec(r);q.push(x);\n    fa[x]=son[x][0]=son[x][1]=0;\n    tag[x]=rev[x]=0;\n}\nint split(int k,int tt)\n{\n    int x=find(root,k),y=find(root,k+tt+1);\n    splay(x,root);splay(y,son[x][1]);\n    return son[y][0];\n}\nvoid modify(int k,int tt,int val)\n{\n    int x=split(k,tt),y=fa[x];\n    v[x]=val;tag[x]=1;sum[x]=size[x]*val;\n    if(val&gt;=0)lx[x]=rx[x]=mx[x]=sum[x];\n    else lx[x]=rx[x]=0,mx[x]=val;\n    update(y);update(fa[y]);\n}\nvoid rever(int k,int tt)\n{\n    int x=split(k,tt),y=fa[x];\n    if(!tag[x])\n    {\n        rev[x]^=1;\n        swap(son[x][0],son[x][1]);\n        swap(lx[x],rx[x]);\n        update(y);update(fa[y]);\n    }\n}\nvoid delet(int k,int tt)\n{\n    int x=split(k,tt),y=fa[x];\n    rec(x);son[y][0]=0;\n    update(y);update(fa[y]);\n}\nvoid build(int l,int r,int s)\n{\n    if(l&gt;r)return;\n    int mid=(l+r)&gt;&gt;1,now=id[mid],last=id[s];\n    if(l==r)\n    {\n        sum[now]=a[l];size[now]=1;\n        tag[now]=rev[now]=0;\n        if(a[l]&gt;=0)lx[now]=rx[now]=mx[now]=a[l];\n        else lx[now]=rx[now]=0,mx[now]=a[l];\n    }\n    else build(l,mid-1,mid),build(mid+1,r,mid);\n    v[now]=a[mid];fa[now]=last;update(now);\n    son[last][mid&gt;=s]=now;\n   }\nvoid insert(int k,int tt)\n{\n    for(int i=1;i&lt;=tt;i++)a[i]=read();\n    for(int i=1;i&lt;=tt;i++)\n    if(!q.empty())id[i]=q.front(),q.pop();\n    else id[i]=++cnt;\n    build(1,tt,0);int z=id[(1+tt)&gt;&gt;1];\n    int x=find(root,k+1),y=find(root,k+2);\n    splay(x,root);splay(y,son[x][1]);\n    fa[z]=y;son[y][0]=z;\n    update(y);update(x);\n}\nint main()\n{\n//    freopen(&quot;seq2005.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;seq2005.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    mx[0]=a[1]=a[n+2]=-inf;\n    for(int i=2;i&lt;=n+1;i++)a[i]=read();\n    for(int i=1;i&lt;=n+2;i++)id[i]=i;\n    build(1,n+2,0);\n    root=(n+3)&gt;&gt;1;cnt=n+2;\n    int k,tt,val;\n    char op[19];\n    for(int i=1;i&lt;=m;++i)\n    {\n        scanf(&quot;%s&quot;,op);\n        if(op[0]==&#39;I&#39;)k=read(),tt=read(),insert(k,tt);\n        if(op[0]==&#39;D&#39;)k=read(),tt=read(),delet(k,tt);\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;X&#39;)printf(&quot;%d\\n&quot;,mx[root]);\n        if(op[0]==&#39;M&#39;&amp;&amp;op[2]==&#39;K&#39;)k=read(),tt=read(),val=read(),modify(k,tt,val);\n        if(op[0]==&#39;R&#39;)k=read(),tt=read(),rever(k,tt);\n        if(op[0]==&#39;G&#39;){k=read(),tt=read();printf(&quot;%d\\n&quot;,sum[split(k,tt)]);}\n    }\n//        inorder(root);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/21/NOI2005维修数列/","excerpt":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"平衡树","slug":"数据结构/平衡树","permalink":"https://prostkhala.github.io/categories/数据结构/平衡树/"},{"name":"SPLAY","slug":"数据结构/平衡树/SPLAY","permalink":"https://prostkhala.github.io/categories/数据结构/平衡树/SPLAY/"}],"tags":[{"name":"SPLAY","slug":"SPLAY","permalink":"https://prostkhala.github.io/tags/SPLAY/"}]},{"title":"普通平衡树","date":"2017-03-19T12:21:17.000Z","path":"2017/03/19/普通平衡树/","text":"普通平衡树BZOJ3224 COGS1829 题目描述您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 插入x数 删除x数(若有多个相同的数，因只删除一个) 查询x数的排名(若有多个相同的数，因输出最小的排名) 查询排名为x的数 求x的前驱(前驱定义为小于x，且最大的数) 求x的后继(后继定义为大于x，且最小的数)输入输出格式输入格式：第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号$(1&lt;=opt&lt;=6)$ 输出格式：对于操作3,4,5,6每行输出一个数，表示对应答案 输入输出样例输入样例：10 1 106465 4 1 1 317721 1 460929 1 644985 1 84185 1 89851 6 81968 1 492737 5 493598 输出样例：106465 84185 492737 数据范围1.n的数据范围：$n&lt;=100000$ 2.每个数的数据范围：$[-1e7,1e7]$（BZOJ3224:$[-2e9,2e9]$） 题解各种平衡树的模板题（然而只会SPLAY） CODE#include #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; const int inf = 0x7fffffff; const int N = 1e5+1; struct splay{int data,ls,rs,fa,size;}a[N]; int q,root=0,tot=0; void pushup(int x){a[x].size=a[a[x].ls].size+a[a[x].rs].size+1;} void zig(int x) { int y=a[x].fa; int z=a[y].fa; a[y].fa=x;a[x].fa=z; a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y; if(y==a[z].ls) a[z].ls=x; else a[z].rs=x; pushup(y); } void zag(int x) { int y=a[x].fa; int z=a[y].fa; a[y].fa=x,a[x].fa=z; a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y; if(y==a[z].ls) a[z].ls=x; else a[z].rs=x; pushup(y); } void splay(int x,int s) { while (a[x].fa!=s) { int y=a[x].fa; int z=a[y].fa; if(z==s) { if(x==a[y].ls) zig(x); else zag(x); break; } if(y==a[z].ls) { if(x==a[y].ls) zig(y),zig(x); else zag(x),zig(x); } else { if(x==a[y].rs) zag(y),zag(x); else zig(x),zag(x); } } pushup(x); if (s==0) root=x; } int Search(int w) { int p,x=root; while (x) { p=x; if (a[x].data&gt;w) x=a[x].ls; else x=a[x].rs; } return p; } void newnode(int &amp;x,int fa,int key) { x=++tot; a[x].ls=a[x].rs=0; a[x].fa=fa; a[x].data=key; } void insert(int w) { if (root==0) { newnode(root,0,w); return; } int i=Search(w); if (w&lt;a[i].data) newnode(a[i].ls,i,w); else newnode(a[i].rs,i,w); splay(tot,0); } int get(int w) { int x=root,ans=tot+1; while(x) { if(a[x].data&gt;w){x=a[x].ls;continue;} if(a[x].data&lt;w){x=a[x].rs;continue;} if(a[x].data==w) { ans=x; x=a[x].ls; } } if(ans==tot+1) return -1; return ans; } int getmax(int x){while(a[x].rs)x=a[x].rs;return x;} int getmin(int x){while (a[x].ls)x=a[x].ls;return x;} int getpre1(int x){return getmax(a[root].ls);} int getne1(int x){return getmin(a[root].rs);} void delet(int w) { int x=get(w); splay(x,0); int pp=getpre1(x),nn=getne1(x); splay(pp,0); splay(nn,root); int y=a[x].fa; a[x].fa=0; if(x==a[y].ls) a[y].ls=0; else a[x].ls=0; pushup(y);pushup(root); } int find(int w) { int x=get(w); splay(x,0); return a[a[x].ls].size; } int findkth(int x,int k) { int s=a[a[x].ls].size; if (k==s+1) return a[x].data; if (s&gt;=k) return findkth(a[x].ls,k); else return findkth(a[x].rs,k-s-1); } int getpre(int w) { int y=get(w); insert(w); if(y!=-1)splay(y,0); int ans=getmax(a[root].ls); delet(w); return a[ans].data; } int getne(int w) { insert(w); int ans=getmin(a[root].rs); delet(w); return a[ans].data; } int main() { root=tot=0; insert(-inf);insert(inf); scanf(&quot;%d&quot;,&amp;q); while(q--) { int x,k; scanf(&quot;%d%d&quot;,&amp;x,&amp;k); if(x==1) insert(k); else if(x==2) delet(k); else if(x==3) printf(&quot;%d\\n&quot;,find(k)); else if(x==4) printf(&quot;%d\\n&quot;,findkth(root,k+1)); else if(x==5) printf(&quot;%d\\n&quot;,getpre(k)); else if(x==6) printf(&quot;%d\\n&quot;,getne(k)); } return 0; } CODE V2 #include&lt;cstdio&gt; #include&lt;iostream&gt; const int N=1e5+5; int tot,root,size[N],num[N],key[N],fa[N],son[N][2]; void pushup(int x) { size[x]=size[son[x][0]]+size[son[x][1]]+num[x]; } void zg(int x) { //push_down(fa[x]);push_down(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(z) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; pushup(y);pushup(x); } void splay(int x,int f) { while(fa[x]!=f) { int y=fa[x],z=fa[y]; if(z!=f) { if(son[z][0]==y^son[y][0]==x) zg(x); else zg(y); } zg(x); } if(!f) root=x; } void insert(int &amp;x,int v,int f) { if(!x) { x=++tot; son[x][0]=son[x][1]=0; size[x]=num[x]=1; key[x]=v;fa[x]=f; splay(x,0); return; } if(v==key[x]) { num[x]++;size[x]++; splay(x,0); return; } insert(son[x][v&gt;key[x]],v,x); pushup(x); } int get(int v) { int x=root; while(x&amp;&amp;v!=key[x]) x=son[x][v&gt;key[x]]; return x; } void delet(int x) { x=get(x);if(!x) return; splay(x,0); if(num[x]&gt;1) {num[x]--;size[x]--;return;} if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1]; else { int y=son[x][1];while(son[y][0]) y=son[y][0]; splay(y,x); son[y][0]=son[x][0];fa[son[y][0]]=y; root=y; } fa[root]=0; pushup(root); } int getrank(int v) { insert(root,v,0); int ans=size[son[root][0]]+1; delet(v); return ans; } int kth(int x) { int y=root; while(x&lt;=size[son[y][0]]||x&gt;size[son[y][0]]+num[y]) { if(x&lt;=size[son[y][0]]) y=son[y][0]; else x-=size[son[y][0]]+num[y],y=son[y][1]; } return key[y]; } int pre(int v) { insert(root,v,0); int x=son[root][0];while(son[x][1]) x=son[x][1]; delet(v); return key[x]; } int ne(int v) { insert(root,v,0); int x=son[root][1];while(son[x][0]) x=son[x][0]; delet(v); return key[x]; } int main() { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1,x,y;i&lt;=n;++i) { if(x==1) insert(root,y,0); if(x==2) delet(y); if(x==3) printf(&quot;%d\\n&quot;,getrank(y)); if(x==4) printf(&quot;%d\\n&quot;,kth(y)); if(x==5) printf(&quot;%d\\n&quot;,pre(y)); if(x==6) printf(&quot;%d\\n&quot;,ne(y)); } }","raw":"title: 普通平衡树\ndate: 2017-03-19 20:21:17\ncategories:\n  - 数据结构\n  - 平衡树\n  - SPLAY\ntags:\n  - SPLAY\n  - TREAP\n  - 模板\n---\n\n# 普通平衡树\n\n## [BZOJ3224](http://www.lydsy.com/JudgeOnline/problem.php?id=3224) [COGS1829](http://cogs.pro/cogs/problem/problem.php?pid=1829)\n\n---\n## 题目描述\n您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：\n1. 插入x数\n2. 删除x数(若有多个相同的数，因只删除一个)\n3. 查询x数的排名(若有多个相同的数，因输出最小的排名)\n4. 查询排名为x的数\n5. 求x的前驱(前驱定义为小于x，且最大的数)\n6. 求x的后继(后继定义为大于x，且最小的数)\n### 输入输出格式\n#### 输入格式：\n第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号$(1<=opt<=6)$\n\n#### 输出格式：\n对于操作3,4,5,6每行输出一个数，表示对应答案\n\n\n### 输入输出样例\n#### 输入样例：\n    10\n    1 106465\n    4 1\n    1 317721\n    1 460929\n    1 644985\n    1 84185\n    1 89851\n    6 81968\n    1 492737\n    5 493598\n    \n\n#### 输出样例：\n    106465\n    84185\n    492737\n    \n\n### 数据范围\n\n1.n的数据范围：$n<=100000$\n\n2.每个数的数据范围：$[-1e7,1e7]$（BZOJ3224:$[-2e9,2e9]$）\n\n---\n\n## 题解\n各种平衡树的模板题（然而只会SPLAY）\n\n---\n### CODE\n#include <iostream>\n\t#include<cstring>\n\t#include<algorithm>\n\t#include<cstdio>\n\tusing namespace std;\n\tconst int inf = 0x7fffffff;\n\tconst int N = 1e5+1;\n\tstruct splay{int data,ls,rs,fa,size;}a[N];  \n\tint q,root=0,tot=0;\n\tvoid pushup(int x){a[x].size=a[a[x].ls].size+a[a[x].rs].size+1;}  \n\tvoid zig(int x)  \n\t{  \n\t    int y=a[x].fa; \n\t    int z=a[y].fa; \n\t    a[y].fa=x;a[x].fa=z;  \n\t    a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y;  \n\t    if(y==a[z].ls)\ta[z].ls=x;\n\t    else \t\t\ta[z].rs=x;\n\t    pushup(y);\n\t}\n\tvoid zag(int x)\n\t{\n\t    int y=a[x].fa;  \n\t    int z=a[y].fa;\n\t    a[y].fa=x,a[x].fa=z;\n\t    a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y;\n\t    if(y==a[z].ls) \ta[z].ls=x;\n\t    else \t\t\ta[z].rs=x;\n\t    pushup(y);\n\t}\n\tvoid splay(int x,int s)  \n\t{  \n\t    while (a[x].fa!=s)  \n\t    {  \n\t        int y=a[x].fa;  \n\t        int z=a[y].fa;  \n\t        if(z==s)  \n\t        {\n\t            if(x==a[y].ls) zig(x);  \n\t            else \t\t  zag(x);  \n\t            break;  \n\t        }  \n\t        if(y==a[z].ls)  \n\t        {  \n\t            if(x==a[y].ls) zig(y),zig(x);  \n\t            else \t\t  zag(x),zig(x);  \n\t        }  \n\t        else \n\t        {  \n\t            if(x==a[y].rs) zag(y),zag(x);  \n\t            else \t\t  zig(x),zag(x);  \n\t        }  \n\t    }\n\t    pushup(x);  \n\t    if (s==0) root=x;  \n\t}  \n\tint Search(int w)  \n\t{  \n\t    int p,x=root;  \n\t    while (x)  \n\t    {  \n\t        p=x;  \n\t        if (a[x].data>w) x=a[x].ls;  \n\t        else x=a[x].rs;  \n\t    }  \n\t    return p;  \n\t}  \n\tvoid newnode(int &x,int fa,int key)  \n\t{  \n\t    x=++tot;  \n\t    a[x].ls=a[x].rs=0;  \n\t    a[x].fa=fa;  \n\t    a[x].data=key;  \n\t}  \n\tvoid insert(int w)  \n\t{  \n\t    if (root==0)  \n\t    {  \n\t        newnode(root,0,w);  \n\t        return;  \n\t    }  \n\t    int i=Search(w);  \n\t    if (w<a[i].data) newnode(a[i].ls,i,w);     \n\t    else newnode(a[i].rs,i,w);\n\t    splay(tot,0);  \n\t}  \n\tint get(int w)\n\t{\n\t    int x=root,ans=tot+1;  \n\t    while(x)  \n\t    {  \n\t        if(a[x].data>w){x=a[x].ls;continue;}  \n\t        if(a[x].data<w){x=a[x].rs;continue;}  \n\t        if(a[x].data==w)  \n\t        {  \n\t            ans=x;\n\t            x=a[x].ls; \n\t        }  \n\t    }  \n\t    if(ans==tot+1) return -1;\n\t    return ans;  \n\t}\n\tint getmax(int x){while(a[x].rs)x=a[x].rs;return x;}  \n\tint getmin(int x){while (a[x].ls)x=a[x].ls;return x;}  \n\tint getpre1(int x){return getmax(a[root].ls);}  \n\tint getne1(int x){return getmin(a[root].rs);}\n\tvoid delet(int w)  \n\t{  \n\t    int x=get(w);  \n\t    splay(x,0);  \n\t    int pp=getpre1(x),nn=getne1(x);  \n\t    splay(pp,0);  \n\t    splay(nn,root);  \n\t    int y=a[x].fa;  \n\t    a[x].fa=0;  \n\t    if(x==a[y].ls) a[y].ls=0;\n\t    else \t\t  a[x].ls=0;\n\t    pushup(y);pushup(root);  \n\t}  \n\tint find(int w)  \n\t{  \n\t    int x=get(w);  \n\t    splay(x,0);  \n\t    return a[a[x].ls].size;  \n\t}  \n\tint findkth(int x,int k)  \n\t{  \n\t    int s=a[a[x].ls].size;  \n\t    if (k==s+1) return a[x].data;  \n\t    if (s>=k) return findkth(a[x].ls,k);  \n\t    else return findkth(a[x].rs,k-s-1);  \n\t}  \n\tint getpre(int w) \n\t{  \n\t    int y=get(w);  \n\t    insert(w);  \n\t    if(y!=-1)splay(y,0);  \n\t    int ans=getmax(a[root].ls);  \n\t    delet(w);  \n\t    return a[ans].data;  \n\t}  \n\tint getne(int w)  \n\t{  \n\t    insert(w);\n\t    int ans=getmin(a[root].rs);\n\t    delet(w);\n\t    return a[ans].data;\n\t}\n\tint main()\n\t{\n\t    root=tot=0;\n\t    insert(-inf);insert(inf);\n\t    scanf(\"%d\",&q);\n\t    while(q--)\n\t    {\n\t        int x,k;\n\t        scanf(\"%d%d\",&x,&k);\n\t        if(x==1) \t  insert(k);\n\t        else if(x==2) delet(k);\n\t        else if(x==3) printf(\"%d\\n\",find(k));\n\t        else if(x==4) printf(\"%d\\n\",findkth(root,k+1));\n\t        else if(x==5) printf(\"%d\\n\",getpre(k));\n\t        else if(x==6) printf(\"%d\\n\",getne(k));\n\t    }\n\t    return 0;\n\t}    \n    \n    \n ---\n ### CODE V2\n \n     #include<cstdio>\n     #include<iostream>\n    const int N=1e5+5;\n    int tot,root,size[N],num[N],key[N],fa[N],son[N][2];\n    void pushup(int x)\n    {\n        size[x]=size[son[x][0]]+size[son[x][1]]+num[x];\n    }\n    void zg(int x)\n    {\n        //push_down(fa[x]);push_down(x); \n        int y=fa[x],z=fa[y],t=(son[y][0]==x);\n        if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n        son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n        son[x][t]=y;fa[y]=x;\n        pushup(y);pushup(x);\n    }\n    void splay(int x,int f)\n    {\n        while(fa[x]!=f)\n        {\n            int y=fa[x],z=fa[y];\n            if(z!=f)\n            {\n                if(son[z][0]==y^son[y][0]==x) zg(x);\n                else zg(y);\n            } \n            zg(x);\t\n        }\n        if(!f) root=x;\n    }\n    void insert(int &x,int v,int f)\n    {\n        if(!x)\n        {\n            x=++tot;\n            son[x][0]=son[x][1]=0;\n            size[x]=num[x]=1;\n            key[x]=v;fa[x]=f;\n            splay(x,0);\n            return;\n        }\n        if(v==key[x])\n        {\n            num[x]++;size[x]++;\n            splay(x,0);\n            return;\n        }\n        insert(son[x][v>key[x]],v,x);\n        pushup(x);\n    }\n    int get(int v)\n    {\n        int x=root;\n        while(x&&v!=key[x]) x=son[x][v>key[x]];\n        return x;\n    }\n    void delet(int x)\n    {\n        x=get(x);if(!x) return;\n        splay(x,0);\n        if(num[x]>1) {num[x]--;size[x]--;return;}\n        if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1];\n        else\n        {\n            int y=son[x][1];while(son[y][0]) y=son[y][0];\n            splay(y,x);\n            son[y][0]=son[x][0];fa[son[y][0]]=y;\n            root=y;\n        }\n        fa[root]=0;\n        pushup(root);\n    }\n    int getrank(int v)\n    {\n        insert(root,v,0);\n        int ans=size[son[root][0]]+1;\n        delet(v);\n        return ans;\n    }\n    int kth(int x)\n    {\n        int y=root;\n        while(x<=size[son[y][0]]||x>size[son[y][0]]+num[y])\n        {\n            if(x<=size[son[y][0]]) y=son[y][0];\n            else x-=size[son[y][0]]+num[y],y=son[y][1];\n        }\n        return key[y];\n    }\n    int pre(int v)\n    {\n        insert(root,v,0);\n        int x=son[root][0];while(son[x][1]) x=son[x][1];\n        delet(v);\n        return key[x];\n    }\n    int ne(int v)\n    {\n        insert(root,v,0);\n        int x=son[root][1];while(son[x][0]) x=son[x][0];\n        delet(v);\n        return key[x];\n    }\n    int main()\n    {\n        int n;\n        scanf(\"%d\",&n);\n        for(int i=1,x,y;i<=n;++i)\n        {\n            if(x==1) \t\tinsert(root,y,0);\n            if(x==2) \t\tdelet(y);\n            if(x==3) \t\tprintf(\"%d\\n\",getrank(y));\n            if(x==4) \t\tprintf(\"%d\\n\",kth(y));\n            if(x==5) \t\tprintf(\"%d\\n\",pre(y));\n            if(x==6)\t\tprintf(\"%d\\n\",ne(y));\n        }\n    }","content":"<h1 id=\"普通平衡树\"><a href=\"#普通平衡树\" class=\"headerlink\" title=\"普通平衡树\"></a>普通平衡树</h1><h2 id=\"BZOJ3224-COGS1829\"><a href=\"#BZOJ3224-COGS1829\" class=\"headerlink\" title=\"BZOJ3224 COGS1829\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=3224\" target=\"_blank\" rel=\"external\">BZOJ3224</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1829\" target=\"_blank\" rel=\"external\">COGS1829</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：</p>\n<ol>\n<li>插入x数</li>\n<li>删除x数(若有多个相同的数，因只删除一个)</li>\n<li>查询x数的排名(若有多个相同的数，因输出最小的排名)</li>\n<li>查询排名为x的数</li>\n<li>求x的前驱(前驱定义为小于x，且最大的数)</li>\n<li>求x的后继(后继定义为大于x，且最小的数)<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4>第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号$(1&lt;=opt&lt;=6)$</li>\n</ol>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于操作3,4,5,6每行输出一个数，表示对应答案</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>10\n1 106465\n4 1\n1 317721\n1 460929\n1 644985\n1 84185\n1 89851\n6 81968\n1 492737\n5 493598\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>106465\n84185\n492737\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>1.n的数据范围：$n&lt;=100000$</p>\n<p>2.每个数的数据范围：$[-1e7,1e7]$（BZOJ3224:$[-2e9,2e9]$）</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>各种平衡树的模板题（然而只会SPLAY）</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><p>#include <iostream></iostream></p>\n<pre><code>#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nconst int inf = 0x7fffffff;\nconst int N = 1e5+1;\nstruct splay{int data,ls,rs,fa,size;}a[N];  \nint q,root=0,tot=0;\nvoid pushup(int x){a[x].size=a[a[x].ls].size+a[a[x].rs].size+1;}  \nvoid zig(int x)  \n{  \n    int y=a[x].fa; \n    int z=a[y].fa; \n    a[y].fa=x;a[x].fa=z;  \n    a[y].ls=a[x].rs;a[a[x].rs].fa=y;a[x].rs=y;  \n    if(y==a[z].ls)    a[z].ls=x;\n    else             a[z].rs=x;\n    pushup(y);\n}\nvoid zag(int x)\n{\n    int y=a[x].fa;  \n    int z=a[y].fa;\n    a[y].fa=x,a[x].fa=z;\n    a[y].rs=a[x].ls;a[a[x].ls].fa=y;a[x].ls=y;\n    if(y==a[z].ls)     a[z].ls=x;\n    else             a[z].rs=x;\n    pushup(y);\n}\nvoid splay(int x,int s)  \n{  \n    while (a[x].fa!=s)  \n    {  \n        int y=a[x].fa;  \n        int z=a[y].fa;  \n        if(z==s)  \n        {\n            if(x==a[y].ls) zig(x);  \n            else           zag(x);  \n            break;  \n        }  \n        if(y==a[z].ls)  \n        {  \n            if(x==a[y].ls) zig(y),zig(x);  \n            else           zag(x),zig(x);  \n        }  \n        else \n        {  \n            if(x==a[y].rs) zag(y),zag(x);  \n            else           zig(x),zag(x);  \n        }  \n    }\n    pushup(x);  \n    if (s==0) root=x;  \n}  \nint Search(int w)  \n{  \n    int p,x=root;  \n    while (x)  \n    {  \n        p=x;  \n        if (a[x].data&gt;w) x=a[x].ls;  \n        else x=a[x].rs;  \n    }  \n    return p;  \n}  \nvoid newnode(int &amp;x,int fa,int key)  \n{  \n    x=++tot;  \n    a[x].ls=a[x].rs=0;  \n    a[x].fa=fa;  \n    a[x].data=key;  \n}  \nvoid insert(int w)  \n{  \n    if (root==0)  \n    {  \n        newnode(root,0,w);  \n        return;  \n    }  \n    int i=Search(w);  \n    if (w&lt;a[i].data) newnode(a[i].ls,i,w);     \n    else newnode(a[i].rs,i,w);\n    splay(tot,0);  \n}  \nint get(int w)\n{\n    int x=root,ans=tot+1;  \n    while(x)  \n    {  \n        if(a[x].data&gt;w){x=a[x].ls;continue;}  \n        if(a[x].data&lt;w){x=a[x].rs;continue;}  \n        if(a[x].data==w)  \n        {  \n            ans=x;\n            x=a[x].ls; \n        }  \n    }  \n    if(ans==tot+1) return -1;\n    return ans;  \n}\nint getmax(int x){while(a[x].rs)x=a[x].rs;return x;}  \nint getmin(int x){while (a[x].ls)x=a[x].ls;return x;}  \nint getpre1(int x){return getmax(a[root].ls);}  \nint getne1(int x){return getmin(a[root].rs);}\nvoid delet(int w)  \n{  \n    int x=get(w);  \n    splay(x,0);  \n    int pp=getpre1(x),nn=getne1(x);  \n    splay(pp,0);  \n    splay(nn,root);  \n    int y=a[x].fa;  \n    a[x].fa=0;  \n    if(x==a[y].ls) a[y].ls=0;\n    else           a[x].ls=0;\n    pushup(y);pushup(root);  \n}  \nint find(int w)  \n{  \n    int x=get(w);  \n    splay(x,0);  \n    return a[a[x].ls].size;  \n}  \nint findkth(int x,int k)  \n{  \n    int s=a[a[x].ls].size;  \n    if (k==s+1) return a[x].data;  \n    if (s&gt;=k) return findkth(a[x].ls,k);  \n    else return findkth(a[x].rs,k-s-1);  \n}  \nint getpre(int w) \n{  \n    int y=get(w);  \n    insert(w);  \n    if(y!=-1)splay(y,0);  \n    int ans=getmax(a[root].ls);  \n    delet(w);  \n    return a[ans].data;  \n}  \nint getne(int w)  \n{  \n    insert(w);\n    int ans=getmin(a[root].rs);\n    delet(w);\n    return a[ans].data;\n}\nint main()\n{\n    root=tot=0;\n    insert(-inf);insert(inf);\n    scanf(&quot;%d&quot;,&amp;q);\n    while(q--)\n    {\n        int x,k;\n        scanf(&quot;%d%d&quot;,&amp;x,&amp;k);\n        if(x==1)       insert(k);\n        else if(x==2) delet(k);\n        else if(x==3) printf(&quot;%d\\n&quot;,find(k));\n        else if(x==4) printf(&quot;%d\\n&quot;,findkth(root,k+1));\n        else if(x==5) printf(&quot;%d\\n&quot;,getpre(k));\n        else if(x==6) printf(&quot;%d\\n&quot;,getne(k));\n    }\n    return 0;\n}    \n</code></pre><hr>\n<h3 id=\"CODE-V2\"><a href=\"#CODE-V2\" class=\"headerlink\" title=\"CODE V2\"></a>CODE V2</h3><pre><code> #include&lt;cstdio&gt;\n #include&lt;iostream&gt;\nconst int N=1e5+5;\nint tot,root,size[N],num[N],key[N],fa[N],son[N][2];\nvoid pushup(int x)\n{\n    size[x]=size[son[x][0]]+size[son[x][1]]+num[x];\n}\nvoid zg(int x)\n{\n    //push_down(fa[x]);push_down(x); \n    int y=fa[x],z=fa[y],t=(son[y][0]==x);\n    if(z) son[z][son[z][1]==y]=x;fa[x]=z;\n    son[y][!t]=son[x][t];fa[son[y][!t]]=y;\n    son[x][t]=y;fa[y]=x;\n    pushup(y);pushup(x);\n}\nvoid splay(int x,int f)\n{\n    while(fa[x]!=f)\n    {\n        int y=fa[x],z=fa[y];\n        if(z!=f)\n        {\n            if(son[z][0]==y^son[y][0]==x) zg(x);\n            else zg(y);\n        } \n        zg(x);    \n    }\n    if(!f) root=x;\n}\nvoid insert(int &amp;x,int v,int f)\n{\n    if(!x)\n    {\n        x=++tot;\n        son[x][0]=son[x][1]=0;\n        size[x]=num[x]=1;\n        key[x]=v;fa[x]=f;\n        splay(x,0);\n        return;\n    }\n    if(v==key[x])\n    {\n        num[x]++;size[x]++;\n        splay(x,0);\n        return;\n    }\n    insert(son[x][v&gt;key[x]],v,x);\n    pushup(x);\n}\nint get(int v)\n{\n    int x=root;\n    while(x&amp;&amp;v!=key[x]) x=son[x][v&gt;key[x]];\n    return x;\n}\nvoid delet(int x)\n{\n    x=get(x);if(!x) return;\n    splay(x,0);\n    if(num[x]&gt;1) {num[x]--;size[x]--;return;}\n    if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1];\n    else\n    {\n        int y=son[x][1];while(son[y][0]) y=son[y][0];\n        splay(y,x);\n        son[y][0]=son[x][0];fa[son[y][0]]=y;\n        root=y;\n    }\n    fa[root]=0;\n    pushup(root);\n}\nint getrank(int v)\n{\n    insert(root,v,0);\n    int ans=size[son[root][0]]+1;\n    delet(v);\n    return ans;\n}\nint kth(int x)\n{\n    int y=root;\n    while(x&lt;=size[son[y][0]]||x&gt;size[son[y][0]]+num[y])\n    {\n        if(x&lt;=size[son[y][0]]) y=son[y][0];\n        else x-=size[son[y][0]]+num[y],y=son[y][1];\n    }\n    return key[y];\n}\nint pre(int v)\n{\n    insert(root,v,0);\n    int x=son[root][0];while(son[x][1]) x=son[x][1];\n    delet(v);\n    return key[x];\n}\nint ne(int v)\n{\n    insert(root,v,0);\n    int x=son[root][1];while(son[x][0]) x=son[x][0];\n    delet(v);\n    return key[x];\n}\nint main()\n{\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1,x,y;i&lt;=n;++i)\n    {\n        if(x==1)         insert(root,y,0);\n        if(x==2)         delet(y);\n        if(x==3)         printf(&quot;%d\\n&quot;,getrank(y));\n        if(x==4)         printf(&quot;%d\\n&quot;,kth(y));\n        if(x==5)         printf(&quot;%d\\n&quot;,pre(y));\n        if(x==6)        printf(&quot;%d\\n&quot;,ne(y));\n    }\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/19/普通平衡树/","excerpt":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"平衡树","slug":"数据结构/平衡树","permalink":"https://prostkhala.github.io/categories/数据结构/平衡树/"},{"name":"SPLAY","slug":"数据结构/平衡树/SPLAY","permalink":"https://prostkhala.github.io/categories/数据结构/平衡树/SPLAY/"}],"tags":[{"name":"SPLAY","slug":"SPLAY","permalink":"https://prostkhala.github.io/tags/SPLAY/"},{"name":"模板","slug":"模板","permalink":"https://prostkhala.github.io/tags/模板/"},{"name":"TREAP","slug":"TREAP","permalink":"https://prostkhala.github.io/tags/TREAP/"}]},{"title":"DNA Sequence","date":"2017-03-18T02:51:23.000Z","path":"2017/03/18/DNA Sequence/","text":"DNA SequencePOJ2778 题目描述It’s well known that DNA Sequence is a sequence only contains A, C, T and G, and it’s very useful to analyze a segment of DNA Sequence，For example, if a animal’s DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don’t contain those segments. Suppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. 输入输出格式输入格式：First line contains two integer m (0 &lt;= m &lt;= 10), n (1 &lt;= n &lt;=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences. Next m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. 输出格式：An integer, the number of DNA sequences, mod 100000. 输入输出样例输入样例：4 3 AT AC AG AA 输出样例：36 题解题目大意为给定n个病毒串，求不包含这些病毒串且长度为m的资源串个数（均由A,G,C,T组成）。 这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即$res [ i ] [ t ]$存的是从i到t恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res’=res^m$时，$res’[i][t]$表示从i到t恰好走m步能到达的方案数。 有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点（0）到叶节点（i）的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为将赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其fail指针指向病毒串），只需要特判一下即可。 刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了…后来因为取模操作过多又TLE了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int N =200+1; const int mod =100000; const int maxf =255; long long n,m,tr[N][4],tot,tmp,fail[N]; int idd[N]; bool tag[N]; char s[N]; int ss[4]={&#39;A&#39;,&#39;G&#39;,&#39;C&#39;,&#39;T&#39;}; struct martix{long long a[N][N];}res,ans; martix operator * (martix c,martix b) { martix ret; memset(ret.a,0,sizeof(ret.a)); for(int i=0;i&lt;=tot;++i) for(int t=0;t&lt;=tot;++t) { for(int k=0;k&lt;=tot;++k) ret.a[i][t]+=c.a[i][k]*b.a[k][t]; ret.a[i][t]%=mod; } return ret; } void init(){idd[ss[0]]=0;idd[ss[1]]=1;idd[ss[2]]=2;idd[ss[3]]=3;} void insert(int num) { int now=0; int n=strlen(s); for(int i=0;i&lt;n;++i) { if(tr[now][idd[s[i]]]==-1) { tr[now][idd[s[i]]]=++tot; for(int j=0;j&lt;4;++j)tr[tot][j]=-1; // tag[tot]=0; } now=tr[now][idd[s[i]]]; } tag[now]=true; } void getfail() { queue&lt;int&gt;q;fail[0]=0; for(int j=0;j&lt;4;++j) if(tr[0][j]!=-1)q.push(tr[0][j]),fail[tr[0][j]]=0; else tr[0][j]=0; while(!q.empty()) { int x=q.front();q.pop(); if(tag[fail[x]])tag[x]=true; for(int j=0;j&lt;4;++j) if(tr[x][j]!=-1) fail[tr[x][j]]=tr[fail[x]][j],q.push(tr[x][j]); else tr[x][j] =tr[fail[x]][j]; } } void slove() { for(int i=0;i&lt;=tot;i++) for(int j=0;j&lt;4;j++) if(!tag[i]&amp;&amp;!tag[tr[i][j]]) res.a[i][tr[i][j]]++; } int main() { init(); scanf(&quot;%d&quot;,&amp;n);scanf(&quot;%d&quot;,&amp;m); for(int i=0;i&lt;4;++i)tr[0][i]=-1; for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s),insert(i); getfail(); slove(); for(int i=0;i&lt;=tot;++i)ans.a[i][i]=1; if(!m){cout&lt;&lt;0;return 0;} while(m) { if(m&amp;1) ans=ans*res; m/=2; res=res*res; } int anss=0; for(int i=0;i&lt;=tot;++i)(anss+=ans.a[0][i])%=mod; cout&lt;&lt;anss; }","raw":"title: DNA Sequence\ndate: 2017-03-18 10:51:23\ncategories:\n  - 数据结构\n  - Hollerith-type\n  - AC自动机\n  - \ntags:\n  - AC自动机\n  - 矩阵快速幂\n  - KMP\n---\n\n# DNA Sequence\n\n## [POJ2778](http://poj.org/problem?id=2778)\n\n---\n## 题目描述\nIt's well known that DNA Sequence is a sequence only contains A, C, T and G, and it's very useful to analyze a segment of DNA Sequence，For example, if a animal's DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don't contain those segments.\n\nSuppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. \n### 输入输出格式\n#### 输入格式：\nFirst line contains two integer m (0 <= m <= 10), n (1 <= n <=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences.\n\nNext m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. \n\n\n#### 输出格式：\nAn integer, the number of DNA sequences, mod 100000.\n\n\n### 输入输出样例\n#### 输入样例：\n    4 3\n    AT\n    AC\n    AG\n    AA\n    \n\n#### 输出样例：\n\t36\n---\n\n## 题解\n\n题目大意为给定n个病毒串，求不包含这些病毒串且长度为m的资源串个数（均由A,G,C,T组成）。\n\n这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即\n$res [ i ] [ t ]$存的是从i到t恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res'=res^m$时，$res'[i][t]$表示从i到t恰好走m步能到达的方案数。\n\n有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点（0）\n到叶节点（i）的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为将赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其fail指针指向病毒串），只需要特判一下即可。\n\n刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了...后来因为取模操作过多又TLE了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。\n\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<queue>\n    using namespace std;\n    const int  N =200+1;\n    const int mod =100000;\n    const int maxf =255;\n    long long n,m,tr[N][4],tot,tmp,fail[N];\n    int idd[N];\n    bool tag[N];\n    char s[N];\n    int ss[4]={'A','G','C','T'};\n    struct martix{long long a[N][N];}res,ans;\n    martix operator * (martix c,martix b)\n    {\n        martix ret;\n        memset(ret.a,0,sizeof(ret.a));\n        for(int i=0;i<=tot;++i)\n        for(int t=0;t<=tot;++t)\n        {\n            for(int k=0;k<=tot;++k)\n            ret.a[i][t]+=c.a[i][k]*b.a[k][t];\n            ret.a[i][t]%=mod;\n        }\n        return ret;\n    }\n    void init(){idd[ss[0]]=0;idd[ss[1]]=1;idd[ss[2]]=2;idd[ss[3]]=3;}\n    void insert(int num)\n    {\n        int now=0;\n        int n=strlen(s);\n        for(int i=0;i<n;++i)\n        {\n            if(tr[now][idd[s[i]]]==-1)\n            {\n                tr[now][idd[s[i]]]=++tot;\n                for(int j=0;j<4;++j)tr[tot][j]=-1;\t\n            //\ttag[tot]=0;\n            }\n            now=tr[now][idd[s[i]]];\n        }\n        tag[now]=true;\n    }\n    void getfail()\n    {\n        queue<int>q;fail[0]=0;\n        for(int j=0;j<4;++j)\n        if(tr[0][j]!=-1)q.push(tr[0][j]),fail[tr[0][j]]=0;\n        else\t\t\ttr[0][j]=0;\n\n        while(!q.empty())\n        {\n            int x=q.front();q.pop();\n            if(tag[fail[x]])tag[x]=true;\n            for(int j=0;j<4;++j)\n            if(tr[x][j]!=-1)\tfail[tr[x][j]]=tr[fail[x]][j],q.push(tr[x][j]);\t\n            else\t\t\t\t\t tr[x][j] =tr[fail[x]][j];\n        }\n    }\n    void slove()\n    {\n        for(int i=0;i<=tot;i++)\n        for(int j=0;j<4;j++)\n        if(!tag[i]&&!tag[tr[i][j]]) res.a[i][tr[i][j]]++;\n\n    }\n    int main()\n    {\n        init();\n        scanf(\"%d\",&n);scanf(\"%d\",&m);\n        for(int i=0;i<4;++i)tr[0][i]=-1;\n        for(int i=1;i<=n;++i)scanf(\"%s\",s),insert(i);\n        getfail();\n        slove();\n        for(int i=0;i<=tot;++i)ans.a[i][i]=1;\n        if(!m){cout<<0;return 0;}\n        while(m)\n        {\n            if(m&1) ans=ans*res;\n            m/=2;\n            res=res*res;\n        }\n        int anss=0;\n        for(int i=0;i<=tot;++i)(anss+=ans.a[0][i])%=mod;\n        cout<<anss;\n    }\n\n","content":"<h1 id=\"DNA-Sequence\"><a href=\"#DNA-Sequence\" class=\"headerlink\" title=\"DNA Sequence\"></a>DNA Sequence</h1><h2 id=\"POJ2778\"><a href=\"#POJ2778\" class=\"headerlink\" title=\"POJ2778\"></a><a href=\"http://poj.org/problem?id=2778\" target=\"_blank\" rel=\"external\">POJ2778</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>It’s well known that DNA Sequence is a sequence only contains A, C, T and G, and it’s very useful to analyze a segment of DNA Sequence，For example, if a animal’s DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don’t contain those segments.</p>\n<p>Suppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n. </p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>First line contains two integer m (0 &lt;= m &lt;= 10), n (1 &lt;= n &lt;=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences.</p>\n<p>Next m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10. </p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>An integer, the number of DNA sequences, mod 100000.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>4 3\nAT\nAC\nAG\nAA\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>36\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意为给定n个病毒串，求不包含这些病毒串且长度为m的资源串个数（均由A,G,C,T组成）。</p>\n<p>这是一题比较典型的矩阵乘法与AC自动机结合的题，此处用到了一个叫做邻接矩阵的概念，即<br>$res [ i ] [ t ]$存的是从i到t恰好一步能到达的方案数（当边为双向时，该矩阵关于主对角线对称），那么当$res’=res^m$时，$res’[i][t]$表示从i到t恰好走m步能到达的方案数。</p>\n<p>有了这个概念，我们就可以将AC自动机看作一棵树，每一种不同的资源串即为一种从根节点（0）<br>到叶节点（i）的方案。由此建立AC自动机，由于该图是一棵树，两点之间路径唯一，且只能向下走，那么$res$的初始化即为将赋值$res[i][son[i]]$,但此时必然会包含所有的病毒串，那么不妨利用AC自动机的功能记录一下哪些点不能走到，然后进行初始化。需要注意的是，有些资源串虽不是病毒串，但也包含病毒串（即其fail指针指向病毒串），只需要特判一下即可。</p>\n<p>刚开些写的时候，因为矩阵开的太大，导致还没进入主程序就爆栈了…后来因为取模操作过多又TLE了。纠结了好久为什么当该节点没有被病毒串遍历时要赋值成$tr[fail[x]][j]$，导致$res[i][son[i]]++$写成了$res[i][son[i]]=1$又挂了。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int  N =200+1;\nconst int mod =100000;\nconst int maxf =255;\nlong long n,m,tr[N][4],tot,tmp,fail[N];\nint idd[N];\nbool tag[N];\nchar s[N];\nint ss[4]={&#39;A&#39;,&#39;G&#39;,&#39;C&#39;,&#39;T&#39;};\nstruct martix{long long a[N][N];}res,ans;\nmartix operator * (martix c,martix b)\n{\n    martix ret;\n    memset(ret.a,0,sizeof(ret.a));\n    for(int i=0;i&lt;=tot;++i)\n    for(int t=0;t&lt;=tot;++t)\n    {\n        for(int k=0;k&lt;=tot;++k)\n        ret.a[i][t]+=c.a[i][k]*b.a[k][t];\n        ret.a[i][t]%=mod;\n    }\n    return ret;\n}\nvoid init(){idd[ss[0]]=0;idd[ss[1]]=1;idd[ss[2]]=2;idd[ss[3]]=3;}\nvoid insert(int num)\n{\n    int now=0;\n    int n=strlen(s);\n    for(int i=0;i&lt;n;++i)\n    {\n        if(tr[now][idd[s[i]]]==-1)\n        {\n            tr[now][idd[s[i]]]=++tot;\n            for(int j=0;j&lt;4;++j)tr[tot][j]=-1;    \n        //    tag[tot]=0;\n        }\n        now=tr[now][idd[s[i]]];\n    }\n    tag[now]=true;\n}\nvoid getfail()\n{\n    queue&lt;int&gt;q;fail[0]=0;\n    for(int j=0;j&lt;4;++j)\n    if(tr[0][j]!=-1)q.push(tr[0][j]),fail[tr[0][j]]=0;\n    else            tr[0][j]=0;\n\n    while(!q.empty())\n    {\n        int x=q.front();q.pop();\n        if(tag[fail[x]])tag[x]=true;\n        for(int j=0;j&lt;4;++j)\n        if(tr[x][j]!=-1)    fail[tr[x][j]]=tr[fail[x]][j],q.push(tr[x][j]);    \n        else                     tr[x][j] =tr[fail[x]][j];\n    }\n}\nvoid slove()\n{\n    for(int i=0;i&lt;=tot;i++)\n    for(int j=0;j&lt;4;j++)\n    if(!tag[i]&amp;&amp;!tag[tr[i][j]]) res.a[i][tr[i][j]]++;\n\n}\nint main()\n{\n    init();\n    scanf(&quot;%d&quot;,&amp;n);scanf(&quot;%d&quot;,&amp;m);\n    for(int i=0;i&lt;4;++i)tr[0][i]=-1;\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s),insert(i);\n    getfail();\n    slove();\n    for(int i=0;i&lt;=tot;++i)ans.a[i][i]=1;\n    if(!m){cout&lt;&lt;0;return 0;}\n    while(m)\n    {\n        if(m&amp;1) ans=ans*res;\n        m/=2;\n        res=res*res;\n    }\n    int anss=0;\n    for(int i=0;i&lt;=tot;++i)(anss+=ans.a[0][i])%=mod;\n    cout&lt;&lt;anss;\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/18/DNA Sequence/","excerpt":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"Hollerith-type","slug":"数据结构/Hollerith-type","permalink":"https://prostkhala.github.io/categories/数据结构/Hollerith-type/"},{"name":"AC自动机","slug":"数据结构/Hollerith-type/AC自动机","permalink":"https://prostkhala.github.io/categories/数据结构/Hollerith-type/AC自动机/"}],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://prostkhala.github.io/tags/AC自动机/"},{"name":"KMP","slug":"KMP","permalink":"https://prostkhala.github.io/tags/KMP/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://prostkhala.github.io/tags/矩阵快速幂/"}]},{"title":"NOIP模拟赛 2017 3 17","date":"2017-03-17T12:50:23.000Z","path":"2017/03/17/NOIP模拟赛 2017 3 17/","text":"T1 计算几何 题目描述花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问题。今天，他想到了一个十分有意思的题目： 首先，花花会在 x 轴正半轴和 y 轴正半轴分别挑选 n 个点。随后，他将 x 轴的点与 y 轴的点一一连接，形成 n 条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅有一种。最后，花花会给出 m 个询问。对于每个询问，将会给定一个点 P($x_p$ ,$y_p$ )，问线段OP（O 为坐标原点）与 n 条线段会产生多少个交点？ 输入输出格式输入格式：第 1 行包含一个正整数 n，表示线段的数量； 第 2 行包含 n 个正整数，表示花花在 x 轴选取的点的横坐标； 第 3 行包含 n 个正整数，表示花花在 y 轴选取的点的纵坐标； 第 4 行包含一个正整数 m，表示询问数量； 随后 m 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。 输出格式：共 m 行，每行包含一个非负整数，表示你对这条询问给出的答案。 输入输出样例输入样例：3 4 5 3 3 5 4 2 1 1 3 3 输出样例：0 3 数据范围对于 40% 的数据：n,m ≤ $10$； 另有 20% 的数据：n,m ≤ $100$； 另有 20% 的数据：n,m ≤ $1000$； 对于 100% 的数据：n,m ≤ $10^5$,y &lt; $2^{31}$ 题解本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $y_p$ 与 $y_{mid}$ 大小即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N =1e5+1; int n,m,x[N],y[N]; double a[N]; typedef double db; inline void get(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int main() { // freopen(&quot;geometry.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;geometry.out&quot;,&quot;w&quot;,stdout); get(n); for(int i=1;i&lt;=n;++i)get(x[i]);sort(x+1,x+n+1); for(int i=1;i&lt;=n;++i)get(y[i]);sort(y+1,y+n+1); get(m); for(int i=1,xx,yy;i&lt;=m;++i) { get(xx);get(yy); int l=0,r=n,mid; while(l!=r) { mid=l+r+1&gt;&gt;1; if(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid])); double yt=a[mid]*(db)xx+y[mid]; if(yt&lt;=(db)yy) l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,l); } } T2 花花的聚会 题目描述花花住在 H 国。H 国有 n 个城市，其中 1 号城市为其首都。城市间有 n − 1 条单向道路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市走到首都的路径是唯一的。 过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 m 种过路券，每张过路券以三个整数表示：v k w：你可以在城市 v 以价格 w 买到一张过路券。这张券可以使用 k 次。这意味着，拿着这张券通过了 k 条道路之后，这张券就不能再使用了。 请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，并且在所在的城市再买一张。 花花家在首都。他有 q 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。 花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮他么？ 输入输出格式输入格式：输入的第一行包含两个空格隔开的整数 n 和 m，表示 H 国的城市数量和过路券的种数。 之后的 n − 1 行各自包含两个数 a i 和 b i ，代表城市 a i 到城市 b i 间有一条单向道路。 之后的 m 行每行包括三个整数 v i ,k i 和 w i ，表示一种过路券。 下一行包含一个整数 q，表示花花朋友的数量。 之后的 q 行各自包含一个整数，表示花花朋友的所在城市。 输出格式：输出共 q 行，每一行代表一位朋友的路费。 输入输出样例输入样例：7 7 3 1 2 1 7 6 6 3 5 3 4 3 7 2 3 7 1 1 2 3 5 3 6 2 4 2 4 5 3 10 6 1 20 3 5 6 7 输出样例：10 22 5 数据范围对于 40% 的数据：n,m,q ≤ 10,w i ≤ 10； 另有 20% 的数据：n,m,q ≤ 500,w i ≤ 100； 另有 20% 的数据：n,m,q ≤ 5000,w i ≤ 1000； 对于 100% 的数据：n,m,q ≤ 10 5 ,w i ≤ 10000,1 ≤ v i ,k i ≤ n。 题解树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：$f[y] = min ( f[x] + w[y][i] )( x 为 y 祖先 &amp;&amp; dep[x] - dep[y] &gt; = k[y][i] )$ 先进行拓扑排序，顺序进行操作。对于寻找$min(f[x])$的操作，则可以通过LCA或树链剖分实现。(要开 long long 不然会爆) CODE#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; const int inf =0x7fffffff; const int N =1e5+1; const int maxlogn =21; using namespace std; int deep[N],head[N],head2[N]; long long st[N][maxlogn],minn[N][maxlogn],f[N]; int tot,tot2,n,m,qu; struct edg{int t,ne;}e[N*2]; struct edg2{int k,w,ne;}e2[N*2]; void in(int x,int y) { e[++tot].t=y; e[tot].ne=head[x]; head[x]=tot; return; } void in2(int x,int k,int w) { e2[++tot2].k=k; e2[tot2].w=w; e2[tot2].ne=head2[x]; head2[x]=tot2; return; } void getf(int x,int pre) { st[x][0]=pre;minn[x][0]=f[pre]; for(int i=1;i&lt;maxlogn;i++) { st[x][i]=st[st[x][i-1]][i-1]; minn[x][i]=min(minn[x][i-1],minn[st[x][i-1]][i-1]); } f[x]=x==1?0:inf; for(int i=head2[x];i;i=e2[i].ne) { long long tmp=inf,y=x,k=e2[i].k,p=0; while(k) { if(k&amp;1)tmp=min(tmp,minn[y][p]),y=st[y][p]; p++;k&gt;&gt;=1; } f[x]=min(f[x],tmp+e2[i].w); } for(int i=head[x];i;i=e[i].ne) { int y=e[i].t; if(y!=pre)getf(y,x); } return; } int main() { // freopen(&quot;party.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;party.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x,y;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x); for(int i=1,x,k,w;i&lt;=m;i++)scanf(&quot;%d%d%d&quot;,&amp;x,&amp;k,&amp;w),in2(x,k,w); scanf(&quot;%d&quot;,&amp;qu);getf(1,1); for(int i=1,x;i&lt;=qu;i++){scanf(&quot;%d&quot;,&amp;x);printf(&quot;%d\\n&quot;,f[x]);} } T3 文本编辑器 题目描述九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一些功能。 功能列表如下： &lt; w w 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。 该命令将选定光标向左移动，如果已经是最左端则不移动。 命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。 &gt; w w 同上。 与&lt; 命令不同的是，该命令将光标向右移动。 命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。 I w c w 同上。 c 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。 该命令始终输出“T”。 D w w 同上。 代表删除该光标右侧的一个字符。 命令执行成功时输出“T”，若光标右侧没有字符输出“F”。 R 代表翻转左光标和右光标之间的字符。 该命令只有左光标在右光标左侧时才能执行。 （两光标重合时也不能执行） 命令执行成功时输出“T”，否则输“F”。 S 代表显示当前处理的文本。 该命令只输出文本，不输出“T”和“F”。 开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。 注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。 输入输出格式输入格式：第一行是初始时文本编辑器内容。 第二行是一个正整数 N，N 表示操作次数。 接下来有 N 行，每行有一个命令，命令格式如上方表格。 输出格式：对于每个命令，按上方表格要求执行并输出。 输入输出样例输入样例：goodykc 11 I R u I R l &gt; L &gt; L &gt; L &gt; L R D R &lt; R D R S 输出样例：T T T T T T T F T T goodluck 数据范围对于 40% 的数据：1 ≤ N , 初始文本长度 ≤ 100，数据不包含翻转（Reverse）操作； 另有 30% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据不包含翻转（Reverse）操作； 另有 20% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据包含翻转（Reverse）操作； 对于 100% 的数据：1 ≤ N , 初始文本长度 ≤ 4 × 10 6 ，输出文件大小 ≤ 20MB; 题解用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。 具体的实现代码十分清楚，但还有许多细节要注意，因为l，r的相对位置可能互换，所以只能写左开右开或左闭右闭区间。 CODE#include&lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int N=1e7+1; int tot,m,pos[2],cnt[2],pre[N],next[N]; char opreator,ch[N],str[N]; int move(){getchar();return getchar()==&#39;L&#39;?0:1;} void in(int opreator,char c) { ++tot; ch[tot]=c; int u=pos[opreator],v=next[u]; pre[tot]=u;next[tot]=v; next[u]=tot;pre[v]=tot; if (cnt[opreator^1]&gt;=cnt[opreator])cnt[opreator^1]++; pos[opreator]=tot;cnt[opreator]++; if (pos[opreator^1]==u)pos[opreator^1]=tot; printf(&quot;T\\n&quot;); } void ll(int opreator) { if (pos[opreator]==1){printf(&quot;F\\n&quot;);return;} int u=pos[opreator],v=pre[u]; if (next[v]!=u)swap(next[v],pre[v]); pos[opreator]=v; cnt[opreator]--; printf(&quot;T\\n&quot;); } void rl(int opreator) { if (next[pos[opreator]]==2){printf(&quot;F\\n&quot;);return;} int u=next[pos[opreator]],v=next[u]; if(pre[v]!=u)swap(next[v],pre[v]); pos[opreator]=u;cnt[opreator]++; printf(&quot;T\\n&quot;); } void D(int opreator) { if (next[pos[opreator]]== 2){printf(&quot;F\\n&quot;);return;} int u = pos[opreator], v = next[u], w = next[v]; if (pre[w]!=v) swap(next[w], pre[w]); if (cnt[opreator^1]&gt;cnt[opreator])cnt[opreator^1]--; if (pos[opreator^1]==v)pos[opreator^1]=u; next[u]= w;pre[w]=u; printf(&quot;T\\n&quot;); } void R() { if (cnt[1]-cnt[0]&lt;=0){printf(&quot;F\\n&quot;);return;} if (cnt[1]-cnt[0]==1){printf(&quot;T\\n&quot;);return;} int now=pos[0],ne=next[now],c=pos[1],d=next[c]; swap(pre[ne], next[ne]);swap(pre[c],next[c]); next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne; pos[1]=ne; printf(&quot;T\\n&quot;); } void show() { int u=1; while(true) { if(pre[next[u]]!= u)swap(pre[next[u]],next[next[u]]); u=next[u]; if (u==2)break; putchar(ch[u]); } printf(&quot;\\n&quot;); } void init() { tot=2; pre[1]=-1;next[1]= 2; pre[2]=1;next[2]=-1; pos[0]=pos[1]=cnt[0]=cnt[1]=1; int len=strlen(str); for(int i=0;i&lt;len;i++) { ++tot; ch[tot]=str[i]; pre[tot]= i==0?1:tot-1; next[tot]= i==len-1?2:tot+1; } if(len&gt;0) { next[1]=3;pre[2]=tot; pos[1]=tot;cnt[1]=len+1; } } int act() { if(opreator==&#39;&lt;&#39;) ll(move()); if(opreator==&#39;&gt;&#39;) rl(move()); if(opreator==&#39;I&#39;) { int d=move(); char c=getchar(); while (c&lt;33||c&gt;126)c=getchar(); in(d,c); } if (opreator==&#39;D&#39;) D(move()); if (opreator==&#39;R&#39;) R(); if (opreator==&#39;S&#39;) show(); } int main() { // freopen(&quot;editor.in&quot;,&quot;r&quot;, stdin); // freopen(&quot;editor.out&quot;,&quot;w&quot;, stdout); scanf(&quot;%s&quot;,str); init(); scanf(&quot;%d&quot;,&amp;m); for (int i=1;i&lt;=m;i++) { getchar(); opreator=getchar(); while (opreator!=&#39;&lt;&#39;&amp;&amp; opreator!=&#39;&gt;&#39;&amp;&amp;!(opreator &gt;=&#39;A&#39;&amp;&amp; opreator &lt;=&#39;Z&#39;))opreator=getchar(); act(); } return 0; }","raw":"title: NOIP模拟赛 2017 3 17\ndate: 2017-03-17 20:50:23\ncategories:\n  - NOIP模拟赛\ntags:\n  - 二分答案\n  - 计算几何\n  - 动态规划\n  - 链表\n  - 树链剖分\n---\n\n# T1 计算几何\n\n---\n## 题目描述\n花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问\n题。今天，他想到了一个十分有意思的题目：\n\n首先，花花会在 x 轴正半轴和 y 轴正半轴分别挑选 n 个点。随后，他将 x 轴的点与 y 轴\n的点一一连接，形成 n 条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅\n有一种。最后，花花会给出 m 个询问。对于每个询问，将会给定一个点 P($x_p$ ,$y_p$ )，问线段\nOP（O 为坐标原点）与 n 条线段会产生多少个交点？\n\n### 输入输出格式\n#### 输入格式：\n第 1 行包含一个正整数 n，表示线段的数量；\n\n第 2 行包含 n 个正整数，表示花花在 x 轴选取的点的横坐标；\n\n第 3 行包含 n 个正整数，表示花花在 y 轴选取的点的纵坐标；\n\n第 4 行包含一个正整数 m，表示询问数量；\n\n随后 m 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。\n\n\n#### 输出格式：\n\n共 m 行，每行包含一个非负整数，表示你对这条询问给出的答案。\n\n### 输入输出样例\n#### 输入样例：\n    3\n    4 5 3\n    3 5 4\n    2\n    1 1\n    3 3\n    \n\n#### 输出样例：\n    0\n\t3\n\n### 数据范围\n对于 40% 的数据：n,m ≤ $10$；\n\n另有 20% 的数据：n,m ≤ $100$；\n\n另有 20% 的数据：n,m ≤ $1000$；\n\n对于 100% 的数据：n,m ≤ $10^5$,y < $2^{31}$\n\n---\n\n## 题解\n\n本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $y_p$ 与 $y_{mid}$ 大小即可。\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N =1e5+1;\n    int n,m,x[N],y[N];\n    double a[N];\n    typedef double db;\n    inline void get(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int main()\n    {\n    //    freopen(\"geometry.in\",\"r\",stdin);\n    //    freopen(\"geometry.out\",\"w\",stdout);\n        get(n);\n        for(int i=1;i<=n;++i)get(x[i]);sort(x+1,x+n+1);\n        for(int i=1;i<=n;++i)get(y[i]);sort(y+1,y+n+1);\n\n        get(m);\n        for(int i=1,xx,yy;i<=m;++i)\n        {\n            get(xx);get(yy);\n            int l=0,r=n,mid;\n            while(l!=r)\n            {\n                mid=l+r+1>>1;\n                if(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid]));\n                double yt=a[mid]*(db)xx+y[mid];\n                if(yt<=(db)yy) l=mid;\n                else\t\t  r=mid-1;\n            }\n            printf(\"%d\\n\",l);\n        }\n    }\n    \n---\n# T2 花花的聚会\n\n---\n## 题目描述\n花花住在 H 国。H 国有 n 个城市，其中 1 号城市为其首都。城市间有 n − 1 条单向道\n路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市\n走到首都的路径是唯一的。\n\n过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 m 种过\n路券，每张过路券以三个整数表示：v k w：你可以在城市 v 以价格 w 买到一张过路券。这\n张券可以使用 k 次。这意味着，拿着这张券通过了 k 条道路之后，这张券就不能再使用了。\n\n请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，\n并且在所在的城市再买一张。\n\n花花家在首都。他有 q 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道\n每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。\n\n花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮\n他么？\n### 输入输出格式\n#### 输入格式：\n输入的第一行包含两个空格隔开的整数 n 和 m，表示 H 国的城市数量和过路券的种数。\n\n之后的 n − 1 行各自包含两个数 a i 和 b i ，代表城市 a i 到城市 b i 间有一条单向道路。\n\n之后的 m 行每行包括三个整数 v i ,k i 和 w i ，表示一种过路券。\n\n下一行包含一个整数 q，表示花花朋友的数量。\n\n之后的 q 行各自包含一个整数，表示花花朋友的所在城市。\n\n\n\n#### 输出格式：\n\n输出共 q 行，每一行代表一位朋友的路费。\n\n### 输入输出样例\n#### 输入样例：\n    7 7\n    3 1\n    2 1\n    7 6\n    6 3\n    5 3\n    4 3\n    7 2 3\n    7 1 1\n    2 3 5\n    3 6 2\n    4 2 4\n    5 3 10\n    6 1 20\n    3\n    5\n    6\n    7\n\n#### 输出样例：\n    10\n    22\n    5\n    \n\n### 数据范围\n对于 40% 的数据：n,m,q ≤ 10,w i ≤ 10；\n \n另有 20% 的数据：n,m,q ≤ 500,w i ≤ 100；\n\n另有 20% 的数据：n,m,q ≤ 5000,w i ≤ 1000；\n\n对于 100% 的数据：n,m,q ≤ 10 5 ,w i ≤ 10000,1 ≤ v i ,k i ≤ n。\n \n---\n\n## 题解\n\n树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：\n$f[y] = min ( f[x] + w[y][i] )( x 为 y 祖先 && dep[x] - dep[y] > = k[y][i] )$\n\n先进行拓扑排序，顺序进行操作。对于寻找$min(f[x])$的操作，则可以通过LCA或树链剖分实现。(要开 long long 不然会爆)\n\n---\n### CODE\n    #include<iostream>\n    #include<algorithm>\n    #include<cstdio>\n    const int inf =0x7fffffff;\n    const int N =1e5+1;\n    const int maxlogn =21;\n    using namespace std;\n    int deep[N],head[N],head2[N];\n    long long st[N][maxlogn],minn[N][maxlogn],f[N];\n    int tot,tot2,n,m,qu;\n    struct edg{int t,ne;}e[N*2];\n    struct edg2{int k,w,ne;}e2[N*2];\n    void in(int x,int y)\n    {\n        e[++tot].t=y;\n        e[tot].ne=head[x];\n        head[x]=tot;\n        return;\n    }\n\n    void in2(int x,int k,int w)\n    {\n        e2[++tot2].k=k;\n        e2[tot2].w=w;\n        e2[tot2].ne=head2[x];\n        head2[x]=tot2;\n        return;\n    }\n\n    void getf(int x,int pre)\n    {\n        st[x][0]=pre;minn[x][0]=f[pre];\n        for(int i=1;i<maxlogn;i++)\n        {\n            st[x][i]=st[st[x][i-1]][i-1];\n            minn[x][i]=min(minn[x][i-1],minn[st[x][i-1]][i-1]);\n        }\n        f[x]=x==1?0:inf;\n        for(int i=head2[x];i;i=e2[i].ne)\n        {\n            long long tmp=inf,y=x,k=e2[i].k,p=0;\n            while(k)\n            {\n                if(k&1)tmp=min(tmp,minn[y][p]),y=st[y][p];\n                p++;k>>=1;\n            }\n            f[x]=min(f[x],tmp+e2[i].w);\n        }\n        for(int i=head[x];i;i=e[i].ne)\n        {\n            int y=e[i].t;\n            if(y!=pre)getf(y,x);\n        }\n        return;\n    }\n\n    int main()\n    {\n    //    freopen(\"party.in\",\"r\",stdin);\n    //    freopen(\"party.out\",\"w\",stdout);\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1,x,y;i<n;i++)scanf(\"%d%d\",&x,&y),in(x,y),in(y,x);\n        for(int i=1,x,k,w;i<=m;i++)scanf(\"%d%d%d\",&x,&k,&w),in2(x,k,w);\n        scanf(\"%d\",&qu);getf(1,1);\n        for(int i=1,x;i<=qu;i++){scanf(\"%d\",&x);printf(\"%d\\n\",f[x]);}\n    }\n---\n# T3 文本编辑器\n\n---\n## 题目描述\n九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时\n在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用\n处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但\n是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一\n些功能。\n\n功能列表如下：\n\n\n    < w\n    \n    w 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。\n    该命令将选定光标向左移动，如果已经是最左端则不移动。\n    命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。\n    \n    > w\n    \n    w 同上。\n    与< 命令不同的是，该命令将光标向右移动。\n    命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。\n    \n    I w c\n    \n    w 同上。\n    c 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。\n    该命令始终输出“T”。\n    \n    D w\n    \n    w 同上。\n    代表删除该光标右侧的一个字符。\n    命令执行成功时输出“T”，若光标右侧没有字符输出“F”。\n    \n    R\n    \n    代表翻转左光标和右光标之间的字符。\n    该命令只有左光标在右光标左侧时才能执行。\n    （两光标重合时也不能执行）\n    命令执行成功时输出“T”，否则输“F”。\n    \n    S\n    \n    代表显示当前处理的文本。\n    该命令只输出文本，不输出“T”和“F”。\n    \n开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。\n\n注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。\n### 输入输出格式\n#### 输入格式：\n第一行是初始时文本编辑器内容。\n\n第二行是一个正整数 N，N 表示操作次数。\n\n接下来有 N 行，每行有一个命令，命令格式如上方表格。\n\n#### 输出格式：\n对于每个命令，按上方表格要求执行并输出。\n\n\n### 输入输出样例\n#### 输入样例：\n    goodykc\n    11\n    I R u\n    I R l\n    > L\n    > L\n    > L\n    > L\n    R\n    D R\n    < R\n    D R\n    S\n\n\n#### 输出样例：\n    T\n    T\n    T\n    T\n    T\n    T\n    T\n    F\n    T\n    T\n    goodluck\n    \n\n### 数据范围\n对于 40% 的数据：1 ≤ N , 初始文本长度 ≤ 100，数据不包含翻转（Reverse）操作；\n\n另有 30% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据不包含翻转（Reverse）操作；\n\n另有 20% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据包含翻转（Reverse）操作；\n\n对于 100% 的数据：1 ≤ N , 初始文本长度 ≤ 4 × 10 6 ，输出文件大小 ≤ 20MB;\n\n---\n\n## 题解\n用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。\n\n具体的实现代码十分清楚，但还有许多细节要注意，因为l，r的相对位置可能互换，所以只能写左开右开或左闭右闭区间。\n\n---\n### CODE\n    #include<iostream>\n    #include <cstdio>\n    #include <cstring>\n    using namespace std;\n    const int N=1e7+1;\n\n    int tot,m,pos[2],cnt[2],pre[N],next[N];\n\n    char opreator,ch[N],str[N];\n\n    int move(){getchar();return getchar()=='L'?0:1;}\n\n    void in(int opreator,char c)\n    {\n        ++tot;\n        ch[tot]=c;\n        int u=pos[opreator],v=next[u];\n\n        pre[tot]=u;next[tot]=v;\n        next[u]=tot;pre[v]=tot;\n\n        if (cnt[opreator^1]>=cnt[opreator])cnt[opreator^1]++;\n\n        pos[opreator]=tot;cnt[opreator]++;\n        if (pos[opreator^1]==u)pos[opreator^1]=tot;\n        printf(\"T\\n\");\n    }\n\n    void ll(int opreator)\n    {\n        if (pos[opreator]==1){printf(\"F\\n\");return;}\n        int u=pos[opreator],v=pre[u];\n\n        if (next[v]!=u)swap(next[v],pre[v]);\n\n        pos[opreator]=v; cnt[opreator]--;\n        printf(\"T\\n\");\n    }\n\n    void rl(int opreator)\n    {\n        if (next[pos[opreator]]==2){printf(\"F\\n\");return;}\n        int u=next[pos[opreator]],v=next[u];\n\n        if(pre[v]!=u)swap(next[v],pre[v]);\n\n        pos[opreator]=u;cnt[opreator]++;\n        printf(\"T\\n\");\t\n    }\n\n    void D(int opreator)\n    {\n        if (next[pos[opreator]]== 2){printf(\"F\\n\");return;}\n        int u = pos[opreator], v = next[u], w = next[v];\n\n        if (pre[w]!=v) swap(next[w], pre[w]);\n        if (cnt[opreator^1]>cnt[opreator])cnt[opreator^1]--;\n        if (pos[opreator^1]==v)pos[opreator^1]=u;\n\n        next[u]= w;pre[w]=u;\n        printf(\"T\\n\");\n    }\n\n    void R()\n    {\n        if (cnt[1]-cnt[0]<=0){printf(\"F\\n\");return;}\n        if (cnt[1]-cnt[0]==1){printf(\"T\\n\");return;}\n        int now=pos[0],ne=next[now],c=pos[1],d=next[c];\n\n        swap(pre[ne], next[ne]);swap(pre[c],next[c]);\n        next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne;\n        pos[1]=ne;\n        printf(\"T\\n\");\n    }\n\n    void show()\n    {\n        int u=1;\n        while(true)\n        {\n            if(pre[next[u]]!= u)swap(pre[next[u]],next[next[u]]);\n            u=next[u];\n            if (u==2)break;\n            putchar(ch[u]);\n        }\n        printf(\"\\n\");\n    }\n\n    void init()\n    {\n        tot=2;\n        pre[1]=-1;next[1]= 2;\n        pre[2]=1;next[2]=-1;\n        pos[0]=pos[1]=cnt[0]=cnt[1]=1;\n        int len=strlen(str);\n        for(int i=0;i<len;i++)\n        {\n            ++tot;\n            ch[tot]=str[i];\n            pre[tot]= i==0?1:tot-1;\n            next[tot]= i==len-1?2:tot+1;\n        }\n        if(len>0)\n        {\n            next[1]=3;pre[2]=tot;\n            pos[1]=tot;cnt[1]=len+1;\n        }\n    }\n\n    int act()\n    {\n        if(opreator=='<') \t\tll(move());\n        if(opreator=='>') \t\trl(move());\n        if(opreator=='I')\n        {\n            int d=move();\n            char c=getchar();\n            while (c<33||c>126)c=getchar();\n            in(d,c);\n        }\n        if (opreator=='D') \t\tD(move());\n        if (opreator=='R') \t\tR();\n        if (opreator=='S') \t\tshow();\n    }\n    int main()\n    {\n    //    freopen(\"editor.in\",\"r\", stdin);\n    //    freopen(\"editor.out\",\"w\", stdout);\n        scanf(\"%s\",str);\n        init();\n        scanf(\"%d\",&m);\n        for (int i=1;i<=m;i++)\n        {\n            getchar();\n            opreator=getchar();\n            while (opreator!='<'&& opreator!='>'&&!(opreator >='A'&& opreator <='Z'))opreator=getchar();\n            act();\n        }\n        return 0;\n    }\n---","content":"<h1 id=\"T1-计算几何\"><a href=\"#T1-计算几何\" class=\"headerlink\" title=\"T1 计算几何\"></a>T1 计算几何</h1><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>花花对计算几何有着浓厚的兴趣。他经常对着平面直角坐标系发呆，思考一些有趣的问<br>题。今天，他想到了一个十分有意思的题目：</p>\n<p>首先，花花会在 x 轴正半轴和 y 轴正半轴分别挑选 n 个点。随后，他将 x 轴的点与 y 轴<br>的点一一连接，形成 n 条线段，并保证任意两条线段不相交。花花确定这种连接方式有且仅<br>有一种。最后，花花会给出 m 个询问。对于每个询问，将会给定一个点 P($x_p$ ,$y_p$ )，问线段<br>OP（O 为坐标原点）与 n 条线段会产生多少个交点？</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第 1 行包含一个正整数 n，表示线段的数量；</p>\n<p>第 2 行包含 n 个正整数，表示花花在 x 轴选取的点的横坐标；</p>\n<p>第 3 行包含 n 个正整数，表示花花在 y 轴选取的点的纵坐标；</p>\n<p>第 4 行包含一个正整数 m，表示询问数量；</p>\n<p>随后 m 行，每行包含两个正整数 $x_p$ 和 $y_p$ ，表示询问中给定的点的横、纵坐标。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>共 m 行，每行包含一个非负整数，表示你对这条询问给出的答案。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>3\n4 5 3\n3 5 4\n2\n1 1\n3 3\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>0\n3\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 40% 的数据：n,m ≤ $10$；</p>\n<p>另有 20% 的数据：n,m ≤ $100$；</p>\n<p>另有 20% 的数据：n,m ≤ $1000$；</p>\n<p>对于 100% 的数据：n,m ≤ $10^5$,y &lt; $2^{31}$</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>本题考察了计算几何中较为基础的知识，根据题意，可以先将数据升序排序，然后进行二分答案。对于判定直线是否相交则可以用求零点的方法，已知每条线段的纵坐标都是大于零的，所以只需要比较当 $x=x_p$ 时的 $y_p$ 与 $y_{mid}$ 大小即可。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N =1e5+1;\nint n,m,x[N],y[N];\ndouble a[N];\ntypedef double db;\ninline void get(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint main()\n{\n//    freopen(&quot;geometry.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;geometry.out&quot;,&quot;w&quot;,stdout);\n    get(n);\n    for(int i=1;i&lt;=n;++i)get(x[i]);sort(x+1,x+n+1);\n    for(int i=1;i&lt;=n;++i)get(y[i]);sort(y+1,y+n+1);\n\n    get(m);\n    for(int i=1,xx,yy;i&lt;=m;++i)\n    {\n        get(xx);get(yy);\n        int l=0,r=n,mid;\n        while(l!=r)\n        {\n            mid=l+r+1&gt;&gt;1;\n            if(!a[mid])a[mid]=-((db)(y[mid]))/((db)(x[mid]));\n            double yt=a[mid]*(db)xx+y[mid];\n            if(yt&lt;=(db)yy) l=mid;\n            else          r=mid-1;\n        }\n        printf(&quot;%d\\n&quot;,l);\n    }\n}\n</code></pre><hr>\n<h1 id=\"T2-花花的聚会\"><a href=\"#T2-花花的聚会\" class=\"headerlink\" title=\"T2 花花的聚会\"></a>T2 花花的聚会</h1><hr>\n<h2 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>花花住在 H 国。H 国有 n 个城市，其中 1 号城市为其首都。城市间有 n − 1 条单向道<br>路。从任意一个城市出发，都可以沿着这些单向道路一路走到首都。事实上，从任何一个城市<br>走到首都的路径是唯一的。</p>\n<p>过路并不是免费的。想要通过某一条道路，你必须使用一次过路券。H 国一共有 m 种过<br>路券，每张过路券以三个整数表示：v k w：你可以在城市 v 以价格 w 买到一张过路券。这<br>张券可以使用 k 次。这意味着，拿着这张券通过了 k 条道路之后，这张券就不能再使用了。</p>\n<p>请注意你同一时间最多只能拥有最多一张过路券。但你可以随时撕掉手中已有的过路券，<br>并且在所在的城市再买一张。</p>\n<p>花花家在首都。他有 q 位朋友，他希望把这些朋友们都邀请到他家做客。所以他想要知道<br>每位朋友要花多少路费。他的朋友们都很聪明，永远都会选择一条花费最少的方式到达首都。</p>\n<p>花花需要准备晚餐去了，所以他没有时间亲自计算出朋友们将要花费的路费。你可以帮帮<br>他么？</p>\n<h3 id=\"输入输出格式-1\"><a href=\"#输入输出格式-1\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：-1\"><a href=\"#输入格式：-1\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入的第一行包含两个空格隔开的整数 n 和 m，表示 H 国的城市数量和过路券的种数。</p>\n<p>之后的 n − 1 行各自包含两个数 a i 和 b i ，代表城市 a i 到城市 b i 间有一条单向道路。</p>\n<p>之后的 m 行每行包括三个整数 v i ,k i 和 w i ，表示一种过路券。</p>\n<p>下一行包含一个整数 q，表示花花朋友的数量。</p>\n<p>之后的 q 行各自包含一个整数，表示花花朋友的所在城市。</p>\n<h4 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出共 q 行，每一行代表一位朋友的路费。</p>\n<h3 id=\"输入输出样例-1\"><a href=\"#输入输出样例-1\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>7 7\n3 1\n2 1\n7 6\n6 3\n5 3\n4 3\n7 2 3\n7 1 1\n2 3 5\n3 6 2\n4 2 4\n5 3 10\n6 1 20\n3\n5\n6\n7\n</code></pre><h4 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>10\n22\n5\n</code></pre><h3 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 40% 的数据：n,m,q ≤ 10,w i ≤ 10；</p>\n<p>另有 20% 的数据：n,m,q ≤ 500,w i ≤ 100；</p>\n<p>另有 20% 的数据：n,m,q ≤ 5000,w i ≤ 1000；</p>\n<p>对于 100% 的数据：n,m,q ≤ 10 5 ,w i ≤ 10000,1 ≤ v i ,k i ≤ n。</p>\n<hr>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>树形动态规划。设$f[i]$为从$i$到根节点的最小花费，则可以得到状态转移方程：<br>$f[y] = min ( f[x] + w[y][i] )( x 为 y 祖先 &amp;&amp; dep[x] - dep[y] &gt; = k[y][i] )$</p>\n<p>先进行拓扑排序，顺序进行操作。对于寻找$min(f[x])$的操作，则可以通过LCA或树链剖分实现。(要开 long long 不然会爆)</p>\n<hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\nconst int inf =0x7fffffff;\nconst int N =1e5+1;\nconst int maxlogn =21;\nusing namespace std;\nint deep[N],head[N],head2[N];\nlong long st[N][maxlogn],minn[N][maxlogn],f[N];\nint tot,tot2,n,m,qu;\nstruct edg{int t,ne;}e[N*2];\nstruct edg2{int k,w,ne;}e2[N*2];\nvoid in(int x,int y)\n{\n    e[++tot].t=y;\n    e[tot].ne=head[x];\n    head[x]=tot;\n    return;\n}\n\nvoid in2(int x,int k,int w)\n{\n    e2[++tot2].k=k;\n    e2[tot2].w=w;\n    e2[tot2].ne=head2[x];\n    head2[x]=tot2;\n    return;\n}\n\nvoid getf(int x,int pre)\n{\n    st[x][0]=pre;minn[x][0]=f[pre];\n    for(int i=1;i&lt;maxlogn;i++)\n    {\n        st[x][i]=st[st[x][i-1]][i-1];\n        minn[x][i]=min(minn[x][i-1],minn[st[x][i-1]][i-1]);\n    }\n    f[x]=x==1?0:inf;\n    for(int i=head2[x];i;i=e2[i].ne)\n    {\n        long long tmp=inf,y=x,k=e2[i].k,p=0;\n        while(k)\n        {\n            if(k&amp;1)tmp=min(tmp,minn[y][p]),y=st[y][p];\n            p++;k&gt;&gt;=1;\n        }\n        f[x]=min(f[x],tmp+e2[i].w);\n    }\n    for(int i=head[x];i;i=e[i].ne)\n    {\n        int y=e[i].t;\n        if(y!=pre)getf(y,x);\n    }\n    return;\n}\n\nint main()\n{\n//    freopen(&quot;party.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;party.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1,x,y;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;x,&amp;y),in(x,y),in(y,x);\n    for(int i=1,x,k,w;i&lt;=m;i++)scanf(&quot;%d%d%d&quot;,&amp;x,&amp;k,&amp;w),in2(x,k,w);\n    scanf(&quot;%d&quot;,&amp;qu);getf(1,1);\n    for(int i=1,x;i&lt;=qu;i++){scanf(&quot;%d&quot;,&amp;x);printf(&quot;%d\\n&quot;,f[x]);}\n}\n</code></pre><hr>\n<h1 id=\"T3-文本编辑器\"><a href=\"#T3-文本编辑器\" class=\"headerlink\" title=\"T3 文本编辑器\"></a>T3 文本编辑器</h1><hr>\n<h2 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>九发明了一个完美的文本编辑器。这个编辑器拥有两个光标（cursor），所以九能够同时<br>在两处地方插入和删除文本。这个编辑器除了正常的编辑功能以外，还有一些只有九才知道用<br>处的功能，例如翻转两个光标之间的文本。某一天，九把自己的完美文本编辑器给弄丢了，但<br>是她还有好多好多文本需要处理。于是她想请聪明又智慧的你帮她实现完美文本编辑器的一<br>些功能。</p>\n<p>功能列表如下：</p>\n<pre><code>&lt; w\n\nw 为一个字符，“L”或“R”，表示左光标还是右光标（下同）。\n该命令将选定光标向左移动，如果已经是最左端则不移动。\n命令执行成功时输出“T”，若光标已经在最左端，则输出“F”。\n\n&gt; w\n\nw 同上。\n与&lt; 命令不同的是，该命令将光标向右移动。\n命令执行成功时输出“T”，若光标已经在最右端，则输出“F”。\n\nI w c\n\nw 同上。\nc 是一个可见字符(33≤ ascii 码 ≤ 126)，代表在该光标左侧插入该字符。\n该命令始终输出“T”。\n\nD w\n\nw 同上。\n代表删除该光标右侧的一个字符。\n命令执行成功时输出“T”，若光标右侧没有字符输出“F”。\n\nR\n\n代表翻转左光标和右光标之间的字符。\n该命令只有左光标在右光标左侧时才能执行。\n（两光标重合时也不能执行）\n命令执行成功时输出“T”，否则输“F”。\n\nS\n\n代表显示当前处理的文本。\n该命令只输出文本，不输出“T”和“F”。\n</code></pre><p>开始时文本编辑器中有一定内容，左光标在第一个字符左，右光标在最后一个字符右。</p>\n<p>注意：在插入和删除操作中，没有被操作的光标与文本的相对左右位置保持不变。特别地，若两个光标重叠，操作后也仍然重叠。</p>\n<h3 id=\"输入输出格式-2\"><a href=\"#输入输出格式-2\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：-2\"><a href=\"#输入格式：-2\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行是初始时文本编辑器内容。</p>\n<p>第二行是一个正整数 N，N 表示操作次数。</p>\n<p>接下来有 N 行，每行有一个命令，命令格式如上方表格。</p>\n<h4 id=\"输出格式：-2\"><a href=\"#输出格式：-2\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对于每个命令，按上方表格要求执行并输出。</p>\n<h3 id=\"输入输出样例-2\"><a href=\"#输入输出样例-2\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：-2\"><a href=\"#输入样例：-2\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>goodykc\n11\nI R u\nI R l\n&gt; L\n&gt; L\n&gt; L\n&gt; L\nR\nD R\n&lt; R\nD R\nS\n</code></pre><h4 id=\"输出样例：-2\"><a href=\"#输出样例：-2\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>T\nT\nT\nT\nT\nT\nT\nF\nT\nT\ngoodluck\n</code></pre><h3 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>对于 40% 的数据：1 ≤ N , 初始文本长度 ≤ 100，数据不包含翻转（Reverse）操作；</p>\n<p>另有 30% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据不包含翻转（Reverse）操作；</p>\n<p>另有 20% 的数据：1 ≤ N , 初始文本长度 ≤ 10 5 ，数据包含翻转（Reverse）操作；</p>\n<p>对于 100% 的数据：1 ≤ N , 初始文本长度 ≤ 4 × 10 6 ，输出文件大小 ≤ 20MB;</p>\n<hr>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>用链表可以模拟所有操作，对于时间复杂度较高的翻转操作，可以考虑将所有的节点前驱后驱交换一下，边界的前后驱特殊处理。但这样时间复杂度仍过高，可以考虑借鉴一下树形数据结构的LAZY_TAG思想，只有在访问到该节点时才修改并交换先后驱。</p>\n<p>具体的实现代码十分清楚，但还有许多细节要注意，因为l，r的相对位置可能互换，所以只能写左开右开或左闭右闭区间。</p>\n<hr>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int N=1e7+1;\n\nint tot,m,pos[2],cnt[2],pre[N],next[N];\n\nchar opreator,ch[N],str[N];\n\nint move(){getchar();return getchar()==&#39;L&#39;?0:1;}\n\nvoid in(int opreator,char c)\n{\n    ++tot;\n    ch[tot]=c;\n    int u=pos[opreator],v=next[u];\n\n    pre[tot]=u;next[tot]=v;\n    next[u]=tot;pre[v]=tot;\n\n    if (cnt[opreator^1]&gt;=cnt[opreator])cnt[opreator^1]++;\n\n    pos[opreator]=tot;cnt[opreator]++;\n    if (pos[opreator^1]==u)pos[opreator^1]=tot;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid ll(int opreator)\n{\n    if (pos[opreator]==1){printf(&quot;F\\n&quot;);return;}\n    int u=pos[opreator],v=pre[u];\n\n    if (next[v]!=u)swap(next[v],pre[v]);\n\n    pos[opreator]=v; cnt[opreator]--;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid rl(int opreator)\n{\n    if (next[pos[opreator]]==2){printf(&quot;F\\n&quot;);return;}\n    int u=next[pos[opreator]],v=next[u];\n\n    if(pre[v]!=u)swap(next[v],pre[v]);\n\n    pos[opreator]=u;cnt[opreator]++;\n    printf(&quot;T\\n&quot;);    \n}\n\nvoid D(int opreator)\n{\n    if (next[pos[opreator]]== 2){printf(&quot;F\\n&quot;);return;}\n    int u = pos[opreator], v = next[u], w = next[v];\n\n    if (pre[w]!=v) swap(next[w], pre[w]);\n    if (cnt[opreator^1]&gt;cnt[opreator])cnt[opreator^1]--;\n    if (pos[opreator^1]==v)pos[opreator^1]=u;\n\n    next[u]= w;pre[w]=u;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid R()\n{\n    if (cnt[1]-cnt[0]&lt;=0){printf(&quot;F\\n&quot;);return;}\n    if (cnt[1]-cnt[0]==1){printf(&quot;T\\n&quot;);return;}\n    int now=pos[0],ne=next[now],c=pos[1],d=next[c];\n\n    swap(pre[ne], next[ne]);swap(pre[c],next[c]);\n    next[now]=c;pre[c]=now;next[ne]=d;pre[d]=ne;\n    pos[1]=ne;\n    printf(&quot;T\\n&quot;);\n}\n\nvoid show()\n{\n    int u=1;\n    while(true)\n    {\n        if(pre[next[u]]!= u)swap(pre[next[u]],next[next[u]]);\n        u=next[u];\n        if (u==2)break;\n        putchar(ch[u]);\n    }\n    printf(&quot;\\n&quot;);\n}\n\nvoid init()\n{\n    tot=2;\n    pre[1]=-1;next[1]= 2;\n    pre[2]=1;next[2]=-1;\n    pos[0]=pos[1]=cnt[0]=cnt[1]=1;\n    int len=strlen(str);\n    for(int i=0;i&lt;len;i++)\n    {\n        ++tot;\n        ch[tot]=str[i];\n        pre[tot]= i==0?1:tot-1;\n        next[tot]= i==len-1?2:tot+1;\n    }\n    if(len&gt;0)\n    {\n        next[1]=3;pre[2]=tot;\n        pos[1]=tot;cnt[1]=len+1;\n    }\n}\n\nint act()\n{\n    if(opreator==&#39;&lt;&#39;)         ll(move());\n    if(opreator==&#39;&gt;&#39;)         rl(move());\n    if(opreator==&#39;I&#39;)\n    {\n        int d=move();\n        char c=getchar();\n        while (c&lt;33||c&gt;126)c=getchar();\n        in(d,c);\n    }\n    if (opreator==&#39;D&#39;)         D(move());\n    if (opreator==&#39;R&#39;)         R();\n    if (opreator==&#39;S&#39;)         show();\n}\nint main()\n{\n//    freopen(&quot;editor.in&quot;,&quot;r&quot;, stdin);\n//    freopen(&quot;editor.out&quot;,&quot;w&quot;, stdout);\n    scanf(&quot;%s&quot;,str);\n    init();\n    scanf(&quot;%d&quot;,&amp;m);\n    for (int i=1;i&lt;=m;i++)\n    {\n        getchar();\n        opreator=getchar();\n        while (opreator!=&#39;&lt;&#39;&amp;&amp; opreator!=&#39;&gt;&#39;&amp;&amp;!(opreator &gt;=&#39;A&#39;&amp;&amp; opreator &lt;=&#39;Z&#39;))opreator=getchar();\n        act();\n    }\n    return 0;\n}\n</code></pre><hr>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/17/NOIP模拟赛 2017 3 17/","excerpt":"","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"https://prostkhala.github.io/categories/NOIP模拟赛/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"计算几何","slug":"计算几何","permalink":"https://prostkhala.github.io/tags/计算几何/"},{"name":"二分答案","slug":"二分答案","permalink":"https://prostkhala.github.io/tags/二分答案/"},{"name":"链表","slug":"链表","permalink":"https://prostkhala.github.io/tags/链表/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://prostkhala.github.io/tags/树链剖分/"}]},{"title":"病毒侵袭","date":"2017-03-17T02:21:17.000Z","path":"2017/03/17/病毒入侵/","text":"病毒侵袭hdu 2896 题目描述当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~ 但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。 万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~ 输入输出格式输入格式：第一行，一个整数N（1&lt;=N&lt;=500），表示病毒特征码的个数。 接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。每个病毒都有一个编号，依此为1—N。 不同编号的病毒特征码不会相同。 在这之后一行，有一个整数M（1&lt;=M&lt;=1000），表示网站数。 接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。 每个网站都有一个编号，依此为1—M。 以上字符串中字符都是ASCII码可见字符（不包括回车）。 输出格式：依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。 web 网站编号: 病毒编号 病毒编号 … 冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。 最后一行输出统计信息，如下格式 total: 带病毒网站数 (冒号后有一个空格) 输入输出样例输入样例#1：3 aaa bbb ccc 2 aaabbbccc bbaacc 输出样例#1：web 1: 1 2 3 total: 1 AC自动机模板题CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N=501*201+5; const int maxf = 128; int ans[1001],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N]; char s[10001]; bool use[N]; void insert(int noww) { int n=strlen(s),now=0; for(int i=0;i&lt;n;++i) { if(tr[now][s[i]]==-1) { tr[now][s[i]]=++tot; for(int j=0;j&lt;maxf;++j)tr[tot][j]=-1; tag[tot]=0; } now=tr[now][s[i]]; } tag[now]=noww; } void getfail() { queue&lt;int&gt;q; fail[0]=0; for(int i=0;i&lt;maxf;++i) if(tr[0][i]!=-1) fail[tr[0][i]]=0,q.push(tr[0][i]); else tr[0][i]=0; while(!q.empty()) { int x=q.front();q.pop(); for(int j=0;j&lt;maxf;++j) if(tr[x][j]!=-1) {q.push(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];} else tr[x][j]=tr[fail[x]][j]; } } void solve(int noww) { int n=strlen(s),now=0; memset(use,0,sizeof(use)); tmp=0; for(int i=0;i&lt;n;++i) { now=tr[now][s[i]]; for(int j=now;j;j=fail[j]) if(tag[j]&amp;&amp;!use[tag[j]]) ans[++tmp]=tag[j],use[tag[j]]=1; } if(tmp) { ans2++; printf(&quot;web %d:&quot;,noww); sort(ans+1,ans+tmp+1); for(int j=1;j&lt;=tmp;++j) printf(&quot; %d&quot;,ans[j]); printf(&quot;\\n&quot;); } } int main() { int n,m; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;maxf;++i)tr[0][i]=-1; for(int i=1;i&lt;=n;++i) scanf(&quot;%s&quot;,s),insert(i); getfail(); scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;++i) scanf(&quot;%s&quot;,s),solve(i); printf(&quot;total: %d\\n&quot;,ans2); }","raw":"title: 病毒侵袭\ndate: 2017-03-17 10:21:17\ncategories:\n  - 数据结构\n  - Hollerith-type\n  - AC自动机\ntags:\n  - AC自动机\n  - 模板\n  - KMP\n---\n\n# 病毒侵袭\n\n## [hdu 2896](http://acm.hdu.edu.cn/showproblem.php?pid=2896)\n\n---\n## 题目描述\n\n当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~\n\n但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。\n\n万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~\n### 输入输出格式\n#### 输入格式：\n第一行，一个整数N（1<=N<=500），表示病毒特征码的个数。\n\n接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。\n每个病毒都有一个编号，依此为1—N。\n\n不同编号的病毒特征码不会相同。\n\n在这之后一行，有一个整数M（1<=M<=1000），表示网站数。\n\n接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。\n\n每个网站都有一个编号，依此为1—M。\n\n以上字符串中字符都是ASCII码可见字符（不包括回车）。\n#### 输出格式：\n依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。\n\nweb 网站编号: 病毒编号 病毒编号 …\n\n冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。\n\n最后一行输出统计信息，如下格式\n\ntotal: 带病毒网站数\n\n(冒号后有一个空格)\n\n\n### 输入输出样例\n#### 输入样例#1：\n    3\n    aaa\n    bbb\n    ccc\n    2\n    aaabbbccc\n    bbaacc\n\n\n    \n\n#### 输出样例#1：\n\n    web 1: 1 2 3\n\ttotal: 1\n\n---\nAC自动机模板题\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<queue>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N=501*201+5;\n    const int maxf = 128;\n    int ans[1001],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N];\n    char s[10001];\n    bool use[N];\n    void insert(int noww)\n    {\n        int n=strlen(s),now=0;\n        for(int i=0;i<n;++i)\n        {\n            if(tr[now][s[i]]==-1)\n            {\n                tr[now][s[i]]=++tot;\n                for(int j=0;j<maxf;++j)tr[tot][j]=-1;\n                tag[tot]=0;\n            }\n            now=tr[now][s[i]];\n        }\n        tag[now]=noww;\n    }\n    void getfail()\n    {\n        queue<int>q;\n        fail[0]=0;\n        for(int i=0;i<maxf;++i)\n        if(tr[0][i]!=-1)\n        fail[tr[0][i]]=0,q.push(tr[0][i]);\n        else tr[0][i]=0;\n        while(!q.empty())\n        {\n            int x=q.front();q.pop();\n            for(int j=0;j<maxf;++j)\n            if(tr[x][j]!=-1)\n            {q.push(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];}\n            else\n            tr[x][j]=tr[fail[x]][j];\n        }\n    }\n    void solve(int noww)\n    {\n        int n=strlen(s),now=0;\n        memset(use,0,sizeof(use));\n        tmp=0;\n        for(int i=0;i<n;++i)\n        {\n            now=tr[now][s[i]];\n            for(int j=now;j;j=fail[j])\n            if(tag[j]&&!use[tag[j]])\n            ans[++tmp]=tag[j],use[tag[j]]=1;\n        }\n        if(tmp)\n        {\n            ans2++;\n            printf(\"web %d:\",noww);\n            sort(ans+1,ans+tmp+1);\n            for(int j=1;j<=tmp;++j)\n            printf(\" %d\",ans[j]);\n            printf(\"\\n\");\n        }\n    }\n    int main()\n    {\n        int n,m;\n        scanf(\"%d\",&n);\n        for(int i=0;i<maxf;++i)tr[0][i]=-1;\n        for(int i=1;i<=n;++i)\n        scanf(\"%s\",s),insert(i);\n        getfail();\n        scanf(\"%d\",&m);\n        for(int i=1;i<=m;++i)\n        scanf(\"%s\",s),solve(i);\n            printf(\"total: %d\\n\",ans2);\n    }","content":"<h1 id=\"病毒侵袭\"><a href=\"#病毒侵袭\" class=\"headerlink\" title=\"病毒侵袭\"></a>病毒侵袭</h1><h2 id=\"hdu-2896\"><a href=\"#hdu-2896\" class=\"headerlink\" title=\"hdu 2896\"></a><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2896\" target=\"_blank\" rel=\"external\">hdu 2896</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~</p>\n<p>但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。</p>\n<p>万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行，一个整数N（1&lt;=N&lt;=500），表示病毒特征码的个数。</p>\n<p>接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。<br>每个病毒都有一个编号，依此为1—N。</p>\n<p>不同编号的病毒特征码不会相同。</p>\n<p>在这之后一行，有一个整数M（1&lt;=M&lt;=1000），表示网站数。</p>\n<p>接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。</p>\n<p>每个网站都有一个编号，依此为1—M。</p>\n<p>以上字符串中字符都是ASCII码可见字符（不包括回车）。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。</p>\n<p>web 网站编号: 病毒编号 病毒编号 …</p>\n<p>冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。</p>\n<p>最后一行输出统计信息，如下格式</p>\n<p>total: 带病毒网站数</p>\n<p>(冒号后有一个空格)</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>3\naaa\nbbb\nccc\n2\naaabbbccc\nbbaacc\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>web 1: 1 2 3\ntotal: 1\n</code></pre><hr>\n<h2 id=\"AC自动机模板题\"><a href=\"#AC自动机模板题\" class=\"headerlink\" title=\"AC自动机模板题\"></a>AC自动机模板题</h2><h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;queue&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N=501*201+5;\nconst int maxf = 128;\nint ans[1001],ans2,tmp,tr[N][maxf],tot,tag[N],fail[N];\nchar s[10001];\nbool use[N];\nvoid insert(int noww)\n{\n    int n=strlen(s),now=0;\n    for(int i=0;i&lt;n;++i)\n    {\n        if(tr[now][s[i]]==-1)\n        {\n            tr[now][s[i]]=++tot;\n            for(int j=0;j&lt;maxf;++j)tr[tot][j]=-1;\n            tag[tot]=0;\n        }\n        now=tr[now][s[i]];\n    }\n    tag[now]=noww;\n}\nvoid getfail()\n{\n    queue&lt;int&gt;q;\n    fail[0]=0;\n    for(int i=0;i&lt;maxf;++i)\n    if(tr[0][i]!=-1)\n    fail[tr[0][i]]=0,q.push(tr[0][i]);\n    else tr[0][i]=0;\n    while(!q.empty())\n    {\n        int x=q.front();q.pop();\n        for(int j=0;j&lt;maxf;++j)\n        if(tr[x][j]!=-1)\n        {q.push(tr[x][j]);fail[tr[x][j]]=tr[fail[x]][j];}\n        else\n        tr[x][j]=tr[fail[x]][j];\n    }\n}\nvoid solve(int noww)\n{\n    int n=strlen(s),now=0;\n    memset(use,0,sizeof(use));\n    tmp=0;\n    for(int i=0;i&lt;n;++i)\n    {\n        now=tr[now][s[i]];\n        for(int j=now;j;j=fail[j])\n        if(tag[j]&amp;&amp;!use[tag[j]])\n        ans[++tmp]=tag[j],use[tag[j]]=1;\n    }\n    if(tmp)\n    {\n        ans2++;\n        printf(&quot;web %d:&quot;,noww);\n        sort(ans+1,ans+tmp+1);\n        for(int j=1;j&lt;=tmp;++j)\n        printf(&quot; %d&quot;,ans[j]);\n        printf(&quot;\\n&quot;);\n    }\n}\nint main()\n{\n    int n,m;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=0;i&lt;maxf;++i)tr[0][i]=-1;\n    for(int i=1;i&lt;=n;++i)\n    scanf(&quot;%s&quot;,s),insert(i);\n    getfail();\n    scanf(&quot;%d&quot;,&amp;m);\n    for(int i=1;i&lt;=m;++i)\n    scanf(&quot;%s&quot;,s),solve(i);\n        printf(&quot;total: %d\\n&quot;,ans2);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/17/病毒入侵/","excerpt":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"Hollerith-type","slug":"数据结构/Hollerith-type","permalink":"https://prostkhala.github.io/categories/数据结构/Hollerith-type/"},{"name":"AC自动机","slug":"数据结构/Hollerith-type/AC自动机","permalink":"https://prostkhala.github.io/categories/数据结构/Hollerith-type/AC自动机/"}],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://prostkhala.github.io/tags/AC自动机/"},{"name":"KMP","slug":"KMP","permalink":"https://prostkhala.github.io/tags/KMP/"},{"name":"模板","slug":"模板","permalink":"https://prostkhala.github.io/tags/模板/"}]},{"title":"HAOI2007 理想的正方形","date":"2017-03-14T07:36:17.000Z","path":"2017/03/14/理想的正方形/","text":"[HAOI2007] 理想的正方形BZOJ1047 洛谷2216 题目描述有一个ab的整数组成的矩阵，现请你从中找出一个nn的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 输入输出格式输入格式：第一行为3个整数，分别表示a,b,n的值 第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。 输出格式：仅一个整数，为ab矩阵中所有“nn正方形区域中的最大整数和最小整数的差值”的最小值。 输入输出样例输入样例：5 4 2 1 2 5 6 0 17 16 0 16 17 2 1 2 10 2 1 1 2 2 2 输出样例：1 数据范围矩阵中的所有数都不超过1,000,000,000 20%的数据2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10 100%的数据2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100 题解二维滑动窗口，先对每一行建立双端队列，记录每一个$1n$的长方体中的极值，将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n1$的长方体(在原矩阵中为nn的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的nn正方形的极值信息)，枚举即可。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int inf = 0x7fffffff; const int N =1e3+1; inline int get(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N]; int y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N]; int mapp[N][N],a,b,n; long long ans=inf; int main() { get(a),get(b),get(n); for(int i=1;i&lt;=a;++i)for(int t=1;t&lt;=b;++t)get(mapp[i][t]); for(int i=1;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1; for(int i=1;i&lt;=a;++i) for(int t=1;t&lt;=b;++t) { while(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--; x1[++tailx1[i]]=t; while(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++; minx[i][t]=mapp[i][x1[headx1[i]]]; } for(int i=1;i&lt;=a;++i) for(int t=1;t&lt;=b;++t) { while(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--; x2[++tailx2[i]]=t; while(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++; maxx[i][t]=mapp[i][x2[headx2[i]]]; } for(int t=n;t&lt;=b;++t) for(int i=1;i&lt;=a;++i) { while(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--; y1[++taily1[t]]=i; while(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++; miny[i][t]=minx[y1[heady1[t]]][t]; } for(int t=n;t&lt;=b;++t) for(int i=1;i&lt;=a;++i) { while(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--; y2[++taily2[t]]=i; while(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++; maxy[i][t]=maxx[y2[heady2[t]]][t]; } for(int t=n;t&lt;=b;++t) for(int i=n;i&lt;=a;++i) if(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t]; printf(&quot;%lld&quot;,ans); }","raw":"title: HAOI2007 理想的正方形\ndate: 2017-03-14 15:36:17\ncategories:\n  - 动态规划\n  - 单调性优化\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n---\n\n# [HAOI2007] 理想的正方形\n\n## [BZOJ1047](http://www.lydsy.com/JudgeOnline/problem.php?id=1047) [洛谷2216](https://www.luogu.org/problem/show?pid=2216)\n\n---\n## 题目描述\n\n有一个a*b的整数组成的矩阵，现请你从中找出一个n*n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。\n\n### 输入输出格式\n#### 输入格式：\n第一行为3个整数，分别表示a,b,n的值\n\n第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。\n\n\n#### 输出格式：\n仅一个整数，为a*b矩阵中所有“n*n正方形区域中的最大整数和最小整数的差值”的最小值。\n\n\n### 输入输出样例\n#### 输入样例：\n    5 4 2\n    1 2 5 6\n    0 17 16 0\n    16 17 2 1\n    2 10 2 1\n    1 2 2 2\n    \n\n#### 输出样例：\n\t1\n    \n\n### 数据范围\n矩阵中的所有数都不超过1,000,000,000\n\n20%的数据2<=a,b<=100,n<=a,n<=b,n<=10\n\n100%的数据2<=a,b<=1000,n<=a,n<=b,n<=100\n\n---\n\n## 题解\n二维滑动窗口，先对每一行建立双端队列，记录每一个$1*n$的长方体中的极值，\n将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n*1$的长方体(在原矩阵中为n*n的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的n*n正方形的极值信息)，枚举即可。\n\n---\n### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<queue>\n    using namespace std;\n    const int inf = 0x7fffffff;\n    const int N =1e3+1;\n    inline int get(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];\n    int y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];\n    int mapp[N][N],a,b,n;\n    long long ans=inf;\n    int main()\n    {\n\n        get(a),get(b),get(n);\n        for(int i=1;i<=a;++i)for(int t=1;t<=b;++t)get(mapp[i][t]);\n        for(int i=1;i<N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1;\n        for(int i=1;i<=a;++i)\n        for(int t=1;t<=b;++t)\n        {\n            while(headx1[i]<=tailx1[i]&&mapp[i][x1[tailx1[i]]]>=mapp[i][t])tailx1[i]--;\n            x1[++tailx1[i]]=t;\n            while(headx1[i]<=tailx1[i]&&x1[headx1[i]]<=t-n)headx1[i]++;\n            minx[i][t]=mapp[i][x1[headx1[i]]];\n        }\n        for(int i=1;i<=a;++i)\n        for(int t=1;t<=b;++t)\n        {\n            while(headx2[i]<=tailx2[i]&&mapp[i][x2[tailx2[i]]]<=mapp[i][t])tailx2[i]--;\n            x2[++tailx2[i]]=t;\n            while(headx2[i]<=tailx2[i]&&x2[headx2[i]]<=t-n)headx2[i]++;\n            maxx[i][t]=mapp[i][x2[headx2[i]]];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=1;i<=a;++i)\n        {\n            while(heady1[t]<=taily1[t]&&minx[y1[taily1[t]]][t]>=minx[i][t])taily1[t]--;\n            y1[++taily1[t]]=i;\n            while(heady1[t]<=taily1[t]&&y1[heady1[t]]<=i-n)heady1[t]++;\n            miny[i][t]=minx[y1[heady1[t]]][t];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=1;i<=a;++i)\n        {\n            while(heady2[t]<=taily2[t]&&maxx[y2[taily2[t]]][t]<=maxx[i][t])taily2[t]--;\n            y2[++taily2[t]]=i;\n            while(heady2[t]<=taily2[t]&&y2[heady2[t]]<=i-n)heady2[t]++;\n            maxy[i][t]=maxx[y2[heady2[t]]][t];\n        }\n        for(int t=n;t<=b;++t)\n        for(int i=n;i<=a;++i)\n        if(maxy[i][t]-miny[i][t]<ans)ans=maxy[i][t]-miny[i][t];\n        printf(\"%lld\",ans);\n    }","content":"<h1 id=\"HAOI2007-理想的正方形\"><a href=\"#HAOI2007-理想的正方形\" class=\"headerlink\" title=\"[HAOI2007] 理想的正方形\"></a>[HAOI2007] 理想的正方形</h1><h2 id=\"BZOJ1047-洛谷2216\"><a href=\"#BZOJ1047-洛谷2216\" class=\"headerlink\" title=\"BZOJ1047 洛谷2216\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1047\" target=\"_blank\" rel=\"external\">BZOJ1047</a> <a href=\"https://www.luogu.org/problem/show?pid=2216\" target=\"_blank\" rel=\"external\">洛谷2216</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有一个a<em>b的整数组成的矩阵，现请你从中找出一个n</em>n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行为3个整数，分别表示a,b,n的值</p>\n<p>第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>仅一个整数，为a<em>b矩阵中所有“n</em>n正方形区域中的最大整数和最小整数的差值”的最小值。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><pre><code>5 4 2\n1 2 5 6\n0 17 16 0\n16 17 2 1\n2 10 2 1\n1 2 2 2\n</code></pre><h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><pre><code>1\n</code></pre><h3 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h3><p>矩阵中的所有数都不超过1,000,000,000</p>\n<p>20%的数据2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10</p>\n<p>100%的数据2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100</p>\n<hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>二维滑动窗口，先对每一行建立双端队列，记录每一个$1<em>n$的长方体中的极值，<br>将二维矩阵压缩成$a$行$b-n+1$列的矩阵，再对每一列依次建立双端队列，记录$n</em>1$的长方体(在原矩阵中为n<em>n的正方形)中的极值(in(max)y[i][t]存储的是以map[i][t]为右下角端点的n</em>n正方形的极值信息)，枚举即可。</p>\n<hr>\n<h3 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int inf = 0x7fffffff;\nconst int N =1e3+1;\ninline int get(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint x1[N],x2[N],headx1[N],tailx1[N],headx2[N],tailx2[N],minx[N][N],maxx[N][N];\nint y1[N],y2[N],heady1[N],taily1[N],heady2[N],taily2[N],miny[N][N],maxy[N][N];\nint mapp[N][N],a,b,n;\nlong long ans=inf;\nint main()\n{\n\n    get(a),get(b),get(n);\n    for(int i=1;i&lt;=a;++i)for(int t=1;t&lt;=b;++t)get(mapp[i][t]);\n    for(int i=1;i&lt;N;++i)headx1[i]=headx2[i]=heady1[i]=heady2[i]=1;\n    for(int i=1;i&lt;=a;++i)\n    for(int t=1;t&lt;=b;++t)\n    {\n        while(headx1[i]&lt;=tailx1[i]&amp;&amp;mapp[i][x1[tailx1[i]]]&gt;=mapp[i][t])tailx1[i]--;\n        x1[++tailx1[i]]=t;\n        while(headx1[i]&lt;=tailx1[i]&amp;&amp;x1[headx1[i]]&lt;=t-n)headx1[i]++;\n        minx[i][t]=mapp[i][x1[headx1[i]]];\n    }\n    for(int i=1;i&lt;=a;++i)\n    for(int t=1;t&lt;=b;++t)\n    {\n        while(headx2[i]&lt;=tailx2[i]&amp;&amp;mapp[i][x2[tailx2[i]]]&lt;=mapp[i][t])tailx2[i]--;\n        x2[++tailx2[i]]=t;\n        while(headx2[i]&lt;=tailx2[i]&amp;&amp;x2[headx2[i]]&lt;=t-n)headx2[i]++;\n        maxx[i][t]=mapp[i][x2[headx2[i]]];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=1;i&lt;=a;++i)\n    {\n        while(heady1[t]&lt;=taily1[t]&amp;&amp;minx[y1[taily1[t]]][t]&gt;=minx[i][t])taily1[t]--;\n        y1[++taily1[t]]=i;\n        while(heady1[t]&lt;=taily1[t]&amp;&amp;y1[heady1[t]]&lt;=i-n)heady1[t]++;\n        miny[i][t]=minx[y1[heady1[t]]][t];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=1;i&lt;=a;++i)\n    {\n        while(heady2[t]&lt;=taily2[t]&amp;&amp;maxx[y2[taily2[t]]][t]&lt;=maxx[i][t])taily2[t]--;\n        y2[++taily2[t]]=i;\n        while(heady2[t]&lt;=taily2[t]&amp;&amp;y2[heady2[t]]&lt;=i-n)heady2[t]++;\n        maxy[i][t]=maxx[y2[heady2[t]]][t];\n    }\n    for(int t=n;t&lt;=b;++t)\n    for(int i=n;i&lt;=a;++i)\n    if(maxy[i][t]-miny[i][t]&lt;ans)ans=maxy[i][t]-miny[i][t];\n    printf(&quot;%lld&quot;,ans);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/14/理想的正方形/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"},{"name":"单调性优化","slug":"动态规划/单调性优化","permalink":"https://prostkhala.github.io/categories/动态规划/单调性优化/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"}]},{"title":"NOIP模拟赛 2017 3 12","date":"2017-03-13T10:01:11.000Z","path":"2017/03/13/NOIP模拟赛 2017 3 12/","text":"T1 Blue题目描述Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。 他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。 当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。 输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。 输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。 样例输入5 10 9 16 30 2 4 6 9 11 15 18 19 25 27 10 1 23 30 10 11 13 14 15 16 18 26 27 29 10 7 28 30 2 3 7 9 12 15 20 24 27 28 10 3 18 30 1 6 9 14 18 19 22 27 28 29 10 7 10 30 1 2 4 6 18 19 20 22 23 26 样例输出5 Excited Excited Excited 0 数据范围对于 10%的数据保证 $m=1$. 对于另外 10%的数据保证 $D=L$. 对于另外 10%的数据保证 $n=L-1$. 对于另外 30%的数据保证 $n&lt;=100, L&lt;=10^5$. 对于 100%的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$.数据范围中的 n、m 皆代表题目描述中 n、m 的总和。 题解这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。 具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了…. CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N =1e6+1; inline void read(int &amp;x) { x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar(); while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} } int tt,n,m,d,l,a[N],b[N]; bool can(int ans) { for(int i=1;i&lt;=ans;++i)b[i]=0; int anss=0; for(int now=1;now&lt;=n;++now) { if(a[now]-b[++anss]&lt;=d)b[anss]=a[now]; if(anss==ans)anss=0; } for(int i=1;i&lt;=ans;++i) if(l-b[i]&gt;d)return 0; return 1; } int main() { // freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout); read(tt); while(tt--) { read(n),read(m),read(d),read(l); for(int i=1;i&lt;=n;++i)read(a[i]); int ll=0,rr=m,mid; while(ll!=rr) { mid=ll+rr+1&gt;&gt;1; if(can(mid)) ll=mid; else rr=mid-1; } if(rr==m) printf(&quot;Excited\\n&quot;); else printf(&quot;%d\\n&quot;,rr); } return 0; } T2 Weed题目描述duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。 电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上面没有金坷垃了。 duyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最终金坷垃的量有多少。 输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，后面 2 个数描述更改为这样的操作。 输出 q 行代表每次金坷垃的量为多少 样例输入10 5 0 10 1 5 0 13 0 18 0 2 1 1 0 8 0 9 1 3 0 7 9 0 3 10 1 7 6 0 8 10 0 5 8 1 2 样例输出58 0 0 66 41 数据范围对于 30%的数据，m&lt;=1000,q&lt;=1000. 对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。 对于 100%的数据，m&lt;=210^5,q&lt;=210^5,vi&lt;=10^4. 题解由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现… 题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。 CODE#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; inline void read(int &amp;x) { x=0;int f=1;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} x*=f; } const int N =2e5+7; struct build{int sum,in,out;}tr[8*N]; int n,q,k,a[N],tot; int find(int x,int pot) { if(pot&gt;=tr[x].in) return 0; if(!pot) return tr[x].sum; if(pot&lt;=tr[x*2+1].in) return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot); return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out); } void update(int x) { tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out); tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in); tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out); } void build(int x,int l,int r) { if(l==r) { if(a[l]&lt;0) tr[x].out=-a[l]; else tr[x].in=1,tr[x].sum=a[l]; } else { int mid=l+r&gt;&gt;1; build(x*2,l,mid); build(x*2+1,mid+1,r); update(x); } } void change(int x,int pot,int w,int l,int r) { if(l==r) { memset(&amp;tr[x],0,sizeof(tr[x])); if(w&lt;0) tr[x].out=-w; else tr[x].in=1,tr[x].sum=w; } else { int mid=l+r&gt;&gt;1; if(pot&gt;mid) change(x*2+1,pot,w,mid+1,r); else change(x*2,pot,w,l,mid); update(x); } } int main() { // freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout); read(n),read(q); for(int i=1;i&lt;=n;++i) { read(k),read(a[i]); if(k)a[i]*=-1; } build(1,1,n); while(q--) { int x,w; read(x);read(k);read(w); if(k)w*=-1; change(1,x,w,1,n); printf(&quot;%d\\n&quot;,tr[1].sum); } } T3 Drink题目描述在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚不到这么多资本），所以决定用特殊的方法赏赐毒液哥。 Link的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财的他想知道最后棋盘内所有的宝物价值以方便他挑选。 作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）和资产阶级代表（Link）之间的贫富差距么。 输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c的正方形。 输出一个 N * M 的矩阵表示最后的棋盘。 样例输入4 4 3 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 1 3 3 3 2 2 2 2 样例输出1 5 1 4 2 7 6 8 3 7 2 3 5 6 8 4 数据范围对于 30%的数据，N, M, Q &lt;= 100. 对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。 对于 100%的数据, N, M, Q &lt;= 1000.所有数取值都为 0~9. 题解以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。 CODE/* * @Author: 閫搁棽 * @Date: 2016-09-25 13:04:44 * @Last Modified by: 閫搁棽 * @Last Modified time: 2016-10-01 10:19:00 */ #include &quot;cstdio&quot; #include &quot;cstdlib&quot; #include &quot;iostream&quot; #include &quot;algorithm&quot; #include &quot;cstring&quot; #include &quot;queue&quot; using namespace std; #define INF 0x3F3F3F3F #define MAX_SIZE 2005 #define Eps #define Mod #define Get(x, a) (x ? x -&gt; a : 0) #define Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it) inline int Get_Int() { int Num = 0, Flag = 1; char ch; do { ch = getchar(); if(ch == &#39;-&#39;) Flag = -Flag; } while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;); do { Num = Num * 10 + ch - &#39;0&#39;; ch = getchar(); } while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;); return Num * Flag; } int N, M, Q; int A[MAX_SIZE * MAX_SIZE][4], Map[MAX_SIZE][MAX_SIZE]; inline void Move(int &amp;Direction, int &amp;Now, int j) { int Next = A[Now][j - Direction + 4 &amp; 3]; for(Direction = 0; A[Next][j - Direction + 6 &amp; 3] != Now; ++Direction); Now = Next; } int main() { #ifndef ONLINE_JUDGE // freopen(&quot;drink.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;drink.out&quot;, &quot;w&quot;, stdout); #endif cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q; for(int i = 1; i &lt;= N; ++i) for(int j = 1; j &lt;= M; ++j) Map[i][j] = Get_Int(); for(int i = 1; i &lt;= (N + 2) * (M + 2); ++i) { A[i][0] = i - M - 2; A[i][1] = i + 1; A[i][2] = i + M + 2; A[i][3] = i - 1; } while(Q--) { int x = Get_Int(), y = Get_Int(), c = Get_Int(); int Direction = 0, Now = 1; vector&lt; pair&lt;int, int&gt; &gt; Border[4][2]; for(int i = 1; i &lt;= x; ++i) Move(Direction, Now, 2); for(int i = 1; i &lt;= y; ++i) Move(Direction, Now, 1); for(int j = 0; j &lt; 4; ++j) for(int i = 1; i &lt;= c; ++i) { Border[j][0].push_back(make_pair(Direction, Now)); Move(Direction, Now, j); Border[j][1].push_back(make_pair(Direction, Now)); Move(Direction, Now, j + 2 &amp; 3); if(i != c) Move(Direction, Now, j + 1 &amp; 3); } for(int j = 0; j &lt; 4; ++j) for(int i = 0; i &lt; c; ++i) { pair&lt;int, int&gt; Now = Border[j][1][i]; A[Now.second][j + 6 - Now.first &amp; 3] = Border[j + 3 &amp; 3][0][i].second; Now = Border[j][0][i]; A[Now.second][j + 4 - Now.first &amp; 3] = Border[j + 1 &amp; 3][1][i].second; } } int Direction = 0, Now = 1; for(int i = 1; i &lt;= N; ++i) { Move(Direction, Now, 2); int temp = Direction, Next = Now; for(int j = 1; j &lt;= M; ++j) { Move(temp, Next, 1); printf(&quot;%d &quot;, Map[(Next - 1) / (M + 2)][(Next - 1) % (M + 2)]); } printf(&quot;\\n&quot;); } fclose(stdin); fclose(stdout); return 0; }","raw":"title: NOIP模拟赛 2017 3 12\ndate: 2017-03-13 18:01:11\ncategories:\n  - NOIP模拟赛\ntags:\n  - 二分答案\n  - 贪心\n  - 线段树\n  - 二维线段树\n---\n\n## T1 Blue\n### 题目描述\nBlue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。\n\n他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)\n中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。\n\n当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就\n会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。\n\n输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。\n第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。\n\n输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。\n\n\n#### 样例输入\n    5\n    10 9 16 30\n    2 4 6 9 11 15 18 19 25 27 \n    10 1 23 30\n    10 11 13 14 15 16 18 26 27 29 \n    10 7 28 30\n    2 3 7 9 12 15 20 24 27 28 \n    10 3 18 30\n    1 6 9 14 18 19 22 27 28 29 \n    10 7 10 30\n    1 2 4 6 18 19 20 22 23 26 \n#### 样例输出\n    5\n    Excited\n    Excited\n    Excited\n    0\n#### 数据范围\n对于 10%的数据保证 $m=1$.\n\n对于另外 10%的数据保证 $D=L$.\n\n对于另外 10%的数据保证 $n=L-1$.\n\n对于另外 30%的数据保证 $n<=100, L<=10^5$.\n\n对于 100%的数据保证 $m<=n<=10^6,D<=L<=10^9$.\n数据范围中的 n、m 皆代表题目描述中 n、m 的总和。\n\n---\n### 题解\n\n这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D<=L<=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。\n\n具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了....\n\n---\n#### CODE\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N =1e6+1;\n    inline void read(int &x)\n    {\n        x=0;char ch=getchar();\n        while(ch<'0'||ch>'9')ch=getchar();\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    }\n    int tt,n,m,d,l,a[N],b[N];\n    bool can(int ans)\n    {\n        for(int i=1;i<=ans;++i)b[i]=0;\n        int anss=0;\n        for(int now=1;now<=n;++now)\n        {\n            if(a[now]-b[++anss]<=d)b[anss]=a[now];\n            if(anss==ans)anss=0;\n        }\n        for(int i=1;i<=ans;++i)\n        if(l-b[i]>d)return 0;\n        return 1;\n    }\n    int main()\n    {\n    //    freopen(\"Blue.in\",\"r\",stdin);\n    //    freopen(\"Blue.out\",\"w\",stdout);\n        read(tt);\n        while(tt--)\n        {\n            read(n),read(m),read(d),read(l);\n            for(int i=1;i<=n;++i)read(a[i]);\n            int ll=0,rr=m,mid;\n            while(ll!=rr)\n            {\n                mid=ll+rr+1>>1;\n                if(can(mid))\tll=mid;\n                else\t\t\trr=mid-1;\n            }\n            if(rr==m)\tprintf(\"Excited\\n\");\n            else \t\tprintf(\"%d\\n\",rr);\n        }\n        return 0;\n    }\n\n\n---\n## T2 Weed\n### 题目描述\nduyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。\n为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。\n\n电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最\n新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上\n面没有金坷垃了。\n\nduyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行\n了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最\n终金坷垃的量有多少。\n\n输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，\n为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，\n后面 2 个数描述更改为这样的操作。\n\n输出 q 行代表每次金坷垃的量为多少\n#### 样例输入\n    10 5\n    0 10\n    1 5\n    0 13\n    0 18\n    0 2\n    1 1\n    0 8\n    0 9\n    1 3\n    0 7\n    9 0 3\n    10 1 7\n    6 0 8\n    10 0 5\n    8 1 2\n\n\n#### 样例输出\n    58\n    0\n    0\n    66\n    41\n\n#### 数据范围\n对于 30%的数据，m<=1000,q<=1000.\n\n对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。\n\n对于 100%的数据，m<=2*10^5,q<=2*10^5,vi<=10^4.\n\n---\n### 题解\n由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现...\n\n题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。\n\n---\n### CODE\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    inline void read(int &x)\n    {\n        x=0;int f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n        x*=f;\n    }\n    const int N =2e5+7;\n    struct build{int sum,in,out;}tr[8*N];\n    int n,q,k,a[N],tot;\n    int find(int x,int pot)\n    {\n        if(pot>=tr[x].in)\t\t\treturn 0;\n        if(!pot)\t\t\t\t\treturn tr[x].sum;\n        if(pot<=tr[x*2+1].in)\n        return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot);\n        return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out);\n    }\n    void update(int x)\n    {\n        tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out);\n        tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in);\n        tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out);\n    }\n    void build(int x,int l,int r)\n    {\n        if(l==r)\n        {\n            if(a[l]<0)\ttr[x].out=-a[l];\n            else\t\ttr[x].in=1,tr[x].sum=a[l];\n        }\n        else\n        {\n            int mid=l+r>>1;\n            build(x*2,l,mid);\n            build(x*2+1,mid+1,r);\n            update(x);\n        }\n    }\n    void change(int x,int pot,int w,int l,int r)\n    {\n        if(l==r)\n        {\n            memset(&tr[x],0,sizeof(tr[x]));\n            if(w<0)\t\ttr[x].out=-w;\n            else\t\ttr[x].in=1,tr[x].sum=w;\n        }\n        else\n        {\n            int mid=l+r>>1;\n            if(pot>mid)\tchange(x*2+1,pot,w,mid+1,r);\n            else\t\tchange(x*2,pot,w,l,mid);\n            update(x);\n        }\n    }\n    int main()\n    {\n    //    freopen(\"weed.in\", \"r\", stdin);\n    //    freopen(\"weed.out\", \"w\", stdout);\n        read(n),read(q);\n        for(int i=1;i<=n;++i)\n        {\n            read(k),read(a[i]);\n            if(k)a[i]*=-1;\n        }\n        build(1,1,n);\n        while(q--)\n        {\n            int x,w;\n            read(x);read(k);read(w);\n            if(k)w*=-1;\n            change(1,x,w,1,n);\n            printf(\"%d\\n\",tr[1].sum);\n        }\n    }\n---\n## T3 Drink\n### 题目描述\n在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份\n丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚\n不到这么多资本），所以决定用特殊的方法赏赐毒液哥。\n\nLink的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，\n每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。\n毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财\n的他想知道最后棋盘内所有的宝物价值以方便他挑选。\n\n作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）\n和资产阶级代表（Link）之间的贫富差距么。\n\n输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。\n接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。\n接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c\n的正方形。\n\n输出一个 N * M 的矩阵表示最后的棋盘。\n#### 样例输入\n    4 4 3\n    1 2 3 4\n    5 6 7 8\n    1 2 3 4\n    5 6 7 8\n    1 1 3\n    3 3 2\n    2 2 2\n\n\n#### 样例输出\n    1 5 1 4 \n    2 7 6 8 \n    3 7 2 3 \n    5 6 8 4 \n\n#### 数据范围\n对于 30%的数据，N, M, Q <= 100.\n\n对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。\n\n对于 100%的数据, N, M, Q <= 1000.所有数取值都为 0~9.\n\n---\n### 题解\n以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。\n\n### CODE\n\n    /*\n    * @Author: 閫搁棽\n    * @Date:   2016-09-25 13:04:44\n    * @Last Modified by:   閫搁棽\n    * @Last Modified time: 2016-10-01 10:19:00\n    */\n\n    #include \"cstdio\"\n    #include \"cstdlib\"\n    #include \"iostream\"\n    #include \"algorithm\"\n    #include \"cstring\"\n    #include \"queue\"\n\n    using namespace std;\n\n    #define INF 0x3F3F3F3F\n    #define MAX_SIZE 2005\n    #define Eps\n    #define Mod\n    #define Get(x, a) (x ? x -> a : 0)\n    #define Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it)\n\n    inline int Get_Int()\n    {\n        int Num = 0, Flag = 1;\n        char ch;\n        do\n        {\n            ch = getchar();\n            if(ch == '-')\n                Flag = -Flag;\n        }\n        while(ch < '0' || ch > '9');\n        do\n        {\n            Num = Num * 10 + ch - '0';\n            ch = getchar();\n        }\n        while(ch >= '0' && ch <= '9');\n        return Num * Flag;\n    }\n\n    int N, M, Q;\n    int A[MAX_SIZE * MAX_SIZE][4], Map[MAX_SIZE][MAX_SIZE];\n\n    inline void Move(int &Direction, int &Now, int j)\n    {\n        int Next = A[Now][j - Direction + 4 & 3];\n        for(Direction = 0; A[Next][j - Direction + 6 & 3] != Now; ++Direction);\n        Now = Next;\n    }\n\n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n    //\tfreopen(\"drink.in\", \"r\", stdin);\n    //\tfreopen(\"drink.out\", \"w\", stdout);\n    #endif\n        cin >> N >> M >> Q;\n        for(int i = 1; i <= N; ++i)\n            for(int j = 1; j <= M; ++j)\n                Map[i][j] = Get_Int();\n        for(int i = 1; i <= (N + 2) * (M + 2); ++i)\n        {\n            A[i][0] = i - M - 2;\n            A[i][1] = i + 1;\n            A[i][2] = i + M + 2;\n            A[i][3] = i - 1;\n        }\n        while(Q--)\n        {\n            int x = Get_Int(), y = Get_Int(), c = Get_Int();\n            int Direction = 0, Now = 1;\n            vector< pair<int, int> > Border[4][2];\n            for(int i = 1; i <= x; ++i)\n                Move(Direction, Now, 2);\n            for(int i = 1; i <= y; ++i)\n                Move(Direction, Now, 1);\n            for(int j = 0; j < 4; ++j)\n                for(int i = 1; i <= c; ++i)\n                {\n                    Border[j][0].push_back(make_pair(Direction, Now));\n                    Move(Direction, Now, j);\n                    Border[j][1].push_back(make_pair(Direction, Now));\n                    Move(Direction, Now, j + 2 & 3);\n                    if(i != c)\n                        Move(Direction, Now, j + 1 & 3);\n                }\n            for(int j = 0; j < 4; ++j)\n                for(int i = 0; i < c; ++i)\n                {\n                    pair<int, int> Now = Border[j][1][i];\n                    A[Now.second][j + 6 - Now.first & 3] = Border[j + 3 & 3][0][i].second;\n                    Now = Border[j][0][i];\n                    A[Now.second][j + 4 - Now.first & 3] = Border[j + 1 & 3][1][i].second;\n                }\n        }\n        int Direction = 0, Now = 1;\n        for(int i = 1; i <= N; ++i)\n        {\n            Move(Direction, Now, 2);\n            int temp = Direction, Next = Now;\n            for(int j = 1; j <= M; ++j)\n            {\n                Move(temp, Next, 1);\n                printf(\"%d \", Map[(Next - 1) / (M + 2)][(Next - 1) % (M + 2)]);\n            }\n            printf(\"\\n\");\n        }\n        fclose(stdin);\n        fclose(stdout);\n        return 0;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h2 id=\"T1-Blue\"><a href=\"#T1-Blue\" class=\"headerlink\" title=\"T1 Blue\"></a>T1 Blue</h2><h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>Blue 是个动物学家，不仅喜欢研究猫和老鼠，还喜欢研究青蛙。</p>\n<p>他最近开始研究青蛙过河的问题，可以简化成：数轴上 0 为岸边，L 为河对岸。(0,L)<br>中间存在 n 个石子。已知青蛙一跳可以跳距离 D，而且不能沾水。求问能不能跳到河对岸。</p>\n<p>当然他觉得这个问题非常 naïve，于是在思考如果青蛙有 m 个，且石头被踩过之后就<br>会沉下去，m 个青蛙还能不能依次安全过河。如果不能则问最多能有多少个过河。</p>\n<p>输入第一行为一个正整数 T 代表数据组数。每组数据第一行四个正整数：n、m、D、L。<br>第二行 n 个升序正整数 ai 代表第 i 个石子坐标为 ai。保证没有重复且都小于 L。</p>\n<p>输出 T 行”Excited”代表全部能过河或者一个整数代表有多少个能过河的。</p>\n<h4 id=\"样例输入\"><a href=\"#样例输入\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>5\n10 9 16 30\n2 4 6 9 11 15 18 19 25 27 \n10 1 23 30\n10 11 13 14 15 16 18 26 27 29 \n10 7 28 30\n2 3 7 9 12 15 20 24 27 28 \n10 3 18 30\n1 6 9 14 18 19 22 27 28 29 \n10 7 10 30\n1 2 4 6 18 19 20 22 23 26 \n</code></pre><h4 id=\"样例输出\"><a href=\"#样例输出\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>5\nExcited\nExcited\nExcited\n0\n</code></pre><h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 10%的数据保证 $m=1$.</p>\n<p>对于另外 10%的数据保证 $D=L$.</p>\n<p>对于另外 10%的数据保证 $n=L-1$.</p>\n<p>对于另外 30%的数据保证 $n&lt;=100, L&lt;=10^5$.</p>\n<p>对于 100%的数据保证 $m&lt;=n&lt;=10^6,D&lt;=L&lt;=10^9$.<br>数据范围中的 n、m 皆代表题目描述中 n、m 的总和。</p>\n<hr>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>这题就是比较简单的二分答案+贪心，一开始想到了这种思路，但一直没有正确的贪心策略，后来开始尝试树状数组，看到$D&lt;=L&lt;=10^9$的数据范围后，又写了回离散化，然后又想到还要记录离散化的前的相对位置和d的关系，然后就掉进了深坑中无法自拔。最后半小时重新推了下贪心，（伪）A掉了这题。教训就是不要浮躁，做题要静下心来。</p>\n<p>具体的策略就是，每次针对不同答案进行贪心的时，记录一下这些青蛙的位置，然后就没了….</p>\n<hr>\n<h4 id=\"CODE\"><a href=\"#CODE\" class=\"headerlink\" title=\"CODE\"></a>CODE</h4><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N =1e6+1;\ninline void read(int &amp;x)\n{\n    x=0;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)ch=getchar();\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n}\nint tt,n,m,d,l,a[N],b[N];\nbool can(int ans)\n{\n    for(int i=1;i&lt;=ans;++i)b[i]=0;\n    int anss=0;\n    for(int now=1;now&lt;=n;++now)\n    {\n        if(a[now]-b[++anss]&lt;=d)b[anss]=a[now];\n        if(anss==ans)anss=0;\n    }\n    for(int i=1;i&lt;=ans;++i)\n    if(l-b[i]&gt;d)return 0;\n    return 1;\n}\nint main()\n{\n//    freopen(&quot;Blue.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;Blue.out&quot;,&quot;w&quot;,stdout);\n    read(tt);\n    while(tt--)\n    {\n        read(n),read(m),read(d),read(l);\n        for(int i=1;i&lt;=n;++i)read(a[i]);\n        int ll=0,rr=m,mid;\n        while(ll!=rr)\n        {\n            mid=ll+rr+1&gt;&gt;1;\n            if(can(mid))    ll=mid;\n            else            rr=mid-1;\n        }\n        if(rr==m)    printf(&quot;Excited\\n&quot;);\n        else         printf(&quot;%d\\n&quot;,rr);\n    }\n    return 0;\n}\n</code></pre><hr>\n<h2 id=\"T2-Weed\"><a href=\"#T2-Weed\" class=\"headerlink\" title=\"T2 Weed\"></a>T2 Weed</h2><h3 id=\"题目描述-1\"><a href=\"#题目描述-1\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>duyege的电脑上面已经长草了，经过辨认上面有金坷垃的痕迹。<br>为了查出真相，duyege 准备修好电脑之后再进行一次金坷垃的模拟实验。</p>\n<p>电脑上面有若干层金坷垃，每次只能在上面撒上一层高度为 vi 的金坷垃，或者除掉最<br>新 vi 层（不是量）撒的金坷垃。如果上面只留有不足 vi 层金坷垃，那么就相当于电脑上<br>面没有金坷垃了。</p>\n<p>duyege 非常严谨，一开始先给你 m 个上述操作要你依次完成。然后又对实验步骤进行<br>了 q 次更改，每次更改都会改变其中一个操作为另外一个操作。每次修改之后都会询问最<br>终金坷垃的量有多少。</p>\n<p>输入第一行为两个正整数 m、q，接下来 m 行每行 2 个整数 k、vi。k为 0 时撒金坷垃，<br>为 1 时除金坷垃。接下来 q 行每行 3 个整数 ci、k、vi，ci代表被更改的操作是第 ci 个，<br>后面 2 个数描述更改为这样的操作。</p>\n<p>输出 q 行代表每次金坷垃的量为多少</p>\n<h4 id=\"样例输入-1\"><a href=\"#样例输入-1\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>10 5\n0 10\n1 5\n0 13\n0 18\n0 2\n1 1\n0 8\n0 9\n1 3\n0 7\n9 0 3\n10 1 7\n6 0 8\n10 0 5\n8 1 2\n</code></pre><h4 id=\"样例输出-1\"><a href=\"#样例输出-1\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>58\n0\n0\n66\n41\n</code></pre><h4 id=\"数据范围-1\"><a href=\"#数据范围-1\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 30%的数据，m&lt;=1000,q&lt;=1000.</p>\n<p>对于另外 20%的数据，每次 k=1 时都会将金坷垃清空。</p>\n<p>对于 100%的数据，m&lt;=2<em>10^5,q&lt;=2</em>10^5,vi&lt;=10^4.</p>\n<hr>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>由于该题涉及中间量的改变，所以要用线段树来记录，一开始想的是链表，每次操作修改一下链表中与更改操作相关的指针，然而最后也没有实现…</p>\n<p>题解还是挺巧妙，将每次操作依次进栈，对于每次更改，即为将被更改操作以上的所有操作出栈，将更改后的操作入栈，然后将其余出栈操作按原顺序入栈，我在考场时也仅止步于此，这样的时间复杂度太高，最后并没有尝试这样写。题解便巧妙在用线段树来记录每一段操作的三项信息：执行完这段操作后会删除多少金坷垃，会插入多少，一共又是多少。然后通过一个查找函数来依次向父亲节点更新。</p>\n<hr>\n<h3 id=\"CODE-1\"><a href=\"#CODE-1\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\ninline void read(int &amp;x)\n{\n    x=0;int f=1;char ch=getchar();\n    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}\n    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}\n    x*=f;\n}\nconst int N =2e5+7;\nstruct build{int sum,in,out;}tr[8*N];\nint n,q,k,a[N],tot;\nint find(int x,int pot)\n{\n    if(pot&gt;=tr[x].in)            return 0;\n    if(!pot)                    return tr[x].sum;\n    if(pot&lt;=tr[x*2+1].in)\n    return tr[x].sum-tr[x*2+1].sum+find(x*2+1,pot);\n    return find(x*2,pot-tr[x*2+1].in+tr[x*2+1].out);\n}\nvoid update(int x)\n{\n    tr[x].in=tr[x*2+1].in+max(0,tr[x*2].in-tr[x*2+1].out);\n    tr[x].out=tr[x*2].out+max(0,tr[x*2+1].out-tr[x*2].in);\n    tr[x].sum=tr[x*2+1].sum+find(x*2,tr[x*2+1].out);\n}\nvoid build(int x,int l,int r)\n{\n    if(l==r)\n    {\n        if(a[l]&lt;0)    tr[x].out=-a[l];\n        else        tr[x].in=1,tr[x].sum=a[l];\n    }\n    else\n    {\n        int mid=l+r&gt;&gt;1;\n        build(x*2,l,mid);\n        build(x*2+1,mid+1,r);\n        update(x);\n    }\n}\nvoid change(int x,int pot,int w,int l,int r)\n{\n    if(l==r)\n    {\n        memset(&amp;tr[x],0,sizeof(tr[x]));\n        if(w&lt;0)        tr[x].out=-w;\n        else        tr[x].in=1,tr[x].sum=w;\n    }\n    else\n    {\n        int mid=l+r&gt;&gt;1;\n        if(pot&gt;mid)    change(x*2+1,pot,w,mid+1,r);\n        else        change(x*2,pot,w,l,mid);\n        update(x);\n    }\n}\nint main()\n{\n//    freopen(&quot;weed.in&quot;, &quot;r&quot;, stdin);\n//    freopen(&quot;weed.out&quot;, &quot;w&quot;, stdout);\n    read(n),read(q);\n    for(int i=1;i&lt;=n;++i)\n    {\n        read(k),read(a[i]);\n        if(k)a[i]*=-1;\n    }\n    build(1,1,n);\n    while(q--)\n    {\n        int x,w;\n        read(x);read(k);read(w);\n        if(k)w*=-1;\n        change(1,x,w,1,n);\n        printf(&quot;%d\\n&quot;,tr[1].sum);\n    }\n}\n</code></pre><hr>\n<h2 id=\"T3-Drink\"><a href=\"#T3-Drink\" class=\"headerlink\" title=\"T3 Drink\"></a>T3 Drink</h2><h3 id=\"题目描述-2\"><a href=\"#题目描述-2\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>在一个遥远的国度有一个腰缠万贯的资本家 Link，每一个拜访他的人都可以得到一份<br>丰厚的赏赐。有一名穷困潦倒的旅行者毒液哥来到了 Link 家。Link 智商超群（不然也赚<br>不到这么多资本），所以决定用特殊的方法赏赐毒液哥。</p>\n<p>Link的藏宝库是一个N * M棋盘，每个格子里都有宝物。Link会对棋盘做Q次操作，<br>每次操作会选取棋盘内一个正方形，让其中的宝物顺时针转一圈（旋转90度）。<br>毒液哥不仅财富值被 Link 碾压，智商也同样被碾压（不然怎么会这么穷），但是贪财<br>的他想知道最后棋盘内所有的宝物价值以方便他挑选。</p>\n<p>作为建设中国特色社会主义道路上的一颗螺丝钉，你能帮助缩小无产阶级代表（毒液哥）<br>和资产阶级代表（Link）之间的贫富差距么。</p>\n<p>输入第一行三个数 N, M, Q 分别表示棋盘的行数、列数和操作个数。<br>接下来 N 行每行 M 个数表示一开始棋盘上宝物的价值。<br>接下来 Q 行每行 3 个数 x, y, c 表示操作区域为以第 x 行第 y列为左上角的边长为 c<br>的正方形。</p>\n<p>输出一个 N * M 的矩阵表示最后的棋盘。</p>\n<h4 id=\"样例输入-2\"><a href=\"#样例输入-2\" class=\"headerlink\" title=\"样例输入\"></a>样例输入</h4><pre><code>4 4 3\n1 2 3 4\n5 6 7 8\n1 2 3 4\n5 6 7 8\n1 1 3\n3 3 2\n2 2 2\n</code></pre><h4 id=\"样例输出-2\"><a href=\"#样例输出-2\" class=\"headerlink\" title=\"样例输出\"></a>样例输出</h4><pre><code>1 5 1 4 \n2 7 6 8 \n3 7 2 3 \n5 6 8 4 \n</code></pre><h4 id=\"数据范围-2\"><a href=\"#数据范围-2\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>对于 30%的数据，N, M, Q &lt;= 100.</p>\n<p>对于另外 30%的数据，保证所有 Q 个正方形两两之间不相交或相等。</p>\n<p>对于 100%的数据, N, M, Q &lt;= 1000.所有数取值都为 0~9.</p>\n<hr>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>以前写过类似的模拟题，便套用了之前的思路，即对于每个点，记录其前后左右的点，然后将所有点的朝向初始化为朝前（p=0），每次旋转，更改一下最外围点的前后左右点，对于内圈的点，其前后左右的点没有改变，只需要将所有被旋转的点的朝向旋转一下（p=(p+1)%4），这一步操作通过二维线段树来实现（然而并不会写）。题解的大体思路相近，只是在处理朝向那里更加巧妙，且也没有用二维数组存储每个点的相对位置，而是用一维数组操作，其他的还有许多处理上的技巧。</p>\n<h3 id=\"CODE-2\"><a href=\"#CODE-2\" class=\"headerlink\" title=\"CODE\"></a>CODE</h3><pre><code>/*\n* @Author: 閫搁棽\n* @Date:   2016-09-25 13:04:44\n* @Last Modified by:   閫搁棽\n* @Last Modified time: 2016-10-01 10:19:00\n*/\n\n#include &quot;cstdio&quot;\n#include &quot;cstdlib&quot;\n#include &quot;iostream&quot;\n#include &quot;algorithm&quot;\n#include &quot;cstring&quot;\n#include &quot;queue&quot;\n\nusing namespace std;\n\n#define INF 0x3F3F3F3F\n#define MAX_SIZE 2005\n#define Eps\n#define Mod\n#define Get(x, a) (x ? x -&gt; a : 0)\n#define Travel(x) for(typeof(x.begin()) it = x.begin(); it != x.end(); ++it)\n\ninline int Get_Int()\n{\n    int Num = 0, Flag = 1;\n    char ch;\n    do\n    {\n        ch = getchar();\n        if(ch == &#39;-&#39;)\n            Flag = -Flag;\n    }\n    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;);\n    do\n    {\n        Num = Num * 10 + ch - &#39;0&#39;;\n        ch = getchar();\n    }\n    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);\n    return Num * Flag;\n}\n\nint N, M, Q;\nint A[MAX_SIZE * MAX_SIZE][4], Map[MAX_SIZE][MAX_SIZE];\n\ninline void Move(int &amp;Direction, int &amp;Now, int j)\n{\n    int Next = A[Now][j - Direction + 4 &amp; 3];\n    for(Direction = 0; A[Next][j - Direction + 6 &amp; 3] != Now; ++Direction);\n    Now = Next;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//    freopen(&quot;drink.in&quot;, &quot;r&quot;, stdin);\n//    freopen(&quot;drink.out&quot;, &quot;w&quot;, stdout);\n#endif\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q;\n    for(int i = 1; i &lt;= N; ++i)\n        for(int j = 1; j &lt;= M; ++j)\n            Map[i][j] = Get_Int();\n    for(int i = 1; i &lt;= (N + 2) * (M + 2); ++i)\n    {\n        A[i][0] = i - M - 2;\n        A[i][1] = i + 1;\n        A[i][2] = i + M + 2;\n        A[i][3] = i - 1;\n    }\n    while(Q--)\n    {\n        int x = Get_Int(), y = Get_Int(), c = Get_Int();\n        int Direction = 0, Now = 1;\n        vector&lt; pair&lt;int, int&gt; &gt; Border[4][2];\n        for(int i = 1; i &lt;= x; ++i)\n            Move(Direction, Now, 2);\n        for(int i = 1; i &lt;= y; ++i)\n            Move(Direction, Now, 1);\n        for(int j = 0; j &lt; 4; ++j)\n            for(int i = 1; i &lt;= c; ++i)\n            {\n                Border[j][0].push_back(make_pair(Direction, Now));\n                Move(Direction, Now, j);\n                Border[j][1].push_back(make_pair(Direction, Now));\n                Move(Direction, Now, j + 2 &amp; 3);\n                if(i != c)\n                    Move(Direction, Now, j + 1 &amp; 3);\n            }\n        for(int j = 0; j &lt; 4; ++j)\n            for(int i = 0; i &lt; c; ++i)\n            {\n                pair&lt;int, int&gt; Now = Border[j][1][i];\n                A[Now.second][j + 6 - Now.first &amp; 3] = Border[j + 3 &amp; 3][0][i].second;\n                Now = Border[j][0][i];\n                A[Now.second][j + 4 - Now.first &amp; 3] = Border[j + 1 &amp; 3][1][i].second;\n            }\n    }\n    int Direction = 0, Now = 1;\n    for(int i = 1; i &lt;= N; ++i)\n    {\n        Move(Direction, Now, 2);\n        int temp = Direction, Next = Now;\n        for(int j = 1; j &lt;= M; ++j)\n        {\n            Move(temp, Next, 1);\n            printf(&quot;%d &quot;, Map[(Next - 1) / (M + 2)][(Next - 1) % (M + 2)]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n    fclose(stdin);\n    fclose(stdout);\n    return 0;\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/13/NOIP模拟赛 2017 3 12/","excerpt":"","categories":[{"name":"NOIP模拟赛","slug":"NOIP模拟赛","permalink":"https://prostkhala.github.io/categories/NOIP模拟赛/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://prostkhala.github.io/tags/二分答案/"},{"name":"贪心","slug":"贪心","permalink":"https://prostkhala.github.io/tags/贪心/"},{"name":"线段树","slug":"线段树","permalink":"https://prostkhala.github.io/tags/线段树/"},{"name":"二维线段树","slug":"二维线段树","permalink":"https://prostkhala.github.io/tags/二维线段树/"}]},{"title":"SCOI2010 股票交易","date":"2017-03-11T01:11:51.000Z","path":"2017/03/11/股票交易/","text":"[SCOI2010] 股票交易BZOJ1855 洛谷2569 题目描述最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。 通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi&gt;=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。 另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。 在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？ 输入输出格式输入格式：输入数据第一行包括3个整数，分别是T，MaxP，W。 接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。 输出格式：输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。 输入输出样例输入样例#1：5 2 0 2 1 1 1 2 1 1 1 3 2 1 1 4 3 1 1 5 4 1 1 输出样例#1：3 说明对于30%的数据，0&lt;=W&lt;T&lt;=50,1&lt;=MaxP&lt;=50 对于50%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=50 对于100%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=2000 对于所有的数据，1&lt;=BPi&lt;=APi&lt;=1000,1&lt;=ASi,BSi&lt;=MaxP $o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i]j$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。 $O(t*maxp^2)$算法：#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 2017; int n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w); for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i); memset(dp,-0x3f,sizeof(dp)); for(int i=1;i&lt;=n;++i) { for(int j=0;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。 for(int j=0;j&lt;=maxp;++j) { dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作 if(i-w-1&gt;=0) for(int k=j+1;k&lt;=min(j+bs[i],maxp);++k) dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出 if(i-w-1&gt;=0) for(int k=max(j-as[i],0);k&lt;j;++k) dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入 } } printf(&quot;%d&quot;,dp[n][0]); } 此题单调队列优化思想不难，但是还要注意各种细节。 $O(t*maxp)$算法(单调队列)：#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 2017; int n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N]; int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w); for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i); memset(dp,-0x3f,sizeof(dp)); for(int i=1;i&lt;=n;++i) { for(int j=0;j&lt;=as[i];++j) dp[i][j]=-ap[i]*j; for(int j=0;j&lt;=maxp;++j) dp[i][j]=max(dp[i][j],dp[i-1][j]); if(i-w-1&gt;=0) { head=1,tail=0; for(int j=0;j&lt;=maxp;++j)//买入 { while(head&lt;=tail&amp;&amp;q[head]&lt;max(0,j-as[i]))head++; if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]); while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*ap[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--; q[++tail]=j; } head=1,tail=0; for(int j=maxp;j&gt;=0;--j)//卖出 { while(head&lt;=tail&amp;&amp;q[head]&gt;min(maxp,j+bs[i]))head++; if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]); while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*bp[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--; q[++tail]=j; } } } printf(&quot;%d&quot;,dp[n][0]); }","raw":"title: SCOI2010 股票交易\ndate: 2017-03-11 9:11:51\ncategories:\n  - 动态规划\n  - 单调性优化\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n---\n# [SCOI2010] 股票交易\n## [BZOJ1855](http://www.lydsy.com/JudgeOnline/problem.php?id=1855) [洛谷2569](https://www.luogu.org/problem/show?pid=2569)\n---\n\n## 题目描述\n\n最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。\n\n通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi>=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。\n\n另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。\n\n在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？\n### 输入输出格式\n#### 输入格式：\n\n输入数据第一行包括3个整数，分别是T，MaxP，W。\n\n接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。\n\n#### 输出格式：\n\n输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。\n\n### 输入输出样例\n#### 输入样例#1：\n\n    5 2 0\n    2 1 1 1\n    2 1 1 1\n    3 2 1 1\n    4 3 1 1\n    5 4 1 1\n\n#### 输出样例#1：\n\n    3\n\n### 说明\n\n对于30%的数据，0<=W<T<=50,1<=MaxP<=50\n\n对于50%的数据，0<=W<T<=2000,1<=MaxP<=50\n\n对于100%的数据，0<=W<T<=2000,1<=MaxP<=2000\n\n对于所有的数据，1<=BPi<=APi<=1000,1<=ASi,BSi<=MaxP\n\n---\n\n$o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i][j](j<=t，j<=maxp)$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。\n\n## $O(t*maxp^2)$算法：\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 2017;\n    int n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];\n    int main()\n    {\n      scanf(\"%d%d%d\",&n,&maxp,&w);\n        for(int i=1;i<=n;++i)scanf(\"%d%d%d%d\",ap+i,bp+i,as+i,bs+i);\n      memset(dp,-0x3f,sizeof(dp));\n      for(int i=1;i<=n;++i)\n      {\n          for(int j=0;j<=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。\n          for(int j=0;j<=maxp;++j)\n          {\n              dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作\n              if(i-w-1>=0)\n              for(int k=j+1;k<=min(j+bs[i],maxp);++k)\n              dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出\n              if(i-w-1>=0)\n              for(int k=max(j-as[i],0);k<j;++k)\n              dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入\n          }\n      }\n      printf(\"%d\",dp[n][0]);\n    }\n---\n此题单调队列优化思想不难，但是还要注意各种细节。\n## $O(t*maxp)$算法(单调队列)：\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 2017;\n    int n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N];\n    int main()\n    {\n        scanf(\"%d%d%d\",&n,&maxp,&w);\n        for(int i=1;i<=n;++i)scanf(\"%d%d%d%d\",ap+i,bp+i,as+i,bs+i);\n        memset(dp,-0x3f,sizeof(dp));\n        for(int i=1;i<=n;++i)\n        {\n            for(int j=0;j<=as[i];++j)\tdp[i][j]=-ap[i]*j;\n            for(int j=0;j<=maxp;++j)\tdp[i][j]=max(dp[i][j],dp[i-1][j]);\n            if(i-w-1>=0)\n            {\n                head=1,tail=0;\n                for(int j=0;j<=maxp;++j)//买入 \n                {\n                    while(head<=tail&&q[head]<max(0,j-as[i]))head++;\n                    if(head<=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]);\n                    while(head<=tail&&dp[i-w-1][j]+j*ap[i]>=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--;\n                    q[++tail]=j;\n                }\n                head=1,tail=0;\n                for(int j=maxp;j>=0;--j)//卖出 \n                {\n                    while(head<=tail&&q[head]>min(maxp,j+bs[i]))head++;\n                    if(head<=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]);\n                    while(head<=tail&&dp[i-w-1][j]+j*bp[i]>=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--;\n                    q[++tail]=j;\n                }\n            }\n        }\n        printf(\"%d\",dp[n][0]);\n    }","content":"<h1 id=\"SCOI2010-股票交易\"><a href=\"#SCOI2010-股票交易\" class=\"headerlink\" title=\"[SCOI2010] 股票交易\"></a>[SCOI2010] 股票交易</h1><h2 id=\"BZOJ1855-洛谷2569\"><a href=\"#BZOJ1855-洛谷2569\" class=\"headerlink\" title=\"BZOJ1855 洛谷2569\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1855\" target=\"_blank\" rel=\"external\">BZOJ1855</a> <a href=\"https://www.luogu.org/problem/show?pid=2569\" target=\"_blank\" rel=\"external\">洛谷2569</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>最近lxhgww又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。</p>\n<p>通过一段时间的观察，lxhgww预测到了未来T天内某只股票的走势，第i天的股票买入价为每股APi，第i天的股票卖出价为每股BPi（数据保证对于每个i，都有APi&gt;=BPi），但是每天不能无限制地交易，于是股票交易所规定第i天的一次买入至多只能购买ASi股，一次卖出至多只能卖出BSi股。</p>\n<p>另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔W天，也就是说如果在第i天发生了交易，那么从第i+1天到第i+W天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过MaxP。</p>\n<p>在第1天之前，lxhgww手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T天以后，lxhgww想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入数据第一行包括3个整数，分别是T，MaxP，W。</p>\n<p>接下来T行，第i行代表第i-1天的股票走势，每行4个整数，分别表示APi，BPi，ASi，BSi。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出数据为一行，包括1个数字，表示lxhgww能赚到的最多的钱数。</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>5 2 0\n2 1 1 1\n2 1 1 1\n3 2 1 1\n4 3 1 1\n5 4 1 1\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>3\n</code></pre><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>对于30%的数据，0&lt;=W&lt;T&lt;=50,1&lt;=MaxP&lt;=50</p>\n<p>对于50%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=50</p>\n<p>对于100%的数据，0&lt;=W&lt;T&lt;=2000,1&lt;=MaxP&lt;=2000</p>\n<p>对于所有的数据，1&lt;=BPi&lt;=APi&lt;=1000,1&lt;=ASi,BSi&lt;=MaxP</p>\n<hr>\n<p>$o(t*maxp^2)$算法有70分，还是比较良心的。这题转移方程也不难想，可以设$dp[i]<a href=\"j&lt;=t，j&lt;=maxp\">j</a>$为第i天后手中还剩t张股票时的最大收益。但这里有些细节要注意一下，有些情况是无法达到的，比如说第一天只能买3涨股票，那么$dp[1][4]$是便是无效的，不妨将dp数组初始化为极小值，这样没有在转移中赋过值的状态就会在比较中去掉（具体转移方程见下）。</p>\n<h2 id=\"O-t-maxp-2-算法：\"><a href=\"#O-t-maxp-2-算法：\" class=\"headerlink\" title=\"$O(t*maxp^2)$算法：\"></a>$O(t*maxp^2)$算法：</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 2017;\nint n,maxp,w,ap[N],bp[N],as[N],bs[N],dp[N][N];\nint main()\n{\n  scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i);\n  memset(dp,-0x3f,sizeof(dp));\n  for(int i=1;i&lt;=n;++i)\n  {\n      for(int j=0;j&lt;=as[i];++j)dp[i][j]=-ap[i]*j;//表示这些状态是可以达到的，具体的含义为第i天前不做任何操作时，第i天的收益。\n      for(int j=0;j&lt;=maxp;++j)\n      {\n          dp[i][j]=max(dp[i-1][j],dp[i][j]);//该天没有操作\n          if(i-w-1&gt;=0)\n          for(int k=j+1;k&lt;=min(j+bs[i],maxp);++k)\n          dp[i][j]=max(dp[i][j],dp[i-w-1][k]+(k-j)*bp[i]);//卖出\n          if(i-w-1&gt;=0)\n          for(int k=max(j-as[i],0);k&lt;j;++k)\n          dp[i][j]=max(dp[i][j],dp[i-w-1][k]-(j-k)*ap[i]);//买入\n      }\n  }\n  printf(&quot;%d&quot;,dp[n][0]);\n}\n</code></pre><hr>\n<p>此题单调队列优化思想不难，但是还要注意各种细节。</p>\n<h2 id=\"O-t-maxp-算法-单调队列-：\"><a href=\"#O-t-maxp-算法-单调队列-：\" class=\"headerlink\" title=\"$O(t*maxp)$算法(单调队列)：\"></a>$O(t*maxp)$算法(单调队列)：</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 2017;\nint n,maxp,w,head,tail,ap[N],bp[N],as[N],bs[N],dp[N][N],q[2*N];\nint main()\n{\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;maxp,&amp;w);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d%d%d&quot;,ap+i,bp+i,as+i,bs+i);\n    memset(dp,-0x3f,sizeof(dp));\n    for(int i=1;i&lt;=n;++i)\n    {\n        for(int j=0;j&lt;=as[i];++j)    dp[i][j]=-ap[i]*j;\n        for(int j=0;j&lt;=maxp;++j)    dp[i][j]=max(dp[i][j],dp[i-1][j]);\n        if(i-w-1&gt;=0)\n        {\n            head=1,tail=0;\n            for(int j=0;j&lt;=maxp;++j)//买入 \n            {\n                while(head&lt;=tail&amp;&amp;q[head]&lt;max(0,j-as[i]))head++;\n                if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]-(j-q[head])*ap[i]);\n                while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*ap[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*ap[i])tail--;\n                q[++tail]=j;\n            }\n            head=1,tail=0;\n            for(int j=maxp;j&gt;=0;--j)//卖出 \n            {\n                while(head&lt;=tail&amp;&amp;q[head]&gt;min(maxp,j+bs[i]))head++;\n                if(head&lt;=tail)dp[i][j]=max(dp[i][j],dp[i-w-1][q[head]]+(q[head]-j)*bp[i]);\n                while(head&lt;=tail&amp;&amp;dp[i-w-1][j]+j*bp[i]&gt;=dp[i-w-1][q[tail]]+q[tail]*bp[i])tail--;\n                q[++tail]=j;\n            }\n        }\n    }\n    printf(&quot;%d&quot;,dp[n][0]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/11/股票交易/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"},{"name":"单调性优化","slug":"动态规划/单调性优化","permalink":"https://prostkhala.github.io/categories/动态规划/单调性优化/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"}]},{"title":"动态规划优化 题目列表","date":"2017-03-10T14:12:24.000Z","path":"2017/03/10/动态规划 题目列表/","text":"单调队列优化dpBZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047! 单调栈BZOJ 1057!、BZOJ 1683、BZOJ 3956、BZOJ 3611 状压DPBZOJ 1879!、BZOJ 1087!、BZOJ 2669!、BZOJ 3812 斜率优化BZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675 dp+四边形不等式优化POJ1160! HDU2829! HDU3480 HDU3506 HDU3516http://blog.csdn.net/shiwei408/article/details/8791011 斜率优化DP和四边形不等式优化DP整理http://blog.csdn.net/tomorrowtodie/article/details/52279807 http://blog.csdn.net/u014800748/article/details/45750737","raw":"title: 动态规划优化 题目列表\ndate: 2017-03-10 22:12:24\ncategories:\n  - 动态规划\n  - 单调性优化\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n  - 斜率优化\n  - 单调栈\n---\n# 单调队列优化dp\nBZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047!\n\n# 单调栈\nBZOJ 1057!、BZOJ 1683、BZOJ 3956、BZOJ 3611\n\n# 状压DP\nBZOJ 1879!、BZOJ 1087!、BZOJ 2669!、BZOJ 3812\n\n# 斜率优化\nBZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675\n\n# dp+四边形不等式优化\nPOJ1160! HDU2829! HDU3480 HDU3506 HDU3516\nhttp://blog.csdn.net/shiwei408/article/details/8791011\n\n# 斜率优化DP和四边形不等式优化DP整理\nhttp://blog.csdn.net/tomorrowtodie/article/details/52279807\n\nhttp://blog.csdn.net/u014800748/article/details/45750737","content":"<h1 id=\"单调队列优化dp\"><a href=\"#单调队列优化dp\" class=\"headerlink\" title=\"单调队列优化dp\"></a>单调队列优化dp</h1><p>BZOJ 1855!、BZOJ 2442!、BZOJ 2500?、BZOJ 1047!</p>\n<h1 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h1><p>BZOJ 1057!、BZOJ 1683、BZOJ 3956、BZOJ 3611</p>\n<h1 id=\"状压DP\"><a href=\"#状压DP\" class=\"headerlink\" title=\"状压DP\"></a>状压DP</h1><p>BZOJ 1879!、BZOJ 1087!、BZOJ 2669!、BZOJ 3812</p>\n<h1 id=\"斜率优化\"><a href=\"#斜率优化\" class=\"headerlink\" title=\"斜率优化\"></a>斜率优化</h1><p>BZOJ 1096!、BZOJ 4518!、BZOJ 1010、BZOJ 675</p>\n<h1 id=\"dp-四边形不等式优化\"><a href=\"#dp-四边形不等式优化\" class=\"headerlink\" title=\"dp+四边形不等式优化\"></a>dp+四边形不等式优化</h1><p>POJ1160! HDU2829! HDU3480 HDU3506 HDU3516<br><a href=\"http://blog.csdn.net/shiwei408/article/details/8791011\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/shiwei408/article/details/8791011</a></p>\n<h1 id=\"斜率优化DP和四边形不等式优化DP整理\"><a href=\"#斜率优化DP和四边形不等式优化DP整理\" class=\"headerlink\" title=\"斜率优化DP和四边形不等式优化DP整理\"></a>斜率优化DP和四边形不等式优化DP整理</h1><p><a href=\"http://blog.csdn.net/tomorrowtodie/article/details/52279807\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/tomorrowtodie/article/details/52279807</a></p>\n<p><a href=\"http://blog.csdn.net/u014800748/article/details/45750737\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u014800748/article/details/45750737</a></p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/10/动态规划 题目列表/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"},{"name":"单调性优化","slug":"动态规划/单调性优化","permalink":"https://prostkhala.github.io/categories/动态规划/单调性优化/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://prostkhala.github.io/tags/斜率优化/"},{"name":"单调栈","slug":"单调栈","permalink":"https://prostkhala.github.io/tags/单调栈/"}]},{"title":"HNOI2008     玩具装箱Toy(详解)","date":"2017-03-10T14:02:35.000Z","path":"2017/03/10/玩具装箱toy/","text":"[HNOI2008] 玩具装箱toyBZOJ1010 COGS1330 题目描述P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小. 输入输出格式输入格式：第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7 输出格式：输出最小费用. 输入输出样例输入样例#1：5 4 3 4 2 1 4 输出样例#1：1 题解设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0&lt;=i&lt;j&lt;=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N=50005; long long n,l,dp[N],a[N]; int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1]; memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l)); printf(&quot;%lld&quot;,dp[n]); } 观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。 斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性， 一般可以通过决策表的方法进行验证，对于此题来说，数据容易生成，可以尝试一下。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N=50005; long long n,l,dp[N],a[N],best[N]; int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1]; memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j; for(int i=1;i&lt;=n;i++)printf(&quot;%d&quot;,best[i]);//决策表 printf(&quot;%lld&quot;,dp[n]); } 易观察到best[i]单调不降，满足决策单调性。（证明见下文） 则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有 $dp[k]+(i-k-1+a[i]-a[k]-l)^2&lt;dp[j]+(i-j-1+a[i]-a[j]-l)^2$ $dp[k]-dp[j]&lt;(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$ 对于该方程，可设 $b[i]=a[i]+i$; $l=l+1$ 则有 $dp[k]-dp[j]&lt;(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$ 化简得 $((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])&lt;2b[i]-2l$ 此时的形式为点斜式方程： $(yk-yj)/(xk-xj)&lt;ansi$ 已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。 设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]&lt;b[i]-2l$时，由$A1$转移而来优于$A2$。 当$g[c,b]&lt;g[b,a]$时,易证得b必不为最优决策。 证明1.$g[c,b]&lt;ansi$此时c决策优于b，则b一定不为最优决策。 2.$g[c,b]&gt;=ansi$此时b决策优于c，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时b决策不优于a决策。 综上所述，则可将所有满足$g[c,b]&lt;gb,a$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。 以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：1： 用单调队列维护点集信息。2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。AC代码如下： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 50005; long long n,l,a[N],b[N],dp[N],q[N]; double g(long long k,long long j) { return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]); } int main() { // freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,a+i),a[i]+=a[i-1]; for(int i=1;i&lt;=n;++i)b[i]=a[i]+i; l++; int head=1,tail=1; q[1]=0; for(int i=1;i&lt;=n;++i) { while(head&lt;tail&amp;&amp;g(q[head+1],q[head])&lt;2*b[i]-2*l)head++; int j=q[head]; dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l); while(head&lt;tail&amp;&amp;g(i,q[tail])&lt;g(q[tail],q[tail-1]))tail--; q[++tail]=i; } printf(&quot;%lld&quot;,dp[n]); }","raw":"title: HNOI2008     玩具装箱toy(详解)\ndate: 2017-03-10 22:02:35\ncategories:\n  - 动态规划\n  - 单调性优化\ntags:\n  - 决策单调性\n  - 动态规划\n  - 单调队列\n  - 斜率优化\n---\n# [HNOI2008]  玩具装箱toy\n\n## [BZOJ1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010) [COGS1330](http://cogs.pro/cogs/problem/problem.php?pid=1330)\n\n---\n\n## 题目描述\n\nP教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1...N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i<=K<=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.\n### 输入输出格式\n#### 输入格式：\n\n第一行输入两个整数N，L.接下来N行输入Ci.1<=N<=50000,1<=L,Ci<=10^7\n\n#### 输出格式：\n\n输出最小费用.\n\n### 输入输出样例\n#### 输入样例#1：\n\n    5 4\n    3\n    4\n    2\n    1\n    4\n\n#### 输出样例#1：\n\n    1\n\n\n---\n## 题解\n设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0<=i<j<=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。\n```cpp\n    #include<cstdio>\n    #include<iostream>\n    #include<cstring>\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N];\n\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i<=n;i++)\n        for(int j=0;j<i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l));\n        printf(\"%lld\",dp[n]);\n    } \n```\n观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。\n\n斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性， 一般可以通过决策表的方法进行验证，对于此题来说，数据容易生成，可以尝试一下。\n\n    #include<cstdio>\n    #include<iostream>\n    #include<cstring>\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N],best[N];\n\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i<=n;i++)\n        for(int j=0;j<i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j;\n        for(int i=1;i<=n;i++)printf(\"%d\",best[i]);//决策表\n        printf(\"%lld\",dp[n]);\n    } \n\n易观察到best[i]单调不降，满足决策单调性。（证明见下文）\n\n\n则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有\n\n$dp[k]+(i-k-1+a[i]-a[k]-l)^2<dp[j]+(i-j-1+a[i]-a[j]-l)^2$\n\n$dp[k]-dp[j]<(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$\n\n对于该方程，可设\n\n$b[i]=a[i]+i$;\n\n$l=l+1$\n\n则有\n\n$dp[k]-dp[j]<(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$\n\n化简得\n\n$((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])<2b[i]-2l$\n\n此时的形式为点斜式方程：\n\n$(yk-yj)/(xk-xj)<ansi$\n\n已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。\n\n设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]<b[i]-2l$时，由$A1$转移而来优于$A2$。\n\n当$g[c,b]<g[b,a]$时,易证得b必不为最优决策。\n## 证明\n### 1.$g[c,b]<ansi$\n此时c决策优于b，则b一定不为最优决策。\n### 2.$g[c,b]>=ansi$\n此时b决策优于c，但又有$g[b,a]>g[c,b]>=ansi$,此时b决策不优于a决策。\n\n综上所述，则可将所有满足$g[c,b]<g[b,a](a<b<c)$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。\n\n## 以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\n### 1： 用单调队列维护点集信息。\n### 2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)<ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。\n### 3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\n\nAC代码如下：\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 50005;\n    long long n,l,a[N],b[N],dp[N],q[N];\n    double g(long long k,long long j)\n    {\n        return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);\n    }\n    int main()\n    {\n    //\tfreopen(\"bzoj_1010.in\",\"r\",stdin);\n    //\tfreopen(\"bzoj_1010.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&l);\n        for(int i=1;i<=n;++i)scanf(\"%lld\",a+i),a[i]+=a[i-1];\n        for(int i=1;i<=n;++i)b[i]=a[i]+i;\n        l++;\n        int head=1,tail=1;\n        q[1]=0;\n        for(int i=1;i<=n;++i)\n        {\n            while(head<tail&&g(q[head+1],q[head])<2*b[i]-2*l)head++;\n            int j=q[head];\n            dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);\n            while(head<tail&&g(i,q[tail])<g(q[tail],q[tail-1]))tail--;\n            q[++tail]=i;\n        }\n        printf(\"%lld\",dp[n]);\n    }","content":"<h1 id=\"HNOI2008-玩具装箱toy\"><a href=\"#HNOI2008-玩具装箱toy\" class=\"headerlink\" title=\"[HNOI2008]  玩具装箱toy\"></a>[HNOI2008]  玩具装箱toy</h1><h2 id=\"BZOJ1010-COGS1330\"><a href=\"#BZOJ1010-COGS1330\" class=\"headerlink\" title=\"BZOJ1010 COGS1330\"></a><a href=\"http://www.lydsy.com/JudgeOnline/problem.php?id=1010\" target=\"_blank\" rel=\"external\">BZOJ1010</a> <a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1330\" target=\"_blank\" rel=\"external\">COGS1330</a></h2><hr>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为1…N的N件玩具，第i件玩具经过压缩后变成一维长度为Ci.为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第i件玩具到第j个玩具放到一个容器中，那么容器的长度将为 x=j-i+Sigma(Ck) i&lt;=K&lt;=j 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为x,其制作费用为(X-L)^2.其中L是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过L。但他希望费用最小.</p>\n<h3 id=\"输入输出格式\"><a href=\"#输入输出格式\" class=\"headerlink\" title=\"输入输出格式\"></a>输入输出格式</h3><h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>输出最小费用.</p>\n<h3 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h3><h4 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例#1：\"></a>输入样例#1：</h4><pre><code>5 4\n3\n4\n2\n1\n4\n</code></pre><h4 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例#1：\"></a>输出样例#1：</h4><pre><code>1\n</code></pre><hr>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>设$dp[i]$为处理前$i$个玩具的最小花费，a[i]为前i个玩具长度的前缀和。易得转移方程为$dp[i]=min(dp[j]+(i-j-1+a[i]-a[j]-l)^2)(0&lt;=i&lt;j&lt;=n)$此方法时间复杂度为$O(n^2)$，只能水到20分。</p>\n<pre><code class=\"cpp\">    #include&lt;cstdio&gt;\n    #include&lt;iostream&gt;\n    #include&lt;cstring&gt;\n    using namespace std;\n\n    const int N=50005;\n\n    long long n,l,dp[N],a[N];\n\n    int main()\n    {\n    //    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n    //    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n        for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1];\n        memset(dp,0x3f,sizeof(dp));\n        dp[0]=0;\n        for(int i=1;i&lt;=n;i++)\n        for(int j=0;j&lt;i;j++)\n        dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l));\n        printf(&quot;%lld&quot;,dp[n]);\n    }\n</code></pre>\n<p>观察该题数据范围和状态只有一维的转移方程，我们可以尝试通过斜率优化将时间复杂度降到$O(n)$。</p>\n<p>斜率优化中涉及单调队列的使用，自然要求方程满足决策单调性， 一般可以通过决策表的方法进行验证，对于此题来说，数据容易生成，可以尝试一下。</p>\n<pre><code>#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N=50005;\n\nlong long n,l,dp[N],a[N],best[N];\n\nint main()\n{\n//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n    for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),a[i]+=a[i-1];\n    memset(dp,0x3f,sizeof(dp));\n    dp[0]=0;\n    for(int i=1;i&lt;=n;i++)\n    for(int j=0;j&lt;i;j++)\n    dp[i]=min(dp[i],dp[j]+(i-j-1+a[i]-a[j]-l)*(i-j-1+a[i]-a[j]-l))，best[i]=j;\n    for(int i=1;i&lt;=n;i++)printf(&quot;%d&quot;,best[i]);//决策表\n    printf(&quot;%lld&quot;,dp[n]);\n} \n</code></pre><p>易观察到best[i]单调不降，满足决策单调性。（证明见下文）</p>\n<p>则对于$dp[i]$，当其由$dp[k]$转移而来优于$dp[j]$时，有</p>\n<p>$dp[k]+(i-k-1+a[i]-a[k]-l)^2&lt;dp[j]+(i-j-1+a[i]-a[j]-l)^2$</p>\n<p>$dp[k]-dp[j]&lt;(i-j-1+a[i]-a[j]-l)^2-(i-k-1+a[i]-a[k]-l)^2$</p>\n<p>对于该方程，可设</p>\n<p>$b[i]=a[i]+i$;</p>\n<p>$l=l+1$</p>\n<p>则有</p>\n<p>$dp[k]-dp[j]&lt;(b[i]-b[j]-l)^2-(b[i]-b[k]-l)^2$</p>\n<p>化简得</p>\n<p>$((dp[k]+b[k]^2)-(dp[j]+b[j]^2))/(b[k]-b[j])&lt;2b[i]-2l$</p>\n<p>此时的形式为点斜式方程：</p>\n<p>$(yk-yj)/(xk-xj)&lt;ansi$</p>\n<p>已知b[i]为前缀和的形式，所以b[i]单调递增，可知斜率为单调递增。则适用决策单调性。</p>\n<p>设$g[k,j]=(yk-yj)/(xk-xj)$,则当且仅当$g[A1,A2]&lt;b[i]-2l$时，由$A1$转移而来优于$A2$。</p>\n<p>当$g[c,b]&lt;g[b,a]$时,易证得b必不为最优决策。</p>\n<h2 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h2><h3 id=\"1-g-c-b-lt-ansi\"><a href=\"#1-g-c-b-lt-ansi\" class=\"headerlink\" title=\"1.$g[c,b]&lt;ansi$\"></a>1.$g[c,b]&lt;ansi$</h3><p>此时c决策优于b，则b一定不为最优决策。</p>\n<h3 id=\"2-g-c-b-gt-ansi\"><a href=\"#2-g-c-b-gt-ansi\" class=\"headerlink\" title=\"2.$g[c,b]&gt;=ansi$\"></a>2.$g[c,b]&gt;=ansi$</h3><p>此时b决策优于c，但又有$g[b,a]&gt;g[c,b]&gt;=ansi$,此时b决策不优于a决策。</p>\n<p>综上所述，则可将所有满足$g[c,b]&lt;g<a href=\"a&lt;b&lt;c\">b,a</a>$的决策b排除掉。此时函数满足上凸的性质，即有斜率递减。</p>\n<h2 id=\"以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\"><a href=\"#以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\" class=\"headerlink\" title=\"以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：\"></a>以下我们便可以进行斜率优化（严格建立在决策单调性的基础上）：</h2><h3 id=\"1：-用单调队列维护点集信息。\"><a href=\"#1：-用单调队列维护点集信息。\" class=\"headerlink\" title=\"1： 用单调队列维护点集信息。\"></a>1： 用单调队列维护点集信息。</h3><h3 id=\"2：-求解dp-i-可以从队首开始扫描，当g-head-1-head-lt-ansi时，可知head-1优于head，故继续扫描，直到不满足条件，此时bext-i-head-即使dp-i-最优的决策为队首。\"><a href=\"#2：-求解dp-i-可以从队首开始扫描，当g-head-1-head-lt-ansi时，可知head-1优于head，故继续扫描，直到不满足条件，此时bext-i-head-即使dp-i-最优的决策为队首。\" class=\"headerlink\" title=\"2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。\"></a>2： 求解dp[i],可以从队首开始扫描，当g(head+1,head)&lt;ansi时，可知head+1优于head，故继续扫描，直到不满足条件，此时bext[i]=head,即使dp[i]最优的决策为队首。</h3><h3 id=\"3：-当加入点i，我们要维护队列的上凸性质-即从队尾开始扫描，判断g-i-tail-是否小于g-tail，tail-1-，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\"><a href=\"#3：-当加入点i，我们要维护队列的上凸性质-即从队尾开始扫描，判断g-i-tail-是否小于g-tail，tail-1-，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\" class=\"headerlink\" title=\"3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。\"></a>3： 当加入点i，我们要维护队列的上凸性质,即从队尾开始扫描，判断g(i,tail)是否小于g(tail，tail-1)，如果满足，则可删除tail，并继续扫描，直到不满足该条件，则i在此处入队，队列仍满足上凸性质。</h3><p>AC代码如下：</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N = 50005;\nlong long n,l,a[N],b[N],dp[N],q[N];\ndouble g(long long k,long long j)\n{\n    return ((dp[k]+b[k]*b[k])-(dp[j]+b[j]*b[j]))/(b[k]-b[j]);\n}\nint main()\n{\n//    freopen(&quot;bzoj_1010.in&quot;,&quot;r&quot;,stdin);\n//    freopen(&quot;bzoj_1010.out&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);\n    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,a+i),a[i]+=a[i-1];\n    for(int i=1;i&lt;=n;++i)b[i]=a[i]+i;\n    l++;\n    int head=1,tail=1;\n    q[1]=0;\n    for(int i=1;i&lt;=n;++i)\n    {\n        while(head&lt;tail&amp;&amp;g(q[head+1],q[head])&lt;2*b[i]-2*l)head++;\n        int j=q[head];\n        dp[i]=dp[j]+(b[i]-b[j]-l)*(b[i]-b[j]-l);\n        while(head&lt;tail&amp;&amp;g(i,q[tail])&lt;g(q[tail],q[tail-1]))tail--;\n        q[++tail]=i;\n    }\n    printf(&quot;%lld&quot;,dp[n]);\n}\n</code></pre>","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/10/玩具装箱toy/","excerpt":"","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/categories/动态规划/"},{"name":"单调性优化","slug":"动态规划/单调性优化","permalink":"https://prostkhala.github.io/categories/动态规划/单调性优化/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://prostkhala.github.io/tags/动态规划/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://prostkhala.github.io/tags/决策单调性/"},{"name":"单调队列","slug":"单调队列","permalink":"https://prostkhala.github.io/tags/单调队列/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://prostkhala.github.io/tags/斜率优化/"}]},{"title":"后缀数组十三题","date":"2017-03-08T03:02:35.000Z","path":"2017/03/08/后缀数组13题/","text":"论文后缀数组——处理字符串的有力工具–罗穗骞 题目 例3 (1).cogs902:Musical Theme(poj1743)本题题目描述与论文略有差别。 应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..）） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; const int inf = 0x7fffffff; int wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N]; int s[N]; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(p=1,j=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } bool can(int k,int n) { int tmp=0,maxsa=-1,minsa=inf; for(int i=1;i&lt;=n;++i) { if(h[i]&lt;k)maxsa=-1,minsa=inf; if(sa[i]&lt;minsa)minsa=sa[i]; if(sa[i]&gt;maxsa)maxsa=sa[i]; if(maxsa-minsa&gt;k)return 1; } return 0; } int main() { // freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout); int n,x; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) { memset(h,0,sizeof(h)); memset(sa,0,sizeof(sa)); memset(rank,0,sizeof(rank)); if(!n)break; cin&gt;&gt;x; for(int i=1;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;s[i]); s[0]=s[1]-x; for(int i=1;i&lt;n-1;++i)s[i]=s[i+1]-s[i]; n--; for(int i=0;i&lt;n;++i)s[i]+=150; da(n+1,maxf); getheight(n); int l=0,r=1e6,ans; int mid=0; while(l!=r) { ans=l+r+1&gt;&gt;1; if(can(ans,n)) l=ans; else r=ans-1; } l++; printf(&quot;%d\\n&quot;,(l)&gt;=5?l:0); } } CODE 例4 (1).poj3261：Milk Patterns #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int maxf = 255; const int inf = 0x7fffffff; const int N = 1e5+5; int sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N]; int s[N],k; int cmp(int*r,int a,int b,int l) {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;height[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } bool can(int ans,int n) { int tot=0; for(int i=1;i&lt;=n;++i) { if(height[i]&lt;ans)tot=0; tot++; if(tot==k)return 1; } return 0; } int main() { int n; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,s+i); da(n+1,maxf); getheight(n); int l=1,r=n+1,ans,mid; while(l!=r) { int mid=(l+r&gt;&gt;1)+1; if(can(mid,n))ans=l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,ans); } CODE 例5 (1).spoj694：Distinct Substrings(Vjudge)这题论文中的方法不太好想，可以换一种思路。 易证长度为len的字符串一共有$（len+1）*len / 2$个子串。而其中重复的字串个数则为height数组的总和，减去即可。 以 sa[i-1] abba sa[i] abcd //height[i] = 2 这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。 这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为 bba bcd //height = 1 重复的子串 b 将在此处减掉。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; const int N =1e4+5; using namespace std; char s[N]; int sa[N],wa[N],wb[N],tong[N],wv[N]; int rank[N],height[N]; int cmp(int*r,int a,int b,int l) {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void calheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;i++) rank[sa[i]]=i; for(i=0;i&lt;n;height[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int i; scanf(&quot;%s&quot;,s); int n=strlen(s); da(n+1,128); calheight(n); long long ans=n*(n+1)/2; for(i=1;i&lt;=n;i++) ans-=height[i]; printf(&quot;%lld\\n&quot;,ans); } } CODE (2).cogs1709:不同的子串 （spoj705） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N]; char s[N]; bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); return; } int main() { // freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%s&quot;,s); int n=strlen(s); da(n+1,maxf); getheight(n); for(int i=1;i&lt;=n;++i)sa[i]++; long long ans=0; for(int i=1;i&lt;=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1; printf(&quot;%d&quot;,ans); } CODE 例6 (1).ural1297：Palindrome(Vjudge)这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。 #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; const int N = 1e4+1; int tong[N],wv[N],wa[N],wb[N]; int rank1[N],height[N],sa[N]; char s[N]; int a[N],n; int dp[N][30]; int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=a[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;i++)tong[i]=0; for(i=0;i&lt;n;i++)tong[wv[i]]++; for(i=1;i&lt;m;i++)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void calheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;i++)rank1[sa[i]]=i; for(i=0;i&lt;n;height[rank1[i++]]=k) for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++); return; } void preRMQ() { int i,j; memset(dp,127,sizeof(dp)); for(i=1;i&lt;=n*2+1;i++)dp[i][0]=height[i]; for(j=1;(1&lt;&lt;j)&lt;=2*n+1;j++) for(i=1;i+(1&lt;&lt;j)-1&lt;=2*n+1;i++) dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]); } int lcp(int l,int r) { int a=rank1[l],b=rank1[r]; if(a&gt;b) swap(a,b); a++; int t=(int)(log(double(b-a+1))/log(2.00)); return min(dp[a][t],dp[b-(1&lt;&lt;t)+1][t]); } int main() { int i,res,flag,max; while(scanf(&quot;%s&quot;,s)!=EOF) { max=0; n=strlen(s); for(i=0;i&lt;n;i++)a[i]=(int)s[i]; a[n]=1; for(i=0;i&lt;n;i++)a[i+n+1]=int(s[n-i-1]); a[2*n+1]=0; da(2*n+2,123); calheight(2*n+1); preRMQ(); for(i=0;i&lt;n;i++) { res=lcp(i,2*n-i)*2-1; if(max&lt;res) max=res,flag=i; if(i&gt;0) { res=lcp(i,2*n-i+1)*2; if(max&lt;res) max=res,flag=i; } } if(max%2==1)for(i=flag-max/2;i&lt;=flag+max/2;i++) printf(&quot;%c&quot;,s[i]); else for(i=flag-max/2;i&lt;=flag+max/2-1;i++) printf(&quot;%c&quot;,s[i]); printf(&quot;\\n&quot;); } } CODE 例7 (1).cogs1710:Power Strings （poj2406）本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。 例8 (1).poj3693:Maximum repetition substring #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 1e5+1; const int maxf = 255; int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N]; int k,now,jj,maxr,cnt; int d[N][21],ans[N]; char s[N*2]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } } void getheight(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } int prermq(int*a,int n) { for(int i=0;i&lt;n;++i)d[i][0]=a[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;++j) for(int i=0;i+(1&lt;&lt;j)-1&lt;n;++i) d[i][j]=min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]); } int askrmq(int l,int r) { l=rank[l],r=rank[r]; if(l&gt;r)swap(l,r); l++; int k=0; while((1&lt;&lt;(k+1))&lt;=r-l+1)k++; return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]); } int main() { int ccase=0; while(1) { memset(h,0,sizeof(h)); memset(d,0,sizeof(d)); memset(tong,0,sizeof(tong)); memset(rank,0,sizeof(rank)); memset(ans,0,sizeof(ans)); ccase++; k=now=jj=maxr=cnt=0; scanf(&quot;%s&quot;,s); if(s[0]==&#39;#&#39;)return 0; int n=strlen(s); da(n+1,maxf); getheight(n); prermq(h,n+1); for(int i=1;i&lt;n;++i) for(int j=0;j+i&lt;n;j+=i) { k=askrmq(j,j+i); now=k/i+1; jj=j-(i-k%i); if (jj&gt;=0&amp;&amp;askrmq(jj,jj+i)&gt;=(i-k%i))++now; if(now&gt;maxr) {cnt=0;maxr=now;ans[cnt++]=i;} else if(now==maxr) ans[cnt++]=i; } for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;cnt;++j) if(askrmq(sa[i],sa[i]+ans[j])&gt;=(maxr-1)*ans[j]) { jj=sa[i],k=ans[j]; goto dd; } dd:; printf(&quot;Case %d: &quot;,ccase); for (int i=0;i&lt;maxr*k;++i)putchar(s[jj++]); printf(&quot;\\n&quot;); } } CODE (2).cogs1711:重复的字符串 （spoj687） 例9 (1).cogs1713:Long Long Message （poj2774） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N = 3e5+1; const int maxf = 255; const int inf =0x7fffffff; int sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N]; char s[N],ss[N]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;m=p,j&lt;&lt;=1) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;n;++i)wv[i]=x[y[i]]; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } int main() { freopen(&quot;longlongmessage.in&quot;,&quot;r&quot;,stdin); freopen(&quot;longlongmessage.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%s&quot;,s); scanf(&quot;%s&quot;,ss); int n=strlen(s),m=strlen(ss); s[n]=&#39;*&#39;; for(int i=n+1;i&lt;=n+m;++i)s[i]=ss[i-n-1]; int l=n+m+1; da(l+1,maxf); geth(l); int maxx=0; for(int i=2;i&lt;=l;++i) { if(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i-1]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i-1]&lt;n))) maxx=h[i]; } cout&lt;&lt;maxx; } CODE 例10 (1).cogs1712:Common Substrings （poj3415） 例11 (1).cogs2128:生命形态 （poj3294）例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 2e5+1; const int inf =0x7fffffff; const int maxf = 255; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} int sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N]; char ss[111][10001],s[N]; int nn[111],tt; bool inq[111]; int ll[N]; void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(i=1,p=1,swap(x,y),x[sa[0]]=0;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } return; } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++); } int k; int ansg; bool can(int ans,int n,int flag) { if(!flag) { int tot1=0; memset(inq,0,sizeof(inq)); for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { memset(inq,0,sizeof(inq)); tot1=0; } else { int nowq,nowt; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t; if(!inq[nowq])tot1++,inq[nowq]=true; if(!inq[nowt])tot1++,inq[nowt]=true; if(tot1&gt;=k)return 1; } } return 0; } if(flag) { int lll=inf,rrr=-1; int tot1=0; memset(inq,0,sizeof(inq)); for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { memset(inq,0,sizeof(inq)); tot1=0; lll=inf;rrr=-1; } else { int nowq,nowt; if(sa[i-1]&lt;lll)lll=sa[i-1];if(sa[i-1]&gt;rrr)rrr=sa[i-1]; if(sa[i]&lt;lll)lll=sa[i];if(sa[i]&gt;rrr)rrr=sa[i]; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t; for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t; if(!inq[nowq])tot1++,inq[nowq]=true; if(!inq[nowt])tot1++,inq[nowt]=true; if(tot1==k)ll[++ansg]=lll; } } } } int main() { // freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout); while(scanf(&quot;%d&quot;,&amp;tt)!=EOF) { if(!tt)return 0; memset(wa,0,sizeof(wa)); memset(wb,0,sizeof(wb)); memset(wv,0,sizeof(wv)); memset(rank,0,sizeof(rank)); memset(sa,0,sizeof(sa)); memset(h,0,sizeof(h)); memset(nn,0,sizeof(nn)); memset(s,0,sizeof(s)); int tot=0; int tmp=2; ansg=0; for(int i=1;i&lt;=tt;++i) { scanf(&quot;%s&quot;,ss[i]); nn[i]=strlen(ss[i]); nn[0]=-1; for(int t=0;t&lt;nn[i];++t)s[tot++]=ss[i][t]; nn[i]+=nn[i-1]+(i==tt?0:1); if(i!=tt)s[tot++]=tmp++; } nn[tt]++; int n=strlen(s); da(n+1,maxf); geth(n); k=(tt)/2+1; int l=0,r=n+1,mid; while(l!=r) { mid=(l+r+1)&gt;&gt;1; if(can(mid,n,0)) l=mid; else r=mid-1; } if(l==0){printf(&quot;?&quot;);goto dd;} can(l,n,1); for(int i=1;i&lt;=ansg;++i) { if(i!=1) { bool flag=0; for(int t=0;t&lt;l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;} if(!flag)continue; } for(int t=ll[i];t&lt;=ll[i]+l-1;++t)putchar(s[t]); printf(&quot;\\n&quot;); } dd:; } } CODE 例12 (1).cogs2120:破译进攻计划 （spoj220） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; const int N = 2e5+500; const int maxf = 255; int sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N]; char s[N],ss[13][15031]; int inq[13],maxq[13],minq[13]; int tt,num; bool use[13]; bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];} void da(int n,int m) { int i,j,p,*x=wa,*y=wb; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i; for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p) { for(p=0,i=n-j;i&lt;n;++i)y[p++]=i; for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j; for(i=0;i&lt;m;++i)tong[i]=0; for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++; for(i=1;i&lt;m;++i)tong[i]+=tong[i-1]; for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i]; for(swap(x,y),x[sa[0]]=0,i=1,p=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++; } } void geth(int n) { int i,j,k=0; for(i=1;i&lt;=n;++i)rank[sa[i]]=i; for(i=0;i&lt;n;h[rank[i++]]=k) for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++); } bool can(int ans,int n) { int tot=0; for(int i=1;i&lt;=n;++i) { if(h[i]&lt;ans) { tot=0; memset(inq,0,sizeof(inq)); memset(maxq,0,sizeof(maxq)); memset(minq,0x3f,sizeof(minq)); memset(use,0,sizeof(use)); } else { for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t]) { inq[t]++; minq[t]=min(minq[t],sa[i]); maxq[t]=max(maxq[t],sa[i]); if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true; if(tot==num)return 1; } for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t]) { inq[t]++; minq[t]=min(minq[t],sa[i-1]); maxq[t]=max(maxq[t],sa[i-1]); if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true; if(tot==num)return 1; } } } return 0; } int main() { // freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout); nn[0]=-1; scanf(&quot;%d&quot;,&amp;tt); while(tt--) { memset(inq,0,sizeof(inq)); memset(wa,0,sizeof(wa)); memset(wb,0,sizeof(wb)); memset(wv,0,sizeof(wv)); memset(sa,0,sizeof(sa)); memset(rank,0,sizeof(rank)); memset(h,0,sizeof(h)); scanf(&quot;%d&quot;,&amp;num); int tot=0,qiguaizifu=2; for(int i=1;i&lt;=num;++i) { scanf(&quot;%s&quot;,ss[i]); nn[i]=strlen(ss[i]); } for(int i=1;i&lt;=num;++i) { for(int t=0;t&lt;nn[i];++t) s[tot++]=ss[i][t]; s[tot++]=qiguaizifu++; } for(int i=1;i&lt;=num;++i)nn[i]+=(nn[i-1]+1); int n=strlen(s); da(n+1,maxf); geth(n); int l=0,r=(n+1)/2; while(l!=r) { int mid=l+r+1&gt;&gt;1; if(can(mid,n)) l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,l); } } CODE 例13 (1).poj1226:Substrings","raw":"title: 后缀数组十三题\ndate: 2017-03-08 11:02:35\ncategories:\n  - 数据结构\n  - Hollerith-type\n  - 后缀数组\ntags:\n  - 后缀数组\n  - 模板\n---\n\n\n# 论文\n[后缀数组——处理字符串的有力工具--罗穗骞](https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/pdfs/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E4%B9%8B%E3%80%8A%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E5%8A%9B%E5%B7%A5%E5%85%B7%E3%80%8B.pdf)\n\n\n <!--more--> \n \n \n# 题目\n\n-----------------------------------------------------------------------------------------------------------\n## 例3         (1).[cogs902:Musical Theme](http://cogs.pro/cogs/problem/problem.php?pid=902)(poj1743)\n\n本题题目描述与论文略有差别。\n\n应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa > k，而不是maxsa - minsa > = k（然而POJ并没有卡我..））\n\n```c++\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 1e5+1;\n    const int maxf = 255;\n    const int inf = 0x7fffffff;\n    int wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];\n    int s[N];\n    int cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i<m;i++)tong[i]=0;\n    for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i<m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n    for(p=1,j=1;p<n;j<<=1,m=p)\n    {\n        for(p=0,i=n-j;i<n;++i)y[p++]=i;\n        for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n        for(i=0;i<n;++i)wv[i]=x[y[i]];\n        for(i=0;i<m;i++)tong[i]=0;\n        for(i=0;i<n;++i)tong[wv[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n    }\n    void getheight(int n)\n    {\n    int i,j,k=0;\n    for(i=1;i<=n;++i)rank[sa[i]]=i;\n    for(i=0;i<n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    return;\n    }\n    bool can(int k,int n)\n    {\n    int tmp=0,maxsa=-1,minsa=inf;\n    for(int i=1;i<=n;++i)\n    {\n        if(h[i]<k)maxsa=-1,minsa=inf;\n        if(sa[i]<minsa)minsa=sa[i];\n        if(sa[i]>maxsa)maxsa=sa[i];\n        if(maxsa-minsa>k)return 1;\n    }\n    return 0;\n    }\n    int main()\n    {\n    //  freopen(\"theme.in\",\"r\",stdin);\n    //  freopen(\"theme.out\",\"w\",stdout);\n    int n,x;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        memset(h,0,sizeof(h));\n        memset(sa,0,sizeof(sa));\n        memset(rank,0,sizeof(rank));\n        if(!n)break;\n        cin>>x;\n        for(int i=1;i<n;++i)scanf(\"%d\",&s[i]);\n        s[0]=s[1]-x;\n        for(int i=1;i<n-1;++i)s[i]=s[i+1]-s[i];\n        n--;\n        for(int i=0;i<n;++i)s[i]+=150;\n        da(n+1,maxf);\n        getheight(n);\n        int l=0,r=1e6,ans;\n        int mid=0;\n        while(l!=r)\n        {\n            ans=l+r+1>>1;\n            if(can(ans,n))  l=ans;\n            else      r=ans-1;\n        }\n        l++;\n        printf(\"%d\\n\",(l)>=5?l:0);\n    }\n    }\n```\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B3.cpp)\n\n\n-----------------------------------------------------------------------------------------------------------\n\n\n\n## 例4         (1).[poj3261：Milk Patterns](http://poj.org/problem?id=3261)\n\n```cpp\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int maxf = 255;\n    const int inf = 0x7fffffff;\n    const int N = 1e5+5;\n    int sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];\n    int s[N],k;\n    int cmp(int*r,int a,int b,int l)\n    {return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;i++)tong[i]=0;\n            for(i=0;i<n;i++)tong[wv[i]]++;\n            for(i=1;i<m;i++)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void getheight(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;height[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n        return;\n    }\n    bool can(int ans,int n)\n    {\n        int tot=0;\n        for(int i=1;i<=n;++i)\n        {\n            if(height[i]<ans)tot=0;\n            tot++;\n            if(tot==k)return 1;\n        }\n        return 0;\n    }\n    int main()\n    {\n        int n;\n        scanf(\"%d%d\",&n,&k);\n        for(int i=0;i<n;++i)scanf(\"%d\",s+i);\n        da(n+1,maxf);\n        getheight(n);\n        int l=1,r=n+1,ans,mid;\n        while(l!=r)\n        {\n            int mid=(l+r>>1)+1;\n            if(can(mid,n))ans=l=mid;\n            else    r=mid-1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n```\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B4.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例5         (1).[spoj694：Distinct Substrings](https://vjudge.net/problem/SPOJ-DISUBSTR)(Vjudge)   \n\n这题论文中的方法不太好想，可以换一种思路。\n\n易证长度为len的字符串一共有$（len+1）*len / 2$个子串。\n而其中重复的字串个数则为height数组的总和，减去即可。\n\n以\n\n\tsa[i-1]  abba\n\n\tsa[i]    abcd //height[i] = 2\n\n这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。\n\n这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为\n   \n   \tbba\n       bcd //height = 1\n    \n    \n   重复的子串 b 将在此处减掉。\n   \n```cpp\n      #include<iostream> \n      #include<cstring>\n      #include<cstdio>\n      const int N =1e4+5;       \n      using namespace std;       \n      char s[N];   \n      int sa[N],wa[N],wb[N],tong[N],wv[N];      \n      int rank[N],height[N];      \n      int cmp(int*r,int a,int b,int l)\n      {return r[a]==r[b]&&r[a+l]==r[b+l];}\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<m;i++)tong[i]=0;\n              for(i=0;i<n;i++)tong[wv[i]]++;\n              for(i=1;i<m;i++)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n          return;\n      }\n      void calheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;i++) rank[sa[i]]=i;\n          for(i=0;i<n;height[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n          return;\n      }\n      int main()  \n      {  \n          int t;  \n          scanf(\"%d\",&t);  \n          while(t--)  \n          {  \n              int i;  \n              scanf(\"%s\",s);  \n              int n=strlen(s);   \n              da(n+1,128);  \n              calheight(n);  \n              long long ans=n*(n+1)/2;  \n              for(i=1;i<=n;i++)  \n              ans-=height[i];  \n              printf(\"%lld\\n\",ans);  \n          }  \n      }  \n```\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.cpp)\n\n\n\n## (2).[cogs1709:不同的子串](http://cogs.pro/cogs/problem/problem.php?pid=1709) （spoj705）\n\n```cpp\n\n      #include<iostream>\n      #include<cstdio>\n      #include<cstring>\n      using namespace std;\n      const int N = 1e5+1;\n      const int maxf = 255;\n      int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];\n      char s[N];\n      bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;i--)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<m;++i)tong[i]=0;\n              for(i=0;i<n;++i)tong[wv[i]]++;\n              for(i=1;i<m;++i)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,i=1,x[sa[0]]=0;i<n;++i)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n          return;\n      }\n      void getheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;++i)rank[sa[i]]=i;\n          for(i=0;i<n;h[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n          return;\n      }\n      int main()\n      {\n      //  freopen(\"subst1.in\",\"r\",stdin);\n      //  freopen(\"subst1.out\",\"w\",stdout);\n          scanf(\"%s\",s);\n          int n=strlen(s);\n          da(n+1,maxf);\n          getheight(n);\n          for(int i=1;i<=n;++i)sa[i]++;\n          long long ans=0;\n          for(int i=1;i<=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1;\n          printf(\"%d\",ans);\n      }\n```\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.2.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例6         (1).[ural1297：Palindrome](https://vjudge.net/problem/URAL-1297)(Vjudge)\n\n这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]>=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。\n\n\n```cpp\n    #include<cstring>\n    #include<cstdlib>\n    #include<cstdio>\n    #include<iostream>\n    #include<cmath>\n    using namespace std;\n    const int N = 1e4+1;\n    int tong[N],wv[N],wa[N],wb[N];\n    int rank1[N],height[N],sa[N];\n    char s[N];\n    int a[N],n;\n    int dp[N][30];\n    int cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=a[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;i++)tong[i]=0;\n            for(i=0;i<n;i++)tong[wv[i]]++;\n            for(i=1;i<m;i++)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;i--)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;i++)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n      return;\n    }\n\n    void calheight(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;i++)rank1[sa[i]]=i;\n        for(i=0;i<n;height[rank1[i++]]=k)\n        for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++);\n        return;\n    }\n\n    void preRMQ()\n    {\n        int i,j;\n        memset(dp,127,sizeof(dp));\n        for(i=1;i<=n*2+1;i++)dp[i][0]=height[i];\n        for(j=1;(1<<j)<=2*n+1;j++)\n        for(i=1;i+(1<<j)-1<=2*n+1;i++)\n        dp[i][j]=min(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);\n    }\n\n    int lcp(int l,int r)\n    {\n        int a=rank1[l],b=rank1[r];\n        if(a>b)\n            swap(a,b);\n        a++;\n        int t=(int)(log(double(b-a+1))/log(2.00));\n        return min(dp[a][t],dp[b-(1<<t)+1][t]);\n    }\n\n    int main()\n    {\n        int i,res,flag,max;\n        while(scanf(\"%s\",s)!=EOF)\n        {\n            max=0;\n            n=strlen(s);\n            for(i=0;i<n;i++)a[i]=(int)s[i];\n            a[n]=1;\n            for(i=0;i<n;i++)a[i+n+1]=int(s[n-i-1]);\n            a[2*n+1]=0;\n            da(2*n+2,123);\n            calheight(2*n+1);\n            preRMQ();\n            for(i=0;i<n;i++)\n            {\n                res=lcp(i,2*n-i)*2-1;\n                if(max<res)   max=res,flag=i;\n                if(i>0)\n                {\n                    res=lcp(i,2*n-i+1)*2;\n                    if(max<res) max=res,flag=i;\n                }\n            }\n            if(max%2==1)for(i=flag-max/2;i<=flag+max/2;i++)   printf(\"%c\",s[i]);\n            else    for(i=flag-max/2;i<=flag+max/2-1;i++) printf(\"%c\",s[i]);\n            printf(\"\\n\");\n        }\n  }\n```\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B6.cpp)\n\n-----------------------------------------------------------------------------------------------------------\n## 例7           (1).[cogs1710:Power Strings](http://cogs.pro/cogs/problem/problem.php?pid=1710)  （poj2406）\n\n本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n ## 例8       (1).[poj3693:Maximum repetition substring](http://poj.org/problem?id=3693)\n \n```cpp\n\n      #include<iostream>\n      #include<cstdio>\n      #include<cstring>\n      using namespace std;\n      const int N = 1e5+1;\n      const int maxf = 255;\n      int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];\n      int k,now,jj,maxr,cnt;\n      int d[N][21],ans[N];\n      char s[N*2];\n      bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i<m;++i)tong[i]=0;\n          for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i<m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p<n;j<<=1,m=p)\n          {\n              for(p=0,i=n-j;i<n;++i)y[p++]=i;\n              for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n              for(i=0;i<m;++i)tong[i]=0;\n              for(i=0;i<n;++i)wv[i]=x[y[i]];\n              for(i=0;i<n;++i)tong[wv[i]]++;\n              for(i=1;i<m;++i)tong[i]+=tong[i-1];\n              for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,x[sa[0]]=0,i=1;i<n;++i)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n      }\n      void getheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i<=n;++i)rank[sa[i]]=i;\n          for(i=0;i<n;h[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      }\n      int prermq(int*a,int n)\n      {\n          for(int i=0;i<n;++i)d[i][0]=a[i];\n          for(int j=1;(1<<j)<=n;++j)\n          for(int i=0;i+(1<<j)-1<n;++i)\n          d[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);\n      }\n      int askrmq(int l,int r)\n      {\n          l=rank[l],r=rank[r];\n          if(l>r)swap(l,r);\n          l++;\n          int k=0;\n          while((1<<(k+1))<=r-l+1)k++;\n          return min(d[l][k],d[r-(1<<k)+1][k]);\n      }\n      int main()\n      {\n          int ccase=0;\n          while(1)\n          {\n          memset(h,0,sizeof(h));\n          memset(d,0,sizeof(d));\n          memset(tong,0,sizeof(tong));\n          memset(rank,0,sizeof(rank));\n          memset(ans,0,sizeof(ans));\n          ccase++;\n\n          k=now=jj=maxr=cnt=0;\n          scanf(\"%s\",s);\n          if(s[0]=='#')return 0;\n          int n=strlen(s);\n          da(n+1,maxf);\n          getheight(n);\n          prermq(h,n+1);\n          for(int i=1;i<n;++i) \n          for(int j=0;j+i<n;j+=i) \n          {\n              k=askrmq(j,j+i);\n              now=k/i+1;\n              jj=j-(i-k%i);\n              if (jj>=0&&askrmq(jj,jj+i)>=(i-k%i))++now;\n              if(now>maxr)    {cnt=0;maxr=now;ans[cnt++]=i;}\n              else if(now==maxr)  ans[cnt++]=i;\n          }\n              for(int i=1;i<=n;++i) \n              for(int j=0;j<cnt;++j)\n              if(askrmq(sa[i],sa[i]+ans[j])>=(maxr-1)*ans[j])\n              {\n                  jj=sa[i],k=ans[j];\n                  goto dd;\n              }\n              dd:;\n              printf(\"Case %d: \",ccase);\n              for (int i=0;i<maxr*k;++i)putchar(s[jj++]);\n              printf(\"\\n\");\n          }\n      }\n```\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B8.cpp)\n\n\n\n\n\n## (2).[cogs1711:重复的字符串](http://cogs.pro/cogs/problem/problem.php?pid=1711) （spoj687）\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例9      (1).[cogs1713:Long Long Message](http://cogs.pro/cogs/problem/problem.php?pid=1713)  （poj2774）\n\n```cpp\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    const int N = 3e5+1;\n    const int maxf = 255;\n    const int inf =0x7fffffff;\n    int sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N];\n    char s[N],ss[N];\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;m=p,j<<=1)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<n;++i)wv[i]=x[y[i]];\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,i=1,x[sa[0]]=0;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    }\n    int main()\n    {\n        freopen(\"longlongmessage.in\",\"r\",stdin);\n        freopen(\"longlongmessage.out\",\"w\",stdout);\n        scanf(\"%s\",s);\n        scanf(\"%s\",ss);\n        int n=strlen(s),m=strlen(ss);\n        s[n]='*';\n        for(int i=n+1;i<=n+m;++i)s[i]=ss[i-n-1];\n        int l=n+m+1;\n        da(l+1,maxf);\n        geth(l);\n        int maxx=0;\n        for(int i=2;i<=l;++i)\n        {\n            if(h[i]>maxx&&((sa[i]<n&&sa[i-1]>n)||(sa[i]>n&&sa[i-1]<n)))\n            maxx=h[i];\n        }\n        cout<<maxx;\n    }\n    \n```\n\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B9.tag.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例10    (1).[cogs1712:Common Substrings](http://cogs.pro/cogs/problem/problem.php?pid=1712)  （poj3415）\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例11    (1).[cogs2128:生命形态](http://cogs.pro/cogs/problem/problem.php?pid=2128)   （poj3294）\n\n例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。\n\n```cpp\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    using namespace std;\n    const int N = 2e5+1;\n    const int inf =0x7fffffff;\n    const int maxf = 255;\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    int sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];\n    char ss[111][10001],s[N];\n    int nn[111],tt;\n    bool inq[111];\n    int ll[N];\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]=x[y[i]]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(i=1,p=1,swap(x,y),x[sa[0]]=0;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++);\n    }\n    int k;\n    int ansg;\n    bool can(int ans,int n,int flag)\n    {\n        if(!flag)\n        {\n            int tot1=0;\n            memset(inq,0,sizeof(inq));\n            for(int i=1;i<=n;++i)\n            {\n                if(h[i]<ans)\n                {\n                    memset(inq,0,sizeof(inq));  tot1=0;\n                }\n                else\n                {\n                    int nowq,nowt;\n                    for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])nowt=t;\n                    for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i]&&sa[i]<nn[t])nowq=t;\n                    if(!inq[nowq])tot1++,inq[nowq]=true;\n                    if(!inq[nowt])tot1++,inq[nowt]=true;\n                    if(tot1>=k)return 1;\n                }\n            }\n            return 0;\n        }\n        if(flag)\n        {\n          int lll=inf,rrr=-1;\n          int tot1=0;\n          memset(inq,0,sizeof(inq));\n          for(int i=1;i<=n;++i)\n          {\n              if(h[i]<ans)\n              {\n                  memset(inq,0,sizeof(inq));  tot1=0;\n                  lll=inf;rrr=-1;\n              }\n              else\n              {\n                  int nowq,nowt;\n                  if(sa[i-1]<lll)lll=sa[i-1];if(sa[i-1]>rrr)rrr=sa[i-1];\n                  if(sa[i]<lll)lll=sa[i];if(sa[i]>rrr)rrr=sa[i];\n                  for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])nowt=t;\n                  for(int t=1;t<=tt;++t)if(nn[t-1]<sa[i]&&sa[i]<nn[t])nowq=t;\n                  if(!inq[nowq])tot1++,inq[nowq]=true;\n                  if(!inq[nowt])tot1++,inq[nowt]=true;\n                  if(tot1==k)ll[++ansg]=lll;\n              }\n          }\n      }\n    }\n      int main()\n      {\n      //  freopen(\"Lifeforms.in\",\"r\",stdin);\n      //  freopen(\"Lifeforms.out\",\"w\",stdout);\n          while(scanf(\"%d\",&tt)!=EOF)\n          {\n              if(!tt)return 0;\n              memset(wa,0,sizeof(wa));\n              memset(wb,0,sizeof(wb));\n              memset(wv,0,sizeof(wv));\n              memset(rank,0,sizeof(rank));\n              memset(sa,0,sizeof(sa));\n              memset(h,0,sizeof(h));\n              memset(nn,0,sizeof(nn));\n              memset(s,0,sizeof(s));\n              int tot=0;\n              int tmp=2;\n              ansg=0;\n              for(int i=1;i<=tt;++i)\n              {\n                  scanf(\"%s\",ss[i]);\n                  nn[i]=strlen(ss[i]);\n                  nn[0]=-1;\n                  for(int t=0;t<nn[i];++t)s[tot++]=ss[i][t];\n                  nn[i]+=nn[i-1]+(i==tt?0:1);\n                  if(i!=tt)s[tot++]=tmp++;\n              }\n              nn[tt]++;\n              int n=strlen(s);\n              da(n+1,maxf);\n              geth(n);\n              k=(tt)/2+1;\n              int l=0,r=n+1,mid;\n              while(l!=r)\n              {\n                  mid=(l+r+1)>>1;\n                  if(can(mid,n,0))  l=mid;\n                  else      r=mid-1;\n              }\n              if(l==0){printf(\"?\");goto dd;}\n              can(l,n,1);\n              for(int i=1;i<=ansg;++i)\n              {\n                  if(i!=1)\n                  {\n                  bool flag=0;\n                  for(int t=0;t<l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;}\n                  if(!flag)continue;\n                  }\n                  for(int t=ll[i];t<=ll[i]+l-1;++t)putchar(s[t]);\n                  printf(\"\\n\");\n              }\n              dd:;\n          }\n      }\n```\n[CODE](https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B11.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例12    (1).[cogs2120:破译进攻计划](http://cogs.pro/cogs/problem/problem.php?pid=2120)   （spoj220）\n\n```cpp\n\n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<cmath>\n    using namespace std;\n    const int N = 2e5+500;\n    const int maxf = 255;\n    int sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];\n    char s[N],ss[13][15031];\n    int inq[13],maxq[13],minq[13];\n    int tt,num;\n    bool use[13];\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&&r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i<m;++i)tong[i]=0;\n        for(i=0;i<n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i<m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i>=0;i--)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p<n;j<<=1,m=p)\n        {\n            for(p=0,i=n-j;i<n;++i)y[p++]=i;\n            for(i=0;i<n;++i)if(sa[i]>=j)y[p++]=sa[i]-j;\n            for(i=0;i<m;++i)tong[i]=0;\n            for(i=0;i<n;++i)tong[wv[i]=x[y[i]]]++;\n            for(i=1;i<m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i>=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),x[sa[0]]=0,i=1,p=1;i<n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i<=n;++i)rank[sa[i]]=i;\n        for(i=0;i<n;h[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    }\n    bool can(int ans,int n)\n    {\n        int tot=0;\n        for(int i=1;i<=n;++i)\n        {\n            if(h[i]<ans)\n            {\n                tot=0;\n                memset(inq,0,sizeof(inq));\n                memset(maxq,0,sizeof(maxq));\n                memset(minq,0x3f,sizeof(minq));\n                memset(use,0,sizeof(use));\n            }\n            else\n            {\n                for(int t=1;t<=num;++t)if(nn[t-1]<sa[i]&&sa[i]<=nn[t])\n                {\n                    inq[t]++;\n                    minq[t]=min(minq[t],sa[i]);\n                    maxq[t]=max(maxq[t],sa[i]);\n                    if(maxq[t]-minq[t]>=ans&&!use[t])tot++,use[t]=true;\n                    if(tot==num)return 1;\n                }\n                for(int t=1;t<=num;++t)if(nn[t-1]<sa[i-1]&&sa[i-1]<nn[t])\n                {\n                    inq[t]++;\n                    minq[t]=min(minq[t],sa[i-1]);\n                    maxq[t]=max(maxq[t],sa[i-1]);\n                    if(maxq[t]-minq[t]>=ans&&!use[t])tot++,use[t]=true;\n                    if(tot==num)return 1;\n                }\n            } \n        }\n        return 0;\n    }\n    int main()\n    {\n    //  freopen(\"RelevantPhrasesofAnnihil.in\",\"r\",stdin);\n    //  freopen(\"RelevantPhrasesofAnnihil.out\",\"w\",stdout);\n        nn[0]=-1;\n        scanf(\"%d\",&tt);\n        while(tt--)\n        {\n            memset(inq,0,sizeof(inq));\n            memset(wa,0,sizeof(wa));\n            memset(wb,0,sizeof(wb));\n            memset(wv,0,sizeof(wv));\n            memset(sa,0,sizeof(sa));\n            memset(rank,0,sizeof(rank));\n            memset(h,0,sizeof(h));\n            scanf(\"%d\",&num);\n            int tot=0,qiguaizifu=2;\n            for(int i=1;i<=num;++i)\n            {\n                scanf(\"%s\",ss[i]);\n                nn[i]=strlen(ss[i]);\n            }\n            for(int i=1;i<=num;++i)\n            {\n                for(int t=0;t<nn[i];++t)\n                s[tot++]=ss[i][t];\n                s[tot++]=qiguaizifu++;\n            }\n            for(int i=1;i<=num;++i)nn[i]+=(nn[i-1]+1);\n            int n=strlen(s);\n            da(n+1,maxf);\n            geth(n);\n            int l=0,r=(n+1)/2;\n            while(l!=r)\n            {\n                int mid=l+r+1>>1;\n                if(can(mid,n))  l=mid;\n                else      r=mid-1;\n            }\n            printf(\"%d\\n\",l);\n        }\n    }\n```\n\n[CODE](https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B12.cpp)\n\n\n\n\n-----------------------------------------------------------------------------------------------------------\n## 例13    (1).[poj1226:Substrings](http://poj.org/problem?id=1226)\n-------------------------------------------------------------\n\n    \n","content":"<h1 id=\"论文\"><a href=\"#论文\" class=\"headerlink\" title=\"论文\"></a>论文</h1><p><a href=\"https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/pdfs/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E4%B9%8B%E3%80%8A%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E5%8A%9B%E5%B7%A5%E5%85%B7%E3%80%8B.pdf\" target=\"_blank\" rel=\"external\">后缀数组——处理字符串的有力工具–罗穗骞</a></p>\n <a id=\"more\"></a> \n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><hr>\n<h2 id=\"例3-1-cogs902-Musical-Theme-poj1743\"><a href=\"#例3-1-cogs902-Musical-Theme-poj1743\" class=\"headerlink\" title=\"例3         (1).cogs902:Musical Theme(poj1743)\"></a>例3         (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=902\" target=\"_blank\" rel=\"external\">cogs902:Musical Theme</a>(poj1743)</h2><p>本题题目描述与论文略有差别。</p>\n<p>应处理的字符串为所给数据的差值，且两个不可重叠最长重复子串不能紧挨着，此时虽不会产生重叠，但会共用同一个音符。（故判断条件应为 maxsa - minsa &gt; k，而不是maxsa - minsa &gt; = k（然而POJ并没有卡我..））</p>\n<pre><code class=\"c++\">    #include&lt;iostream&gt;\n    #include&lt;cstdio&gt;\n    #include&lt;cstring&gt;\n    using namespace std;\n    const int N = 1e5+1;\n    const int maxf = 255;\n    const int inf = 0x7fffffff;\n    int wa[N],wb[N],wv[N],tong[N],h[N],sa[N],rank[N],d[N];\n    int s[N];\n    int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n    int i,j,p,*x=wa,*y=wb;\n    for(i=0;i&lt;m;i++)tong[i]=0;\n    for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n    for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n    for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n    for(p=1,j=1;p&lt;n;j&lt;&lt;=1,m=p)\n    {\n        for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n        for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n        for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n        for(i=0;i&lt;m;i++)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[wv[i]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i)\n        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n    }\n    return;\n    }\n    void getheight(int n)\n    {\n    int i,j,k=0;\n    for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n    for(i=0;i&lt;n;h[rank[i++]]=k)\n    for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    return;\n    }\n    bool can(int k,int n)\n    {\n    int tmp=0,maxsa=-1,minsa=inf;\n    for(int i=1;i&lt;=n;++i)\n    {\n        if(h[i]&lt;k)maxsa=-1,minsa=inf;\n        if(sa[i]&lt;minsa)minsa=sa[i];\n        if(sa[i]&gt;maxsa)maxsa=sa[i];\n        if(maxsa-minsa&gt;k)return 1;\n    }\n    return 0;\n    }\n    int main()\n    {\n    //  freopen(&quot;theme.in&quot;,&quot;r&quot;,stdin);\n    //  freopen(&quot;theme.out&quot;,&quot;w&quot;,stdout);\n    int n,x;\n    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)\n    {\n        memset(h,0,sizeof(h));\n        memset(sa,0,sizeof(sa));\n        memset(rank,0,sizeof(rank));\n        if(!n)break;\n        cin&gt;&gt;x;\n        for(int i=1;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;s[i]);\n        s[0]=s[1]-x;\n        for(int i=1;i&lt;n-1;++i)s[i]=s[i+1]-s[i];\n        n--;\n        for(int i=0;i&lt;n;++i)s[i]+=150;\n        da(n+1,maxf);\n        getheight(n);\n        int l=0,r=1e6,ans;\n        int mid=0;\n        while(l!=r)\n        {\n            ans=l+r+1&gt;&gt;1;\n            if(can(ans,n))  l=ans;\n            else      r=ans-1;\n        }\n        l++;\n        printf(&quot;%d\\n&quot;,(l)&gt;=5?l:0);\n    }\n    }\n</code></pre>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B3.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例4-1-poj3261：Milk-Patterns\"><a href=\"#例4-1-poj3261：Milk-Patterns\" class=\"headerlink\" title=\"例4         (1).poj3261：Milk Patterns\"></a>例4         (1).<a href=\"http://poj.org/problem?id=3261\" target=\"_blank\" rel=\"external\">poj3261：Milk Patterns</a></h2><pre><code class=\"cpp\">    #include&lt;iostream&gt;\n    #include&lt;cstdio&gt;\n    #include&lt;cstring&gt;\n    using namespace std;\n    const int maxf = 255;\n    const int inf = 0x7fffffff;\n    const int N = 1e5+5;\n    int sa[N],tong[N],wa[N],wb[N],wv[N],rank[N],height[N];\n    int s[N],k;\n    int cmp(int*r,int a,int b,int l)\n    {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n        {\n            for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n            for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n            for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n            for(i=0;i&lt;m;i++)tong[i]=0;\n            for(i=0;i&lt;n;i++)tong[wv[i]]++;\n            for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n            for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void getheight(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n        for(i=0;i&lt;n;height[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n        return;\n    }\n    bool can(int ans,int n)\n    {\n        int tot=0;\n        for(int i=1;i&lt;=n;++i)\n        {\n            if(height[i]&lt;ans)tot=0;\n            tot++;\n            if(tot==k)return 1;\n        }\n        return 0;\n    }\n    int main()\n    {\n        int n;\n        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);\n        for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,s+i);\n        da(n+1,maxf);\n        getheight(n);\n        int l=1,r=n+1,ans,mid;\n        while(l!=r)\n        {\n            int mid=(l+r&gt;&gt;1)+1;\n            if(can(mid,n))ans=l=mid;\n            else    r=mid-1;\n        }\n        printf(&quot;%d\\n&quot;,ans);\n    }\n</code></pre>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B4.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例5-1-spoj694：Distinct-Substrings-Vjudge\"><a href=\"#例5-1-spoj694：Distinct-Substrings-Vjudge\" class=\"headerlink\" title=\"例5         (1).spoj694：Distinct Substrings(Vjudge)\"></a>例5         (1).<a href=\"https://vjudge.net/problem/SPOJ-DISUBSTR\" target=\"_blank\" rel=\"external\">spoj694：Distinct Substrings</a>(Vjudge)</h2><p>这题论文中的方法不太好想，可以换一种思路。</p>\n<p>易证长度为len的字符串一共有$（len+1）*len / 2$个子串。<br>而其中重复的字串个数则为height数组的总和，减去即可。</p>\n<p>以</p>\n<pre><code>sa[i-1]  abba\n\nsa[i]    abcd //height[i] = 2\n</code></pre><p>这一组数据为例，两者相同的字串有$2*（2+1）/2=3$个。刚开始我不知道为什么这里要减去$2$而不是$3$，后来知道是因为只能减去包含该后缀首个字符的字串个数，否在会导致重复计算。</p>\n<p>这个例子中只应减去a，ab这两个重复字符，之后必有两个后缀为</p>\n<pre><code>   bba\n   bcd //height = 1\n</code></pre><p>   重复的子串 b 将在此处减掉。</p>\n<pre><code class=\"cpp\">      #include&lt;iostream&gt; \n      #include&lt;cstring&gt;\n      #include&lt;cstdio&gt;\n      const int N =1e4+5;       \n      using namespace std;       \n      char s[N];   \n      int sa[N],wa[N],wb[N],tong[N],wv[N];      \n      int rank[N],height[N];      \n      int cmp(int*r,int a,int b,int l)\n      {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i&lt;m;++i)tong[i]=0;\n          for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n          {\n              for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n              for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n              for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n              for(i=0;i&lt;m;i++)tong[i]=0;\n              for(i=0;i&lt;n;i++)tong[wv[i]]++;\n              for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n              for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n          return;\n      }\n      void calheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i&lt;=n;i++) rank[sa[i]]=i;\n          for(i=0;i&lt;n;height[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n          return;\n      }\n      int main()  \n      {  \n          int t;  \n          scanf(&quot;%d&quot;,&amp;t);  \n          while(t--)  \n          {  \n              int i;  \n              scanf(&quot;%s&quot;,s);  \n              int n=strlen(s);   \n              da(n+1,128);  \n              calheight(n);  \n              long long ans=n*(n+1)/2;  \n              for(i=1;i&lt;=n;i++)  \n              ans-=height[i];  \n              printf(&quot;%lld\\n&quot;,ans);  \n          }  \n      }\n</code></pre>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<h2 id=\"2-cogs1709-不同的子串-（spoj705）\"><a href=\"#2-cogs1709-不同的子串-（spoj705）\" class=\"headerlink\" title=\"(2).cogs1709:不同的子串 （spoj705）\"></a>(2).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1709\" target=\"_blank\" rel=\"external\">cogs1709:不同的子串</a> （spoj705）</h2><pre><code class=\"cpp\">\n      #include&lt;iostream&gt;\n      #include&lt;cstdio&gt;\n      #include&lt;cstring&gt;\n      using namespace std;\n      const int N = 1e5+1;\n      const int maxf = 255;\n      int wa[N],wb[N],wv[N],tong[N],sa[N],rank[N],h[N];\n      char s[N];\n      bool cmp(int*r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i&lt;m;++i)tong[i]=0;\n          for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n          {\n              for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n              for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n              for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n              for(i=0;i&lt;m;++i)tong[i]=0;\n              for(i=0;i&lt;n;++i)tong[wv[i]]++;\n              for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n              for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n          return;\n      }\n      void getheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n          for(i=0;i&lt;n;h[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n          return;\n      }\n      int main()\n      {\n      //  freopen(&quot;subst1.in&quot;,&quot;r&quot;,stdin);\n      //  freopen(&quot;subst1.out&quot;,&quot;w&quot;,stdout);\n          scanf(&quot;%s&quot;,s);\n          int n=strlen(s);\n          da(n+1,maxf);\n          getheight(n);\n          for(int i=1;i&lt;=n;++i)sa[i]++;\n          long long ans=0;\n          for(int i=1;i&lt;=n;++i)ans+=n-sa[i]-(i==1?0:h[i])+1;\n          printf(&quot;%d&quot;,ans);\n      }\n</code></pre>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B5.2.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例6-1-ural1297：Palindrome-Vjudge\"><a href=\"#例6-1-ural1297：Palindrome-Vjudge\" class=\"headerlink\" title=\"例6         (1).ural1297：Palindrome(Vjudge)\"></a>例6         (1).<a href=\"https://vjudge.net/problem/URAL-1297\" target=\"_blank\" rel=\"external\">ural1297：Palindrome</a>(Vjudge)</h2><p>这题坑很多，一开始没看论文自己写。先是常规操作，将字符串逆序加在原字符串后面，然后二分判断是否存在长度为height[i]&gt;=mid的子串，且sa[i-1],sa[i]是否不属于同一部份子串，并在倒过来后能首尾相连，但由于没判奇偶被各种数据卡的死去活来。后来换了题解的思路AC了这题。</p>\n<pre><code class=\"cpp\">    #include&lt;cstring&gt;\n    #include&lt;cstdlib&gt;\n    #include&lt;cstdio&gt;\n    #include&lt;iostream&gt;\n    #include&lt;cmath&gt;\n    using namespace std;\n    const int N = 1e4+1;\n    int tong[N],wv[N],wa[N],wb[N];\n    int rank1[N],height[N],sa[N];\n    char s[N];\n    int a[N],n;\n    int dp[N][30];\n    int cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[x[i]=a[i]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n        {\n            for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n            for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n            for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n            for(i=0;i&lt;m;i++)tong[i]=0;\n            for(i=0;i&lt;n;i++)tong[wv[i]]++;\n            for(i=1;i&lt;m;i++)tong[i]+=tong[i-1];\n            for(i=n-1;i&gt;=0;i--)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n      return;\n    }\n\n    void calheight(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i&lt;=n;i++)rank1[sa[i]]=i;\n        for(i=0;i&lt;n;height[rank1[i++]]=k)\n        for(k?k--:0,j=sa[rank1[i]-1];a[i+k]==a[j+k];k++);\n        return;\n    }\n\n    void preRMQ()\n    {\n        int i,j;\n        memset(dp,127,sizeof(dp));\n        for(i=1;i&lt;=n*2+1;i++)dp[i][0]=height[i];\n        for(j=1;(1&lt;&lt;j)&lt;=2*n+1;j++)\n        for(i=1;i+(1&lt;&lt;j)-1&lt;=2*n+1;i++)\n        dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);\n    }\n\n    int lcp(int l,int r)\n    {\n        int a=rank1[l],b=rank1[r];\n        if(a&gt;b)\n            swap(a,b);\n        a++;\n        int t=(int)(log(double(b-a+1))/log(2.00));\n        return min(dp[a][t],dp[b-(1&lt;&lt;t)+1][t]);\n    }\n\n    int main()\n    {\n        int i,res,flag,max;\n        while(scanf(&quot;%s&quot;,s)!=EOF)\n        {\n            max=0;\n            n=strlen(s);\n            for(i=0;i&lt;n;i++)a[i]=(int)s[i];\n            a[n]=1;\n            for(i=0;i&lt;n;i++)a[i+n+1]=int(s[n-i-1]);\n            a[2*n+1]=0;\n            da(2*n+2,123);\n            calheight(2*n+1);\n            preRMQ();\n            for(i=0;i&lt;n;i++)\n            {\n                res=lcp(i,2*n-i)*2-1;\n                if(max&lt;res)   max=res,flag=i;\n                if(i&gt;0)\n                {\n                    res=lcp(i,2*n-i+1)*2;\n                    if(max&lt;res) max=res,flag=i;\n                }\n            }\n            if(max%2==1)for(i=flag-max/2;i&lt;=flag+max/2;i++)   printf(&quot;%c&quot;,s[i]);\n            else    for(i=flag-max/2;i&lt;=flag+max/2-1;i++) printf(&quot;%c&quot;,s[i]);\n            printf(&quot;\\n&quot;);\n        }\n  }\n</code></pre>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B6.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例7-1-cogs1710-Power-Strings-（poj2406）\"><a href=\"#例7-1-cogs1710-Power-Strings-（poj2406）\" class=\"headerlink\" title=\"例7           (1).cogs1710:Power Strings  （poj2406）\"></a>例7           (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1710\" target=\"_blank\" rel=\"external\">cogs1710:Power Strings</a>  （poj2406）</h2><p>本题正解为DC3或KMP，倍增会TLE。论文中的时间复杂度均以DC3为依据，倍增要再乘个logn。</p>\n<hr>\n<h2 id=\"例8-1-poj3693-Maximum-repetition-substring\"><a href=\"#例8-1-poj3693-Maximum-repetition-substring\" class=\"headerlink\" title=\"例8       (1).poj3693:Maximum repetition substring\"></a>例8       (1).<a href=\"http://poj.org/problem?id=3693\" target=\"_blank\" rel=\"external\">poj3693:Maximum repetition substring</a></h2><pre><code class=\"cpp\">\n      #include&lt;iostream&gt;\n      #include&lt;cstdio&gt;\n      #include&lt;cstring&gt;\n      using namespace std;\n      const int N = 1e5+1;\n      const int maxf = 255;\n      int sa[N],h[N],wa[N],wb[N],wv[N],tong[N],pre[N],rank[N];\n      int k,now,jj,maxr,cnt;\n      int d[N][21],ans[N];\n      char s[N*2];\n      bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n\n      void da(int n,int m)\n      {\n          int i,j,p,*x=wa,*y=wb;\n          for(i=0;i&lt;m;++i)tong[i]=0;\n          for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n          for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n          for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n          for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n          {\n              for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n              for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n              for(i=0;i&lt;m;++i)tong[i]=0;\n              for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n              for(i=0;i&lt;n;++i)tong[wv[i]]++;\n              for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n              for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n              for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;++i)\n              x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n          }\n      }\n      void getheight(int n)\n      {\n          int i,j,k=0;\n          for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n          for(i=0;i&lt;n;h[rank[i++]]=k)\n          for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n      }\n      int prermq(int*a,int n)\n      {\n          for(int i=0;i&lt;n;++i)d[i][0]=a[i];\n          for(int j=1;(1&lt;&lt;j)&lt;=n;++j)\n          for(int i=0;i+(1&lt;&lt;j)-1&lt;n;++i)\n          d[i][j]=min(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]);\n      }\n      int askrmq(int l,int r)\n      {\n          l=rank[l],r=rank[r];\n          if(l&gt;r)swap(l,r);\n          l++;\n          int k=0;\n          while((1&lt;&lt;(k+1))&lt;=r-l+1)k++;\n          return min(d[l][k],d[r-(1&lt;&lt;k)+1][k]);\n      }\n      int main()\n      {\n          int ccase=0;\n          while(1)\n          {\n          memset(h,0,sizeof(h));\n          memset(d,0,sizeof(d));\n          memset(tong,0,sizeof(tong));\n          memset(rank,0,sizeof(rank));\n          memset(ans,0,sizeof(ans));\n          ccase++;\n\n          k=now=jj=maxr=cnt=0;\n          scanf(&quot;%s&quot;,s);\n          if(s[0]==&#39;#&#39;)return 0;\n          int n=strlen(s);\n          da(n+1,maxf);\n          getheight(n);\n          prermq(h,n+1);\n          for(int i=1;i&lt;n;++i) \n          for(int j=0;j+i&lt;n;j+=i) \n          {\n              k=askrmq(j,j+i);\n              now=k/i+1;\n              jj=j-(i-k%i);\n              if (jj&gt;=0&amp;&amp;askrmq(jj,jj+i)&gt;=(i-k%i))++now;\n              if(now&gt;maxr)    {cnt=0;maxr=now;ans[cnt++]=i;}\n              else if(now==maxr)  ans[cnt++]=i;\n          }\n              for(int i=1;i&lt;=n;++i) \n              for(int j=0;j&lt;cnt;++j)\n              if(askrmq(sa[i],sa[i]+ans[j])&gt;=(maxr-1)*ans[j])\n              {\n                  jj=sa[i],k=ans[j];\n                  goto dd;\n              }\n              dd:;\n              printf(&quot;Case %d: &quot;,ccase);\n              for (int i=0;i&lt;maxr*k;++i)putchar(s[jj++]);\n              printf(&quot;\\n&quot;);\n          }\n      }\n</code></pre>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B8.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<h2 id=\"2-cogs1711-重复的字符串-（spoj687）\"><a href=\"#2-cogs1711-重复的字符串-（spoj687）\" class=\"headerlink\" title=\"(2).cogs1711:重复的字符串 （spoj687）\"></a>(2).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1711\" target=\"_blank\" rel=\"external\">cogs1711:重复的字符串</a> （spoj687）</h2><hr>\n<h2 id=\"例9-1-cogs1713-Long-Long-Message-（poj2774）\"><a href=\"#例9-1-cogs1713-Long-Long-Message-（poj2774）\" class=\"headerlink\" title=\"例9      (1).cogs1713:Long Long Message  （poj2774）\"></a>例9      (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1713\" target=\"_blank\" rel=\"external\">cogs1713:Long Long Message</a>  （poj2774）</h2><pre><code class=\"cpp\">    #include&lt;iostream&gt;\n    #include&lt;cstdio&gt;\n    #include&lt;cstring&gt;\n    using namespace std;\n    const int N = 3e5+1;\n    const int maxf = 255;\n    const int inf =0x7fffffff;\n    int sa[N],wa[N],wb[N],wv[N],tong[maxf+1],rank[N],h[N];\n    char s[N],ss[N];\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p&lt;n;m=p,j&lt;&lt;=1)\n        {\n            for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n            for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n            for(i=0;i&lt;n;++i)wv[i]=x[y[i]];\n            for(i=0;i&lt;m;++i)tong[i]=0;\n            for(i=0;i&lt;n;++i)tong[wv[i]]++;\n            for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),p=1,i=1,x[sa[0]]=0;i&lt;n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n        for(i=0;i&lt;n;h[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    }\n    int main()\n    {\n        freopen(&quot;longlongmessage.in&quot;,&quot;r&quot;,stdin);\n        freopen(&quot;longlongmessage.out&quot;,&quot;w&quot;,stdout);\n        scanf(&quot;%s&quot;,s);\n        scanf(&quot;%s&quot;,ss);\n        int n=strlen(s),m=strlen(ss);\n        s[n]=&#39;*&#39;;\n        for(int i=n+1;i&lt;=n+m;++i)s[i]=ss[i-n-1];\n        int l=n+m+1;\n        da(l+1,maxf);\n        geth(l);\n        int maxx=0;\n        for(int i=2;i&lt;=l;++i)\n        {\n            if(h[i]&gt;maxx&amp;&amp;((sa[i]&lt;n&amp;&amp;sa[i-1]&gt;n)||(sa[i]&gt;n&amp;&amp;sa[i-1]&lt;n)))\n            maxx=h[i];\n        }\n        cout&lt;&lt;maxx;\n    }\n</code></pre>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B9.tag.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例10-1-cogs1712-Common-Substrings-（poj3415）\"><a href=\"#例10-1-cogs1712-Common-Substrings-（poj3415）\" class=\"headerlink\" title=\"例10    (1).cogs1712:Common Substrings  （poj3415）\"></a>例10    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=1712\" target=\"_blank\" rel=\"external\">cogs1712:Common Substrings</a>  （poj3415）</h2><hr>\n<h2 id=\"例11-1-cogs2128-生命形态-（poj3294）\"><a href=\"#例11-1-cogs2128-生命形态-（poj3294）\" class=\"headerlink\" title=\"例11    (1).cogs2128:生命形态   （poj3294）\"></a>例11    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=2128\" target=\"_blank\" rel=\"external\">cogs2128:生命形态</a>   （poj3294）</h2><p>例11,12都是多个字符串的问题，将其拼在一起时，应在加上不同的分隔符号，否则会被不友善的数据卡掉。</p>\n<pre><code class=\"cpp\">    #include&lt;iostream&gt;\n    #include&lt;cstdio&gt;\n    #include&lt;cstring&gt;\n    #include&lt;algorithm&gt;\n    using namespace std;\n    const int N = 2e5+1;\n    const int inf =0x7fffffff;\n    const int maxf = 255;\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n    int sa[N],wa[N],wb[N],wv[N],rank[N],h[N],tong[N];\n    char ss[111][10001],s[N];\n    int nn[111],tt;\n    bool inq[111];\n    int ll[N];\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;--i)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n        {\n            for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n            for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n            for(i=0;i&lt;m;++i)tong[i]=0;\n            for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;\n            for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(i=1,p=1,swap(x,y),x[sa[0]]=0;i&lt;n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n        return;\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n        for(i=0;i&lt;n;h[rank[i++]]=k)\n        for(j=sa[rank[i]-1],k?k--:0;s[j+k]==s[i+k];k++);\n    }\n    int k;\n    int ansg;\n    bool can(int ans,int n,int flag)\n    {\n        if(!flag)\n        {\n            int tot1=0;\n            memset(inq,0,sizeof(inq));\n            for(int i=1;i&lt;=n;++i)\n            {\n                if(h[i]&lt;ans)\n                {\n                    memset(inq,0,sizeof(inq));  tot1=0;\n                }\n                else\n                {\n                    int nowq,nowt;\n                    for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t;\n                    for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;\n                    if(!inq[nowq])tot1++,inq[nowq]=true;\n                    if(!inq[nowt])tot1++,inq[nowt]=true;\n                    if(tot1&gt;=k)return 1;\n                }\n            }\n            return 0;\n        }\n        if(flag)\n        {\n          int lll=inf,rrr=-1;\n          int tot1=0;\n          memset(inq,0,sizeof(inq));\n          for(int i=1;i&lt;=n;++i)\n          {\n              if(h[i]&lt;ans)\n              {\n                  memset(inq,0,sizeof(inq));  tot1=0;\n                  lll=inf;rrr=-1;\n              }\n              else\n              {\n                  int nowq,nowt;\n                  if(sa[i-1]&lt;lll)lll=sa[i-1];if(sa[i-1]&gt;rrr)rrr=sa[i-1];\n                  if(sa[i]&lt;lll)lll=sa[i];if(sa[i]&gt;rrr)rrr=sa[i];\n                  for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])nowt=t;\n                  for(int t=1;t&lt;=tt;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;nn[t])nowq=t;\n                  if(!inq[nowq])tot1++,inq[nowq]=true;\n                  if(!inq[nowt])tot1++,inq[nowt]=true;\n                  if(tot1==k)ll[++ansg]=lll;\n              }\n          }\n      }\n    }\n      int main()\n      {\n      //  freopen(&quot;Lifeforms.in&quot;,&quot;r&quot;,stdin);\n      //  freopen(&quot;Lifeforms.out&quot;,&quot;w&quot;,stdout);\n          while(scanf(&quot;%d&quot;,&amp;tt)!=EOF)\n          {\n              if(!tt)return 0;\n              memset(wa,0,sizeof(wa));\n              memset(wb,0,sizeof(wb));\n              memset(wv,0,sizeof(wv));\n              memset(rank,0,sizeof(rank));\n              memset(sa,0,sizeof(sa));\n              memset(h,0,sizeof(h));\n              memset(nn,0,sizeof(nn));\n              memset(s,0,sizeof(s));\n              int tot=0;\n              int tmp=2;\n              ansg=0;\n              for(int i=1;i&lt;=tt;++i)\n              {\n                  scanf(&quot;%s&quot;,ss[i]);\n                  nn[i]=strlen(ss[i]);\n                  nn[0]=-1;\n                  for(int t=0;t&lt;nn[i];++t)s[tot++]=ss[i][t];\n                  nn[i]+=nn[i-1]+(i==tt?0:1);\n                  if(i!=tt)s[tot++]=tmp++;\n              }\n              nn[tt]++;\n              int n=strlen(s);\n              da(n+1,maxf);\n              geth(n);\n              k=(tt)/2+1;\n              int l=0,r=n+1,mid;\n              while(l!=r)\n              {\n                  mid=(l+r+1)&gt;&gt;1;\n                  if(can(mid,n,0))  l=mid;\n                  else      r=mid-1;\n              }\n              if(l==0){printf(&quot;?&quot;);goto dd;}\n              can(l,n,1);\n              for(int i=1;i&lt;=ansg;++i)\n              {\n                  if(i!=1)\n                  {\n                  bool flag=0;\n                  for(int t=0;t&lt;l;++t)if(s[ll[i]+t]!=s[ll[i-1]+t]){flag=1;break;}\n                  if(!flag)continue;\n                  }\n                  for(int t=ll[i];t&lt;=ll[i]+l-1;++t)putchar(s[t]);\n                  printf(&quot;\\n&quot;);\n              }\n              dd:;\n          }\n      }\n</code></pre>\n<p><a href=\"https://raw.githubusercontent.com/ProSTKhala/ProSTKhala.github.io/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B11.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例12-1-cogs2120-破译进攻计划-（spoj220）\"><a href=\"#例12-1-cogs2120-破译进攻计划-（spoj220）\" class=\"headerlink\" title=\"例12    (1).cogs2120:破译进攻计划   （spoj220）\"></a>例12    (1).<a href=\"http://cogs.pro/cogs/problem/problem.php?pid=2120\" target=\"_blank\" rel=\"external\">cogs2120:破译进攻计划</a>   （spoj220）</h2><pre><code class=\"cpp\">\n    #include&lt;iostream&gt;\n    #include&lt;cstdio&gt;\n    #include&lt;cstring&gt;\n    #include&lt;cmath&gt;\n    using namespace std;\n    const int N = 2e5+500;\n    const int maxf = 255;\n    int sa[N],rank[N],wa[N],wb[N],wv[N],h[N],tong[N],nn[N];\n    char s[N],ss[13][15031];\n    int inq[13],maxq[13],minq[13];\n    int tt,num;\n    bool use[13];\n    bool cmp(int *r,int a,int b,int l){return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}\n    void da(int n,int m)\n    {\n        int i,j,p,*x=wa,*y=wb;\n        for(i=0;i&lt;m;++i)tong[i]=0;\n        for(i=0;i&lt;n;++i)tong[x[i]=s[i]]++;\n        for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n        for(i=n-1;i&gt;=0;i--)sa[--tong[x[i]]]=i;\n        for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p)\n        {\n            for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;\n            for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;\n            for(i=0;i&lt;m;++i)tong[i]=0;\n            for(i=0;i&lt;n;++i)tong[wv[i]=x[y[i]]]++;\n            for(i=1;i&lt;m;++i)tong[i]+=tong[i-1];\n            for(i=n-1;i&gt;=0;--i)sa[--tong[wv[i]]]=y[i];\n            for(swap(x,y),x[sa[0]]=0,i=1,p=1;i&lt;n;++i)\n            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n        }\n    }\n    void geth(int n)\n    {\n        int i,j,k=0;\n        for(i=1;i&lt;=n;++i)rank[sa[i]]=i;\n        for(i=0;i&lt;n;h[rank[i++]]=k)\n        for(k?k--:0,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);\n    }\n    bool can(int ans,int n)\n    {\n        int tot=0;\n        for(int i=1;i&lt;=n;++i)\n        {\n            if(h[i]&lt;ans)\n            {\n                tot=0;\n                memset(inq,0,sizeof(inq));\n                memset(maxq,0,sizeof(maxq));\n                memset(minq,0x3f,sizeof(minq));\n                memset(use,0,sizeof(use));\n            }\n            else\n            {\n                for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i]&amp;&amp;sa[i]&lt;=nn[t])\n                {\n                    inq[t]++;\n                    minq[t]=min(minq[t],sa[i]);\n                    maxq[t]=max(maxq[t],sa[i]);\n                    if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true;\n                    if(tot==num)return 1;\n                }\n                for(int t=1;t&lt;=num;++t)if(nn[t-1]&lt;sa[i-1]&amp;&amp;sa[i-1]&lt;nn[t])\n                {\n                    inq[t]++;\n                    minq[t]=min(minq[t],sa[i-1]);\n                    maxq[t]=max(maxq[t],sa[i-1]);\n                    if(maxq[t]-minq[t]&gt;=ans&amp;&amp;!use[t])tot++,use[t]=true;\n                    if(tot==num)return 1;\n                }\n            } \n        }\n        return 0;\n    }\n    int main()\n    {\n    //  freopen(&quot;RelevantPhrasesofAnnihil.in&quot;,&quot;r&quot;,stdin);\n    //  freopen(&quot;RelevantPhrasesofAnnihil.out&quot;,&quot;w&quot;,stdout);\n        nn[0]=-1;\n        scanf(&quot;%d&quot;,&amp;tt);\n        while(tt--)\n        {\n            memset(inq,0,sizeof(inq));\n            memset(wa,0,sizeof(wa));\n            memset(wb,0,sizeof(wb));\n            memset(wv,0,sizeof(wv));\n            memset(sa,0,sizeof(sa));\n            memset(rank,0,sizeof(rank));\n            memset(h,0,sizeof(h));\n            scanf(&quot;%d&quot;,&amp;num);\n            int tot=0,qiguaizifu=2;\n            for(int i=1;i&lt;=num;++i)\n            {\n                scanf(&quot;%s&quot;,ss[i]);\n                nn[i]=strlen(ss[i]);\n            }\n            for(int i=1;i&lt;=num;++i)\n            {\n                for(int t=0;t&lt;nn[i];++t)\n                s[tot++]=ss[i][t];\n                s[tot++]=qiguaizifu++;\n            }\n            for(int i=1;i&lt;=num;++i)nn[i]+=(nn[i-1]+1);\n            int n=strlen(s);\n            da(n+1,maxf);\n            geth(n);\n            int l=0,r=(n+1)/2;\n            while(l!=r)\n            {\n                int mid=l+r+1&gt;&gt;1;\n                if(can(mid,n))  l=mid;\n                else      r=mid-1;\n            }\n            printf(&quot;%d\\n&quot;,l);\n        }\n    }\n</code></pre>\n<p><a href=\"https://github.com/ProSTKhala/ProSTKhala.github.io/blob/master/codes/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%8413%E9%A2%98.%E4%BE%8B12.cpp\" target=\"_blank\" rel=\"external\">CODE</a></p>\n<hr>\n<h2 id=\"例13-1-poj1226-Substrings\"><a href=\"#例13-1-poj1226-Substrings\" class=\"headerlink\" title=\"例13    (1).poj1226:Substrings\"></a>例13    (1).<a href=\"http://poj.org/problem?id=1226\" target=\"_blank\" rel=\"external\">poj1226:Substrings</a></h2><hr>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/08/后缀数组13题/","excerpt":"论文后缀数组——处理字符串的有力工具–罗穗骞","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://prostkhala.github.io/categories/数据结构/"},{"name":"Hollerith-type","slug":"数据结构/Hollerith-type","permalink":"https://prostkhala.github.io/categories/数据结构/Hollerith-type/"},{"name":"后缀数组","slug":"数据结构/Hollerith-type/后缀数组","permalink":"https://prostkhala.github.io/categories/数据结构/Hollerith-type/后缀数组/"}],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"https://prostkhala.github.io/tags/后缀数组/"},{"name":"模板","slug":"模板","permalink":"https://prostkhala.github.io/tags/模板/"}]},{"title":"C/C++代码规范","date":"2017-03-07T09:53:42.000Z","path":"2017/03/07/c++代码规范/","text":"命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C+ 命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C++ 12 静态变量的命名前缀 适用于C 13 自定义类型typedef的命名 适用于C++ 14 宏定义的命名 适用于C++ 15 C 函数的命名 适用于C++ 16 枚举的命名 适用于C++ 排版规则 1 布局和模板 11 类的布局模板 适用于C 12 源文件格式 适用于C 13 保护头文件不被重复包含 适用于C++ 14 方法和函数的布局 适用于C++ 2 缩进制表符以及空格 适用于C++ 3 尽量使一行不要超过78个字母 适用于C++ 4 保证一行只写一条语句 适用于C++ 5 花括号 规则 适用于C++ 51 花括号的位置 52 什么时候应使用花括号 53 在花括号结束的位置加上注释 54 注意屏幕大小 6圆括号 规则 适用于C++ 7if else 语句的格式 适用于C++ 8switch 格式 适用于C++ 9 使用gotocontinuebreak 和 适用于C++ 91 Goto 92 Continue and Break 93 10 运算符号的规则 适用于C++ 11 变量声明语句块 适用于C++ 文档及注释 1 文件或程序库的文档注释 适用于C++ 2 类文档注释 适用于C++ 3 函数文档注释 适用于C++ 4 Include 语句注释 适用于C++ 5语句块注释 适用于C++ 编码要求 1 不要忽略编译器的警告 适用于C++ 2 应使用源代码管理器 适用于C++ 3 固有的类方法成员 适用于C 4 使用命名空间 适用于C 5 初始化所有的变量 适用于C++ 6 保持函数短小精悍 适用于C++ 7对空语句进行注释 适用于C++ 8不要用if语句的默认方法测试非零值 适用于C++ 9布尔类型 适用于C++ 10避免在语句中内含赋值 适用于C++ 11正确的使用Const 适用于C++ 12不要在头文件定义数据适用于C++ 13不要直接使用数字 适用于C++ 14宏 适用于C++ 1. 命名规则1.1. 起个合适的名字1.1.1. 类的名称（适用于C++）² 类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。 ² 类的名字不需要告诉我们，它从哪个类继承而来的。 ² 有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。 1.1.2. 方法和函数的名称（适用于C/C++）² 方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。 ² 函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。 ² 可以加一些必要的后缀： Max – 表示取最大值 Cnt – 表示当前的计数值 Key – 表示键值 例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。 ² 前缀也同样有用： Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。 Get – 用于获取一个值。 Set – 用于设置一个值。 例如：IsHitRetryLimit. 1.1.3. 含有度量单位的名称（适用于C/C++）² 如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。 例如： uint32 mTimeoutMsecs; uint32 mMyWeightLbs; 1.1.4. 缩写名称不要全部大写（适用于C/C++）² 无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。 例如： class FluidOz; // 而不是 FluidOZ class NetworkAbcKey; // 而不是 NetworkABCKey 1.2.类的命名（适用于C++）² 用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。 ² 名字的第一个字母应大写 ² 不含有下划线 (‘_’) 例如： class NameOneTwo; class Name; 1.3.类库（或程序库）命名 （适用于C/C++）² 使用命名空间防止名字冲突。 ² 如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。 例如： John Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样： class JjLinkList { } 1.4.方法和函数的命名（适用于C++）² 使用与类名相同的规则 例如： class NameOneTwo { public: int DoIt(); void HandleError(); } 1.5.类属性的命名（适用于C++）² 属性（通常是非公有数据成员）名字以字母’m’开头。 ² 在 ‘m(m_)’ 后面，使用与类名相同的规则。 ² ‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。 例如： class NameOneTwo { public: int VarAbc(); int ErrorNumber(); private: int mVarAbc; int mErrorNumber; String* mpName; } 1.6.方法和函数参数的命名（适用于C++）² 第一个字母必须小写。 ² 第一个字母后面的单词使用与类名相同的规则。 例如： class NameOneTwo { public: int StartYourEngines( Engine&amp;rSomeEngine, Engine&amp;rAnotherEngine); } 1.7.局部变量的命名（适用于C/C++）² 所有字母都用小写 ² 使用下划线 ‘_’ 作为单词的分隔。 例如： int NameOneTwo::HandleError(int errorNumber) { int error= OsErr(); Time time_of_error; ErrorProcessor error_processor; } 1.8.指针变量的命名前缀（适用于C/C++）² 指针变量多数情况应在前面加 ‘p’。 ² 星号 ‘*’ 应靠近类型，而不是变量名。 例如： String* pName=new String; 特别的：String* pName, name; 应分成两行来写： String* pName; String name; 1.9.引用变量和返回引用函数的命名前缀（适用于C++）² 引用必须用 ‘r’作前缀修饰。 例如： class Test { public: void DoSomething(StatusInfo&amp;rStatus); StatusInfo&amp; rStatus(); constStatusInfo&amp; Status() const; // 这里返回的是常量引用，所以不符合本规则 private: StatusInfo&amp; mrStatus; } 1.10. 全局变量的命名前缀（适用于C/C++）² 全局变量总是以 ‘g(g_)’ 作为前缀。 例如： Logger g_Log; Logger* g_pLog; 1.11. 全局常量的命名（适用于C/C++）² 全局常量全部大写，并以下划线 ‘_’ 分隔单词。 例如： const intA_GLOBAL_CONSTANT = 5; 1.12. 静态变量的命名前缀（适用于C++）² 静态变量以 ‘s’ 作为前缀。 例如： class Test { public: private: staticStatusInfo m_sStatus; } 1.13. 自定义类型（typedef）的命名（适用于C/C++）² 类型定义名称指的是用typedef定义的名称。 ² 类型定义名称使用与类名相同的规则，并使用Type作为后缀。 例如： typedefuint16 ModuleType; typedefuint32 SystemType; 1.14. 宏定义的命名（适用于C/C++）² 所有单词的字母都用大写，并使用下划线 ‘_’ 分隔. 例如： #define MAX(a,b) blah #define IS_ERR(err) blah 1.15. C 函数的命名（适用于C/C++）² C++项目中，应尽量少用C函数。 ² C函数使用GNU规范，所有字母都使用小写，并用下划线 ‘_’ 作为单词的分隔。 例如： int some_bloody_function() { } ² 特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数： extern “C” int some_bloody_function(); ² 或在C/C++中推荐使用下面的格式： #ifdef__cplusplus__ extern “C”{ #endif int some_bloody_function() { } #ifdef__cplusplus__ } #endif 1.16. 枚举的命名（适用于C/C++）² 所有字母都大写，并用下划线 ‘_’ 作为单词分隔。 例如： enumPinStateType { PIN_OFF, PIN_ON }; enum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING}; 2. 排版规则2.1. 布局和模板2.1.1. 类的布局模板 （适用于C++）² 请使用下面的模板来创建一个新的类： /** * 用一行来描述类 * *#include &quot;XX.h&quot; &lt;BR&gt; *-llib * * 类的详细说明 * * @seesomething */ #ifndef SORUTION_PROJECT_CLASSNAME_H #define SORUTION_PROJECT_CLASSNAME_H // 在这里包含系统头文件 // // 在这里包含项目头文件 // // 在这里包含局部头文件 // // 在这里放置前置引用 // class XX { public: // 类的生命周期控制函数，如构造和析构，以及状态机 /** *Default constructor. */ XX(void); /** *Copy constructor. * *@param from The value to copy to this object. */ XX(const XX&amp; from); /** *Destructor. */ virtual ~XX(void); // 在这里放置类的运算操作符 /** *Assignment operator. * *@param from THe value to assign to this object. * *@return A reference to this object. */ XX&amp; operator=(XX&amp;from); // 在这里放置类的操作 // 在这里放置属性存取 // 在这里放置类的状态查询 protected: private: }; // 内联方法定义 // // 外部引用 // #endif // SORUTION_PROJECT_CLASSNAME_H ² 定义的顺序是: public, protected, private ² 要清楚public/protected/private都应该放置哪些东西 2.1.2. 源文件格式（适用于C++） #include &quot;XX.h&quot; // class implemented /////////////// PUBLIC/////////////////////// //================= 构造函数 ==================== XX::XX() { }// XX XX::XX(const XX&amp;) { }// XX XX::~XX() { }// ~XX //=============== 操作符========================= XX&amp; XX::operator=(XX&amp;); { return *this; }// = //==============类的操作 ===================== //==============属性存取 ===================== //==============状态查询 ===================== ///////////// PROTECTED ////////////////// ///////////// PRIVATE ////////////////// 2.1.3. 保护头文件不被重复包含 （适用于C/C++）² 应使用宏定义来保护头文件不被重复包含： #ifndef SORUTION_PROJECT_CLASSNAME_H #define SORUTION_PROJECT_CLASSNAME_H #endif // SORUTION_PROJECT_CLASSNAME_H ² 如果使用命名空间的时候，要把命名空间加到文件名前面： #ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H #define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H #endif 2.1.4. 方法和函数的布局 （适用于C/C++）² 对于有较多参数的函数的写法 如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐： int AnyMethod( int arg1, int arg2, int arg3, int arg4); 或 int AnyMethod( int arg1 , int arg2 , int arg3 , int arg4); 2.2. 缩进、制表符以及空格 （适用于C/C++）² 缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格） ² 不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。 ² 虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。 例如： void func() { if (something bad) { if (another thing bad) { while (more input) { } } } } 2.3. 尽量使一行不要超过78个字母 （适用于C/C++）² 有许多编辑器屏幕只有78个字母宽 2.4. 保证一行只写一条语句 （适用于C/C++）² 一行最多只写一条语句 ² 一行只定义一个变量 例如： 不要象下面这样: char** a, *x; int width, height; //widthand height of image 要象这样: char** a= 0; // 文档说明 char* x= 0; // 文档说明 2.5. 花括号 {} 规则 （适用于C/C++） 2.5.1. 花括号的位置 ² 在关键字的下一行单独放置括号，并且与关键字对齐，如： if (condition) { ... } while (condition) { … } 2.5.2. 什么时候应使用花括号所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。 ² 使用花括号格式： if (1 == somevalue) { somevalue = 2; } ² 单行格式： if (1 == somevalue) somevalue = 2; 或下面这样（对于这种写法，建议使用花括号）： if (1 == somevalue) { somevalue = 2; } 2.5.3. 在花括号结束的位置加上注释² 在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如： while(1) { if (valid) { } // if valid else { } // not valid } // end forever 2.5.4. 注意屏幕大小² 一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。 2.6.圆括号 () 规则 （适用于C/C++）² 圆括号与关键字之间应放一个空格。 ² 圆括号与函数名之间不要有空格。 ² Return 语句不要使用圆括号。 例如： if (condition) { } while(condition) { } strcpy(s, s1); return 1; 2.7.if else 语句的格式 （适用于C/C++）² 布局 if (条件) // 注释 { } else if (条件) // 注释 { } else // 注释 { } ² 条件格式 总是把常量放在等号或不等于号的左边： if ( 6 == errorNum ) ... 一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。 比如： if ( errorNum == 6) ... 错写成： if ( errorNum = 6) ... // 这是一个不容易发现的灾难 2.8.switch 格式 （适用于C/C++）² 直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。 ² 总是要写default语句，不管是否是需要。 ² 在case中需要定义变量的时候，应把所有代码放在语句块中。 例如： switch (...) { case 1: ... // 继续执行case2 case 2: { int v; ... } break; default: } 2.9. 使用goto,continue,break 和 ?: （适用于C/C++）2.9.1. Goto² 尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如： for (...) { while (...) { ... if (disaster) goto error; //跳出循环 } } ... error: clean up the mess ² 跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。 2.9.2. Continue and Break² Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。 2.9.3. ?:² 用括号把条件表达式括起来。 ² 不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。 ² 操作语句应分行写，除非它们能够简洁的放在一行当中。 例如： (condition) ?funct1() : func2(); 或 (condition) ? longstatement : anotherlong statement; 2.10. 运算符号的规则 （适用于C/C++）² 一元操作符如（!、~ 等等）应贴近操作对象。如： if (!IsOk) return ++v; ² 二元操作符如（+、*、%、== 等等）应在前后留空格。如： if ( v1 == v2) return v1 * 3; ² ++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。如： for(int i = 0; i &lt; 10; ++i) 2.11. 变量声明语句块 （适用于C/C++）² 变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。如： for(int i = 0; i &lt; 10; ++i) ² 声明语句块必须要对齐 类型，变量，等号和初始化值要分别对齐。 例如： DWORD mDword; DWORD* mpDword; char* mpChar; char mChar; mDword = 0; mpDword = NULL; mpChar = NULL; mChar = 0; 3. 文档及注释应当使用文档自动生成工具，来生成相关的程序文档。 3.1. 文件或程序库的文档注释（适用于C/C++）可以为整个文件编写文档。 例如： /** @file file.h * Abrief file description. * Amore elaborated file description. */ 3.2. 类文档注释（适用于C/C++）在类定义前面应加上类说明文档。 例如： /** WindowsNT * @brief Windows Nice Try. * @author Bill Gates * @author Several species of small furryanimals gathered together * in a cave and grooving with a pict. * @version 4.0 * @date 1996-1998 * @bug It crashes a lot and requires hugeamounts of memory. * @bug The class introduces the more bugs, thelonger it is used. * @warning This class may explode in your face. * @warning If you inherit anything from thisclass, you&#39;re doomed. */ class WindowsNT {}; 3.3. 函数文档注释（适用于C/C++）² 函数注释 所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如： /** * 赋值操作符 * *@param val 将要赋给本对象的值 * *@return 本对象的引用 */ XX&amp; operator =(XX&amp; val); ² 注释属性 一些自动文档工具定义的属性可以包含在文档中，常用的有： n 前提条件 (pre)定义调用这个函数的前提条件 n 警告说明 (warning)定义一些关于这个函数必须知道的事情。 n 备注说明 (remarks)定义一些关于这个函数的备注信息。 n 将要完成的工作 (todo)说明哪些事情将在不久以后完成 n 使用例子说明 (example)一个图片能表达100句话，一个好的例子能解答1000个问题。 例如： /** * 复制一个字串 * *@pre * - 需要保证(from != 0) * - 需要保证(to != 0) * *@warning * 缓冲区必需足够大，以便容纳的下要拷贝的字串。 * *@example teststrcpy.cpp * *@param from 要拷贝的字串 *@param to 用于容纳字串的缓冲区 *@return void */ void strcpy(constchar* from, char* to); 3.4. Include 语句注释 （适用于C/C++）² 如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。 3.5.语句块注释（适用于C/C++）² 语句块的注释可以用在语句块的开头和结束位置： { // Block1 (meaningful comment about Block1) ... some code { // Block2 (meaningful comment about Block2) ... somecode } // End Block2 } // End Block1 4. 编码要求4.1. 不要忽略编译器的警告（适用于C/C++）² 编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。 4.2. 应使用源代码管理器（适用于C/C++）² 根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。 4.3. 固有的类方法成员（适用于C++）² 默认构造函数(DefaultConstructor) 如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。 ² 虚析构函数(Virtual Destructor) 如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。 ² 拷贝构造函数(Copy Constructor) 如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。 ² 赋值操作(AssignmentOperator) 如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。 4.4. 使用命名空间 （适用于C++）² 命名规则 根名字一般是设计者的名字。比如公司名称等等。 ² 不要在全局空间使用using语句。 4.5. 初始化所有的变量 （适用于C/C++）² 无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。 4.6. 保持函数短小精悍（适用于C/C++）² 一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。 4.7.对空语句进行注释 （适用于C/C++）² For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如： while(*dest++ = *srC++) ; // VOID ² 不允许写成： while (*dest++ = *srC++) ; // 绝对不允许这么写 4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）² If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如： 建议使用： if (FAIL != f()) 不建议使用下面的表达式： if (f()) ² 宏定义的情况也一样： #define STREQ(a,b) (strcmp((a), (b)) == 0) 或者使用内联函数： inline bool StringEqual(char* a, char* b) { (strcmp(a, b)== 0) ? return true : return false; Or more compactly: returnstrcmp(a, b) == 0; } 4.9.布尔类型 （适用于C/C++）² 早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。 早期的布尔类型定义为： typedef int bool; #defineTRUE 1 #defineFALSE 0 或： const intTRUE = 1; const int FALSE= 0; ² 在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如： if (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？ 必须写成： if (FALSE !=func()) { ... 4.10. 避免在语句中内含赋值 （适用于C/C++）² 只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如： while (EOF != (c= getchar())) { process thecharacter } ² ++ 和 – 操作也是一种赋值语句 ² 内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如： a = b + c; d = a + r; 不应该写成： d = (a = b + c)+ r; 4.11. 正确的使用Const （适用于C/C++）² C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。 4.12. 不要在头文件定义数据（适用于C/C++）不要把数据定义放在头文件，如： /* * aheader.h */ int x = 0; 4.13. 不要直接使用数字 （适用于C/C++）² 直接使用数字，会使源代码难以理解和维护。如： if (22 ==foo) { start_thermo_nuclear_war(); } else if (19 == foo) {refund_lotso_money(); } else if (16 == foo) {infinite_loop(); } else { cry_cause_im_lost(); } 当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。 ² 我们可以用#define或者常量来改变这一状况，如： #define PRESIDENT_WENT_CRAZY (22) const int WE_GOOFED= 19; enum { THEY_DIDNT_PAY=16 }; if (PRESIDENT_WENT_CRAZY == foo) { start_thermo_nuclear_war(); } else if (WE_GOOFED == foo) {refund_lotso_money(); } else if (THEY_DIDNT_PAY == foo) { infinite_loop();} else {happy_days_i_know_why_im_here(); } 4.14. 宏（适用于C/C++）² 如果可以，使用内联函数代替宏。 例如： #ifndef MAX #define MAX(x,y) (((x) &gt; (y) ? (x) : (y)) // 取最大数 #endif 使用内联函数可以达到相同的效果，而且更安全： inline int max(int x, inty) { return (x&gt; y ? x : y); } ² 要注意副作用 必须小心副作用，因为在调用表达式时，会发生潜在的错误。 例如： MAX(f(x),z++); ² 表达式总是用括号括起来 在宏展开时，使用括号可以避免宏展开后产生的二义性。 例如： #define ADD(x,y) x + y 必须写成： #define ADD(x,y) ((x) + (y)) ² 保证宏名称的唯一性 和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题： n 在宏名称前加上库的名字避免使用简单而常用的名字，如：MAX 和MIN。","raw":"title: C/C++代码规范\ndate: 2017-03-07 17:53:42\ncategories:\n  - 代码规范\ntags:\n  - 代码规范\n---\n\n        命名规则\n        1 起个合适的名字\n            11    类的名称 适用于C\n            12    方法和函数的名称 适用于C++\n            13   含有度量单位的名称 适用于C++\n            14    缩写名称不要全部大写 适用于C++\n        2类的命名 适用于C\n        3类库或程序库命名 适用于C++\n        4方法和函数的命名 适用于C\n        5类属性的命名 适用于C\n        6方法和函数参数的命名 适用于C\n        7局部变量的命名 适用于C++\n        8指针变量的命名前缀 适用于C++\n        9引用变量和返回引用函数的命名前缀 适用于C\n        10   全局变量的命名前缀 适用于C++\n        11   全局常量的命名 适用于C+\n        命名规则\n        1 起个合适的名字\n            11    类的名称 适用于C\n            12    方法和函数的名称 适用于C++\n            13   含有度量单位的名称 适用于C++\n            14    缩写名称不要全部大写 适用于C++\n        2类的命名 适用于C\n        3类库或程序库命名 适用于C++\n        4方法和函数的命名 适用于C\n        5类属性的命名 适用于C\n        6方法和函数参数的命名 适用于C\n        7局部变量的命名 适用于C++\n        8指针变量的命名前缀 适用于C++\n        9引用变量和返回引用函数的命名前缀 适用于C\n        10   全局变量的命名前缀 适用于C++\n        11   全局常量的命名 适用于C++\n        12   静态变量的命名前缀 适用于C\n        13   自定义类型typedef的命名 适用于C++\n        14   宏定义的命名 适用于C++\n        15   C 函数的命名 适用于C++\n        16   枚举的命名 适用于C++\n        排版规则\n        1 布局和模板\n            11    类的布局模板 适用于C\n            12   源文件格式 适用于C\n            13    保护头文件不被重复包含 适用于C++\n            14    方法和函数的布局 适用于C++\n        2 缩进制表符以及空格 适用于C++\n        3 尽量使一行不要超过78个字母 适用于C++\n        4 保证一行只写一条语句 适用于C++\n        5 花括号 规则 适用于C++\n            51    花括号的位置\n            52    什么时候应使用花括号\n            53    在花括号结束的位置加上注释\n            54    注意屏幕大小 \n        6圆括号 规则 适用于C++\n        7if else 语句的格式 适用于C++\n        8switch 格式 适用于C++\n        9 使用gotocontinuebreak 和 适用于C++\n            91    Goto\n            92    Continue and Break\n            93    \n        10   运算符号的规则 适用于C++\n        11    变量声明语句块 适用于C++\n        文档及注释\n        1 文件或程序库的文档注释 适用于C++\n        2 类文档注释 适用于C++\n        3 函数文档注释 适用于C++\n        4 Include 语句注释 适用于C++\n        5语句块注释 适用于C++\n        编码要求\n        1 不要忽略编译器的警告 适用于C++\n        2 应使用源代码管理器 适用于C++\n        3 固有的类方法成员 适用于C\n        4 使用命名空间 适用于C\n        5 初始化所有的变量 适用于C++\n        6 保持函数短小精悍 适用于C++\n        7对空语句进行注释 适用于C++\n        8不要用if语句的默认方法测试非零值 适用于C++\n        9布尔类型 适用于C++\n        10避免在语句中内含赋值 适用于C++\n        11正确的使用Const 适用于C++\n        12不要在头文件定义数据适用于C++\n        13不要直接使用数字 适用于C++\n        14宏 适用于C++\n        \n <!--more--> \n \n# 1.    命名规则\n## 1.1. 起个合适的名字\n### 1.1.1.    类的名称（适用于C++）\n\n²  类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。\n\n²  类的名字不需要告诉我们，它从哪个类继承而来的。\n\n²  有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。\n### 1.1.2.    方法和函数的名称（适用于C/C++）\n\n²  方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。\n\n²  函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。\n\n²  可以加一些必要的后缀：\n\nMax – 表示取最大值\n\nCnt – 表示当前的计数值\n\nKey – 表示键值\n\n例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。\n\n²  前缀也同样有用：\n\nIs – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。\n\nGet – 用于获取一个值。\n\nSet – 用于设置一个值。\n\n例如：IsHitRetryLimit.\n### 1.1.3.   含有度量单位的名称（适用于C/C++）\n\n²  如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。\n\n例如：\n\n\tuint32 mTimeoutMsecs;\n\n\tuint32 mMyWeightLbs;\n### 1.1.4.    缩写名称不要全部大写（适用于C/C++）\n\n²  无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。\n\n例如：\n\n\tclass FluidOz;            // 而不是 FluidOZ\n\n\tclass NetworkAbcKey;      // 而不是 NetworkABCKey\n## 1.2.类的命名（适用于C++）\n\n²  用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。\n\n²  名字的第一个字母应大写\n\n²  不含有下划线 ('_')\n\n例如：\n\n   \tclass NameOneTwo; \n\n   \tclass Name;\n## 1.3.类库（或程序库）命名 （适用于C/C++）\n\n²  使用命名空间防止名字冲突。\n\n²  如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。\n\n例如：\n\nJohn Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样：\n\n   \tclass JjLinkList\n\n   \t{\n\n   \t}\n## 1.4.方法和函数的命名（适用于C++）\n\n²  使用与类名相同的规则\n\n例如：\n\n   \tclass NameOneTwo\n\n   \t{\n\n   \t\tpublic:\n\n      int     DoIt();\n\n      void    HandleError();\n\n   \t}\n   \n## 1.5.类属性的命名（适用于C++）\n\n²  属性（通常是非公有数据成员）名字以字母'm'开头。\n\n²  在 'm(m_)'  后面，使用与类名相同的规则。\n\n²  'm(m_)' 总是位于其它修饰符（如表示指针的 'p'）的前面。\n\n例如：\n\n       class NameOneTwo\n\n       {\n\n       public:\n\n          int     VarAbc();\n\n          int     ErrorNumber();\n\n       private:\n\n          int          mVarAbc;\n\n          int          mErrorNumber;\n\n          String*      mpName;\n\n       }\n## 1.6.方法和函数参数的命名（适用于C++）\n\n²  第一个字母必须小写。\n\n²  第一个字母后面的单词使用与类名相同的规则。\n\n例如：\n\n       class NameOneTwo\n\n       {\n\n       public:\n\n      int     StartYourEngines(\n\n                               Engine&rSomeEngine,\n\n                              Engine&rAnotherEngine);\n\n   \t}\n## 1.7.局部变量的命名（适用于C/C++）\n\n²  所有字母都用小写\n\n²  使用下划线 '_' 作为单词的分隔。\n\n例如：\n\n       int\n\n      NameOneTwo::HandleError(int errorNumber)\n\n       {\n\n      int            error= OsErr();\n\n      Time           time_of_error;\n\n     ErrorProcessor error_processor;\n\n   }\n## 1.8.指针变量的命名前缀（适用于C/C++）\n\n²  指针变量多数情况应在前面加 'p'。\n\n²  星号 '*' 应靠近类型，而不是变量名。\n\n例如：\n\n  \tString* pName=new String;\n\n \n\n  特别的：String* pName, name; 应分成两行来写：\n\n  \tString* pName;\n\n  \tString  name;\n## 1.9.引用变量和返回引用函数的命名前缀（适用于C++）\n\n²  引用必须用 'r'作前缀修饰。\n\n例如：\n\n   \tclass Test\n\n   \t{\n\n   \tpublic:\n\n      void               DoSomething(StatusInfo&rStatus);\n\n \n\n     StatusInfo&        rStatus();\n\n      constStatusInfo&  Status() const; // 这里返回的是常量引用，所以不符合本规则\n\n \n\n   \tprivate:\n\n     \tStatusInfo&        mrStatus;\n\n   \t}\n## 1.10.   全局变量的命名前缀（适用于C/C++）\n\n²  全局变量总是以 'g(g_)' 作为前缀。\n\n例如：\n\n    Logger g_Log;\n\n    Logger* g_pLog;\n## 1.11.   全局常量的命名（适用于C/C++）\n\n²  全局常量全部大写，并以下划线 '_' 分隔单词。\n\n例如：\n\n    const intA_GLOBAL_CONSTANT = 5;\n## 1.12.   静态变量的命名前缀（适用于C++）\n\n²  静态变量以 's' 作为前缀。\n\n例如：\n\n       class Test\n\n       {\n\n       public:\n\n       private:\n\n          staticStatusInfo m_sStatus;\n\n       }\n## 1.13.   自定义类型（typedef）的命名（适用于C/C++）\n\n²  类型定义名称指的是用typedef定义的名称。\n\n²  类型定义名称使用与类名相同的规则，并使用Type作为后缀。\n\n例如：\n\n       typedefuint16  ModuleType;\n\n       typedefuint32  SystemType;\n## 1.14.   宏定义的命名（适用于C/C++）\n\n²  所有单词的字母都用大写，并使用下划线 '_' 分隔.\n\n例如：\n\n\t#define MAX(a,b) blah\n\n\t#define IS_ERR(err) blah\n## 1.15.   C 函数的命名（适用于C/C++）\n\n²  C++项目中，应尽量少用C函数。\n\n²  C函数使用GNU规范，所有字母都使用小写，并用下划线 '_' 作为单词的分隔。\n\n例如：\n\n   \tint\n\n  \tsome_bloody_function()\n\n   \t{\n\n   \t}\n\n²  特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：\n\n       extern “C” int some_bloody_function();\n\n²  或在C/C++中推荐使用下面的格式：\n\n       #ifdef__cplusplus__\n\n       extern “C”{\n\n       #endif\n\n       int\n\n      some_bloody_function()\n\n       {\n\n       }\n\n       #ifdef__cplusplus__\n\n       }\n\n       #endif\n## 1.16.   枚举的命名（适用于C/C++）\n\n²  所有字母都大写，并用下划线 '_' 作为单词分隔。\n\n例如：\n\n   \tenumPinStateType\n\n   \t{\n\n      \tPIN_OFF,\n\n      \tPIN_ON\n\n   \t};\n\n\tenum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING};\n# 2.    排版规则\n## 2.1. 布局和模板\n### 2.1.1.    类的布局模板 （适用于C++）\n\n²  请使用下面的模板来创建一个新的类：\n\n\t/**     \n\n \t* 用一行来描述类\n\n \t*\n\n \t*#include \"XX.h\" <BR>\n\n \t*-llib\n\n \t*\n\n \t* 类的详细说明\n\n \t* \n\n \t* @seesomething\n\n \t*/\n\n \n\n\t#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n\t#define SORUTION_PROJECT_CLASSNAME_H\n\n \n\n\t// 在这里包含系统头文件\n\n\t//\n\n \n\n\t// 在这里包含项目头文件\n\n\t//\n\n \n\n\t// 在这里包含局部头文件\n\n\t//\n\n \n\n\t// 在这里放置前置引用\n\n\t//\n\n \n\n \n\n\t\tclass XX\n\n\t\t{\n\n\t\tpublic:\n\n    \t// 类的生命周期控制函数，如构造和析构，以及状态机\n\n \n\n    \t\t/**\n\n    \t\t*Default constructor.\n\n    \t\t*/\n\n    \t\tXX(void);\n\n \n\n    \t\t/**\n\n    \t\t*Copy constructor.\n\n    \t\t*\n\n    \t\t*@param from The value to copy to this object.\n\n    \t\t*/\n\n    \t\tXX(const XX& from);\n\n \n\n    \t\t/**\n\n    \t\t*Destructor.\n\n    \t\t*/\n\n\t\t    virtual ~XX(void);\n\n\t\t \n\n\t\t    // 在这里放置类的运算操作符\n\n\t\t \n\n\t\t    /**\n\n\t\t    *Assignment operator.\n\n\t\t    *\n\n\t\t    *@param from THe value to assign to this object.\n\n\t\t    *\n\n\t\t    *@return A reference to this object.\n\n\t\t    */\n\n\t\t    XX&                     operator=(XX&from); \n\n\t\t \n\n\t\t    // 在这里放置类的操作                      \n\n\t\t    // 在这里放置属性存取\n\n\t\t    // 在这里放置类的状态查询\n\n\t\t \n\n\t\t\tprotected:\n\n\t\t\tprivate:\n\n\t\t\t};\n\n \n\n\t\t// 内联方法定义\n\n\t\t//\n\n\t\t \n\n\t\t// 外部引用\n\n\t\t//\n\n\t\t \n\n\t\t#endif  // SORUTION_PROJECT_CLASSNAME_H\n\n \n\n²  定义的顺序是: public, protected, private\n\n²  要清楚public/protected/private都应该放置哪些东西\n### 2.1.2.   源文件格式（适用于C++）\n\n\t\t#include \"XX.h\"                               // class implemented\n\n \n\n \n\n/////////////// PUBLIC///////////////////////\n\n \n\n//================= 构造函数 ====================\n\n \n\n\t\tXX::XX()\n\n\t\t{\n\n\t\t}// XX\n\n\t\t \n\n\t\tXX::XX(const XX&)\n\n\t\t{\n\n\t\t}// XX\n\n\t\t \n\n\t\tXX::~XX()\n\n\t\t{\n\n\t\t}// ~XX\n\n\t\t \n\n \n\n//=============== 操作符=========================\n\n \n\n\t\tXX&\n\n\t\tXX::operator=(XX&);\n\n\t\t{\n\n\t\t   return *this;\n\n\t\t \n\n\t\t}// =\n\n\t\t \n\n//==============类的操作 =====================\n\n//==============属性存取 =====================\n\n//==============状态查询   =====================\n\n///////////// PROTECTED  //////////////////\n\n \n\n///////////// PRIVATE    //////////////////\n### 2.1.3.    保护头文件不被重复包含 （适用于C/C++）\n\n²  应使用宏定义来保护头文件不被重复包含：\n\n\t\t#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n\t\t#define SORUTION_PROJECT_CLASSNAME_H\n\n\t\t \n\n\t\t#endif // SORUTION_PROJECT_CLASSNAME_H\n\n \n\n \n\n²  如果使用命名空间的时候，要把命名空间加到文件名前面：\n\n\t\t#ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n\t\t#define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n \n\n#endif\n### 2.1.4.    方法和函数的布局 （适用于C/C++）\n\n²  对于有较多参数的函数的写法\n\n如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：\n\n\t\t   int AnyMethod(\n\n\t\t                 int  arg1, \n\n\t\t                 int   arg2,\n\n\t\t                 int   arg3,\n\n\t\t                 int   arg4); \n或\n\n\t\tint AnyMethod( int   arg1 \n\n\t\t               , int   arg2\n\n\t\t               , int   arg3\n\n\t\t               , int   arg4);\n\n \n## 2.2. 缩进、制表符以及空格 （适用于C/C++）\n\n²  缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格）\n\n²  不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。\n\n²  虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。\n\n例如：\n\n\t\t   void\n\n\t\t   func()\n\n\t\t   {\n\n\t\t      if (something bad)\n\n\t\t      {\n\n\t\t          if (another thing bad)\n\n\t\t          {\n\n\t\t              while (more input)\n\n\t\t              {\n\n\t\t              }\n\n\t\t          }\n\n\t\t      }\n\n\t\t   }\n## 2.3. 尽量使一行不要超过78个字母 （适用于C/C++）\n\n²  有许多编辑器屏幕只有78个字母宽\n## 2.4. 保证一行只写一条语句 （适用于C/C++）\n\n²  一行最多只写一条语句\n\n²  一行只定义一个变量\n\n例如：\n\n不要象下面这样:\n\n\t\tchar** a, *x;\n\n\t\t \n\n\t\tint width, height; //widthand height of image\n\n \n\n要象这样:\n\n\t\tchar** a= 0;  // 文档说明\n\n\t\tchar*  x= 0;  // 文档说明\n\t\t2.5. 花括号 {} 规则 （适用于C/C++）\n\t\t2.5.1.    花括号的位置\n\n²  在关键字的下一行单独放置括号，并且与关键字对齐，如：\n\n\t\tif (condition)       \n\n\t\t{\n\n\t\t    ...\n\n\t\t}\n\n\t\twhile (condition)\n\n\t\t{\n\n\t\t    …\n\n\t\t}\n### 2.5.2.    什么时候应使用花括号\n\n所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。\n\n²  使用花括号格式：\n\n\t\tif (1 == somevalue)\n\n\t\t{\n\n\t\t   somevalue = 2;\n\n\t\t}\n\n\t\t²  单行格式：\n\n\t\tif (1 == somevalue) somevalue = 2;\n\n\t\t或下面这样（对于这种写法，建议使用花括号）：\n\n\t\tif (1 == somevalue)\n\n\t\t{\n\t\tsomevalue = 2;\n\n\t\t}\n### 2.5.3.    在花括号结束的位置加上注释\n\n²  在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如：\n\n\t\twhile(1)\n\n\t\t{\n\n\t\t   if (valid)\n\n\t\t   {\n\n\t\t \n\n\t\t   } // if valid\n\n\t\t   else\n\n\t\t   {\n\n\t\t   } // not valid\n\n \n\n\t\t} // end forever\n### 2.5.4.    注意屏幕大小\n\n²  一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。\n## 2.6.圆括号 () 规则 （适用于C/C++）\n\n²  圆括号与关键字之间应放一个空格。\n\n²  圆括号与函数名之间不要有空格。\n\n²  Return 语句不要使用圆括号。\n\n例如：\n\n\t    if (condition)\n\n\t    {\n\n\t    }\n\n\t \n\n\t    while(condition)\n\n\t    {\n\n\t    }\n\n\t \n\n\t    strcpy(s, s1);\n\n \n\n    \treturn 1;\n## 2.7.if else 语句的格式 （适用于C/C++）\n\n²  布局\n\n\t\t   if (条件)               // 注释\n\n\t\t   {\n\n\t\t   }\n\n\t\t   else if (条件)           // 注释\n\n\t\t   {\n\n\t\t   }\n\n\t\t   else                   // 注释\n\n\t\t   {\n\n\t\t   }\n\n²  条件格式\n\n总是把常量放在等号或不等于号的左边：\n\n\t\tif ( 6 == errorNum ) ...\n\n一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。\n\n比如：\n\n\t\tif ( errorNum == 6) ...\n\n错写成：\n\n\t\tif ( errorNum = 6) ... // 这是一个不容易发现的灾难\n\n \n## 2.8.switch 格式 （适用于C/C++）\n\n²  直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。\n\n²  总是要写default语句，不管是否是需要。\n\n²  在case中需要定义变量的时候，应把所有代码放在语句块中。\n\n例如：\n\n\t\tswitch (...)\n\n\t\t{\n\n\t\tcase 1:\n\n\t\t    ...\n\n\t\t        // 继续执行case2\n\n\t\t \n\n\t\tcase 2:\n\n\t\t    {       \n\n\t\t        int v;\n\n\t\t        ...\n\n\t\t    }\n\n\t\t    break;\n\n\t\t \n\n\t\tdefault:\n\n\t\t}\n## 2.9. 使用goto,continue,break 和 ?: （适用于C/C++）\n### 2.9.1.    Goto\n\n²  尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如：\n\n\t\tfor (...)\n\n\t\t{\n\n\t\t    while (...)\n\n\t\t    {\n\n\t\t        ...\n\n\t\t            if (disaster)\n\n\t\tgoto error; //跳出循环\n\n\t\t    }\n\n\t\t}\n\n\t\t...\n\n\t\terror:\n\n\t\tclean up the mess\n\n²  跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。\n### 2.9.2.    Continue and Break\n\n²  Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。\n### 2.9.3.    ?:\n\n²  用括号把条件表达式括起来。\n\n²  不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。\n\n²  操作语句应分行写，除非它们能够简洁的放在一行当中。\n\n例如：\n\n   \t\t(condition) ?funct1() : func2();\n\n   或\n\n   \t\t(condition)\n\n     \t\t ? longstatement\n\n      \t\t: anotherlong statement;\n## 2.10.   运算符号的规则 （适用于C/C++）\n\n²  一元操作符如（!、~ 等等）应贴近操作对象。\n如：\n\n\t\tif (!IsOk)\n\n\t\t\treturn ++v;\n\n²  二元操作符如（+、*、%、== 等等）应在前后留空格。\n如：\n\n\t\tif ( v1 == v2)\n\n\t\t     return v1 * 3;\n\n²  ++ 和 -- 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。\n如：\n\t\tfor(int i = 0; i < 10; ++i)\n## 2.11.    变量声明语句块 （适用于C/C++）\n\n²  变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。\n如：\n\t\tfor(int i = 0; i < 10; ++i)\n\n \n\n²  声明语句块必须要对齐\n\n类型，变量，等号和初始化值要分别对齐。\n\n例如：\n\n\t\t   DWORD      mDword;\n\n\t\t   DWORD*     mpDword;\n\n\t\t   char*      mpChar;\n\n\t\t   char       mChar;\n\n\t\t \n\n\t\t   mDword     =    0;\n\n\t\t   mpDword    =    NULL;\n\n\t\t   mpChar      =    NULL;\n\n\t\t   mChar      =    0;\n# 3.    文档及注释\n\n应当使用文档自动生成工具，来生成相关的程序文档。\n## 3.1. 文件或程序库的文档注释（适用于C/C++）\n\n可以为整个文件编写文档。\n\n例如：\n\n\t\t/** @file file.h\n\n\t\t * Abrief file description.\n\n\t\t * Amore elaborated file description.\n\n\t\t */\n\n \n## 3.2. 类文档注释（适用于C/C++）\n\n在类定义前面应加上类说明文档。\n\n例如：\n\n\t\t/** WindowsNT\n\n\t\t *  @brief Windows Nice Try.\n\n\t\t *  @author Bill Gates\n\n\t\t *  @author Several species of small furryanimals gathered together\n\n\t\t *          in a cave and grooving with a pict.\n\n\t\t *  @version 4.0\n\n\t\t *  @date   1996-1998\n\n\t\t *  @bug It crashes a lot and requires hugeamounts of memory.\n\n\t\t *  @bug The class introduces the more bugs, thelonger it is used.\n\n\t\t *  @warning This class may explode in your face.\n\n\t\t *  @warning If you inherit anything from thisclass, you're doomed.\n\n\t\t */\n\n\t\tclass WindowsNT {};\n\n \n## 3.3. 函数文档注释（适用于C/C++）\n\n²  函数注释\n\n所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如：\n\n\t\t  /**\n\n\t\t   * 赋值操作符\n\n\t\t   *\n\n\t\t   *@param val 将要赋给本对象的值\n\n\t\t   *\n\n\t\t   *@return 本对象的引用\n\n\t\t   */\n\n\t\t  XX&  operator =(XX& val);\n\n²  注释属性\n\n一些自动文档工具定义的属性可以包含在文档中，常用的有：\n\nn  前提条件 (pre)\n定义调用这个函数的前提条件\n\nn  警告说明 (warning)\n定义一些关于这个函数必须知道的事情。\n\nn  备注说明 (remarks)\n定义一些关于这个函数的备注信息。\n\nn  将要完成的工作 (todo)\n说明哪些事情将在不久以后完成\n\nn  使用例子说明 (example)\n一个图片能表达100句话，一个好的例子能解答1000个问题。\n\n例如：\n\n\t\t  /**\n\n\t\t   * 复制一个字串\n\n\t\t   *\n\n\t\t   *@pre\n\n\t\t   *     - 需要保证(from != 0)\n\n\t\t   *     - 需要保证(to != 0)\n\n\t\t   *\n\n\t\t   *@warning\n\n\t\t   * 缓冲区必需足够大，以便容纳的下要拷贝的字串。\n\n\t\t   *\n\n\t\t   *@example teststrcpy.cpp\n\n\t\t   *\n\n\t\t   *@param from 要拷贝的字串\n\n\t\t   *@param to 用于容纳字串的缓冲区\n\n\t\t   *@return void\n\n\t\t   */\n\n\t\t  void  strcpy(constchar* from, char* to);\n## 3.4. Include 语句注释 （适用于C/C++）\n\n²  如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。\n## 3.5.语句块注释（适用于C/C++）\n\n²  语句块的注释可以用在语句块的开头和结束位置：\n\n\t\t{ \n\n\t\t    // Block1 (meaningful comment about Block1)\n\n\t\t    ... some code\n\n\t\t \n\n\t\t    { \n\n\t\t        // Block2 (meaningful comment about Block2)\n\n\t\t        ... somecode\n\n\t\t    }  // End Block2\n\n\t\t \n\n\t\t}  // End Block1\n# 4.    编码要求\n## 4.1. 不要忽略编译器的警告（适用于C/C++）\n\n²  编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。\n## 4.2. 应使用源代码管理器（适用于C/C++）\n\n²  根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。\n## 4.3. 固有的类方法成员（适用于C++）\n\n²  默认构造函数(DefaultConstructor)\n\n如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。\n\n²  虚析构函数(Virtual Destructor)\n\n如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。\n\n²  拷贝构造函数(Copy Constructor)\n\n如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。\n\n²  赋值操作(AssignmentOperator)\n\n如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。\n## 4.4. 使用命名空间 （适用于C++）\n\n²  命名规则\n\n根名字一般是设计者的名字。比如公司名称等等。\n\n²  不要在全局空间使用using语句。\n## 4.5. 初始化所有的变量 （适用于C/C++）\n\n²  无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。\n## 4.6. 保持函数短小精悍（适用于C/C++）\n\n²  一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。\n## 4.7.对空语句进行注释 （适用于C/C++）\n\n²  For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如：\n\n\t\t   while(*dest++ = *srC++)\n\n\t\t      ;         // VOID\n\n²  不允许写成：\n\n\t\t   while (*dest++ = *srC++) ;   // 绝对不允许这么写\n\n \n## 4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）\n\n²  If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如：\n\n建议使用：\n\n   \t\tif (FAIL != f())\n\n不建议使用下面的表达式：\n\n   \t\tif (f())\n\n \n\n²  宏定义的情况也一样：\n\n   \t\t#define STREQ(a,b) (strcmp((a), (b)) == 0)\n\n或者使用内联函数：\n\n\t\t   inline bool\n\n\t\t  StringEqual(char* a, char* b)\n\n\t\t   {\n\n\t\t      (strcmp(a, b)== 0) ? return true : return false;\n\n\t\t       Or more compactly:\n\n\t\t      returnstrcmp(a, b) == 0;\n\n\t\t   }\n## 4.9.布尔类型 （适用于C/C++）\n\n²  早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。\n\n \n\n早期的布尔类型定义为：\n\n\t\t   typedef int     bool;\n\n\t\t   #defineTRUE    1\n\n\t\t   #defineFALSE   0\n\n \n\n或：\n\n\t\t   const intTRUE  = 1;\n\n\t\t   const int FALSE= 0;\n\n \n\n²  在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如：\n\n   \t\tif (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？\n\n必须写成：\n\n   \t\tif (FALSE !=func()) { ...\n## 4.10.   避免在语句中内含赋值 （适用于C/C++）\n\n²  只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如：\n\n\t\t   while (EOF != (c= getchar()))\n\n\t\t   {\n\n\t\t      process thecharacter\n\n\t\t   }\n\n²  ++ 和 -- 操作也是一种赋值语句\n\n²  内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如：\n\n\t\t   a = b + c;\n\n\t\t   d = a + r;\n\n不应该写成：\n\n   \t\t\td = (a = b + c)+ r;\n## 4.11.   正确的使用Const （适用于C/C++）\n\n²  C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。\n## 4.12.    不要在头文件定义数据（适用于C/C++）\n\n不要把数据定义放在头文件，如：\n\n\t\t/*\n\n\t\t * aheader.h\n\n\t\t */\n\n\t\tint x = 0;\n## 4.13.   不要直接使用数字 （适用于C/C++）\n\n²  直接使用数字，会使源代码难以理解和维护。如：\n\n\t\tif      (22 ==foo)    { start_thermo_nuclear_war(); }\n\n\t\telse if (19 == foo)    {refund_lotso_money(); }\n\n\t\telse if (16 == foo)    {infinite_loop(); }\n\n\t\telse                   { cry_cause_im_lost(); }\n\n当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。\n\n²  我们可以用#define或者常量来改变这一状况，如：\n\n\t\t#define  PRESIDENT_WENT_CRAZY  (22)\n\n\t\tconst int WE_GOOFED= 19;\n\n\t\tenum\n\n\t\t{\n\n\t\t    THEY_DIDNT_PAY=16\n\n\t\t};\n\n\t\t \n\n\t\tif (PRESIDENT_WENT_CRAZY    == foo) { start_thermo_nuclear_war(); }\n\n\t\telse if (WE_GOOFED          == foo)  {refund_lotso_money(); }\n\n\t\telse if (THEY_DIDNT_PAY     == foo) { infinite_loop();}\n\n\t\telse                                 {happy_days_i_know_why_im_here(); }\n\n \n## 4.14.    宏（适用于C/C++）\n\n²  如果可以，使用内联函数代替宏。\n\n例如：\n\n\t\t#ifndef MAX\n\n\t\t#define  MAX(x,y)  (((x) > (y) ? (x) : (y))    // 取最大数\n\n\t\t#endif\n\n使用内联函数可以达到相同的效果，而且更安全：\n\n\t\t   inline int\n\n\t\t   max(int x, inty)\n\n\t\t   {\n\n\t\t      return (x> y ? x : y);\n\n\t\t   }\n\n²  要注意副作用\n\n必须小心副作用，因为在调用表达式时，会发生潜在的错误。\n\n例如：\n\n  \t\t MAX(f(x),z++);\n\n²  表达式总是用括号括起来\n\n在宏展开时，使用括号可以避免宏展开后产生的二义性。\n\n例如：\n\n\t\t#define ADD(x,y) x + y\n\n必须写成：\n\n\t\t#define ADD(x,y) ((x) + (y))\n\n²  保证宏名称的唯一性\n\n和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题：\n\nn  在宏名称前加上库的名字\n避免使用简单而常用的名字，如：MAX 和MIN。","content":"<pre><code>    命名规则\n    1 起个合适的名字\n        11    类的名称 适用于C\n        12    方法和函数的名称 适用于C++\n        13   含有度量单位的名称 适用于C++\n        14    缩写名称不要全部大写 适用于C++\n    2类的命名 适用于C\n    3类库或程序库命名 适用于C++\n    4方法和函数的命名 适用于C\n    5类属性的命名 适用于C\n    6方法和函数参数的命名 适用于C\n    7局部变量的命名 适用于C++\n    8指针变量的命名前缀 适用于C++\n    9引用变量和返回引用函数的命名前缀 适用于C\n    10   全局变量的命名前缀 适用于C++\n    11   全局常量的命名 适用于C+\n    命名规则\n    1 起个合适的名字\n        11    类的名称 适用于C\n        12    方法和函数的名称 适用于C++\n        13   含有度量单位的名称 适用于C++\n        14    缩写名称不要全部大写 适用于C++\n    2类的命名 适用于C\n    3类库或程序库命名 适用于C++\n    4方法和函数的命名 适用于C\n    5类属性的命名 适用于C\n    6方法和函数参数的命名 适用于C\n    7局部变量的命名 适用于C++\n    8指针变量的命名前缀 适用于C++\n    9引用变量和返回引用函数的命名前缀 适用于C\n    10   全局变量的命名前缀 适用于C++\n    11   全局常量的命名 适用于C++\n    12   静态变量的命名前缀 适用于C\n    13   自定义类型typedef的命名 适用于C++\n    14   宏定义的命名 适用于C++\n    15   C 函数的命名 适用于C++\n    16   枚举的命名 适用于C++\n    排版规则\n    1 布局和模板\n        11    类的布局模板 适用于C\n        12   源文件格式 适用于C\n        13    保护头文件不被重复包含 适用于C++\n        14    方法和函数的布局 适用于C++\n    2 缩进制表符以及空格 适用于C++\n    3 尽量使一行不要超过78个字母 适用于C++\n    4 保证一行只写一条语句 适用于C++\n    5 花括号 规则 适用于C++\n        51    花括号的位置\n        52    什么时候应使用花括号\n        53    在花括号结束的位置加上注释\n        54    注意屏幕大小 \n    6圆括号 规则 适用于C++\n    7if else 语句的格式 适用于C++\n    8switch 格式 适用于C++\n    9 使用gotocontinuebreak 和 适用于C++\n        91    Goto\n        92    Continue and Break\n        93    \n    10   运算符号的规则 适用于C++\n    11    变量声明语句块 适用于C++\n    文档及注释\n    1 文件或程序库的文档注释 适用于C++\n    2 类文档注释 适用于C++\n    3 函数文档注释 适用于C++\n    4 Include 语句注释 适用于C++\n    5语句块注释 适用于C++\n    编码要求\n    1 不要忽略编译器的警告 适用于C++\n    2 应使用源代码管理器 适用于C++\n    3 固有的类方法成员 适用于C\n    4 使用命名空间 适用于C\n    5 初始化所有的变量 适用于C++\n    6 保持函数短小精悍 适用于C++\n    7对空语句进行注释 适用于C++\n    8不要用if语句的默认方法测试非零值 适用于C++\n    9布尔类型 适用于C++\n    10避免在语句中内含赋值 适用于C++\n    11正确的使用Const 适用于C++\n    12不要在头文件定义数据适用于C++\n    13不要直接使用数字 适用于C++\n    14宏 适用于C++\n</code></pre> <a id=\"more\"></a> \n<h1 id=\"1-命名规则\"><a href=\"#1-命名规则\" class=\"headerlink\" title=\"1.    命名规则\"></a>1.    命名规则</h1><h2 id=\"1-1-起个合适的名字\"><a href=\"#1-1-起个合适的名字\" class=\"headerlink\" title=\"1.1. 起个合适的名字\"></a>1.1. 起个合适的名字</h2><h3 id=\"1-1-1-类的名称（适用于C-）\"><a href=\"#1-1-1-类的名称（适用于C-）\" class=\"headerlink\" title=\"1.1.1.    类的名称（适用于C++）\"></a>1.1.1.    类的名称（适用于C++）</h3><p>²  类的名称要能告诉我们，这个类是什么。因此，类的名称通常是名词。</p>\n<p>²  类的名字不需要告诉我们，它从哪个类继承而来的。</p>\n<p>²  有时候加个后缀是很有用的。比如类是一个代理(Agents)时，起名叫DownloadAgent更能表达真实的意图。</p>\n<h3 id=\"1-1-2-方法和函数的名称（适用于C-C-）\"><a href=\"#1-1-2-方法和函数的名称（适用于C-C-）\" class=\"headerlink\" title=\"1.1.2.    方法和函数的名称（适用于C/C++）\"></a>1.1.2.    方法和函数的名称（适用于C/C++）</h3><p>²  方法和函数通常都要执行某种行为，因此，名称要能清楚的说明它做什么：CheckForErrors() 而不是ErrorCheck(),DumpDataToFile() 而不是 DataFile()。 这样也可以很容易的区别函数和数据。</p>\n<p>²  函数名总以动词开头，后面跟随其它名称。这样看起来更自然些。</p>\n<p>²  可以加一些必要的后缀：</p>\n<p>Max – 表示取最大值</p>\n<p>Cnt – 表示当前的计数值</p>\n<p>Key – 表示键值</p>\n<p>例如：RetryMax 表示可接收的最大数，RetryCnt表示当前接收的数量。</p>\n<p>²  前缀也同样有用：</p>\n<p>Is – 用于询问一些问题。只要看到Is开头，就知道这是一个查询。</p>\n<p>Get – 用于获取一个值。</p>\n<p>Set – 用于设置一个值。</p>\n<p>例如：IsHitRetryLimit.</p>\n<h3 id=\"1-1-3-含有度量单位的名称（适用于C-C-）\"><a href=\"#1-1-3-含有度量单位的名称（适用于C-C-）\" class=\"headerlink\" title=\"1.1.3.   含有度量单位的名称（适用于C/C++）\"></a>1.1.3.   含有度量单位的名称（适用于C/C++）</h3><p>²  如果一个变量用于表示时间，重量或其它度量单位，应把度量单位添加到名称中，以便开发人员更早一步发现问题。</p>\n<p>例如：</p>\n<pre><code>uint32 mTimeoutMsecs;\n\nuint32 mMyWeightLbs;\n</code></pre><h3 id=\"1-1-4-缩写名称不要全部大写（适用于C-C-）\"><a href=\"#1-1-4-缩写名称不要全部大写（适用于C-C-）\" class=\"headerlink\" title=\"1.1.4.    缩写名称不要全部大写（适用于C/C++）\"></a>1.1.4.    缩写名称不要全部大写（适用于C/C++）</h3><p>²  无论是什么缩写名称，我们总以一个大写字母开头，后面跟随的字母全部用小写。</p>\n<p>例如：</p>\n<pre><code>class FluidOz;            // 而不是 FluidOZ\n\nclass NetworkAbcKey;      // 而不是 NetworkABCKey\n</code></pre><h2 id=\"1-2-类的命名（适用于C-）\"><a href=\"#1-2-类的命名（适用于C-）\" class=\"headerlink\" title=\"1.2.类的命名（适用于C++）\"></a>1.2.类的命名（适用于C++）</h2><p>²  用大写字母作为单词的分隔，每个单词的首字母大写，其它字母均小写。</p>\n<p>²  名字的第一个字母应大写</p>\n<p>²  不含有下划线 (‘_’)</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo; \n\n   class Name;\n</code></pre><h2 id=\"1-3-类库（或程序库）命名-（适用于C-C-）\"><a href=\"#1-3-类库（或程序库）命名-（适用于C-C-）\" class=\"headerlink\" title=\"1.3.类库（或程序库）命名 （适用于C/C++）\"></a>1.3.类库（或程序库）命名 （适用于C/C++）</h2><p>²  使用命名空间防止名字冲突。</p>\n<p>²  如果编译器没有实现命名空间，需要用前缀来避名名字冲突，不过前缀不要过长（2个字母比较好）。</p>\n<p>例如：</p>\n<p>John Johnson 完成了一个数据结构的库，它可以使用JJ作为库的前缀，所以类名就象下面这样：</p>\n<pre><code>   class JjLinkList\n\n   {\n\n   }\n</code></pre><h2 id=\"1-4-方法和函数的命名（适用于C-）\"><a href=\"#1-4-方法和函数的命名（适用于C-）\" class=\"headerlink\" title=\"1.4.方法和函数的命名（适用于C++）\"></a>1.4.方法和函数的命名（适用于C++）</h2><p>²  使用与类名相同的规则</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n       public:\n\n  int     DoIt();\n\n  void    HandleError();\n\n   }\n</code></pre><h2 id=\"1-5-类属性的命名（适用于C-）\"><a href=\"#1-5-类属性的命名（适用于C-）\" class=\"headerlink\" title=\"1.5.类属性的命名（适用于C++）\"></a>1.5.类属性的命名（适用于C++）</h2><p>²  属性（通常是非公有数据成员）名字以字母’m’开头。</p>\n<p>²  在 ‘m(m_)’  后面，使用与类名相同的规则。</p>\n<p>²  ‘m(m_)’ 总是位于其它修饰符（如表示指针的 ‘p’）的前面。</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n   public:\n\n      int     VarAbc();\n\n      int     ErrorNumber();\n\n   private:\n\n      int          mVarAbc;\n\n      int          mErrorNumber;\n\n      String*      mpName;\n\n   }\n</code></pre><h2 id=\"1-6-方法和函数参数的命名（适用于C-）\"><a href=\"#1-6-方法和函数参数的命名（适用于C-）\" class=\"headerlink\" title=\"1.6.方法和函数参数的命名（适用于C++）\"></a>1.6.方法和函数参数的命名（适用于C++）</h2><p>²  第一个字母必须小写。</p>\n<p>²  第一个字母后面的单词使用与类名相同的规则。</p>\n<p>例如：</p>\n<pre><code>   class NameOneTwo\n\n   {\n\n   public:\n\n  int     StartYourEngines(\n\n                           Engine&amp;rSomeEngine,\n\n                          Engine&amp;rAnotherEngine);\n\n   }\n</code></pre><h2 id=\"1-7-局部变量的命名（适用于C-C-）\"><a href=\"#1-7-局部变量的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.7.局部变量的命名（适用于C/C++）\"></a>1.7.局部变量的命名（适用于C/C++）</h2><p>²  所有字母都用小写</p>\n<p>²  使用下划线 ‘_’ 作为单词的分隔。</p>\n<p>例如：</p>\n<pre><code>   int\n\n  NameOneTwo::HandleError(int errorNumber)\n\n   {\n\n  int            error= OsErr();\n\n  Time           time_of_error;\n\n ErrorProcessor error_processor;\n</code></pre><p>   }</p>\n<h2 id=\"1-8-指针变量的命名前缀（适用于C-C-）\"><a href=\"#1-8-指针变量的命名前缀（适用于C-C-）\" class=\"headerlink\" title=\"1.8.指针变量的命名前缀（适用于C/C++）\"></a>1.8.指针变量的命名前缀（适用于C/C++）</h2><p>²  指针变量多数情况应在前面加 ‘p’。</p>\n<p>²  星号 ‘*’ 应靠近类型，而不是变量名。</p>\n<p>例如：</p>\n<pre><code>  String* pName=new String;\n</code></pre><p>  特别的：String* pName, name; 应分成两行来写：</p>\n<pre><code>  String* pName;\n\n  String  name;\n</code></pre><h2 id=\"1-9-引用变量和返回引用函数的命名前缀（适用于C-）\"><a href=\"#1-9-引用变量和返回引用函数的命名前缀（适用于C-）\" class=\"headerlink\" title=\"1.9.引用变量和返回引用函数的命名前缀（适用于C++）\"></a>1.9.引用变量和返回引用函数的命名前缀（适用于C++）</h2><p>²  引用必须用 ‘r’作前缀修饰。</p>\n<p>例如：</p>\n<pre><code>   class Test\n\n   {\n\n   public:\n\n  void               DoSomething(StatusInfo&amp;rStatus);\n\n\n\n StatusInfo&amp;        rStatus();\n\n  constStatusInfo&amp;  Status() const; // 这里返回的是常量引用，所以不符合本规则\n\n\n\n   private:\n\n     StatusInfo&amp;        mrStatus;\n\n   }\n</code></pre><h2 id=\"1-10-全局变量的命名前缀（适用于C-C-）\"><a href=\"#1-10-全局变量的命名前缀（适用于C-C-）\" class=\"headerlink\" title=\"1.10.   全局变量的命名前缀（适用于C/C++）\"></a>1.10.   全局变量的命名前缀（适用于C/C++）</h2><p>²  全局变量总是以 ‘g(g_)’ 作为前缀。</p>\n<p>例如：</p>\n<pre><code>Logger g_Log;\n\nLogger* g_pLog;\n</code></pre><h2 id=\"1-11-全局常量的命名（适用于C-C-）\"><a href=\"#1-11-全局常量的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.11.   全局常量的命名（适用于C/C++）\"></a>1.11.   全局常量的命名（适用于C/C++）</h2><p>²  全局常量全部大写，并以下划线 ‘_’ 分隔单词。</p>\n<p>例如：</p>\n<pre><code>const intA_GLOBAL_CONSTANT = 5;\n</code></pre><h2 id=\"1-12-静态变量的命名前缀（适用于C-）\"><a href=\"#1-12-静态变量的命名前缀（适用于C-）\" class=\"headerlink\" title=\"1.12.   静态变量的命名前缀（适用于C++）\"></a>1.12.   静态变量的命名前缀（适用于C++）</h2><p>²  静态变量以 ‘s’ 作为前缀。</p>\n<p>例如：</p>\n<pre><code>   class Test\n\n   {\n\n   public:\n\n   private:\n\n      staticStatusInfo m_sStatus;\n\n   }\n</code></pre><h2 id=\"1-13-自定义类型（typedef）的命名（适用于C-C-）\"><a href=\"#1-13-自定义类型（typedef）的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.13.   自定义类型（typedef）的命名（适用于C/C++）\"></a>1.13.   自定义类型（typedef）的命名（适用于C/C++）</h2><p>²  类型定义名称指的是用typedef定义的名称。</p>\n<p>²  类型定义名称使用与类名相同的规则，并使用Type作为后缀。</p>\n<p>例如：</p>\n<pre><code>   typedefuint16  ModuleType;\n\n   typedefuint32  SystemType;\n</code></pre><h2 id=\"1-14-宏定义的命名（适用于C-C-）\"><a href=\"#1-14-宏定义的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.14.   宏定义的命名（适用于C/C++）\"></a>1.14.   宏定义的命名（适用于C/C++）</h2><p>²  所有单词的字母都用大写，并使用下划线 ‘_’ 分隔.</p>\n<p>例如：</p>\n<pre><code>#define MAX(a,b) blah\n\n#define IS_ERR(err) blah\n</code></pre><h2 id=\"1-15-C-函数的命名（适用于C-C-）\"><a href=\"#1-15-C-函数的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.15.   C 函数的命名（适用于C/C++）\"></a>1.15.   C 函数的命名（适用于C/C++）</h2><p>²  C++项目中，应尽量少用C函数。</p>\n<p>²  C函数使用GNU规范，所有字母都使用小写，并用下划线 ‘_’ 作为单词的分隔。</p>\n<p>例如：</p>\n<pre><code>   int\n\n  some_bloody_function()\n\n   {\n\n   }\n</code></pre><p>²  特别的，为了赚容C/C++，在必要的时候，在C++中应以下面的格式定义C函数：</p>\n<pre><code>   extern “C” int some_bloody_function();\n</code></pre><p>²  或在C/C++中推荐使用下面的格式：</p>\n<pre><code>   #ifdef__cplusplus__\n\n   extern “C”{\n\n   #endif\n\n   int\n\n  some_bloody_function()\n\n   {\n\n   }\n\n   #ifdef__cplusplus__\n\n   }\n\n   #endif\n</code></pre><h2 id=\"1-16-枚举的命名（适用于C-C-）\"><a href=\"#1-16-枚举的命名（适用于C-C-）\" class=\"headerlink\" title=\"1.16.   枚举的命名（适用于C/C++）\"></a>1.16.   枚举的命名（适用于C/C++）</h2><p>²  所有字母都大写，并用下划线 ‘_’ 作为单词分隔。</p>\n<p>例如：</p>\n<pre><code>   enumPinStateType\n\n   {\n\n      PIN_OFF,\n\n      PIN_ON\n\n   };\n\nenum { STATE_ERR, STATE_OPEN, STATE_RUNNING, STATE_DYING};\n</code></pre><h1 id=\"2-排版规则\"><a href=\"#2-排版规则\" class=\"headerlink\" title=\"2.    排版规则\"></a>2.    排版规则</h1><h2 id=\"2-1-布局和模板\"><a href=\"#2-1-布局和模板\" class=\"headerlink\" title=\"2.1. 布局和模板\"></a>2.1. 布局和模板</h2><h3 id=\"2-1-1-类的布局模板-（适用于C-）\"><a href=\"#2-1-1-类的布局模板-（适用于C-）\" class=\"headerlink\" title=\"2.1.1.    类的布局模板 （适用于C++）\"></a>2.1.1.    类的布局模板 （适用于C++）</h3><p>²  请使用下面的模板来创建一个新的类：</p>\n<pre><code>/**     \n\n * 用一行来描述类\n\n *\n\n *#include &quot;XX.h&quot; &lt;BR&gt;\n\n *-llib\n\n *\n\n * 类的详细说明\n\n * \n\n * @seesomething\n\n */\n\n\n\n#ifndef SORUTION_PROJECT_CLASSNAME_H\n\n#define SORUTION_PROJECT_CLASSNAME_H\n\n\n\n// 在这里包含系统头文件\n\n//\n\n\n\n// 在这里包含项目头文件\n\n//\n\n\n\n// 在这里包含局部头文件\n\n//\n\n\n\n// 在这里放置前置引用\n\n//\n\n\n\n\n\n    class XX\n\n    {\n\n    public:\n\n    // 类的生命周期控制函数，如构造和析构，以及状态机\n\n\n\n        /**\n\n        *Default constructor.\n\n        */\n\n        XX(void);\n\n\n\n        /**\n\n        *Copy constructor.\n\n        *\n\n        *@param from The value to copy to this object.\n\n        */\n\n        XX(const XX&amp; from);\n\n\n\n        /**\n\n        *Destructor.\n\n        */\n\n        virtual ~XX(void);\n\n\n\n        // 在这里放置类的运算操作符\n\n\n\n        /**\n\n        *Assignment operator.\n\n        *\n\n        *@param from THe value to assign to this object.\n\n        *\n\n        *@return A reference to this object.\n\n        */\n\n        XX&amp;                     operator=(XX&amp;from); \n\n\n\n        // 在这里放置类的操作                      \n\n        // 在这里放置属性存取\n\n        // 在这里放置类的状态查询\n\n\n\n        protected:\n\n        private:\n\n        };\n\n\n\n    // 内联方法定义\n\n    //\n\n\n\n    // 外部引用\n\n    //\n\n\n\n    #endif  // SORUTION_PROJECT_CLASSNAME_H\n</code></pre><p>²  定义的顺序是: public, protected, private</p>\n<p>²  要清楚public/protected/private都应该放置哪些东西</p>\n<h3 id=\"2-1-2-源文件格式（适用于C-）\"><a href=\"#2-1-2-源文件格式（适用于C-）\" class=\"headerlink\" title=\"2.1.2.   源文件格式（适用于C++）\"></a>2.1.2.   源文件格式（适用于C++）</h3><pre><code>    #include &quot;XX.h&quot;                               // class implemented\n</code></pre><p>/////////////// PUBLIC///////////////////////</p>\n<p>//================= 构造函数 ====================</p>\n<pre><code>    XX::XX()\n\n    {\n\n    }// XX\n\n\n\n    XX::XX(const XX&amp;)\n\n    {\n\n    }// XX\n\n\n\n    XX::~XX()\n\n    {\n\n    }// ~XX\n</code></pre><p>//=============== 操作符=========================</p>\n<pre><code>    XX&amp;\n\n    XX::operator=(XX&amp;);\n\n    {\n\n       return *this;\n\n\n\n    }// =\n</code></pre><p>//==============类的操作 =====================</p>\n<p>//==============属性存取 =====================</p>\n<p>//==============状态查询   =====================</p>\n<p>///////////// PROTECTED  //////////////////</p>\n<p>///////////// PRIVATE    //////////////////</p>\n<h3 id=\"2-1-3-保护头文件不被重复包含-（适用于C-C-）\"><a href=\"#2-1-3-保护头文件不被重复包含-（适用于C-C-）\" class=\"headerlink\" title=\"2.1.3.    保护头文件不被重复包含 （适用于C/C++）\"></a>2.1.3.    保护头文件不被重复包含 （适用于C/C++）</h3><p>²  应使用宏定义来保护头文件不被重复包含：</p>\n<pre><code>    #ifndef SORUTION_PROJECT_CLASSNAME_H\n\n    #define SORUTION_PROJECT_CLASSNAME_H\n\n\n\n    #endif // SORUTION_PROJECT_CLASSNAME_H\n</code></pre><p>²  如果使用命名空间的时候，要把命名空间加到文件名前面：</p>\n<pre><code>    #ifndef SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n\n    #define SORUTION_PROJECT_NAMESPACE_CLASSNAME_H\n</code></pre><p>#endif</p>\n<h3 id=\"2-1-4-方法和函数的布局-（适用于C-C-）\"><a href=\"#2-1-4-方法和函数的布局-（适用于C-C-）\" class=\"headerlink\" title=\"2.1.4.    方法和函数的布局 （适用于C/C++）\"></a>2.1.4.    方法和函数的布局 （适用于C/C++）</h3><p>²  对于有较多参数的函数的写法</p>\n<p>如果参数较多，一行写不下，我们应该分成几行来写，并且每个参数都另起一行对齐：</p>\n<pre><code>       int AnyMethod(\n\n                     int  arg1, \n\n                     int   arg2,\n\n                     int   arg3,\n\n                     int   arg4); \n</code></pre><p>或</p>\n<pre><code>    int AnyMethod( int   arg1 \n\n                   , int   arg2\n\n                   , int   arg3\n\n                   , int   arg4);\n</code></pre><h2 id=\"2-2-缩进、制表符以及空格-（适用于C-C-）\"><a href=\"#2-2-缩进、制表符以及空格-（适用于C-C-）\" class=\"headerlink\" title=\"2.2. 缩进、制表符以及空格 （适用于C/C++）\"></a>2.2. 缩进、制表符以及空格 （适用于C/C++）</h2><p>²  缩进的时候，每一层缩进3，4，或8个空格。（推荐使用4个空格）</p>\n<p>²  不要使用TAB，用空格，大多数编辑器可以用空格代替TAB。TAB应固定4个空格，因为大多数编辑器都是这么设置的。</p>\n<p>²  虽然没有规定缩进的层次，但是4至5层是合适的。如果缩进的层次太多，你可能需要考虑是否进行代码重构了。</p>\n<p>例如：</p>\n<pre><code>       void\n\n       func()\n\n       {\n\n          if (something bad)\n\n          {\n\n              if (another thing bad)\n\n              {\n\n                  while (more input)\n\n                  {\n\n                  }\n\n              }\n\n          }\n\n       }\n</code></pre><h2 id=\"2-3-尽量使一行不要超过78个字母-（适用于C-C-）\"><a href=\"#2-3-尽量使一行不要超过78个字母-（适用于C-C-）\" class=\"headerlink\" title=\"2.3. 尽量使一行不要超过78个字母 （适用于C/C++）\"></a>2.3. 尽量使一行不要超过78个字母 （适用于C/C++）</h2><p>²  有许多编辑器屏幕只有78个字母宽</p>\n<h2 id=\"2-4-保证一行只写一条语句-（适用于C-C-）\"><a href=\"#2-4-保证一行只写一条语句-（适用于C-C-）\" class=\"headerlink\" title=\"2.4. 保证一行只写一条语句 （适用于C/C++）\"></a>2.4. 保证一行只写一条语句 （适用于C/C++）</h2><p>²  一行最多只写一条语句</p>\n<p>²  一行只定义一个变量</p>\n<p>例如：</p>\n<p>不要象下面这样:</p>\n<pre><code>    char** a, *x;\n\n\n\n    int width, height; //widthand height of image\n</code></pre><p>要象这样:</p>\n<pre><code>    char** a= 0;  // 文档说明\n\n    char*  x= 0;  // 文档说明\n    2.5. 花括号 {} 规则 （适用于C/C++）\n    2.5.1.    花括号的位置\n</code></pre><p>²  在关键字的下一行单独放置括号，并且与关键字对齐，如：</p>\n<pre><code>    if (condition)       \n\n    {\n\n        ...\n\n    }\n\n    while (condition)\n\n    {\n\n        …\n\n    }\n</code></pre><h3 id=\"2-5-2-什么时候应使用花括号\"><a href=\"#2-5-2-什么时候应使用花括号\" class=\"headerlink\" title=\"2.5.2.    什么时候应使用花括号\"></a>2.5.2.    什么时候应使用花括号</h3><p>所有的 if, while 和 do 语句，要么用单行格式，要么使用花括号格式。</p>\n<p>²  使用花括号格式：</p>\n<pre><code>    if (1 == somevalue)\n\n    {\n\n       somevalue = 2;\n\n    }\n\n    ²  单行格式：\n\n    if (1 == somevalue) somevalue = 2;\n\n    或下面这样（对于这种写法，建议使用花括号）：\n\n    if (1 == somevalue)\n\n    {\n    somevalue = 2;\n\n    }\n</code></pre><h3 id=\"2-5-3-在花括号结束的位置加上注释\"><a href=\"#2-5-3-在花括号结束的位置加上注释\" class=\"headerlink\" title=\"2.5.3.    在花括号结束的位置加上注释\"></a>2.5.3.    在花括号结束的位置加上注释</h3><p>²  在花括号结束的位置加上注释是一个好习惯。假如前后花括号距离很远，注释就能帮你理解它是如何对应的。如：</p>\n<pre><code>    while(1)\n\n    {\n\n       if (valid)\n\n       {\n\n\n\n       } // if valid\n\n       else\n\n       {\n\n       } // not valid\n\n\n\n    } // end forever\n</code></pre><h3 id=\"2-5-4-注意屏幕大小\"><a href=\"#2-5-4-注意屏幕大小\" class=\"headerlink\" title=\"2.5.4.    注意屏幕大小\"></a>2.5.4.    注意屏幕大小</h3><p>²  一个语句块尽量不超过一个屏幕大小，这样，不要卷动屏幕就可以阅读代码。</p>\n<h2 id=\"2-6-圆括号-规则-（适用于C-C-）\"><a href=\"#2-6-圆括号-规则-（适用于C-C-）\" class=\"headerlink\" title=\"2.6.圆括号 () 规则 （适用于C/C++）\"></a>2.6.圆括号 () 规则 （适用于C/C++）</h2><p>²  圆括号与关键字之间应放一个空格。</p>\n<p>²  圆括号与函数名之间不要有空格。</p>\n<p>²  Return 语句不要使用圆括号。</p>\n<p>例如：</p>\n<pre><code>    if (condition)\n\n    {\n\n    }\n\n\n\n    while(condition)\n\n    {\n\n    }\n\n\n\n    strcpy(s, s1);\n\n\n\n    return 1;\n</code></pre><h2 id=\"2-7-if-else-语句的格式-（适用于C-C-）\"><a href=\"#2-7-if-else-语句的格式-（适用于C-C-）\" class=\"headerlink\" title=\"2.7.if else 语句的格式 （适用于C/C++）\"></a>2.7.if else 语句的格式 （适用于C/C++）</h2><p>²  布局</p>\n<pre><code>       if (条件)               // 注释\n\n       {\n\n       }\n\n       else if (条件)           // 注释\n\n       {\n\n       }\n\n       else                   // 注释\n\n       {\n\n       }\n</code></pre><p>²  条件格式</p>\n<p>总是把常量放在等号或不等于号的左边：</p>\n<pre><code>    if ( 6 == errorNum ) ...\n</code></pre><p>一个很重要的理由是，假如漏写一个等号，这种写法会产生一个编译错误，有助于马上发现问题。</p>\n<p>比如：</p>\n<pre><code>    if ( errorNum == 6) ...\n</code></pre><p>错写成：</p>\n<pre><code>    if ( errorNum = 6) ... // 这是一个不容易发现的灾难\n</code></pre><h2 id=\"2-8-switch-格式-（适用于C-C-）\"><a href=\"#2-8-switch-格式-（适用于C-C-）\" class=\"headerlink\" title=\"2.8.switch 格式 （适用于C/C++）\"></a>2.8.switch 格式 （适用于C/C++）</h2><p>²  直通的case语句，应该放置一条注释说明这个case语句是直通到下一个case语句的。</p>\n<p>²  总是要写default语句，不管是否是需要。</p>\n<p>²  在case中需要定义变量的时候，应把所有代码放在语句块中。</p>\n<p>例如：</p>\n<pre><code>    switch (...)\n\n    {\n\n    case 1:\n\n        ...\n\n            // 继续执行case2\n\n\n\n    case 2:\n\n        {       \n\n            int v;\n\n            ...\n\n        }\n\n        break;\n\n\n\n    default:\n\n    }\n</code></pre><h2 id=\"2-9-使用goto-continue-break-和-（适用于C-C-）\"><a href=\"#2-9-使用goto-continue-break-和-（适用于C-C-）\" class=\"headerlink\" title=\"2.9. 使用goto,continue,break 和 ?: （适用于C/C++）\"></a>2.9. 使用goto,continue,break 和 ?: （适用于C/C++）</h2><h3 id=\"2-9-1-Goto\"><a href=\"#2-9-1-Goto\" class=\"headerlink\" title=\"2.9.1.    Goto\"></a>2.9.1.    Goto</h3><p>²  尽量避免使用Goto 语句。一个合理使用goto语句的场合是，当你需要从多层循环中跳出。例如：</p>\n<pre><code>    for (...)\n\n    {\n\n        while (...)\n\n        {\n\n            ...\n\n                if (disaster)\n\n    goto error; //跳出循环\n\n        }\n\n    }\n\n    ...\n\n    error:\n\n    clean up the mess\n</code></pre><p>²  跳转的标号必须单独在一行的最左边。Goto语句需要有相应的注释，说明它的用途。</p>\n<h3 id=\"2-9-2-Continue-and-Break\"><a href=\"#2-9-2-Continue-and-Break\" class=\"headerlink\" title=\"2.9.2.    Continue and Break\"></a>2.9.2.    Continue and Break</h3><p>²  Continue 和break 实际上起到与goto一样的作用，因此，尽量少用为上。并且，Continue与break最好不要连用。</p>\n<h3 id=\"2-9-3\"><a href=\"#2-9-3\" class=\"headerlink\" title=\"2.9.3.    ?:\"></a>2.9.3.    ?:</h3><p>²  用括号把条件表达式括起来。</p>\n<p>²  不要在 ? : 中写上过多的代码，操作表达式应尽可能简洁。</p>\n<p>²  操作语句应分行写，除非它们能够简洁的放在一行当中。</p>\n<p>例如：</p>\n<pre><code>       (condition) ?funct1() : func2();\n</code></pre><p>   或</p>\n<pre><code>       (condition)\n\n          ? longstatement\n\n          : anotherlong statement;\n</code></pre><h2 id=\"2-10-运算符号的规则-（适用于C-C-）\"><a href=\"#2-10-运算符号的规则-（适用于C-C-）\" class=\"headerlink\" title=\"2.10.   运算符号的规则 （适用于C/C++）\"></a>2.10.   运算符号的规则 （适用于C/C++）</h2><p>²  一元操作符如（!、~ 等等）应贴近操作对象。<br>如：</p>\n<pre><code>    if (!IsOk)\n\n        return ++v;\n</code></pre><p>²  二元操作符如（+、*、%、== 等等）应在前后留空格。<br>如：</p>\n<pre><code>    if ( v1 == v2)\n\n         return v1 * 3;\n</code></pre><p>²  ++ 和 – 尽量使用前置运算。在C++中，不管 ++i 还是 i++，总是++i更容易生成优化代码。<br>如：<br>        for(int i = 0; i &lt; 10; ++i)</p>\n<h2 id=\"2-11-变量声明语句块-（适用于C-C-）\"><a href=\"#2-11-变量声明语句块-（适用于C-C-）\" class=\"headerlink\" title=\"2.11.    变量声明语句块 （适用于C/C++）\"></a>2.11.    变量声明语句块 （适用于C/C++）</h2><p>²  变量应该是随用随声明，不要集中在函数前（有些C语言不支持，则不在此要求之列）。特别是在for语句的循环变量，应只在for语句中定义。<br>如：<br>        for(int i = 0; i &lt; 10; ++i)</p>\n<p>²  声明语句块必须要对齐</p>\n<p>类型，变量，等号和初始化值要分别对齐。</p>\n<p>例如：</p>\n<pre><code>       DWORD      mDword;\n\n       DWORD*     mpDword;\n\n       char*      mpChar;\n\n       char       mChar;\n\n\n\n       mDword     =    0;\n\n       mpDword    =    NULL;\n\n       mpChar      =    NULL;\n\n       mChar      =    0;\n</code></pre><h1 id=\"3-文档及注释\"><a href=\"#3-文档及注释\" class=\"headerlink\" title=\"3.    文档及注释\"></a>3.    文档及注释</h1><p>应当使用文档自动生成工具，来生成相关的程序文档。</p>\n<h2 id=\"3-1-文件或程序库的文档注释（适用于C-C-）\"><a href=\"#3-1-文件或程序库的文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.1. 文件或程序库的文档注释（适用于C/C++）\"></a>3.1. 文件或程序库的文档注释（适用于C/C++）</h2><p>可以为整个文件编写文档。</p>\n<p>例如：</p>\n<pre><code>    /** @file file.h\n\n     * Abrief file description.\n\n     * Amore elaborated file description.\n\n     */\n</code></pre><h2 id=\"3-2-类文档注释（适用于C-C-）\"><a href=\"#3-2-类文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.2. 类文档注释（适用于C/C++）\"></a>3.2. 类文档注释（适用于C/C++）</h2><p>在类定义前面应加上类说明文档。</p>\n<p>例如：</p>\n<pre><code>    /** WindowsNT\n\n     *  @brief Windows Nice Try.\n\n     *  @author Bill Gates\n\n     *  @author Several species of small furryanimals gathered together\n\n     *          in a cave and grooving with a pict.\n\n     *  @version 4.0\n\n     *  @date   1996-1998\n\n     *  @bug It crashes a lot and requires hugeamounts of memory.\n\n     *  @bug The class introduces the more bugs, thelonger it is used.\n\n     *  @warning This class may explode in your face.\n\n     *  @warning If you inherit anything from thisclass, you&#39;re doomed.\n\n     */\n\n    class WindowsNT {};\n</code></pre><h2 id=\"3-3-函数文档注释（适用于C-C-）\"><a href=\"#3-3-函数文档注释（适用于C-C-）\" class=\"headerlink\" title=\"3.3. 函数文档注释（适用于C/C++）\"></a>3.3. 函数文档注释（适用于C/C++）</h2><p>²  函数注释</p>\n<p>所有的参数都应该有文档说明(param)，所有的返回代码都应该有文档说明(return)，所有的例外都应该有文档说明(exception)。可以使用(see)引用有关的开发资源。如：</p>\n<pre><code>      /**\n\n       * 赋值操作符\n\n       *\n\n       *@param val 将要赋给本对象的值\n\n       *\n\n       *@return 本对象的引用\n\n       */\n\n      XX&amp;  operator =(XX&amp; val);\n</code></pre><p>²  注释属性</p>\n<p>一些自动文档工具定义的属性可以包含在文档中，常用的有：</p>\n<p>n  前提条件 (pre)<br>定义调用这个函数的前提条件</p>\n<p>n  警告说明 (warning)<br>定义一些关于这个函数必须知道的事情。</p>\n<p>n  备注说明 (remarks)<br>定义一些关于这个函数的备注信息。</p>\n<p>n  将要完成的工作 (todo)<br>说明哪些事情将在不久以后完成</p>\n<p>n  使用例子说明 (example)<br>一个图片能表达100句话，一个好的例子能解答1000个问题。</p>\n<p>例如：</p>\n<pre><code>      /**\n\n       * 复制一个字串\n\n       *\n\n       *@pre\n\n       *     - 需要保证(from != 0)\n\n       *     - 需要保证(to != 0)\n\n       *\n\n       *@warning\n\n       * 缓冲区必需足够大，以便容纳的下要拷贝的字串。\n\n       *\n\n       *@example teststrcpy.cpp\n\n       *\n\n       *@param from 要拷贝的字串\n\n       *@param to 用于容纳字串的缓冲区\n\n       *@return void\n\n       */\n\n      void  strcpy(constchar* from, char* to);\n</code></pre><h2 id=\"3-4-Include-语句注释-（适用于C-C-）\"><a href=\"#3-4-Include-语句注释-（适用于C-C-）\" class=\"headerlink\" title=\"3.4. Include 语句注释 （适用于C/C++）\"></a>3.4. Include 语句注释 （适用于C/C++）</h2><p>²  如果有必要，＃include语句也应有注释，它可以告诉我们，为什么要包含这个头文件。</p>\n<h2 id=\"3-5-语句块注释（适用于C-C-）\"><a href=\"#3-5-语句块注释（适用于C-C-）\" class=\"headerlink\" title=\"3.5.语句块注释（适用于C/C++）\"></a>3.5.语句块注释（适用于C/C++）</h2><p>²  语句块的注释可以用在语句块的开头和结束位置：</p>\n<pre><code>    { \n\n        // Block1 (meaningful comment about Block1)\n\n        ... some code\n\n\n\n        { \n\n            // Block2 (meaningful comment about Block2)\n\n            ... somecode\n\n        }  // End Block2\n\n\n\n    }  // End Block1\n</code></pre><h1 id=\"4-编码要求\"><a href=\"#4-编码要求\" class=\"headerlink\" title=\"4.    编码要求\"></a>4.    编码要求</h1><h2 id=\"4-1-不要忽略编译器的警告（适用于C-C-）\"><a href=\"#4-1-不要忽略编译器的警告（适用于C-C-）\" class=\"headerlink\" title=\"4.1. 不要忽略编译器的警告（适用于C/C++）\"></a>4.1. 不要忽略编译器的警告（适用于C/C++）</h2><p>²  编译器的警告，通常能够指示出编码存在的笔误或逻辑错误。因此，不能轻视编译器的任何警告。正确的作法是，不允许代码在编译时产生任何警告信息。</p>\n<h2 id=\"4-2-应使用源代码管理器（适用于C-C-）\"><a href=\"#4-2-应使用源代码管理器（适用于C-C-）\" class=\"headerlink\" title=\"4.2. 应使用源代码管理器（适用于C/C++）\"></a>4.2. 应使用源代码管理器（适用于C/C++）</h2><p>²  根据开发规模，选择合适的源代码管理器。使用源代码管理器是非常必要的。</p>\n<h2 id=\"4-3-固有的类方法成员（适用于C-）\"><a href=\"#4-3-固有的类方法成员（适用于C-）\" class=\"headerlink\" title=\"4.3. 固有的类方法成员（适用于C++）\"></a>4.3. 固有的类方法成员（适用于C++）</h2><p>²  默认构造函数(DefaultConstructor)</p>\n<p>如果构造函数的所有参数都是可选的，那么这个构造函数也是默认构造函数。如果没有定义任何普通构造函数，则编译将自动生成一个。</p>\n<p>²  虚析构函数(Virtual Destructor)</p>\n<p>如果一个类可以被继承，那么应该使用虚析构函数。如果没有定义虚析构函数，则编译器将自动生成一个。</p>\n<p>²  拷贝构造函数(Copy Constructor)</p>\n<p>如果一个类不应该被拷贝，应该定义一个私有的拷贝构造函数，并且不定义它的实现。如果不知道一个类是否应该被拷贝，就认为它是不可拷贝的，直到你确认它应该被拷贝。如果没有定义拷贝构造函数，则编译器将自动生成一个。</p>\n<p>²  赋值操作(AssignmentOperator)</p>\n<p>如果一个类不应该被赋值，应该定义一个私有的赋值操作函数，并且不定义它的实现。如果不知道一个类是否应该被赋值，就认为它是不可赋值的，直到你确认它应该被赋值。如果没有定义赋值操作函数，则编译器将自动生成一个。</p>\n<h2 id=\"4-4-使用命名空间-（适用于C-）\"><a href=\"#4-4-使用命名空间-（适用于C-）\" class=\"headerlink\" title=\"4.4. 使用命名空间 （适用于C++）\"></a>4.4. 使用命名空间 （适用于C++）</h2><p>²  命名规则</p>\n<p>根名字一般是设计者的名字。比如公司名称等等。</p>\n<p>²  不要在全局空间使用using语句。</p>\n<h2 id=\"4-5-初始化所有的变量-（适用于C-C-）\"><a href=\"#4-5-初始化所有的变量-（适用于C-C-）\" class=\"headerlink\" title=\"4.5. 初始化所有的变量 （适用于C/C++）\"></a>4.5. 初始化所有的变量 （适用于C/C++）</h2><p>²  无论如何，都要初始化所有的变量。我们无法保证编译器会给个什么样的初值。</p>\n<h2 id=\"4-6-保持函数短小精悍（适用于C-C-）\"><a href=\"#4-6-保持函数短小精悍（适用于C-C-）\" class=\"headerlink\" title=\"4.6. 保持函数短小精悍（适用于C/C++）\"></a>4.6. 保持函数短小精悍（适用于C/C++）</h2><p>²  一般情况下，一个函数最好在一个屏幕内，不要超过三个屏幕。</p>\n<h2 id=\"4-7-对空语句进行注释-（适用于C-C-）\"><a href=\"#4-7-对空语句进行注释-（适用于C-C-）\" class=\"headerlink\" title=\"4.7.对空语句进行注释 （适用于C/C++）\"></a>4.7.对空语句进行注释 （适用于C/C++）</h2><p>²  For和while语句如果跟随一个空语句，需要对此语句进行注释，并且空语句应另起一行。如：</p>\n<pre><code>       while(*dest++ = *srC++)\n\n          ;         // VOID\n</code></pre><p>²  不允许写成：</p>\n<pre><code>       while (*dest++ = *srC++) ;   // 绝对不允许这么写\n</code></pre><h2 id=\"4-8-不要用if语句的默认方法测试非零值（适用于C-C-）\"><a href=\"#4-8-不要用if语句的默认方法测试非零值（适用于C-C-）\" class=\"headerlink\" title=\"4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）\"></a>4.8. 不要用if语句的默认方法测试非零值（适用于C/C++）</h2><p>²  If语句只用于检测布尔值(bool)，不要用默认的方法测试非零值，比如：</p>\n<p>建议使用：</p>\n<pre><code>       if (FAIL != f())\n</code></pre><p>不建议使用下面的表达式：</p>\n<pre><code>       if (f())\n</code></pre><p>²  宏定义的情况也一样：</p>\n<pre><code>       #define STREQ(a,b) (strcmp((a), (b)) == 0)\n</code></pre><p>或者使用内联函数：</p>\n<pre><code>       inline bool\n\n      StringEqual(char* a, char* b)\n\n       {\n\n          (strcmp(a, b)== 0) ? return true : return false;\n\n           Or more compactly:\n\n          returnstrcmp(a, b) == 0;\n\n       }\n</code></pre><h2 id=\"4-9-布尔类型-（适用于C-C-）\"><a href=\"#4-9-布尔类型-（适用于C-C-）\" class=\"headerlink\" title=\"4.9.布尔类型 （适用于C/C++）\"></a>4.9.布尔类型 （适用于C/C++）</h2><p>²  早期的C++没有布尔类型，但新的C++标准增加了布尔类型。如果可以使用内置的布尔类型的情况下，应使用布尔类型。</p>\n<p>早期的布尔类型定义为：</p>\n<pre><code>       typedef int     bool;\n\n       #defineTRUE    1\n\n       #defineFALSE   0\n</code></pre><p>或：</p>\n<pre><code>       const intTRUE  = 1;\n\n       const int FALSE= 0;\n</code></pre><p>²  在这种情况下，条件表达式不要比较1值(如TRUE，YES等等)，而要用0值(如FALSE,NO等等)进行比较。因为多数函数返回0表示FALSE，而非零表示TRUE。如：</p>\n<pre><code>       if (TRUE ==func()) { ... // 错误：假如func()返回 2 怎么办？\n</code></pre><p>必须写成：</p>\n<pre><code>       if (FALSE !=func()) { ...\n</code></pre><h2 id=\"4-10-避免在语句中内含赋值-（适用于C-C-）\"><a href=\"#4-10-避免在语句中内含赋值-（适用于C-C-）\" class=\"headerlink\" title=\"4.10.   避免在语句中内含赋值 （适用于C/C++）\"></a>4.10.   避免在语句中内含赋值 （适用于C/C++）</h2><p>²  只有一种情况可以在语句中内含赋值，它要能使代码显得更易理解，例如：</p>\n<pre><code>       while (EOF != (c= getchar()))\n\n       {\n\n          process thecharacter\n\n       }\n</code></pre><p>²  ++ 和 – 操作也是一种赋值语句</p>\n<p>²  内含赋值语句常常会带来一些副作用。在遇到这种情况时，我们应分成几个语句来写。比如：</p>\n<pre><code>       a = b + c;\n\n       d = a + r;\n</code></pre><p>不应该写成：</p>\n<pre><code>           d = (a = b + c)+ r;\n</code></pre><h2 id=\"4-11-正确的使用Const-（适用于C-C-）\"><a href=\"#4-11-正确的使用Const-（适用于C-C-）\" class=\"headerlink\" title=\"4.11.   正确的使用Const （适用于C/C++）\"></a>4.11.   正确的使用Const （适用于C/C++）</h2><p>²  C/C++ 提供const 关键字，用于指示不应该被修改的对象或数据。正确的使用Const既可以提供编译器的优化指示，也能够避免一些编码错误。</p>\n<h2 id=\"4-12-不要在头文件定义数据（适用于C-C-）\"><a href=\"#4-12-不要在头文件定义数据（适用于C-C-）\" class=\"headerlink\" title=\"4.12.    不要在头文件定义数据（适用于C/C++）\"></a>4.12.    不要在头文件定义数据（适用于C/C++）</h2><p>不要把数据定义放在头文件，如：</p>\n<pre><code>    /*\n\n     * aheader.h\n\n     */\n\n    int x = 0;\n</code></pre><h2 id=\"4-13-不要直接使用数字-（适用于C-C-）\"><a href=\"#4-13-不要直接使用数字-（适用于C-C-）\" class=\"headerlink\" title=\"4.13.   不要直接使用数字 （适用于C/C++）\"></a>4.13.   不要直接使用数字 （适用于C/C++）</h2><p>²  直接使用数字，会使源代码难以理解和维护。如：</p>\n<pre><code>    if      (22 ==foo)    { start_thermo_nuclear_war(); }\n\n    else if (19 == foo)    {refund_lotso_money(); }\n\n    else if (16 == foo)    {infinite_loop(); }\n\n    else                   { cry_cause_im_lost(); }\n</code></pre><p>当一段时间过去以后，有谁会记得22和19是什么意思？假如数字改变，或者是编写错误，更是难以发现问题。</p>\n<p>²  我们可以用#define或者常量来改变这一状况，如：</p>\n<pre><code>    #define  PRESIDENT_WENT_CRAZY  (22)\n\n    const int WE_GOOFED= 19;\n\n    enum\n\n    {\n\n        THEY_DIDNT_PAY=16\n\n    };\n\n\n\n    if (PRESIDENT_WENT_CRAZY    == foo) { start_thermo_nuclear_war(); }\n\n    else if (WE_GOOFED          == foo)  {refund_lotso_money(); }\n\n    else if (THEY_DIDNT_PAY     == foo) { infinite_loop();}\n\n    else                                 {happy_days_i_know_why_im_here(); }\n</code></pre><h2 id=\"4-14-宏（适用于C-C-）\"><a href=\"#4-14-宏（适用于C-C-）\" class=\"headerlink\" title=\"4.14.    宏（适用于C/C++）\"></a>4.14.    宏（适用于C/C++）</h2><p>²  如果可以，使用内联函数代替宏。</p>\n<p>例如：</p>\n<pre><code>    #ifndef MAX\n\n    #define  MAX(x,y)  (((x) &gt; (y) ? (x) : (y))    // 取最大数\n\n    #endif\n</code></pre><p>使用内联函数可以达到相同的效果，而且更安全：</p>\n<pre><code>       inline int\n\n       max(int x, inty)\n\n       {\n\n          return (x&gt; y ? x : y);\n\n       }\n</code></pre><p>²  要注意副作用</p>\n<p>必须小心副作用，因为在调用表达式时，会发生潜在的错误。</p>\n<p>例如：</p>\n<pre><code>       MAX(f(x),z++);\n</code></pre><p>²  表达式总是用括号括起来</p>\n<p>在宏展开时，使用括号可以避免宏展开后产生的二义性。</p>\n<p>例如：</p>\n<pre><code>    #define ADD(x,y) x + y\n</code></pre><p>必须写成：</p>\n<pre><code>    #define ADD(x,y) ((x) + (y))\n</code></pre><p>²  保证宏名称的唯一性</p>\n<p>和全局变量一样，宏也会与其它名称产生冲突。下面两条规则有助于解决这个问题：</p>\n<p>n  在宏名称前加上库的名字<br>避免使用简单而常用的名字，如：MAX 和MIN。</p>\n","comments":true,"link":"","permalink":"https://prostkhala.github.io/2017/03/07/c++代码规范/","excerpt":"命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C+ 命名规则 1 起个合适的名字 11 类的名称 适用于C 12 方法和函数的名称 适用于C++ 13 含有度量单位的名称 适用于C++ 14 缩写名称不要全部大写 适用于C++ 2类的命名 适用于C 3类库或程序库命名 适用于C++ 4方法和函数的命名 适用于C 5类属性的命名 适用于C 6方法和函数参数的命名 适用于C 7局部变量的命名 适用于C++ 8指针变量的命名前缀 适用于C++ 9引用变量和返回引用函数的命名前缀 适用于C 10 全局变量的命名前缀 适用于C++ 11 全局常量的命名 适用于C++ 12 静态变量的命名前缀 适用于C 13 自定义类型typedef的命名 适用于C++ 14 宏定义的命名 适用于C++ 15 C 函数的命名 适用于C++ 16 枚举的命名 适用于C++ 排版规则 1 布局和模板 11 类的布局模板 适用于C 12 源文件格式 适用于C 13 保护头文件不被重复包含 适用于C++ 14 方法和函数的布局 适用于C++ 2 缩进制表符以及空格 适用于C++ 3 尽量使一行不要超过78个字母 适用于C++ 4 保证一行只写一条语句 适用于C++ 5 花括号 规则 适用于C++ 51 花括号的位置 52 什么时候应使用花括号 53 在花括号结束的位置加上注释 54 注意屏幕大小 6圆括号 规则 适用于C++ 7if else 语句的格式 适用于C++ 8switch 格式 适用于C++ 9 使用gotocontinuebreak 和 适用于C++ 91 Goto 92 Continue and Break 93 10 运算符号的规则 适用于C++ 11 变量声明语句块 适用于C++ 文档及注释 1 文件或程序库的文档注释 适用于C++ 2 类文档注释 适用于C++ 3 函数文档注释 适用于C++ 4 Include 语句注释 适用于C++ 5语句块注释 适用于C++ 编码要求 1 不要忽略编译器的警告 适用于C++ 2 应使用源代码管理器 适用于C++ 3 固有的类方法成员 适用于C 4 使用命名空间 适用于C 5 初始化所有的变量 适用于C++ 6 保持函数短小精悍 适用于C++ 7对空语句进行注释 适用于C++ 8不要用if语句的默认方法测试非零值 适用于C++ 9布尔类型 适用于C++ 10避免在语句中内含赋值 适用于C++ 11正确的使用Const 适用于C++ 12不要在头文件定义数据适用于C++ 13不要直接使用数字 适用于C++ 14宏 适用于C++","categories":[{"name":"代码规范","slug":"代码规范","permalink":"https://prostkhala.github.io/categories/代码规范/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://prostkhala.github.io/tags/代码规范/"}]}]}